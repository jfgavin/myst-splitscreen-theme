{
  "version": 3,
  "sources": ["../../../../../node_modules/doi-utils/dist/validatePart.js", "../../../../../node_modules/doi-utils/dist/resolvers.js", "../../../../../node_modules/doi-utils/dist/index.js", "../../../../../node_modules/simple-validators/dist/utils.js", "../../../../../node_modules/simple-validators/dist/validators.js", "../../../../../node_modules/myst-frontmatter/dist/numbering/validators.js"],
  "sourcesContent": ["const DOI_VALIDATION_PATTERN = /^10.\\d{4,9}\\/[-._;()/:A-Z0-9]+$/i; // source: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n// const DOI_URL_PATTERN = /(?:https?:\\/\\/)?(?:dx\\.)?(?:www\\.)?doi.org\\//;\n/**\n * Validate that the input DOI string is valid.\n *\n * Uses DOI pattern described here: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n *\n * @param possibleDOI\n * @returns true if DOI is valid\n */\nexport function validatePart(possibleDOI) {\n    if (!possibleDOI)\n        return false;\n    return possibleDOI.match(DOI_VALIDATION_PATTERN) !== null;\n}\n", "import { validatePart } from './validatePart.js';\nconst doiOrg = {\n    test(url) {\n        return !!url.hostname.match(/(?:dx\\.)?(?:www\\.)?doi\\.org/);\n    },\n    parse(url) {\n        return url.pathname.replace(/^\\//, '');\n    },\n};\nconst elife = {\n    test(url) {\n        return url.hostname.endsWith('elifesciences.org') && url.pathname.startsWith('/articles/');\n    },\n    parse(url) {\n        return `10.7554/eLife.${url.pathname.replace('/articles/', '')}`;\n    },\n};\nconst zenodo = {\n    test(url) {\n        return (url.hostname.endsWith('zenodo.org') &&\n            !!url.pathname.match(/^\\/(?:record|badge\\/latestdoi)\\//));\n    },\n    parse(url) {\n        return `10.5281/zenodo.${url.pathname.replace(/^\\/(?:record|badge\\/latestdoi)\\//, '')}`;\n    },\n};\nfunction clumpParts(url) {\n    const parts = url.pathname.split('/').filter((p) => !!p);\n    return parts.slice(0, -1).map((a, i) => `${a}/${parts[i + 1]}`);\n}\nconst pathParts = {\n    test(url) {\n        return !!clumpParts(url).find(validatePart);\n    },\n    parse(url) {\n        return clumpParts(url).find(validatePart);\n    },\n};\nconst idInQuery = {\n    test(url) {\n        return validatePart(url.searchParams.get('id'));\n    },\n    parse(url) {\n        var _a;\n        return (_a = url.searchParams.get('id')) !== null && _a !== void 0 ? _a : undefined;\n    },\n};\nexport const STRICT_RESOLVERS = [doiOrg];\nexport const DEFAULT_RESOLVERS = [doiOrg, pathParts, elife, zenodo, idInQuery];\n", "import { DEFAULT_RESOLVERS, STRICT_RESOLVERS } from './resolvers.js';\nimport { validatePart } from './validatePart.js';\nexport { DEFAULT_RESOLVERS, STRICT_RESOLVERS } from './resolvers.js';\nexport const OPEN_FUNDER_REGISTRY_PREFIX = '10.13039';\n/**\n * Validate that the input string is valid.\n *\n * Uses DOI pattern described here: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n *\n * @param possibleDOI\n * @returns true if DOI is valid\n */\nexport function validate(possibleDOI, opts) {\n    if (!possibleDOI)\n        return false;\n    return !!normalize(possibleDOI, opts);\n}\n/**\n * Normalize an input string to the component of the DOI\n *\n * @param possibleDOI\n * @returns a string if it is valid\n */\nexport function normalize(possibleDOI, opts) {\n    let doi = undefined;\n    if (!possibleDOI)\n        return undefined;\n    if (validatePart(possibleDOI))\n        return possibleDOI;\n    if (possibleDOI.startsWith('doi:')) {\n        doi = possibleDOI.slice(4);\n        if (validatePart(doi))\n            return doi;\n    }\n    try {\n        const url = new URL(possibleDOI.startsWith('http') ? possibleDOI : `http://${possibleDOI}`);\n        const strictResolver = STRICT_RESOLVERS.find((r) => r.test(url));\n        const nonStrictResolver = DEFAULT_RESOLVERS.find((r) => r.test(url));\n        if ((opts === null || opts === void 0 ? void 0 : opts.strict) && !strictResolver)\n            return undefined;\n        const resolver = strictResolver !== null && strictResolver !== void 0 ? strictResolver : nonStrictResolver;\n        if (!resolver)\n            return undefined;\n        doi = resolver.parse(url);\n        if (!(opts === null || opts === void 0 ? void 0 : opts.strict) && strictResolver)\n            return doi;\n    }\n    catch (error) {\n        // pass\n    }\n    if (validatePart(doi))\n        return doi;\n    return undefined;\n}\n/**\n * Builds a canonical URL pointing to https://doi.org\n *\n * @param possibleDOI\n * @returns the doi as a string\n */\nexport function buildUrl(possibleDOI, opts) {\n    const doi = normalize(possibleDOI, opts);\n    if (!doi)\n        return undefined;\n    return `https://doi.org/${doi}`;\n}\n/**\n * Returns `true` if the DOI is in the Open Funder Registry\n *\n * See https://www.crossref.org/documentation/funder-registry/\n */\nexport function isOpenFunderRegistry(possibleDOI) {\n    const doi = normalize(possibleDOI);\n    if (!doi)\n        return false;\n    return doi.startsWith(`${OPEN_FUNDER_REGISTRY_PREFIX}/`);\n}\nexport const doi = {\n    validatePart,\n    validate,\n    normalize,\n    buildUrl,\n    isOpenFunderRegistry,\n};\n", "export function getDate(object) {\n    if (object == null) {\n        return new Date();\n    }\n    if (object instanceof Date) {\n        return object;\n    }\n    if (typeof object === 'string') {\n        return new Date(object);\n    }\n    if ((object === null || object === void 0 ? void 0 : object.toDate) !== undefined) {\n        return object.toDate();\n    }\n    throw new Error(`Could not parse date: ${object}`);\n}\nexport function formatDate(date) {\n    if (date instanceof Date) {\n        return date.toISOString();\n    }\n    if ((date === null || date === void 0 ? void 0 : date.toDate) !== undefined) {\n        return date.toDate().toISOString();\n    }\n    if (typeof date === 'string') {\n        return formatDate(getDate(date));\n    }\n    return null; // This will parse in JS into a Date.now()\n}\n", "import { formatDate } from './utils.js';\nexport function defined(val) {\n    return val != null;\n}\nexport function locationSuffix(opts) {\n    if (opts.file && opts.location)\n        return ` (at ${opts.file}#${opts.location})`;\n    if (opts.file || opts.location)\n        return ` (at ${opts.file || opts.location})`;\n    return '';\n}\nexport function incrementOptions(property, opts) {\n    let location = opts.property;\n    if (opts.location)\n        location = `${opts.location}.${opts.property}`;\n    return { ...opts, property, location };\n}\nexport function validationError(message, opts) {\n    if (opts.suppressErrors)\n        return undefined;\n    const { messages } = opts;\n    if (!messages.errors)\n        messages.errors = [];\n    const fullMessage = `'${opts.property}' ${message}${locationSuffix(opts)}`;\n    messages.errors.push({\n        property: opts.property,\n        message: fullMessage,\n    });\n    if (opts.errorLogFn)\n        opts.errorLogFn(fullMessage);\n    return undefined;\n}\nexport function validationWarning(message, opts) {\n    if (opts.suppressWarnings)\n        return undefined;\n    const { messages } = opts;\n    if (!messages.warnings)\n        messages.warnings = [];\n    const fullMessage = `'${opts.property}' ${message}${locationSuffix(opts)}`;\n    messages.warnings.push({\n        property: opts.property,\n        message: fullMessage,\n    });\n    if (opts.warningLogFn)\n        opts.warningLogFn(fullMessage);\n    return undefined;\n}\n/**\n * Validate value is boolean\n *\n * String 'true' and 'false' are coerced to booleans; error on any other value, including 1/0, 't'/'f', etc.\n */\nexport function validateBoolean(input, opts) {\n    if (typeof input === 'string') {\n        if (input.toLowerCase() === 'true')\n            return true;\n        if (input.toLowerCase() === 'false')\n            return false;\n    }\n    if (input === true || input === false)\n        return input;\n    return validationError('must be boolean', opts);\n}\n/**\n * Validate value is number\n *\n * Attempts to coerce inputs to number with Number(input)\n */\nexport function validateNumber(input, opts) {\n    const value = Number(input);\n    if (Number.isNaN(value)) {\n        return validationError(`must be a number: ${input}`, opts);\n    }\n    if (defined(opts.min) && value < opts.min) {\n        return validationError(`must be greater than or equal to ${opts.min}: ${value}`, opts);\n    }\n    if (defined(opts.max) && value > opts.max) {\n        return validationError(`must be less than or equal to ${opts.max}: ${value}`, opts);\n    }\n    if (opts.integer && !Number.isInteger(value)) {\n        return validationError(`must be an integer: ${value}`, opts);\n    }\n    return value;\n}\n/**\n * Validates string value\n *\n * Ensures string length is less than `maxLength` and matches regular expression `regex`.\n * If `escapeFn` is provided, this will be applied to the output after other validation.\n */\nexport function validateString(input, opts) {\n    let value = input;\n    if (opts.coerceNumber && typeof value === 'number') {\n        if (Number.isNaN(value))\n            validationWarning('is not a number', opts);\n        value = String(value);\n    }\n    if (typeof value !== 'string')\n        return validationError(`must be string`, opts);\n    if (opts.maxLength && value.length > opts.maxLength) {\n        return validationError(`must be less than ${opts.maxLength} chars`, opts);\n    }\n    if (opts.regex && !value.match(opts.regex)) {\n        return validationError(`must match regex ${opts.regex}`, opts);\n    }\n    if (opts.escapeFn) {\n        value = opts.escapeFn(value);\n    }\n    return value;\n}\n/**\n * Validate value is valid URL string of max length 2048\n *\n * If 'include' is provided, value must include it in the origin.\n */\nexport function validateUrl(input, opts) {\n    const value = validateString(input, { ...opts, maxLength: 2048 });\n    if (value === undefined)\n        return value;\n    let url;\n    try {\n        url = new URL(value);\n    }\n    catch {\n        return validationError(`must be valid URL: ${value}`, opts);\n    }\n    if (opts.includes && !url.origin.includes(opts.includes)) {\n        return validationError(`must include \"${opts.includes}\": ${value}`, opts);\n    }\n    return value;\n}\nexport function validateSubdomain(input, opts) {\n    let value = validateString(input, { ...opts, maxLength: 2048 });\n    if (value === undefined)\n        return value;\n    if (!value.startsWith('https://') && !value.startsWith('http://')) {\n        value = `http://${value}`;\n    }\n    let url;\n    try {\n        url = new URL(value);\n    }\n    catch {\n        return validationError(`must be valid domain: ${input}`, opts);\n    }\n    const { hash, host, pathname, protocol, search } = url;\n    if (protocol !== 'http:' && protocol !== 'https:') {\n        return validationError(`must have http/https protocol or no protocol: ${input}`, opts);\n    }\n    if ((pathname && pathname !== '/') || hash || search) {\n        return validationError(`must not specify path, query, or fragment: ${input}`, opts);\n    }\n    if (!host.match(/^.+\\..+\\..+$/)) {\n        return validationError(`must be a subdomain: ${input}`, opts);\n    }\n    // `host` is already lowercased, but we can be super explicit!\n    return host.toLowerCase();\n}\n/**\n * Validate value is valid email\n */\nexport function validateEmail(input, opts) {\n    const value = validateString(input, opts);\n    if (value === undefined)\n        return value;\n    const valid = value\n        .toLowerCase()\n        .match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/);\n    if (!valid) {\n        return validationError(`must be valid email address: ${value}`, opts);\n    }\n    return value;\n}\n/**\n * Validate value against array of choices\n */\nexport function validateChoice(input, opts) {\n    if (!opts.choices.includes(input)) {\n        return validationError(`invalid value '${input}' - must be one of [${opts.choices.join(', ')}]`, opts);\n    }\n    return input;\n}\n/**\n * Validate value against enum\n *\n * Must provide enum object as both option 'enum' and the type variable.\n */\nexport function validateEnum(input, opts) {\n    if (!Object.values(opts.enum).includes(input)) {\n        return validationError(`invalid value '${input}' - must be one of [${Object.values(opts.enum).join(', ')}]`, opts);\n    }\n    return input;\n}\n/**\n * Validate date string or object\n *\n * Uses javascript Date() constructor; any input to the constructor that returns\n * a valid date is valid input. This includes ISO 8601 formatted strings and\n * IETF timestamps are valid.\n */\nexport function validateDate(input, opts) {\n    const date = new Date(input);\n    if (!date.getDate()) {\n        return validationError(`invalid date \"${input}\" - must be ISO 8601 format or IETF timestamp`, opts);\n    }\n    return typeof input === 'string' ? input : formatDate(date);\n}\n/**\n * Validates value is an object with string keys\n */\nexport function validateObject(input, opts) {\n    if (typeof input !== 'object')\n        return validationError(`must be object`, opts);\n    if (Array.isArray(input))\n        return validationError(`must be object, not array`, opts);\n    return input;\n}\n/**\n * Validate an object has all required keys\n *\n * Returns new object with only required/optional keys\n */\nexport function validateKeys(input, keys, opts) {\n    var _a;\n    const value = {};\n    let required = keys.required || [];\n    const optional = keys.optional || [];\n    const aliasKeys = Object.entries((_a = keys.alias) !== null && _a !== void 0 ? _a : {})\n        // Remove aliases that do not resolve to valid keys\n        .filter((alias) => required.includes(alias[1]) || optional.includes(alias[1]))\n        .map((alias) => alias[0]);\n    const ignored = [];\n    Object.keys(input).forEach((k) => {\n        var _a;\n        if (required.includes(k) || optional.includes(k)) {\n            value[k] = input[k];\n            required = required.filter((val) => val !== k);\n        }\n        else if (aliasKeys.includes(k)) {\n            const normalized = (_a = keys.alias) === null || _a === void 0 ? void 0 : _a[k];\n            if (input[normalized] === undefined) {\n                value[normalized] = input[k];\n                required = required.filter((val) => val !== normalized);\n            }\n            else {\n                validationWarning(`both \"${normalized}\" and \"${k}\" were provided, \"${k}\" was ignored.`, opts);\n            }\n        }\n        else {\n            ignored.push(k);\n            if (opts.keepExtraKeys)\n                value[k] = input[k];\n        }\n    });\n    if (required.length) {\n        validationError(`missing required key${required.length > 1 ? 's' : ''}: ${required.join(', ')}`, opts);\n        if (!opts.returnInvalidPartial)\n            return undefined;\n    }\n    if (ignored.length) {\n        validationWarning(`extra key${ignored.length > 1 ? 's' : ''} ignored: ${ignored.join(', ')}`, opts);\n    }\n    return value;\n}\n/**\n * Validates value is an object and has all required keys\n *\n * Returns new object with only required/optional keys\n */\nexport function validateObjectKeys(input, keys, opts) {\n    const value = validateObject(input, opts);\n    if (value === undefined)\n        return undefined;\n    return validateKeys(value, keys, opts);\n}\n/**\n * Validate value is a list\n */\nexport function validateList(input, opts, itemValidator) {\n    let value;\n    if (Array.isArray(input)) {\n        value = input;\n    }\n    else if (opts.coerce) {\n        value = [input];\n    }\n    else {\n        return validationError('must be an array', opts);\n    }\n    return value\n        .map((item, index) => itemValidator(item, index))\n        .filter((item) => item !== undefined);\n}\n/**\n * Copy 'base' object and fill any 'keys' that are missing with their values from 'filler'\n */\nexport function fillMissingKeys(base, filler, keys) {\n    const output = { ...base };\n    keys.forEach((key) => {\n        if (!defined(output[key]) && defined(filler[key])) {\n            const k = key;\n            output[k] = filler[k];\n        }\n    });\n    return output;\n}\nexport function filterKeys(value, keys) {\n    return fillMissingKeys({}, value, keys);\n}\n", "import { defined, fillMissingKeys, incrementOptions, validateBoolean, validateNumber, validateObjectKeys, validateString, validationWarning, } from 'simple-validators';\nexport const NUMBERING_OPTIONS = ['enumerator', 'all', 'headings'];\nconst HEADING_KEYS = ['heading_1', 'heading_2', 'heading_3', 'heading_4', 'heading_5', 'heading_6'];\nexport const NUMBERING_KEYS = [\n    'figure',\n    'subfigure',\n    'equation',\n    'subequation',\n    'table',\n    'code',\n    ...HEADING_KEYS,\n];\nconst NUMBERING_ITEM_KEYS = ['enabled', 'start', 'template'];\nexport const NUMBERING_ALIAS = {\n    sections: 'headings',\n    h1: 'heading_1',\n    h2: 'heading_2',\n    h3: 'heading_3',\n    h4: 'heading_4',\n    h5: 'heading_5',\n    h6: 'heading_6',\n    heading1: 'heading_1',\n    heading2: 'heading_2',\n    heading3: 'heading_3',\n    heading4: 'heading_4',\n    heading5: 'heading_5',\n    heading6: 'heading_6',\n};\nfunction isBoolean(input) {\n    if (typeof input === 'string') {\n        return ['true', 'false'].includes(input.toLowerCase());\n    }\n    return typeof input === 'boolean';\n}\n/**\n * Validate value for each numbering entry\n *\n * Value may be:\n * - boolean, to simply enable/disable numbering\n * - number, to indicate the starting number\n * - string, to define the cross-reference template\n *   (e.g. 'Fig. %s' to get \"Fig. 1\" instead of \"Figure 1\" in your document)\n * - An object with any of enabled/start/template - specifying the above types\n *   will coerce to this object\n */\nexport function validateNumberingItem(input, opts) {\n    var _a, _b;\n    if (isBoolean(input)) {\n        input = { enabled: input };\n    }\n    else if (typeof input === 'number') {\n        input = { start: input };\n    }\n    else if (typeof input === 'string') {\n        input = { template: input };\n    }\n    const value = validateObjectKeys(input, { optional: NUMBERING_ITEM_KEYS }, opts);\n    if (value === undefined)\n        return undefined;\n    const output = {};\n    if (defined(value.enabled)) {\n        const enabled = validateBoolean(value.enabled, incrementOptions('enabled', opts));\n        if (defined(enabled))\n            output.enabled = enabled;\n    }\n    if (defined(value.start)) {\n        const start = validateNumber(value.start, {\n            ...incrementOptions('start', opts),\n            integer: true,\n            min: 1,\n        });\n        if (start) {\n            output.start = start;\n            output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;\n        }\n    }\n    if (defined(value.template)) {\n        const template = validateString(value.template, incrementOptions('template', opts));\n        if (defined(template)) {\n            output.template = template;\n            output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;\n        }\n    }\n    if (Object.keys(output).length === 0)\n        return undefined;\n    return output;\n}\n/**\n * Validate Numbering object\n */\nexport function validateNumbering(input, opts) {\n    var _a, _b, _c, _d;\n    if (isBoolean(input)) {\n        input = { all: input };\n    }\n    const value = validateObjectKeys(input, { optional: [...NUMBERING_KEYS, ...NUMBERING_OPTIONS], alias: NUMBERING_ALIAS }, { ...opts, suppressWarnings: true, keepExtraKeys: true });\n    if (value === undefined)\n        return undefined;\n    const output = {};\n    let headings;\n    if (defined(value.enumerator)) {\n        const enumeratorOpts = incrementOptions('enumerator', opts);\n        output.enumerator = validateNumberingItem(value.enumerator, enumeratorOpts);\n        if (((_a = output.enumerator) === null || _a === void 0 ? void 0 : _a.enabled) != null) {\n            if (output.enumerator.enabled !== true) {\n                validationWarning(\"value for 'enabled' is ignored\", enumeratorOpts);\n            }\n            delete output.enumerator.enabled;\n        }\n        if (((_b = output.enumerator) === null || _b === void 0 ? void 0 : _b.start) != null) {\n            validationWarning(\"value for 'start' is ignored\", enumeratorOpts);\n            delete output.enumerator.start;\n        }\n    }\n    if (defined(value.all)) {\n        const allOpts = incrementOptions('all', opts);\n        output.all = validateNumberingItem(value.all, allOpts);\n        if (((_c = output.all) === null || _c === void 0 ? void 0 : _c.template) != null) {\n            validationWarning(\"value for 'template' is ignored\", allOpts);\n            delete output.all.template;\n        }\n        if (((_d = output.all) === null || _d === void 0 ? void 0 : _d.start) != null) {\n            validationWarning(\"value for 'start' is ignored\", allOpts);\n            delete output.all.start;\n        }\n    }\n    if (defined(value.headings)) {\n        headings = validateNumberingItem(value.headings, incrementOptions('headings', opts));\n        HEADING_KEYS.forEach((headingKey) => {\n            if (headings && !defined(value[headingKey])) {\n                value[headingKey] = headings;\n            }\n        });\n    }\n    Object.keys(value)\n        .filter((key) => !NUMBERING_OPTIONS.includes(key)) // For all the unknown options\n        .forEach((key) => {\n        if (defined(value[key])) {\n            const item = validateNumberingItem(value[key], incrementOptions(key, opts));\n            if (!defined(item))\n                return;\n            if (headings && HEADING_KEYS.includes(key)) {\n                output[key] = { ...headings, ...item };\n            }\n            else {\n                output[key] = item;\n            }\n        }\n    });\n    if (Object.keys(output).length === 0)\n        return undefined;\n    return output;\n}\nexport function fillNumbering(base, filler) {\n    const output = { ...filler, ...base };\n    Object.entries(filler !== null && filler !== void 0 ? filler : {})\n        .filter(([key]) => !NUMBERING_OPTIONS.includes(key))\n        .forEach(([key, val]) => {\n        var _a, _b, _c;\n        output[key] = fillMissingKeys((_a = base === null || base === void 0 ? void 0 : base[key]) !== null && _a !== void 0 ? _a : {}, \n        // Enabling/disabling all in base overrides filler\n        { ...val, enabled: (_c = (_b = base === null || base === void 0 ? void 0 : base.all) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : val.enabled }, NUMBERING_ITEM_KEYS);\n    });\n    return output;\n}\n"],
  "mappings": "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",
  "names": ["doi", "_a"]
}
