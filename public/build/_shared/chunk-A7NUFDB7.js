import {
  color,
  format,
  init_src,
  init_src2
} from "/myst_assets_folder/_shared/chunk-WYS2FUD5.js";
import {
  SourceFileKind,
  credit,
  orcid
} from "/myst_assets_folder/_shared/chunk-GMJYAADD.js";
import {
  defined,
  doi,
  filterKeys,
  incrementOptions,
  validateBoolean,
  validateChoice,
  validateDate,
  validateEmail,
  validateEnum,
  validateKeys,
  validateList,
  validateNumber,
  validateNumbering,
  validateObject,
  validateObjectKeys,
  validateString,
  validateUrl,
  validationError,
  validationWarning
} from "/myst_assets_folder/_shared/chunk-D7IISHX5.js";
import {
  ArrayExt,
  MessageLoop,
  Platform,
  each,
  init_index_es6 as init_index_es64,
  init_index_es62 as init_index_es65,
  init_index_es63 as init_index_es66
} from "/myst_assets_folder/_shared/chunk-KAB4N37T.js";
import {
  require_entities
} from "/myst_assets_folder/_shared/chunk-6S3SPRRW.js";
import {
  require_classnames
} from "/myst_assets_folder/_shared/chunk-XJ2I6HXP.js";
import {
  VFile
} from "/myst_assets_folder/_shared/chunk-44FAGZWP.js";
import {
  FRONTMATTER_ALIASES,
  RuleId,
  SITE_FRONTMATTER_KEYS,
  copyNode,
  extractPart,
  fileError,
  select,
  selectAll,
  selectMdastNodes
} from "/myst_assets_folder/_shared/chunk-MQHORMXT.js";
import {
  BoxLayout,
  BoxPanel,
  Button,
  FocusTracker,
  GroupItem,
  LabIcon,
  ObservableJSON,
  ObservableList,
  Panel,
  PanelLayout,
  ReactWidget,
  ReactiveToolbar,
  Signal,
  Spinner,
  Styling,
  TabBar,
  TextItem,
  Toolbar,
  ToolbarButton,
  ToolbarButtonComponent,
  UseSignal,
  VDomModel,
  VDomRenderer,
  Widget,
  __assign,
  __awaiter,
  __rest,
  __spreadArray,
  _arrayLikeToArray,
  _defineProperty,
  _extends,
  _toPropertyKey,
  _typeof,
  _unsupportedIterableToArray,
  circleEmptyIcon,
  circleIcon,
  closeIcon,
  init_arrayLikeToArray,
  init_defineProperty,
  init_extends,
  init_index_es6,
  init_index_es62,
  init_index_es63,
  init_lib,
  init_lib2,
  init_lib3,
  init_lib4,
  init_toPropertyKey,
  init_tslib_es6,
  init_typeof,
  init_unsupportedIterableToArray,
  kernelIcon,
  nullTranslator,
  offlineBoltIcon,
  refreshIcon,
  require_dist,
  require_isEqual,
  require_jsx_runtime,
  require_lib,
  require_lib2,
  require_lib3,
  stopIcon,
  terminalIcon,
  tslib_es6_exports
} from "/myst_assets_folder/_shared/chunk-54HHBP5N.js";
import {
  Link,
  Links,
  LiveReload,
  Meta,
  NavLink,
  Scripts,
  ScrollRestoration,
  require_jsx_dev_runtime,
  useLocation,
  useNavigation
} from "/myst_assets_folder/_shared/chunk-JGXWLEDJ.js";
import {
  require_client,
  require_react,
  require_react_dom
} from "/myst_assets_folder/_shared/chunk-SMG2HPMX.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "/myst_assets_folder/_shared/chunk-D5NAPBYJ.js";

// ../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o10) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o11) {
        return typeof o11;
      } : function(o11) {
        return o11 && "function" == typeof Symbol && o11.constructor === Symbol && o11 !== Symbol.prototype ? "symbol" : typeof o11;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o10);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime3() {
      "use strict";
      module.exports = _regeneratorRuntime3 = function _regeneratorRuntime4() {
        return e4;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t10, e4 = {}, r4 = Object.prototype, n4 = r4.hasOwnProperty, o10 = Object.defineProperty || function(t11, e5, r5) {
        t11[e5] = r5.value;
      }, i5 = "function" == typeof Symbol ? Symbol : {}, a4 = i5.iterator || "@@iterator", c6 = i5.asyncIterator || "@@asyncIterator", u4 = i5.toStringTag || "@@toStringTag";
      function define2(t11, e5, r5) {
        return Object.defineProperty(t11, e5, {
          value: r5,
          enumerable: true,
          configurable: true,
          writable: true
        }), t11[e5];
      }
      try {
        define2({}, "");
      } catch (t11) {
        define2 = function define3(t12, e5, r5) {
          return t12[e5] = r5;
        };
      }
      function wrap2(t11, e5, r5, n5) {
        var i6 = e5 && e5.prototype instanceof Generator ? e5 : Generator, a5 = Object.create(i6.prototype), c7 = new Context2(n5 || []);
        return o10(a5, "_invoke", {
          value: makeInvokeMethod(t11, r5, c7)
        }), a5;
      }
      function tryCatch(t11, e5, r5) {
        try {
          return {
            type: "normal",
            arg: t11.call(e5, r5)
          };
        } catch (t12) {
          return {
            type: "throw",
            arg: t12
          };
        }
      }
      e4.wrap = wrap2;
      var h4 = "suspendedStart", l7 = "suspendedYield", f6 = "executing", s7 = "completed", y3 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p3 = {};
      define2(p3, a4, function() {
        return this;
      });
      var d6 = Object.getPrototypeOf, v2 = d6 && d6(d6(values2([])));
      v2 && v2 !== r4 && n4.call(v2, a4) && (p3 = v2);
      var g4 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p3);
      function defineIteratorMethods(t11) {
        ["next", "throw", "return"].forEach(function(e5) {
          define2(t11, e5, function(t12) {
            return this._invoke(e5, t12);
          });
        });
      }
      function AsyncIterator(t11, e5) {
        function invoke(r6, o11, i6, a5) {
          var c7 = tryCatch(t11[r6], t11, o11);
          if ("throw" !== c7.type) {
            var u5 = c7.arg, h5 = u5.value;
            return h5 && "object" == _typeof2(h5) && n4.call(h5, "__await") ? e5.resolve(h5.__await).then(function(t12) {
              invoke("next", t12, i6, a5);
            }, function(t12) {
              invoke("throw", t12, i6, a5);
            }) : e5.resolve(h5).then(function(t12) {
              u5.value = t12, i6(u5);
            }, function(t12) {
              return invoke("throw", t12, i6, a5);
            });
          }
          a5(c7.arg);
        }
        var r5;
        o10(this, "_invoke", {
          value: function value(t12, n5) {
            function callInvokeWithMethodAndArg() {
              return new e5(function(e6, r6) {
                invoke(t12, n5, e6, r6);
              });
            }
            return r5 = r5 ? r5.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e5, r5, n5) {
        var o11 = h4;
        return function(i6, a5) {
          if (o11 === f6)
            throw new Error("Generator is already running");
          if (o11 === s7) {
            if ("throw" === i6)
              throw a5;
            return {
              value: t10,
              done: true
            };
          }
          for (n5.method = i6, n5.arg = a5; ; ) {
            var c7 = n5.delegate;
            if (c7) {
              var u5 = maybeInvokeDelegate(c7, n5);
              if (u5) {
                if (u5 === y3)
                  continue;
                return u5;
              }
            }
            if ("next" === n5.method)
              n5.sent = n5._sent = n5.arg;
            else if ("throw" === n5.method) {
              if (o11 === h4)
                throw o11 = s7, n5.arg;
              n5.dispatchException(n5.arg);
            } else
              "return" === n5.method && n5.abrupt("return", n5.arg);
            o11 = f6;
            var p4 = tryCatch(e5, r5, n5);
            if ("normal" === p4.type) {
              if (o11 = n5.done ? s7 : l7, p4.arg === y3)
                continue;
              return {
                value: p4.arg,
                done: n5.done
              };
            }
            "throw" === p4.type && (o11 = s7, n5.method = "throw", n5.arg = p4.arg);
          }
        };
      }
      function maybeInvokeDelegate(e5, r5) {
        var n5 = r5.method, o11 = e5.iterator[n5];
        if (o11 === t10)
          return r5.delegate = null, "throw" === n5 && e5.iterator["return"] && (r5.method = "return", r5.arg = t10, maybeInvokeDelegate(e5, r5), "throw" === r5.method) || "return" !== n5 && (r5.method = "throw", r5.arg = new TypeError("The iterator does not provide a '" + n5 + "' method")), y3;
        var i6 = tryCatch(o11, e5.iterator, r5.arg);
        if ("throw" === i6.type)
          return r5.method = "throw", r5.arg = i6.arg, r5.delegate = null, y3;
        var a5 = i6.arg;
        return a5 ? a5.done ? (r5[e5.resultName] = a5.value, r5.next = e5.nextLoc, "return" !== r5.method && (r5.method = "next", r5.arg = t10), r5.delegate = null, y3) : a5 : (r5.method = "throw", r5.arg = new TypeError("iterator result is not an object"), r5.delegate = null, y3);
      }
      function pushTryEntry(t11) {
        var e5 = {
          tryLoc: t11[0]
        };
        1 in t11 && (e5.catchLoc = t11[1]), 2 in t11 && (e5.finallyLoc = t11[2], e5.afterLoc = t11[3]), this.tryEntries.push(e5);
      }
      function resetTryEntry(t11) {
        var e5 = t11.completion || {};
        e5.type = "normal", delete e5.arg, t11.completion = e5;
      }
      function Context2(t11) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t11.forEach(pushTryEntry, this), this.reset(true);
      }
      function values2(e5) {
        if (e5 || "" === e5) {
          var r5 = e5[a4];
          if (r5)
            return r5.call(e5);
          if ("function" == typeof e5.next)
            return e5;
          if (!isNaN(e5.length)) {
            var o11 = -1, i6 = function next() {
              for (; ++o11 < e5.length; )
                if (n4.call(e5, o11))
                  return next.value = e5[o11], next.done = false, next;
              return next.value = t10, next.done = true, next;
            };
            return i6.next = i6;
          }
        }
        throw new TypeError(_typeof2(e5) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o10(g4, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o10(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u4, "GeneratorFunction"), e4.isGeneratorFunction = function(t11) {
        var e5 = "function" == typeof t11 && t11.constructor;
        return !!e5 && (e5 === GeneratorFunction || "GeneratorFunction" === (e5.displayName || e5.name));
      }, e4.mark = function(t11) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t11, GeneratorFunctionPrototype) : (t11.__proto__ = GeneratorFunctionPrototype, define2(t11, u4, "GeneratorFunction")), t11.prototype = Object.create(g4), t11;
      }, e4.awrap = function(t11) {
        return {
          __await: t11
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c6, function() {
        return this;
      }), e4.AsyncIterator = AsyncIterator, e4.async = function(t11, r5, n5, o11, i6) {
        void 0 === i6 && (i6 = Promise);
        var a5 = new AsyncIterator(wrap2(t11, r5, n5, o11), i6);
        return e4.isGeneratorFunction(r5) ? a5 : a5.next().then(function(t12) {
          return t12.done ? t12.value : a5.next();
        });
      }, defineIteratorMethods(g4), define2(g4, u4, "Generator"), define2(g4, a4, function() {
        return this;
      }), define2(g4, "toString", function() {
        return "[object Generator]";
      }), e4.keys = function(t11) {
        var e5 = Object(t11), r5 = [];
        for (var n5 in e5)
          r5.push(n5);
        return r5.reverse(), function next() {
          for (; r5.length; ) {
            var t12 = r5.pop();
            if (t12 in e5)
              return next.value = t12, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e4.values = values2, Context2.prototype = {
        constructor: Context2,
        reset: function reset(e5) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t10, this.done = false, this.delegate = null, this.method = "next", this.arg = t10, this.tryEntries.forEach(resetTryEntry), !e5)
            for (var r5 in this)
              "t" === r5.charAt(0) && n4.call(this, r5) && !isNaN(+r5.slice(1)) && (this[r5] = t10);
        },
        stop: function stop() {
          this.done = true;
          var t11 = this.tryEntries[0].completion;
          if ("throw" === t11.type)
            throw t11.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e5) {
          if (this.done)
            throw e5;
          var r5 = this;
          function handle(n5, o12) {
            return a5.type = "throw", a5.arg = e5, r5.next = n5, o12 && (r5.method = "next", r5.arg = t10), !!o12;
          }
          for (var o11 = this.tryEntries.length - 1; o11 >= 0; --o11) {
            var i6 = this.tryEntries[o11], a5 = i6.completion;
            if ("root" === i6.tryLoc)
              return handle("end");
            if (i6.tryLoc <= this.prev) {
              var c7 = n4.call(i6, "catchLoc"), u5 = n4.call(i6, "finallyLoc");
              if (c7 && u5) {
                if (this.prev < i6.catchLoc)
                  return handle(i6.catchLoc, true);
                if (this.prev < i6.finallyLoc)
                  return handle(i6.finallyLoc);
              } else if (c7) {
                if (this.prev < i6.catchLoc)
                  return handle(i6.catchLoc, true);
              } else {
                if (!u5)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i6.finallyLoc)
                  return handle(i6.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t11, e5) {
          for (var r5 = this.tryEntries.length - 1; r5 >= 0; --r5) {
            var o11 = this.tryEntries[r5];
            if (o11.tryLoc <= this.prev && n4.call(o11, "finallyLoc") && this.prev < o11.finallyLoc) {
              var i6 = o11;
              break;
            }
          }
          i6 && ("break" === t11 || "continue" === t11) && i6.tryLoc <= e5 && e5 <= i6.finallyLoc && (i6 = null);
          var a5 = i6 ? i6.completion : {};
          return a5.type = t11, a5.arg = e5, i6 ? (this.method = "next", this.next = i6.finallyLoc, y3) : this.complete(a5);
        },
        complete: function complete(t11, e5) {
          if ("throw" === t11.type)
            throw t11.arg;
          return "break" === t11.type || "continue" === t11.type ? this.next = t11.arg : "return" === t11.type ? (this.rval = this.arg = t11.arg, this.method = "return", this.next = "end") : "normal" === t11.type && e5 && (this.next = e5), y3;
        },
        finish: function finish(t11) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r5 = this.tryEntries[e5];
            if (r5.finallyLoc === t11)
              return this.complete(r5.completion, r5.afterLoc), resetTryEntry(r5), y3;
          }
        },
        "catch": function _catch(t11) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r5 = this.tryEntries[e5];
            if (r5.tryLoc === t11) {
              var n5 = r5.completion;
              if ("throw" === n5.type) {
                var o11 = n5.arg;
                resetTryEntry(r5);
              }
              return o11;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e5, r5, n5) {
          return this.delegate = {
            iterator: values2(e5),
            resultName: r5,
            nextLoc: n5
          }, "next" === this.method && (this.arg = t10), y3;
        }
      }, e4;
    }
    module.exports = _regeneratorRuntime3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "../../node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React85 = require_react();
        var ReactSharedInternals = React85.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x4, y3) {
          return x4 === y3 && (x4 !== 0 || 1 / x4 === 1 / y3) || x4 !== x4 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState23 = React85.useState, useEffect23 = React85.useEffect, useLayoutEffect4 = React85.useLayoutEffect, useDebugValue2 = React85.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React85.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState23({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect4(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect23(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React85.useSyncExternalStore !== void 0 ? React85.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "../../node_modules/spdx-license-ids/index.json"(exports, module) {
    module.exports = [
      "0BSD",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMDPLPA",
      "AML",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "ASWF-Digital-Assets-1.0",
      "ASWF-Digital-Assets-1.1",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Glyph",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Boehm-GC",
      "Borceux",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-3.0-IGO",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Crossword",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DL-DE-BY-2.0",
      "DOC",
      "DRL-1.0",
      "DSDP",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FDK-AAC",
      "FSFAP",
      "FSFUL",
      "FSFULLR",
      "FSFULLRWD",
      "FTL",
      "Fair",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "HP-1986",
      "HPND",
      "HPND-Markus-Kuhn",
      "HPND-export-US",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Inner-Net-2.0",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Latex2e-translated-notice",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-1-para",
      "Linux-man-pages-copyleft",
      "Linux-man-pages-copyleft-2-para",
      "Linux-man-pages-copyleft-var",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Festival",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MITNFA",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "MakeIndex",
      "Martin-Birgmeier",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCGL-UK-2.0",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NIST-Software",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTP",
      "NTP-0",
      "Naumen",
      "Net-SNMP",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OLFL-1.3",
      "OML",
      "OPL-1.0",
      "OPL-UK-3.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "SAX-PD",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SGP4",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSPL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "SimPL-2.0",
      "Sleepycat",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "TermReadKey",
      "UCAR",
      "UCL-1.0",
      "UPL-1.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "UnixCrypt",
      "Unlicense",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Widget-Workshop",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "XFree86-1.1",
      "XSkat",
      "Xdebug-1.03",
      "Xerox",
      "Xfig",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "blessing",
      "bzip2-1.0.6",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "diffmark",
      "dtoa",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "gSOAP-1.3b",
      "gnuplot",
      "iMatix",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "metamail",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "psfrag",
      "psutils",
      "snprintf",
      "w3m",
      "xinetd",
      "xlock",
      "xpp",
      "zlib-acknowledgement"
    ];
  }
});

// ../../node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "../../node_modules/spdx-license-ids/deprecated.json"(exports, module) {
    module.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// ../../node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "../../node_modules/spdx-exceptions/index.json"(exports, module) {
    module.exports = [
      "389-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-3.1",
      "gnu-javamail-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "i2p-gpl-java-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "Nokia-Qt-exception-1.1",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "Swift-exception",
      "u-boot-exception-2.0",
      "Universal-FOSS-exception-1.0",
      "WxWindows-exception-3.1"
    ];
  }
});

// ../../node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "../../node_modules/spdx-expression-parse/scan.js"(exports, module) {
    "use strict";
    var licenses2 = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module.exports = function(source) {
      var index2 = 0;
      function hasMore() {
        return index2 < source.length;
      }
      function read(value) {
        if (value instanceof RegExp) {
          var chars = source.slice(index2);
          var match = chars.match(value);
          if (match) {
            index2 += match[0].length;
            return match[0];
          }
        } else {
          if (source.indexOf(value, index2) === index2) {
            index2 += value.length;
            return value;
          }
        }
      }
      function skipWhitespace() {
        read(/[ ]*/);
      }
      function operator() {
        var string;
        var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
        for (var i5 = 0; i5 < possibilities.length; i5++) {
          string = read(possibilities[i5]);
          if (string) {
            break;
          }
        }
        if (string === "+" && index2 > 1 && source[index2 - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string && {
          type: "OPERATOR",
          string
        };
      }
      function idstring() {
        return read(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string = idstring();
        if (!string) {
          throw new Error("Expected idstring at offset " + index2);
        }
        return string;
      }
      function documentRef() {
        if (read("DocumentRef-")) {
          var string = expectIdstring();
          return { type: "DOCUMENTREF", string };
        }
      }
      function licenseRef() {
        if (read("LicenseRef-")) {
          var string = expectIdstring();
          return { type: "LICENSEREF", string };
        }
      }
      function identifier() {
        var begin = index2;
        var string = idstring();
        if (licenses2.indexOf(string) !== -1) {
          return {
            type: "LICENSE",
            string
          };
        } else if (exceptions.indexOf(string) !== -1) {
          return {
            type: "EXCEPTION",
            string
          };
        }
        index2 = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token = parseToken();
        if (!token) {
          throw new Error("Unexpected `" + source[index2] + "` at offset " + index2);
        }
        tokens.push(token);
      }
      return tokens;
    };
  }
});

// ../../node_modules/spdx-expression-parse/parse.js
var require_parse = __commonJS({
  "../../node_modules/spdx-expression-parse/parse.js"(exports, module) {
    "use strict";
    module.exports = function(tokens) {
      var index2 = 0;
      function hasMore() {
        return index2 < tokens.length;
      }
      function token() {
        return hasMore() ? tokens[index2] : null;
      }
      function next() {
        if (!hasMore()) {
          throw new Error();
        }
        index2++;
      }
      function parseOperator(operator) {
        var t10 = token();
        if (t10 && t10.type === "OPERATOR" && operator === t10.string) {
          next();
          return t10.string;
        }
      }
      function parseWith() {
        if (parseOperator("WITH")) {
          var t10 = token();
          if (t10 && t10.type === "EXCEPTION") {
            next();
            return t10.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index2;
        var string = "";
        var t10 = token();
        if (t10.type === "DOCUMENTREF") {
          next();
          string += "DocumentRef-" + t10.string + ":";
          if (!parseOperator(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t10 = token();
        if (t10.type === "LICENSEREF") {
          next();
          string += "LicenseRef-" + t10.string;
          return { license: string };
        }
        index2 = begin;
      }
      function parseLicense() {
        var t10 = token();
        if (t10 && t10.type === "LICENSE") {
          next();
          var node2 = { license: t10.string };
          if (parseOperator("+")) {
            node2.plus = true;
          }
          var exception2 = parseWith();
          if (exception2) {
            node2.exception = exception2;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left = parseOperator("(");
        if (!left) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left = nextParser();
          if (!left) {
            return;
          }
          if (!parseOperator(operator)) {
            return left;
          }
          var right = parseBinaryOp();
          if (!right) {
            throw new Error("Expected expression");
          }
          return {
            left,
            conjunction: operator.toLowerCase(),
            right
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// ../../node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "../../node_modules/spdx-expression-parse/index.js"(exports, module) {
    "use strict";
    var scan = require_scan();
    var parse4 = require_parse();
    module.exports = function(source) {
      return parse4(scan(source));
    };
  }
});

// ../../node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS({
  "../../node_modules/spdx-correct/index.js"(exports, module) {
    var parse4 = require_spdx_expression_parse();
    var spdxLicenseIds = require_spdx_license_ids();
    function valid2(string) {
      try {
        parse4(string);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sortTranspositions(a4, b4) {
      var length = b4[0].length - a4[0].length;
      if (length !== 0)
        return length;
      return a4[0].toUpperCase().localeCompare(b4[0].toUpperCase());
    }
    var transpositions = [
      ["APGL", "AGPL"],
      ["Gpl", "GPL"],
      ["GLP", "GPL"],
      ["APL", "Apache"],
      ["ISD", "ISC"],
      ["GLP", "GPL"],
      ["IST", "ISC"],
      ["Claude", "Clause"],
      [" or later", "+"],
      [" International", ""],
      ["GNU", "GPL"],
      ["GUN", "GPL"],
      ["+", ""],
      ["GNU GPL", "GPL"],
      ["GNU LGPL", "LGPL"],
      ["GNU/GPL", "GPL"],
      ["GNU GLP", "GPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["GNU Lesser General Public License", "LGPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["GNU Lesser General Public License", "LGPL-2.1"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["Lesser General Public License", "LGPL"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["Lesser General Public License", "LGPL-2.1"],
      ["GNU General Public License", "GPL"],
      ["Gnu public license", "GPL"],
      ["GNU Public License", "GPL"],
      ["GNU GENERAL PUBLIC LICENSE", "GPL"],
      ["MTI", "MIT"],
      ["Mozilla Public License", "MPL"],
      ["Universal Permissive License", "UPL"],
      ["WTH", "WTF"],
      ["WTFGPL", "WTFPL"],
      ["-License", ""]
    ].sort(sortTranspositions);
    var TRANSPOSED = 0;
    var CORRECT = 1;
    var transforms = [
      // e.g. 'mit'
      function(argument) {
        return argument.toUpperCase();
      },
      // e.g. 'MIT '
      function(argument) {
        return argument.trim();
      },
      // e.g. 'M.I.T.'
      function(argument) {
        return argument.replace(/\./g, "");
      },
      // e.g. 'Apache- 2.0'
      function(argument) {
        return argument.replace(/\s+/g, "");
      },
      // e.g. 'CC BY 4.0''
      function(argument) {
        return argument.replace(/\s+/g, "-");
      },
      // e.g. 'LGPLv2.1'
      function(argument) {
        return argument.replace("v", "-");
      },
      // e.g. 'Apache 2.0'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1");
      },
      // e.g. 'GPL 2'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1.0");
      },
      // e.g. 'Apache Version 2.0'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
      },
      // e.g. 'Apache Version 2'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
      },
      // e.g. 'ZLIB'
      function(argument) {
        return argument[0].toUpperCase() + argument.slice(1);
      },
      // e.g. 'MPL/2.0'
      function(argument) {
        return argument.replace("/", "-");
      },
      // e.g. 'Apache 2'
      function(argument) {
        return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
      },
      // e.g. 'GPL-2.0', 'GPL-3.0'
      function(argument) {
        if (argument.indexOf("3.0") !== -1) {
          return argument + "-or-later";
        } else {
          return argument + "-only";
        }
      },
      // e.g. 'GPL-2.0-'
      function(argument) {
        return argument + "only";
      },
      // e.g. 'GPL2'
      function(argument) {
        return argument.replace(/(\d)$/, "-$1.0");
      },
      // e.g. 'BSD 3'
      function(argument) {
        return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
      },
      // e.g. 'BSD clause 3'
      function(argument) {
        return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
      },
      // e.g. 'New BSD license'
      function(argument) {
        return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
      },
      // e.g. 'Simplified BSD license'
      function(argument) {
        return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
      },
      // e.g. 'Free BSD license'
      function(argument) {
        return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
      },
      // e.g. 'Clear BSD license'
      function(argument) {
        return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
      },
      // e.g. 'Old BSD License'
      function(argument) {
        return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
      },
      // e.g. 'BY-NC-4.0'
      function(argument) {
        return "CC-" + argument;
      },
      // e.g. 'BY-NC'
      function(argument) {
        return "CC-" + argument + "-4.0";
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
      }
    ];
    var licensesWithVersions = spdxLicenseIds.map(function(id) {
      var match = /^(.*)-\d+\.\d+$/.exec(id);
      return match ? [match[0], match[1]] : [id, null];
    }).reduce(function(objectMap, item) {
      var key = item[1];
      objectMap[key] = objectMap[key] || [];
      objectMap[key].push(item[0]);
      return objectMap;
    }, {});
    var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
      return [key, licensesWithVersions[key]];
    }).filter(function identifySoleVersions(item) {
      return (
        // Licenses has just one valid version suffix.
        item[1].length === 1 && item[0] !== null && // APL will be considered Apache, rather than APL-1.0
        item[0] !== "APL"
      );
    }).map(function createLastResorts(item) {
      return [item[0], item[1][0]];
    });
    licensesWithVersions = void 0;
    var lastResorts = [
      ["UNLI", "Unlicense"],
      ["WTF", "WTFPL"],
      ["2 CLAUSE", "BSD-2-Clause"],
      ["2-CLAUSE", "BSD-2-Clause"],
      ["3 CLAUSE", "BSD-3-Clause"],
      ["3-CLAUSE", "BSD-3-Clause"],
      ["AFFERO", "AGPL-3.0-or-later"],
      ["AGPL", "AGPL-3.0-or-later"],
      ["APACHE", "Apache-2.0"],
      ["ARTISTIC", "Artistic-2.0"],
      ["Affero", "AGPL-3.0-or-later"],
      ["BEER", "Beerware"],
      ["BOOST", "BSL-1.0"],
      ["BSD", "BSD-2-Clause"],
      ["CDDL", "CDDL-1.1"],
      ["ECLIPSE", "EPL-1.0"],
      ["FUCK", "WTFPL"],
      ["GNU", "GPL-3.0-or-later"],
      ["LGPL", "LGPL-3.0-or-later"],
      ["GPLV1", "GPL-1.0-only"],
      ["GPL-1", "GPL-1.0-only"],
      ["GPLV2", "GPL-2.0-only"],
      ["GPL-2", "GPL-2.0-only"],
      ["GPL", "GPL-3.0-or-later"],
      ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
      ["MIT", "MIT"],
      ["MPL", "MPL-2.0"],
      ["X11", "X11"],
      ["ZLIB", "Zlib"]
    ].concat(licensesWithOneVersion).sort(sortTranspositions);
    var SUBSTRING = 0;
    var IDENTIFIER = 1;
    var validTransformation = function(identifier) {
      for (var i5 = 0; i5 < transforms.length; i5++) {
        var transformed = transforms[i5](identifier).trim();
        if (transformed !== identifier && valid2(transformed)) {
          return transformed;
        }
      }
      return null;
    };
    var validLastResort = function(identifier) {
      var upperCased = identifier.toUpperCase();
      for (var i5 = 0; i5 < lastResorts.length; i5++) {
        var lastResort = lastResorts[i5];
        if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
          return lastResort[IDENTIFIER];
        }
      }
      return null;
    };
    var anyCorrection = function(identifier, check) {
      for (var i5 = 0; i5 < transpositions.length; i5++) {
        var transposition = transpositions[i5];
        var transposed = transposition[TRANSPOSED];
        if (identifier.indexOf(transposed) > -1) {
          var corrected = identifier.replace(
            transposed,
            transposition[CORRECT]
          );
          var checked = check(corrected);
          if (checked !== null) {
            return checked;
          }
        }
      }
      return null;
    };
    module.exports = function(identifier, options) {
      options = options || {};
      var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
      function postprocess(value) {
        return upgrade ? upgradeGPLs(value) : value;
      }
      var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
      if (!validArugment) {
        throw Error("Invalid argument. Expected non-empty string.");
      }
      identifier = identifier.trim();
      if (valid2(identifier)) {
        return postprocess(identifier);
      }
      var noPlus = identifier.replace(/\+$/, "").trim();
      if (valid2(noPlus)) {
        return postprocess(noPlus);
      }
      var transformed = validTransformation(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, function(argument) {
        if (valid2(argument)) {
          return argument;
        }
        return validTransformation(argument);
      });
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = validLastResort(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, validLastResort);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      return null;
    };
    function upgradeGPLs(value) {
      if ([
        "GPL-1.0",
        "LGPL-1.0",
        "AGPL-1.0",
        "GPL-2.0",
        "LGPL-2.0",
        "AGPL-2.0",
        "LGPL-2.1"
      ].indexOf(value) !== -1) {
        return value + "-only";
      } else if ([
        "GPL-1.0+",
        "GPL-2.0+",
        "GPL-3.0+",
        "LGPL-2.0+",
        "LGPL-2.1+",
        "LGPL-3.0+",
        "AGPL-1.0+",
        "AGPL-3.0+"
      ].indexOf(value) !== -1) {
        return value.replace(/\+$/, "-or-later");
      } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
        return value + "-or-later";
      } else {
        return value;
      }
    }
  }
});

// ../../node_modules/thebe-react/dist/OutputAreaByRef.js
var require_OutputAreaByRef = __commonJS({
  "../../node_modules/thebe-react/dist/OutputAreaByRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputAreaByRef = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    exports.OutputAreaByRef = react_1.default.forwardRef(({ busy, content }, ref) => {
      return (0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "m-1 hover:delay-15" }, { children: [(0, jsx_runtime_1.jsx)("div", Object.assign({ className: "p-1 rounded", ref }, { children: content ? content : "[Output Area]" })), busy && (0, jsx_runtime_1.jsx)("div", { children: "Cell is running..." })] })) });
    });
  }
});

// ../../node_modules/thebe-core/dist/esm/url.js
function makeDefaultStorageKey(storagePrefix, url) {
  const urlObj = new URL(url);
  return `${storagePrefix}-${urlObj.origin + urlObj.pathname}`;
}
function makeDefaultBuildSpec(storagePrefix, binderUrl, stub) {
  const build = `${binderUrl}/build/${stub}`;
  const launch = `${binderUrl}/v2/${stub}`;
  return {
    build,
    launch,
    storageKey: makeDefaultStorageKey(storagePrefix, build)
  };
}
function makeGitUrls(config) {
  if (!config.binder.repo)
    throw Error("repo is required for git provider");
  const { repo, binderUrl, ref } = config.binder;
  const encodedRepo = encodeURIComponent(repo.replace(/(^\/)|(\/?$)/g, ""));
  const base = binderUrl === null || binderUrl === void 0 ? void 0 : binderUrl.replace(/(\/?$)/g, "");
  const stub = `git/${encodedRepo}/${ref !== null && ref !== void 0 ? ref : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, base, stub);
}
function makeGitLabUrl(config) {
  var _a, _b, _c;
  if (!config.binder.repo)
    throw Error("repo is required for gitlab provider");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const repo = encodeURIComponent(((_b = config.binder.repo) !== null && _b !== void 0 ? _b : "").replace(/^(https?:\/\/)?gitlab.com\//, "").replace(/(^\/)|(\/?$)/g, ""));
  const stub = `gl/${repo}/${(_c = config.binder.ref) !== null && _c !== void 0 ? _c : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGitHubUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for github provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gh/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGistUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for gist provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gist/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeBinderUrls(config, repoProviders) {
  var _a, _b;
  const providerMap = (_a = repoProviders.reduce((obj, spec) => Object.assign(Object.assign({}, obj), { [spec.name]: spec }), {})) !== null && _a !== void 0 ? _a : {};
  const provider = (_b = config.binder.repoProvider) !== null && _b !== void 0 ? _b : "github";
  if (!Object.keys(providerMap).includes(provider))
    throw Error(`Unknown provider ${config.binder.repoProvider}`);
  if (!providerMap[provider].makeUrls)
    throw Error(`No makeUrls function for ${provider}`);
  return providerMap[provider].makeUrls(config);
}
var GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC, WELL_KNOWN_REPO_PROVIDERS;
var init_url = __esm({
  "../../node_modules/thebe-core/dist/esm/url.js"() {
    GITHUB_SPEC = {
      name: "github",
      makeUrls: makeGitHubUrl
    };
    GITLAB_SPEC = {
      name: "gitlab",
      makeUrls: makeGitLabUrl
    };
    GIT_SPEC = {
      name: "git",
      makeUrls: makeGitUrls
    };
    GIST_SPEC = {
      name: "gist",
      makeUrls: makeGistUrl
    };
    WELL_KNOWN_REPO_PROVIDERS = [GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC];
  }
});

// ../../node_modules/thebe-core/dist/esm/sessions.js
function updateLastUsedTimestamp(storageKey) {
  const saved = window.localStorage.getItem(storageKey);
  if (!saved)
    return;
  const obj = JSON.parse(saved);
  window.localStorage.setItem(storageKey, JSON.stringify(Object.assign(Object.assign({}, obj), { lastUsed: /* @__PURE__ */ new Date() })));
}
function saveServerInfo(storageKey, id, serverSettings) {
  try {
    const { baseUrl, token, wsUrl } = serverSettings;
    window.localStorage.setItem(storageKey, JSON.stringify({
      id,
      baseUrl,
      token,
      wsUrl,
      lastUsed: /* @__PURE__ */ new Date()
    }));
  } catch (e4) {
    console.warn("Couldn't save thebe binder connection info to local storage", e4);
  }
}
function getExistingServer(savedSessionOptions, storageKey) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!savedSessionOptions.enabled)
      return null;
    const storedInfoJSON = window.localStorage.getItem(storageKey);
    if (storedInfoJSON == null) {
      console.debug("thebe:getExistingServer No session saved in ", storageKey);
      return null;
    }
    console.debug("thebe:getExistingServer Saved binder session found");
    const existingSettings = JSON.parse(storedInfoJSON !== null && storedInfoJSON !== void 0 ? storedInfoJSON : "");
    const lastUsed = new Date(existingSettings.lastUsed);
    const now = /* @__PURE__ */ new Date();
    const ageSeconds = (now.getTime() - lastUsed.getTime()) / 1e3;
    if (ageSeconds > savedSessionOptions.maxAge) {
      console.debug(`thebe:getExistingServer Not using expired binder session for ${existingSettings.baseUrl} from ${lastUsed}`);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    try {
      yield import_services.KernelAPI.listRunning(import_services.ServerConnection.makeSettings(existingSettings));
    } catch (err) {
      console.debug("thebe:getExistingServer Saved binder connection appears to be invalid, requesting new session", err);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    updateLastUsedTimestamp(storageKey);
    console.debug(`thebe:getExistingServer Saved binder session is valid and will be reused ${existingSettings.baseUrl}`);
    return existingSettings;
  });
}
function clearAllSavedSessions(storagePrefix = "thebe-binder") {
  const keysToRemove = [];
  for (let i5 = 0; i5 < window.localStorage.length; i5++) {
    const key = window.localStorage.key(i5);
    if (key === null || key === void 0 ? void 0 : key.startsWith(storagePrefix)) {
      keysToRemove.push(key);
    }
  }
  console.debug(`thebe:clearAllSavedSessions - removing ${keysToRemove.length} saved sessions`, keysToRemove.join(","));
  keysToRemove.forEach((key) => window.localStorage.removeItem(key));
}
function clearSavedSession(storageKey) {
  console.debug(`thebe:clearSavedSession - removing ${storageKey}`);
  window.localStorage.removeItem(storageKey);
}
var import_services;
var init_sessions = __esm({
  "../../node_modules/thebe-core/dist/esm/sessions.js"() {
    init_tslib_es6();
    import_services = __toESM(require_lib());
  }
});

// ../../node_modules/thebe-core/dist/esm/events.js
function errorToMessage(json2) {
  var _a;
  if (!json2.traceback) {
    return json2.evalue;
  } else if (Array.isArray(json2.traceback)) {
    return `${json2.evalue}
${((_a = json2.traceback) !== null && _a !== void 0 ? _a : []).join("")}`;
  } else {
    return `${json2.evalue}
${JSON.stringify(json2.traceback)}`;
  }
}
var ServerStatusEvent, SessionStatusEvent, KernelStatusEvent, NotebookStatusEvent, CellStatusEvent, EventSubject, ErrorStatusEvent, ThebeEventType, ThebeEvents;
var init_events = __esm({
  "../../node_modules/thebe-core/dist/esm/events.js"() {
    (function(ServerStatusEvent2) {
      ServerStatusEvent2["launching"] = "launching";
      ServerStatusEvent2["ready"] = "server-ready";
      ServerStatusEvent2["closed"] = "closed";
      ServerStatusEvent2["unknown"] = "unknown";
    })(ServerStatusEvent || (ServerStatusEvent = {}));
    (function(SessionStatusEvent2) {
      SessionStatusEvent2["starting"] = "starting";
      SessionStatusEvent2["ready"] = "ready";
      SessionStatusEvent2["shutdown"] = "shutdown";
    })(SessionStatusEvent || (SessionStatusEvent = {}));
    (function(KernelStatusEvent2) {
      KernelStatusEvent2["starting"] = "starting";
      KernelStatusEvent2["ready"] = "ready";
      KernelStatusEvent2["shutdown"] = "shutdown";
    })(KernelStatusEvent || (KernelStatusEvent = {}));
    (function(NotebookStatusEvent2) {
      NotebookStatusEvent2["attached"] = "attached";
      NotebookStatusEvent2["detached"] = "detached";
      NotebookStatusEvent2["executing"] = "executing";
      NotebookStatusEvent2["idle"] = "idle";
    })(NotebookStatusEvent || (NotebookStatusEvent = {}));
    (function(CellStatusEvent2) {
      CellStatusEvent2["attached"] = "attached";
      CellStatusEvent2["detached"] = "detached";
      CellStatusEvent2["executing"] = "executing";
      CellStatusEvent2["idle"] = "idle";
    })(CellStatusEvent || (CellStatusEvent = {}));
    (function(EventSubject2) {
      EventSubject2["server"] = "server";
      EventSubject2["session"] = "session";
      EventSubject2["kernel"] = "kernel";
      EventSubject2["notebook"] = "notebook";
      EventSubject2["cell"] = "cell";
    })(EventSubject || (EventSubject = {}));
    (function(ErrorStatusEvent2) {
      ErrorStatusEvent2["warning"] = "warning";
      ErrorStatusEvent2["executeError"] = "execute-error";
      ErrorStatusEvent2["error"] = "error";
      ErrorStatusEvent2["server"] = "server-error";
      ErrorStatusEvent2["session"] = "session-error";
    })(ErrorStatusEvent || (ErrorStatusEvent = {}));
    (function(ThebeEventType2) {
      ThebeEventType2["status"] = "status";
      ThebeEventType2["error"] = "error";
    })(ThebeEventType || (ThebeEventType = {}));
    ThebeEvents = class {
      constructor() {
        this.listeners = {};
      }
      _ensureMap(event) {
        if (!(event in this.listeners))
          this.listeners[event] = /* @__PURE__ */ new Map();
      }
      trigger(event, evt) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].forEach(({ unbind }, cb2) => {
          cb2(event, evt);
          if (unbind)
            this.listeners[event].delete(cb2);
        });
      }
      on(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: false });
        return () => this.off(event, cb2);
      }
      one(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: true });
        return () => this.off(event, cb2);
      }
      off(event, cb2) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].delete(cb2);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/algorithm/dist/index.es6.js
function find(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (fn(value, index2++)) {
      return value;
    }
  }
  return void 0;
}
function every(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (false === fn(value, index2++)) {
      return false;
    }
  }
  return true;
}
function some(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    if (fn(value, index2++)) {
      return true;
    }
  }
  return false;
}
function* retro(object2) {
  if (typeof object2.retro === "function") {
    yield* object2.retro();
  } else {
    for (let index2 = object2.length - 1; index2 > -1; index2--) {
      yield object2[index2];
    }
  }
}
var ArrayExt2, Private, StringExt;
var init_index_es67 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt4) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n4 - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let d6;
        if (start < stop) {
          d6 = start + 1 + (n4 - stop);
        } else {
          d6 = start - stop + 1;
        }
        for (let i5 = 0; i5 < d6; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index2 = findFirstIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index2 = findLastIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt4.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt4.upperBound = upperBound;
      function shallowEqual(a4, b4, fn) {
        if (a4 === b4) {
          return true;
        }
        if (a4.length !== b4.length) {
          return false;
        }
        for (let i5 = 0, n4 = a4.length; i5 < n4; ++i5) {
          if (fn ? !fn(a4[i5], b4[i5]) : a4[i5] !== b4[i5]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt4.shallowEqual = shallowEqual;
      function slice2(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n4 = array.length;
        if (start === void 0) {
          start = step < 0 ? n4 - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n4, step < 0 ? -1 : 0);
        } else if (start >= n4) {
          start = step < 0 ? n4 - 1 : n4;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n4;
        } else if (stop < 0) {
          stop = Math.max(stop + n4, step < 0 ? -1 : 0);
        } else if (stop >= n4) {
          stop = step < 0 ? n4 - 1 : n4;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result2 = [];
        for (let i5 = 0; i5 < length; ++i5) {
          result2[i5] = array[start + i5 * step];
        }
        return result2;
      }
      ArrayExt4.slice = slice2;
      function move(array, fromIndex, toIndex) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n4);
        } else {
          fromIndex = Math.min(fromIndex, n4 - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n4);
        } else {
          toIndex = Math.min(toIndex, n4 - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d6 = fromIndex < toIndex ? 1 : -1;
        for (let i5 = fromIndex; i5 !== toIndex; i5 += d6) {
          array[i5] = array[i5 + d6];
        }
        array[toIndex] = value;
      }
      ArrayExt4.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        while (start < stop) {
          let a4 = array[start];
          let b4 = array[stop];
          array[start++] = b4;
          array[stop--] = a4;
        }
      }
      ArrayExt4.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt4.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          array[(start + i5) % n4] = value;
        }
      }
      ArrayExt4.fill = fill;
      function insert(array, index2, value) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 = Math.max(0, index2 + n4);
        } else {
          index2 = Math.min(index2, n4);
        }
        for (let i5 = n4; i5 > index2; --i5) {
          array[i5] = array[i5 - 1];
        }
        array[index2] = value;
      }
      ArrayExt4.insert = insert;
      function removeAt(array, index2) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 += n4;
        }
        if (index2 < 0 || index2 >= n4) {
          return void 0;
        }
        let value = array[index2];
        for (let i5 = index2 + 1; i5 < n4; ++i5) {
          array[i5 - 1] = array[i5];
        }
        array.length = n4 - 1;
        return value;
      }
      ArrayExt4.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index2 = firstIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index2 = lastIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && array[i5] === value) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && array[i5] === value) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index2 = findFirstIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index2 = findLastIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && fn(array[i5], i5)) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && fn(array[i5], i5)) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllWhere = removeAllWhere;
    })(ArrayExt2 || (ArrayExt2 = {}));
    (function(Private20) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private20.rangeLength = rangeLength;
    })(Private || (Private = {}));
    (function(StringExt3) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i5 = 0, j2 = start, n4 = query.length; i5 < n4; ++i5, ++j2) {
          j2 = source.indexOf(query[i5], j2);
          if (j2 === -1) {
            return null;
          }
          indices[i5] = j2;
        }
        return indices;
      }
      StringExt3.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5] - start;
          score += j2 * j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last2 = start - 1;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5];
          score += j2 - last2 - 1;
          last2 = j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result2 = [];
        let k = 0;
        let last2 = 0;
        let n4 = indices.length;
        while (k < n4) {
          let i5 = indices[k];
          let j2 = indices[k];
          while (++k < n4 && indices[k] === j2 + 1) {
            j2++;
          }
          if (last2 < i5) {
            result2.push(source.slice(last2, i5));
          }
          if (i5 < j2 + 1) {
            result2.push(fn(source.slice(i5, j2 + 1)));
          }
          last2 = j2 + 1;
        }
        if (last2 < source.length) {
          result2.push(source.slice(last2));
        }
        return result2;
      }
      StringExt3.highlight = highlight;
      function cmp(a4, b4) {
        return a4 < b4 ? -1 : a4 > b4 ? 1 : 0;
      }
      StringExt3.cmp = cmp;
    })(StringExt || (StringExt = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList, Private2;
var init_index_es68 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private2.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private2.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private2.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private2.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private2.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private2.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private2.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList2) {
      function from(values2) {
        let list = new LinkedList2();
        list.assign(values2);
        return list;
      }
      LinkedList2.from = from;
    })(LinkedList || (LinkedList = {}));
    (function(Private20) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private20.LinkedListNode = LinkedListNode;
    })(Private2 || (Private2 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/messaging/dist/index.es6.js
var MessageLoop2;
var init_index_es69 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es67();
    init_index_es68();
    (function(MessageLoop3) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop3.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop3.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop3.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i5 = hooks.indexOf(hook);
        if (i5 === -1) {
          return;
        }
        hooks[i5] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop3.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt2.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop3.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop3.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop3.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop3.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt2.removeAllWhere(hooks, isNull3);
      }
      function isNull3(value) {
        return value === null;
      }
    })(MessageLoop2 || (MessageLoop2 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/widgettracker.js
var import_statedb, WidgetTracker;
var init_widgettracker = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/widgettracker.js"() {
    import_statedb = __toESM(require_lib3());
    init_index_es6();
    init_index_es63();
    WidgetTracker = class {
      /**
       * Create a new widget tracker.
       *
       * @param options - The instantiation options for a widget tracker.
       */
      constructor(options) {
        this._currentChanged = new Signal(this);
        this._deferred = null;
        this._isDisposed = false;
        this._widgetAdded = new Signal(this);
        this._widgetUpdated = new Signal(this);
        const focus = this._focusTracker = new FocusTracker();
        const pool = this._pool = new import_statedb.RestorablePool(options);
        this.namespace = options.namespace;
        focus.currentChanged.connect((_5, current) => {
          if (current.newValue !== this.currentWidget) {
            pool.current = current.newValue;
          }
        }, this);
        pool.added.connect((_5, widget) => {
          this._widgetAdded.emit(widget);
        }, this);
        pool.currentChanged.connect((_5, widget) => {
          if (widget === null && focus.currentWidget) {
            pool.current = focus.currentWidget;
            return;
          }
          this.onCurrentChanged(widget);
          this._currentChanged.emit(widget);
        }, this);
        pool.updated.connect((_5, widget) => {
          this._widgetUpdated.emit(widget);
        }, this);
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * The current widget is the most recently focused or added widget.
       *
       * #### Notes
       * It is the most recently focused widget, or the most recently added
       * widget if no widget has taken focus.
       */
      get currentWidget() {
        return this._pool.current || null;
      }
      /**
       * A promise resolved when the tracker has been restored.
       */
      get restored() {
        if (this._deferred) {
          return Promise.resolve();
        } else {
          return this._pool.restored;
        }
      }
      /**
       * The number of widgets held by the tracker.
       */
      get size() {
        return this._pool.size;
      }
      /**
       * A signal emitted when a widget is added.
       *
       * #### Notes
       * This signal will only fire when a widget is added to the tracker. It will
       * not fire if a widget is injected into the tracker.
       */
      get widgetAdded() {
        return this._widgetAdded;
      }
      /**
       * A signal emitted when a widget is updated.
       */
      get widgetUpdated() {
        return this._widgetUpdated;
      }
      /**
       * Add a new widget to the tracker.
       *
       * @param widget - The widget being added.
       *
       * #### Notes
       * The widget passed into the tracker is added synchronously; its existence in
       * the tracker can be checked with the `has()` method. The promise this method
       * returns resolves after the widget has been added and saved to an underlying
       * restoration connector, if one is available.
       *
       * The newly added widget becomes the current widget unless the focus tracker
       * already had a focused widget.
       */
      async add(widget) {
        this._focusTracker.add(widget);
        await this._pool.add(widget);
        if (!this._focusTracker.activeWidget) {
          this._pool.current = widget;
        }
      }
      /**
       * Test whether the tracker is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the tracker.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._pool.dispose();
        this._focusTracker.dispose();
        Signal.clearData(this);
      }
      /**
       * Find the first widget in the tracker that satisfies a filter function.
       *
       * @param - fn The filter function to call on each widget.
       *
       * #### Notes
       * If no widget is found, the value returned is `undefined`.
       */
      find(fn) {
        return this._pool.find(fn);
      }
      /**
       * Iterate through each widget in the tracker.
       *
       * @param fn - The function to call on each widget.
       */
      forEach(fn) {
        return this._pool.forEach(fn);
      }
      /**
       * Filter the widgets in the tracker based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        return this._pool.filter(fn);
      }
      /**
       * Inject a foreign widget into the widget tracker.
       *
       * @param widget - The widget to inject into the tracker.
       *
       * #### Notes
       * Injected widgets will not have their state saved by the tracker.
       *
       * The primary use case for widget injection is for a plugin that offers a
       * sub-class of an extant plugin to have its instances share the same commands
       * as the parent plugin (since most relevant commands will use the
       * `currentWidget` of the parent plugin's widget tracker). In this situation,
       * the sub-class plugin may well have its own widget tracker for layout and
       * state restoration in addition to injecting its widgets into the parent
       * plugin's widget tracker.
       */
      inject(widget) {
        return this._pool.inject(widget);
      }
      /**
       * Check if this tracker has the specified widget.
       *
       * @param widget - The widget whose existence is being checked.
       */
      has(widget) {
        return this._pool.has(widget);
      }
      /**
       * Restore the widgets in this tracker's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should not typically be invoked by client code.
       * Its primary use case is to be invoked by a restorer.
       */
      async restore(options) {
        const deferred = this._deferred;
        if (deferred) {
          this._deferred = null;
          return this._pool.restore(deferred);
        }
        if (options) {
          return this._pool.restore(options);
        }
        console.warn("No options provided to restore the tracker.");
      }
      /**
       * Save the restore options for this tracker, but do not restore yet.
       *
       * @param options - The configuration options that describe restoration.
       *
       * ### Notes
       * This function is useful when starting the shell in 'single-document' mode,
       * to avoid restoring all useless widgets. It should not ordinarily be called
       * by client code.
       */
      defer(options) {
        this._deferred = options;
      }
      /**
       * Save the restore data for a given widget.
       *
       * @param widget - The widget being saved.
       */
      async save(widget) {
        return this._pool.save(widget);
      }
      /**
       * Handle the current change event.
       *
       * #### Notes
       * The default implementation is a no-op.
       */
      onCurrentChanged(value) {
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/dialog.js
function showDialog(options = {}) {
  const dialog = new Dialog(options);
  return dialog.launch();
}
var import_coreutils, React61, Dialog, Private3;
var init_dialog = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/dialog.js"() {
    init_lib();
    init_lib2();
    init_index_es67();
    import_coreutils = __toESM(require_dist());
    init_index_es69();
    init_index_es63();
    React61 = __toESM(require_react());
    init_widgettracker();
    Dialog = class extends Widget {
      /**
       * Create a dialog panel instance.
       *
       * @param options - The dialog setup options.
       */
      constructor(options = {}) {
        const dialogNode = document.createElement("dialog");
        dialogNode.ariaModal = "true";
        super({ node: dialogNode });
        this._ready = new import_coreutils.PromiseDelegate();
        this._focusNodeSelector = "";
        this.addClass("jp-Dialog");
        const normalized = Private3.handleOptions(options);
        const renderer = normalized.renderer;
        this._host = normalized.host;
        this._defaultButton = normalized.defaultButton;
        this._buttons = normalized.buttons;
        this._hasClose = normalized.hasClose;
        this._buttonNodes = this._buttons.map((b4) => renderer.createButtonNode(b4));
        this._checkboxNode = null;
        this._lastMouseDownInDialog = false;
        if (normalized.checkbox) {
          const { label = "", caption = "", checked = false, className = "" } = normalized.checkbox;
          this._checkboxNode = renderer.createCheckboxNode({
            label,
            caption: caption !== null && caption !== void 0 ? caption : label,
            checked,
            className
          });
        }
        const layout = this.layout = new PanelLayout();
        const content = new Panel();
        content.addClass("jp-Dialog-content");
        if (typeof options.body === "string") {
          content.addClass("jp-Dialog-content-small");
          dialogNode.ariaLabel = [normalized.title, options.body].join(" ");
        }
        layout.addWidget(content);
        this._body = normalized.body;
        const header = renderer.createHeader(normalized.title, () => this.reject(), options);
        const body = renderer.createBody(normalized.body);
        const footer = renderer.createFooter(this._buttonNodes, this._checkboxNode);
        content.addWidget(header);
        content.addWidget(body);
        content.addWidget(footer);
        this._bodyWidget = body;
        this._primary = this._buttonNodes[this._defaultButton];
        this._focusNodeSelector = options.focusNodeSelector;
        void Dialog.tracker.add(this);
      }
      /**
       * A promise that resolves when the Dialog first rendering is done.
       */
      get ready() {
        return this._ready.promise;
      }
      /**
       * Dispose of the resources used by the dialog.
       */
      dispose() {
        const promise = this._promise;
        if (promise) {
          this._promise = null;
          promise.reject(void 0);
          ArrayExt2.removeFirstOf(Private3.launchQueue, promise.promise);
        }
        super.dispose();
      }
      /**
       * Launch the dialog as a modal window.
       *
       * @returns a promise that resolves with the result of the dialog.
       */
      launch() {
        if (this._promise) {
          return this._promise.promise;
        }
        const promise = this._promise = new import_coreutils.PromiseDelegate();
        const promises = Promise.all(Private3.launchQueue);
        Private3.launchQueue.push(this._promise.promise);
        return promises.then(() => {
          if (!this._promise) {
            return Promise.resolve({
              button: Dialog.cancelButton(),
              isChecked: null,
              value: null
            });
          }
          Widget.attach(this, this._host);
          return promise.promise;
        });
      }
      /**
       * Resolve the current dialog.
       *
       * @param index - An optional index to the button to resolve.
       *
       * #### Notes
       * Will default to the defaultIndex.
       * Will resolve the current `show()` with the button value.
       * Will be a no-op if the dialog is not shown.
       */
      resolve(index2) {
        if (!this._promise) {
          return;
        }
        if (index2 === void 0) {
          index2 = this._defaultButton;
        }
        this._resolve(this._buttons[index2]);
      }
      /**
       * Reject the current dialog with a default reject value.
       *
       * #### Notes
       * Will be a no-op if the dialog is not shown.
       */
      reject() {
        if (!this._promise) {
          return;
        }
        this._resolve(Dialog.cancelButton());
      }
      /**
       * Handle the DOM events for the directory listing.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeydown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "click":
            this._evtClick(event);
            break;
          case "focus":
            this._evtFocus(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
          default:
            break;
        }
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        const node = this.node;
        node.addEventListener("keydown", this, true);
        node.addEventListener("contextmenu", this, true);
        node.addEventListener("click", this, true);
        document.addEventListener("mousedown", this, true);
        document.addEventListener("focus", this, true);
        this._first = Private3.findFirstFocusable(this.node);
        this._original = document.activeElement;
        const setFocus = () => {
          var _a;
          if (this._focusNodeSelector) {
            const body = this.node.querySelector(".jp-Dialog-body");
            const el = body === null || body === void 0 ? void 0 : body.querySelector(this._focusNodeSelector);
            if (el) {
              this._primary = el;
            }
          }
          (_a = this._primary) === null || _a === void 0 ? void 0 : _a.focus();
          this._ready.resolve();
        };
        if (this._bodyWidget instanceof ReactWidget && this._bodyWidget.renderPromise !== void 0) {
          this._bodyWidget.renderPromise.then(() => {
            setFocus();
          }).catch(() => {
            console.error("Error while loading Dialog's body");
          });
        } else {
          setFocus();
        }
      }
      /**
       *  A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        const node = this.node;
        node.removeEventListener("keydown", this, true);
        node.removeEventListener("contextmenu", this, true);
        node.removeEventListener("click", this, true);
        document.removeEventListener("focus", this, true);
        document.removeEventListener("mousedown", this, true);
        this._original.focus();
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        if (this._promise) {
          this.reject();
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'click'` event for a dialog button.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtClick(event) {
        const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
        if (!content.contains(event.target)) {
          event.stopPropagation();
          event.preventDefault();
          if (this._hasClose && !this._lastMouseDownInDialog) {
            this.reject();
          }
          return;
        }
        for (const buttonNode of this._buttonNodes) {
          if (buttonNode.contains(event.target)) {
            const index2 = this._buttonNodes.indexOf(buttonNode);
            this.resolve(index2);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtKeydown(event) {
        switch (event.keyCode) {
          case 27:
            event.stopPropagation();
            event.preventDefault();
            if (this._hasClose) {
              this.reject();
            }
            break;
          case 37: {
            const activeEl = document.activeElement;
            if (activeEl instanceof HTMLButtonElement) {
              let idx = this._buttonNodes.indexOf(activeEl) - 1;
              if (idx < 0) {
                idx = this._buttonNodes.length - 1;
              }
              const node = this._buttonNodes[idx];
              event.stopPropagation();
              event.preventDefault();
              node.focus();
            }
            break;
          }
          case 39: {
            const activeEl = document.activeElement;
            if (activeEl instanceof HTMLButtonElement) {
              let idx = this._buttonNodes.indexOf(activeEl) + 1;
              if (idx == this._buttons.length) {
                idx = 0;
              }
              const node = this._buttonNodes[idx];
              event.stopPropagation();
              event.preventDefault();
              node.focus();
            }
            break;
          }
          case 9: {
            const node = this._buttonNodes[this._buttons.length - 1];
            if (document.activeElement === node && !event.shiftKey) {
              event.stopPropagation();
              event.preventDefault();
              this._first.focus();
            }
            break;
          }
          case 13: {
            event.stopPropagation();
            event.preventDefault();
            const activeEl = document.activeElement;
            let index2;
            if (activeEl instanceof HTMLButtonElement) {
              index2 = this._buttonNodes.indexOf(activeEl);
            }
            this.resolve(index2);
            break;
          }
          default:
            break;
        }
      }
      /**
       * Handle the `'focus'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtFocus(event) {
        var _a;
        const target = event.target;
        if (!this.node.contains(target)) {
          event.stopPropagation();
          (_a = this._buttonNodes[this._defaultButton]) === null || _a === void 0 ? void 0 : _a.focus();
        }
      }
      /**
       * Handle the `'mousedown'` event for the widget.
       *
       * @param event - The DOM event sent to the widget
       */
      _evtMouseDown(event) {
        const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
        const target = event.target;
        this._lastMouseDownInDialog = content.contains(target);
      }
      /**
       * Resolve a button item.
       */
      _resolve(button) {
        var _a, _b, _c;
        const promise = this._promise;
        if (!promise) {
          this.dispose();
          return;
        }
        this._promise = null;
        ArrayExt2.removeFirstOf(Private3.launchQueue, promise.promise);
        const body = this._body;
        let value = null;
        if (button.accept && body instanceof Widget && typeof body.getValue === "function") {
          value = body.getValue();
        }
        this.dispose();
        promise.resolve({
          button,
          isChecked: (_c = (_b = (_a = this._checkboxNode) === null || _a === void 0 ? void 0 : _a.querySelector("input")) === null || _b === void 0 ? void 0 : _b.checked) !== null && _c !== void 0 ? _c : null,
          value
        });
      }
    };
    (function(Dialog2) {
      Dialog2.translator = nullTranslator;
      function createButton(value) {
        value.accept = value.accept !== false;
        const trans = Dialog2.translator.load("jupyterlab");
        const defaultLabel = value.accept ? trans.__("Ok") : trans.__("Cancel");
        return {
          ariaLabel: value.ariaLabel || value.label || defaultLabel,
          label: value.label || defaultLabel,
          iconClass: value.iconClass || "",
          iconLabel: value.iconLabel || "",
          caption: value.caption || "",
          className: value.className || "",
          accept: value.accept,
          actions: value.actions || [],
          displayType: value.displayType || "default"
        };
      }
      Dialog2.createButton = createButton;
      function cancelButton(options = {}) {
        options.accept = false;
        return createButton(options);
      }
      Dialog2.cancelButton = cancelButton;
      function okButton(options = {}) {
        options.accept = true;
        return createButton(options);
      }
      Dialog2.okButton = okButton;
      function warnButton(options = {}) {
        options.displayType = "warn";
        return createButton(options);
      }
      Dialog2.warnButton = warnButton;
      function flush() {
        Dialog2.tracker.forEach((dialog) => {
          dialog.dispose();
        });
      }
      Dialog2.flush = flush;
      class Renderer {
        /**
         * Create the header of the dialog.
         *
         * @param title - The title of the dialog.
         *
         * @returns A widget for the dialog header.
         */
        createHeader(title, reject4 = () => {
        }, options = {}) {
          let header;
          const handleMouseDown = (event) => {
            if (event.button === 0) {
              event.preventDefault();
              reject4();
            }
          };
          const handleKeyDown = (event) => {
            const { key } = event;
            if (key === "Enter" || key === " ") {
              reject4();
            }
          };
          if (typeof title === "string") {
            const trans = Dialog2.translator.load("jupyterlab");
            header = ReactWidget.create(React61.createElement(
              React61.Fragment,
              null,
              title,
              options.hasClose && React61.createElement(
                Button,
                { className: "jp-Dialog-close-button", onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title: trans.__("Cancel"), minimal: true },
                React61.createElement(LabIcon.resolveReact, { icon: closeIcon, iconClass: "jp-Icon", className: "jp-ToolbarButtonComponent-icon", tag: "span" })
              )
            ));
          } else {
            header = ReactWidget.create(title);
          }
          header.addClass("jp-Dialog-header");
          Styling.styleNode(header.node);
          return header;
        }
        /**
         * Create the body of the dialog.
         *
         * @param value - The input value for the body.
         *
         * @returns A widget for the body.
         */
        createBody(value) {
          const styleReactWidget = (widget) => {
            if (widget.renderPromise !== void 0) {
              widget.renderPromise.then(() => {
                Styling.styleNode(widget.node);
              }).catch(() => {
                console.error("Error while loading Dialog's body");
              });
            } else {
              Styling.styleNode(widget.node);
            }
          };
          let body;
          if (typeof value === "string") {
            body = new Widget({ node: document.createElement("span") });
            body.node.textContent = value;
          } else if (value instanceof Widget) {
            body = value;
            if (body instanceof ReactWidget) {
              styleReactWidget(body);
            } else {
              Styling.styleNode(body.node);
            }
          } else {
            body = ReactWidget.create(value);
            MessageLoop2.sendMessage(body, Widget.Msg.UpdateRequest);
            styleReactWidget(body);
          }
          body.addClass("jp-Dialog-body");
          return body;
        }
        /**
         * Create the footer of the dialog.
         *
         * @param buttons - The buttons nodes to add to the footer.
         * @param checkbox - The checkbox node to add to the footer.
         *
         * @returns A widget for the footer.
         */
        createFooter(buttons, checkbox) {
          const footer = new Widget();
          footer.addClass("jp-Dialog-footer");
          if (checkbox) {
            footer.node.appendChild(checkbox);
            footer.node.insertAdjacentHTML("beforeend", '<div class="jp-Dialog-spacer"></div>');
          }
          for (const button of buttons) {
            footer.node.appendChild(button);
          }
          Styling.styleNode(footer.node);
          return footer;
        }
        /**
         * Create a button node for the dialog.
         *
         * @param button - The button data.
         *
         * @returns A node for the button.
         */
        createButtonNode(button) {
          const e4 = document.createElement("button");
          e4.className = this.createItemClass(button);
          e4.appendChild(this.renderIcon(button));
          e4.appendChild(this.renderLabel(button));
          return e4;
        }
        /**
         * Create a checkbox node for the dialog.
         *
         * @param checkbox - The checkbox data.
         *
         * @returns A node for the checkbox.
         */
        createCheckboxNode(checkbox) {
          const e4 = document.createElement("label");
          e4.className = "jp-Dialog-checkbox";
          if (checkbox.className) {
            e4.classList.add(checkbox.className);
          }
          e4.title = checkbox.caption;
          e4.textContent = checkbox.label;
          const input = document.createElement("input");
          input.type = "checkbox";
          input.checked = !!checkbox.checked;
          e4.insertAdjacentElement("afterbegin", input);
          return e4;
        }
        /**
         * Create the class name for the button.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the button.
         */
        createItemClass(data) {
          let name = "jp-Dialog-button";
          if (data.accept) {
            name += " jp-mod-accept";
          } else {
            name += " jp-mod-reject";
          }
          if (data.displayType === "warn") {
            name += " jp-mod-warn";
          }
          const extra = data.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Render an icon element for a dialog item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns An HTML element representing the icon.
         */
        renderIcon(data) {
          const e4 = document.createElement("div");
          e4.className = this.createIconClass(data);
          e4.appendChild(document.createTextNode(data.iconLabel));
          return e4;
        }
        /**
         * Create the class name for the button icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          const name = "jp-Dialog-buttonIcon";
          const extra = data.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Render the label element for a button.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns An HTML element representing the item label.
         */
        renderLabel(data) {
          const e4 = document.createElement("div");
          e4.className = "jp-Dialog-buttonLabel";
          e4.title = data.caption;
          e4.ariaLabel = data.ariaLabel;
          e4.appendChild(document.createTextNode(data.label));
          return e4;
        }
      }
      Dialog2.Renderer = Renderer;
      Dialog2.defaultRenderer = new Renderer();
      Dialog2.tracker = new WidgetTracker({
        namespace: "@jupyterlab/apputils:Dialog"
      });
    })(Dialog || (Dialog = {}));
    (function(Private20) {
      Private20.launchQueue = [];
      Private20.errorMessagePromiseCache = /* @__PURE__ */ new Map();
      function handleOptions(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const buttons = (_a = options.buttons) !== null && _a !== void 0 ? _a : [
          Dialog.cancelButton(),
          Dialog.okButton()
        ];
        return {
          title: (_b = options.title) !== null && _b !== void 0 ? _b : "",
          body: (_c = options.body) !== null && _c !== void 0 ? _c : "",
          host: (_d = options.host) !== null && _d !== void 0 ? _d : document.body,
          checkbox: (_e = options.checkbox) !== null && _e !== void 0 ? _e : null,
          buttons,
          defaultButton: (_f = options.defaultButton) !== null && _f !== void 0 ? _f : buttons.length - 1,
          renderer: (_g = options.renderer) !== null && _g !== void 0 ? _g : Dialog.defaultRenderer,
          focusNodeSelector: (_h = options.focusNodeSelector) !== null && _h !== void 0 ? _h : "",
          hasClose: (_j = options.hasClose) !== null && _j !== void 0 ? _j : true
        };
      }
      Private20.handleOptions = handleOptions;
      function findFirstFocusable(node) {
        const candidateSelectors = [
          "input",
          "select",
          "a[href]",
          "textarea",
          "button",
          "[tabindex]"
        ].join(",");
        return node.querySelectorAll(candidateSelectors)[0];
      }
      Private20.findFirstFocusable = findFirstFocusable;
    })(Private3 || (Private3 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/factory.js
var import_coreutils2;
var init_factory = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/factory.js"() {
    init_index_es67();
    import_coreutils2 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/registry.js
var init_registry = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/registry.js"() {
    init_index_es63();
    init_index_es6();
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/sessioncontext.js
var import_coreutils3, import_coreutils4, React62, SessionContext, SessionContextDialogs, Private4;
var init_sessioncontext = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/sessioncontext.js"() {
    import_coreutils3 = __toESM(require_lib2());
    init_lib();
    init_index_es67();
    import_coreutils4 = __toESM(require_dist());
    init_index_es6();
    init_index_es63();
    React62 = __toESM(require_react());
    init_dialog();
    SessionContext = class {
      /**
       * Construct a new session context.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._path = "";
        this._name = "";
        this._type = "";
        this._prevKernelName = "";
        this._isDisposed = false;
        this._disposed = new Signal(this);
        this._session = null;
        this._ready = new import_coreutils4.PromiseDelegate();
        this._initializing = false;
        this._initStarted = new import_coreutils4.PromiseDelegate();
        this._initPromise = new import_coreutils4.PromiseDelegate();
        this._isReady = false;
        this._isTerminating = false;
        this._isRestarting = false;
        this._kernelChanged = new Signal(this);
        this._preferenceChanged = new Signal(this);
        this._sessionChanged = new Signal(this);
        this._statusChanged = new Signal(this);
        this._connectionStatusChanged = new Signal(this);
        this._pendingInput = false;
        this._iopubMessage = new Signal(this);
        this._unhandledMessage = new Signal(this);
        this._propertyChanged = new Signal(this);
        this._dialog = null;
        this._busyDisposable = null;
        this._pendingKernelName = "";
        this._pendingSessionRequest = "";
        this.sessionManager = options.sessionManager;
        this.specsManager = options.specsManager;
        this.translator = options.translator || nullTranslator;
        this._trans = this.translator.load("jupyterlab");
        this._path = (_a = options.path) !== null && _a !== void 0 ? _a : import_coreutils4.UUID.uuid4();
        this._type = (_b = options.type) !== null && _b !== void 0 ? _b : "";
        this._name = (_c = options.name) !== null && _c !== void 0 ? _c : "";
        this._setBusy = options.setBusy;
        this._kernelPreference = (_d = options.kernelPreference) !== null && _d !== void 0 ? _d : {};
      }
      /**
       * The current session connection.
       */
      get session() {
        var _a;
        return (_a = this._session) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * The session path.
       *
       * #### Notes
       * Typically `.session.path` should be used. This attribute is useful if
       * there is no current session.
       */
      get path() {
        return this._path;
      }
      /**
       * The session type.
       *
       * #### Notes
       * Typically `.session.type` should be used. This attribute is useful if
       * there is no current session.
       */
      get type() {
        return this._type;
      }
      /**
       * The session name.
       *
       * #### Notes
       * Typically `.session.name` should be used. This attribute is useful if
       * there is no current session.
       */
      get name() {
        return this._name;
      }
      /**
       * A signal emitted when the kernel connection changes, proxied from the session connection.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal emitted when the session connection changes.
       */
      get sessionChanged() {
        return this._sessionChanged;
      }
      /**
       * A signal emitted when the kernel status changes, proxied from the kernel.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A flag indicating if the session has ending input, proxied from the kernel.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal emitted when the kernel status changes, proxied from the kernel.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages, proxied from the kernel.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for an unhandled kernel message, proxied from the kernel.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal emitted when a session property changes, proxied from the current session.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * The kernel preference of this client session.
       *
       * This is used when selecting a new kernel, and should reflect the sort of
       * kernel the activity prefers.
       */
      get kernelPreference() {
        return this._kernelPreference;
      }
      set kernelPreference(value) {
        if (!import_coreutils4.JSONExt.deepEqual(value, this._kernelPreference)) {
          const oldValue = this._kernelPreference;
          this._kernelPreference = value;
          this._preferenceChanged.emit({
            name: "kernelPreference",
            oldValue,
            newValue: import_coreutils4.JSONExt.deepCopy(value)
          });
        }
      }
      /**
       * Signal emitted if the kernel preference changes.
       */
      get kernelPreferenceChanged() {
        return this._preferenceChanged;
      }
      /**
       * Whether the context is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that is fulfilled when the context is ready.
       */
      get ready() {
        return this._ready.promise;
      }
      /**
       * Whether the context is terminating.
       */
      get isTerminating() {
        return this._isTerminating;
      }
      /**
       * Whether the context is restarting.
       */
      get isRestarting() {
        return this._isRestarting;
      }
      /**
       * Whether the kernel is "No Kernel" or not.
       *
       * #### Notes
       * As the displayed name is translated, this can be used directly.
       */
      get hasNoKernel() {
        return this.kernelDisplayName === this.noKernelName;
      }
      /**
       * The display name of the current kernel, or a sensible alternative.
       *
       * #### Notes
       * This is a convenience function to have a consistent sensible name for the
       * kernel.
       */
      get kernelDisplayName() {
        var _a, _b, _c, _d, _e, _f, _g;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._pendingKernelName === this.noKernelName) {
          return this.noKernelName;
        }
        if (this._pendingKernelName) {
          return (_d = (_c = (_b = this.specsManager.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[this._pendingKernelName]) === null || _c === void 0 ? void 0 : _c.display_name) !== null && _d !== void 0 ? _d : this._pendingKernelName;
        }
        if (!kernel) {
          return this.noKernelName;
        }
        return (_g = (_f = (_e = this.specsManager.specs) === null || _e === void 0 ? void 0 : _e.kernelspecs[kernel.name]) === null || _f === void 0 ? void 0 : _f.display_name) !== null && _g !== void 0 ? _g : kernel.name;
      }
      /**
       * A sensible status to display
       *
       * #### Notes
       * This combines the status and connection status into a single status for
       * the user.
       */
      get kernelDisplayStatus() {
        var _a, _b;
        const kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (this._isTerminating) {
          return "terminating";
        }
        if (this._isRestarting) {
          return "restarting";
        }
        if (this._pendingKernelName === this.noKernelName) {
          return "unknown";
        }
        if (!kernel && this._pendingKernelName) {
          return "initializing";
        }
        if (!kernel && !this.isReady && this.kernelPreference.canStart !== false && this.kernelPreference.shouldStart !== false) {
          return "initializing";
        }
        return (_b = (kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus) === "connected" ? kernel === null || kernel === void 0 ? void 0 : kernel.status : kernel === null || kernel === void 0 ? void 0 : kernel.connectionStatus) !== null && _b !== void 0 ? _b : "unknown";
      }
      /**
       * The name of the previously started kernel.
       */
      get prevKernelName() {
        return this._prevKernelName;
      }
      /**
       * Test whether the context is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A signal emitted when the poll is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Get the constant displayed name for "No Kernel"
       */
      get noKernelName() {
        return this._trans.__("No Kernel");
      }
      /**
       * Dispose of the resources held by the context.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._session) {
          if (this.kernelPreference.shutdownOnDispose) {
            this.sessionManager.shutdown(this._session.id).catch((reason) => {
              console.error(`Kernel not shut down ${reason}`);
            });
          }
          this._session.dispose();
          this._session = null;
        }
        if (this._dialog) {
          this._dialog.dispose();
        }
        if (this._busyDisposable) {
          this._busyDisposable.dispose();
          this._busyDisposable = null;
        }
        Signal.clearData(this);
      }
      /**
       * Starts new Kernel.
       *
       * @returns Whether to ask the user to pick a kernel.
       */
      async startKernel() {
        const preference = this.kernelPreference;
        if (!preference.autoStartDefault && preference.shouldStart === false) {
          return true;
        }
        let options;
        if (preference.id) {
          options = { id: preference.id };
        } else {
          const name = Private4.getDefaultKernel({
            specs: this.specsManager.specs,
            sessions: this.sessionManager.running(),
            preference
          });
          if (name) {
            options = { name };
          }
        }
        if (options) {
          try {
            await this._changeKernel(options);
            return false;
          } catch (err) {
          }
        }
        return true;
      }
      /**
       * Restart the current Kernel.
       *
       * @returns A promise that resolves when the kernel is restarted.
       */
      async restartKernel() {
        var _a, _b, _c, _d, _e, _f;
        const kernel = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || null;
        if (this._isRestarting) {
          return;
        }
        this._isRestarting = true;
        this._isReady = false;
        this._statusChanged.emit("restarting");
        try {
          await ((_c = (_b = this.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.restart());
          this._isReady = true;
        } catch (e4) {
          console.error(e4);
        }
        this._isRestarting = false;
        this._statusChanged.emit(((_e = (_d = this.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.status) || "unknown");
        this._kernelChanged.emit({
          name: "kernel",
          oldValue: kernel,
          newValue: ((_f = this.session) === null || _f === void 0 ? void 0 : _f.kernel) || null
        });
      }
      /**
       * Change the current kernel associated with the session.
       */
      async changeKernel(options = {}) {
        if (this.isDisposed) {
          throw new Error("Disposed");
        }
        await this._initStarted.promise;
        return this._changeKernel(options);
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns A promise that resolves when the session is shut down.
       */
      async shutdown() {
        if (this.isDisposed || !this._initializing) {
          return;
        }
        await this._initStarted.promise;
        this._pendingSessionRequest = "";
        this._pendingKernelName = this.noKernelName;
        return this._shutdownSession();
      }
      /**
       * Initialize the session context
       *
       * @returns A promise that resolves with whether to ask the user to select a kernel.
       *
       * #### Notes
       * If a server session exists on the current path, we will connect to it.
       * If preferences include disabling `canStart` or `shouldStart`, no
       * server session will be started.
       * If a kernel id is given, we attempt to start a session with that id.
       * If a default kernel is available, we connect to it.
       * Otherwise we ask the user to select a kernel.
       */
      async initialize() {
        if (this._initializing) {
          return this._initPromise.promise;
        }
        this._initializing = true;
        const needsSelection = await this._initialize();
        if (!needsSelection) {
          this._isReady = true;
          this._ready.resolve(void 0);
        }
        if (!this._pendingSessionRequest) {
          this._initStarted.resolve(void 0);
        }
        this._initPromise.resolve(needsSelection);
        return needsSelection;
      }
      /**
       * Inner initialize function that doesn't handle promises.
       * This makes it easier to consolidate promise handling logic.
       */
      async _initialize() {
        const manager = this.sessionManager;
        await manager.ready;
        await manager.refreshRunning();
        const model = find(manager.running(), (item) => {
          return item.path === this._path;
        });
        if (model) {
          try {
            const session = manager.connectTo({ model });
            this._handleNewSession(session);
          } catch (err) {
            void this._handleSessionError(err);
            return Promise.reject(err);
          }
        }
        return await this._startIfNecessary();
      }
      /**
       * Shut down the current session.
       */
      async _shutdownSession() {
        var _a;
        const session = this._session;
        const isTerminating = this._isTerminating;
        const isReady = this._isReady;
        this._isTerminating = true;
        this._isReady = false;
        this._statusChanged.emit("terminating");
        try {
          await (session === null || session === void 0 ? void 0 : session.shutdown());
          this._isTerminating = false;
          session === null || session === void 0 ? void 0 : session.dispose();
          this._session = null;
          const kernel = (session === null || session === void 0 ? void 0 : session.kernel) || null;
          this._statusChanged.emit("unknown");
          this._kernelChanged.emit({
            name: "kernel",
            oldValue: kernel,
            newValue: null
          });
          this._sessionChanged.emit({
            name: "session",
            oldValue: session,
            newValue: null
          });
        } catch (err) {
          this._isTerminating = isTerminating;
          this._isReady = isReady;
          const status = (_a = session === null || session === void 0 ? void 0 : session.kernel) === null || _a === void 0 ? void 0 : _a.status;
          if (status === void 0) {
            this._statusChanged.emit("unknown");
          } else {
            this._statusChanged.emit(status);
          }
          throw err;
        }
        return;
      }
      /**
       * Start the session if necessary.
       *
       * @returns Whether to ask the user to pick a kernel.
       */
      async _startIfNecessary() {
        var _a;
        const preference = this.kernelPreference;
        if (this.isDisposed || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || preference.shouldStart === false || preference.canStart === false) {
          return false;
        }
        return this.startKernel();
      }
      /**
       * Change the kernel.
       */
      async _changeKernel(model = {}) {
        if (model.name) {
          this._pendingKernelName = model.name;
        }
        if (!this._session) {
          this._kernelChanged.emit({
            name: "kernel",
            oldValue: null,
            newValue: null
          });
        }
        if (!this._pendingSessionRequest) {
          this._initStarted.resolve(void 0);
        }
        if (this._session && !this._isTerminating) {
          try {
            await this._session.changeKernel(model);
            return this._session.kernel;
          } catch (err) {
            void this._handleSessionError(err);
            throw err;
          }
        }
        const dirName = import_coreutils3.PathExt.dirname(this._path);
        const requestId = this._pendingSessionRequest = import_coreutils3.PathExt.join(dirName, import_coreutils4.UUID.uuid4());
        try {
          this._statusChanged.emit("starting");
          const session = await this.sessionManager.startNew({
            path: requestId,
            type: this._type,
            name: this._name,
            kernel: model
          });
          if (this._pendingSessionRequest !== session.path) {
            await session.shutdown();
            session.dispose();
            return null;
          }
          await session.setPath(this._path);
          await session.setName(this._name);
          if (this._session && !this._isTerminating) {
            await this._shutdownSession();
          }
          return this._handleNewSession(session);
        } catch (err) {
          void this._handleSessionError(err);
          throw err;
        }
      }
      /**
       * Handle a new session object.
       */
      _handleNewSession(session) {
        var _a, _b, _c;
        if (this.isDisposed) {
          throw Error("Disposed");
        }
        if (!this._isReady) {
          this._isReady = true;
          this._ready.resolve(void 0);
        }
        if (this._session) {
          this._session.dispose();
        }
        this._session = session;
        this._pendingKernelName = "";
        if (session) {
          this._prevKernelName = (_b = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
          session.disposed.connect(this._onSessionDisposed, this);
          session.propertyChanged.connect(this._onPropertyChanged, this);
          session.kernelChanged.connect(this._onKernelChanged, this);
          session.statusChanged.connect(this._onStatusChanged, this);
          session.connectionStatusChanged.connect(this._onConnectionStatusChanged, this);
          session.pendingInput.connect(this._onPendingInput, this);
          session.iopubMessage.connect(this._onIopubMessage, this);
          session.unhandledMessage.connect(this._onUnhandledMessage, this);
          if (session.path !== this._path) {
            this._onPropertyChanged(session, "path");
          }
          if (session.name !== this._name) {
            this._onPropertyChanged(session, "name");
          }
          if (session.type !== this._type) {
            this._onPropertyChanged(session, "type");
          }
        }
        this._sessionChanged.emit({
          name: "session",
          oldValue: null,
          newValue: session
        });
        this._kernelChanged.emit({
          oldValue: null,
          newValue: (session === null || session === void 0 ? void 0 : session.kernel) || null,
          name: "kernel"
        });
        this._statusChanged.emit(((_c = session === null || session === void 0 ? void 0 : session.kernel) === null || _c === void 0 ? void 0 : _c.status) || "unknown");
        return (session === null || session === void 0 ? void 0 : session.kernel) || null;
      }
      /**
       * Handle an error in session startup.
       */
      async _handleSessionError(err) {
        this._handleNewSession(null);
        let traceback = "";
        let message = "";
        try {
          traceback = err.traceback;
          message = err.message;
        } catch (err2) {
        }
        await this._displayKernelError(message, traceback);
      }
      /**
       * Display kernel error
       */
      async _displayKernelError(message, traceback) {
        const body = React62.createElement(
          "div",
          null,
          message && React62.createElement("pre", null, message),
          traceback && React62.createElement(
            "details",
            { className: "jp-mod-wide" },
            React62.createElement("pre", null, traceback)
          )
        );
        const dialog = this._dialog = new Dialog({
          title: this._trans.__("Error Starting Kernel"),
          body,
          buttons: [Dialog.okButton()]
        });
        await dialog.launch();
        this._dialog = null;
      }
      /**
       * Handle a session termination.
       */
      _onSessionDisposed() {
        if (this._session) {
          const oldValue = this._session;
          this._session = null;
          const newValue = this._session;
          this._sessionChanged.emit({ name: "session", oldValue, newValue });
        }
      }
      /**
       * Handle a change to a session property.
       */
      _onPropertyChanged(sender, property2) {
        switch (property2) {
          case "path":
            this._path = sender.path;
            break;
          case "name":
            this._name = sender.name;
            break;
          case "type":
            this._type = sender.type;
            break;
          default:
            throw new Error(`unrecognized property ${property2}`);
        }
        this._propertyChanged.emit(property2);
      }
      /**
       * Handle a change to the kernel.
       */
      _onKernelChanged(sender, args) {
        this._kernelChanged.emit(args);
      }
      /**
       * Handle a change to the session status.
       */
      _onStatusChanged(sender, status) {
        var _a;
        if (status === "dead") {
          const model = (_a = sender.kernel) === null || _a === void 0 ? void 0 : _a.model;
          if (model === null || model === void 0 ? void 0 : model.reason) {
            const traceback = model.traceback || "";
            void this._displayKernelError(model.reason, traceback);
          }
        }
        if (this._setBusy) {
          if (status === "busy") {
            if (!this._busyDisposable) {
              this._busyDisposable = this._setBusy();
            }
          } else {
            if (this._busyDisposable) {
              this._busyDisposable.dispose();
              this._busyDisposable = null;
            }
          }
        }
        this._statusChanged.emit(status);
      }
      /**
       * Handle a change to the session status.
       */
      _onConnectionStatusChanged(sender, status) {
        this._connectionStatusChanged.emit(status);
      }
      /**
       * Handle a change to the pending input.
       */
      _onPendingInput(sender, value) {
        this._pendingInput = value;
      }
      /**
       * Handle an iopub message.
       */
      _onIopubMessage(sender, message) {
        if (message.header.msg_type === "shutdown_reply") {
          this.session.kernel.removeInputGuard();
        }
        this._iopubMessage.emit(message);
      }
      /**
       * Handle an unhandled message.
       */
      _onUnhandledMessage(sender, message) {
        this._unhandledMessage.emit(message);
      }
    };
    (function(SessionContext2) {
      function getDefaultKernel(options) {
        const { preference } = options;
        const { shouldStart } = preference;
        if (shouldStart === false) {
          return null;
        }
        return Private4.getDefaultKernel(options);
      }
      SessionContext2.getDefaultKernel = getDefaultKernel;
    })(SessionContext || (SessionContext = {}));
    SessionContextDialogs = class {
      constructor(options = {}) {
        var _a;
        this._translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
      }
      /**
       * Select a kernel for the session.
       */
      async selectKernel(sessionContext) {
        if (sessionContext.isDisposed) {
          return Promise.resolve();
        }
        const trans = this._translator.load("jupyterlab");
        let label = trans.__("Cancel");
        if (sessionContext.hasNoKernel) {
          label = sessionContext.kernelDisplayName;
        }
        const buttons = [
          Dialog.cancelButton({
            label
          }),
          Dialog.okButton({
            label: trans.__("Select"),
            ariaLabel: trans.__("Select Kernel")
          })
        ];
        const autoStartDefault = sessionContext.kernelPreference.autoStartDefault;
        const hasCheckbox = typeof autoStartDefault === "boolean";
        const dialog = new Dialog({
          title: trans.__("Select Kernel"),
          body: new Private4.KernelSelector(sessionContext, this._translator),
          buttons,
          checkbox: hasCheckbox ? {
            label: trans.__("Always start the preferred kernel"),
            caption: trans.__("Remember my choice and always start the preferred kernel"),
            checked: autoStartDefault
          } : null
        });
        const result2 = await dialog.launch();
        if (sessionContext.isDisposed || !result2.button.accept) {
          return;
        }
        if (hasCheckbox && result2.isChecked !== null) {
          sessionContext.kernelPreference = {
            ...sessionContext.kernelPreference,
            autoStartDefault: result2.isChecked
          };
        }
        const model = result2.value;
        if (model === null && !sessionContext.hasNoKernel) {
          return sessionContext.shutdown();
        }
        if (model) {
          await sessionContext.changeKernel(model);
        }
      }
      /**
       * Restart the session.
       *
       * @returns A promise that resolves with whether the kernel has restarted.
       *
       * #### Notes
       * If there is a running kernel, present a dialog.
       * If there is no kernel, we start a kernel with the last run
       * kernel name and resolves with `true`.
       */
      async restart(sessionContext) {
        var _a;
        const trans = this._translator.load("jupyterlab");
        await sessionContext.initialize();
        if (sessionContext.isDisposed) {
          throw new Error("session already disposed");
        }
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel && sessionContext.prevKernelName) {
          await sessionContext.changeKernel({
            name: sessionContext.prevKernelName
          });
          return true;
        }
        if (!kernel) {
          throw new Error("No kernel to restart");
        }
        const restartBtn = Dialog.warnButton({
          label: trans.__("Restart"),
          ariaLabel: trans.__("Confirm Kernel Restart")
        });
        const result2 = await showDialog({
          title: trans.__("Restart Kernel?"),
          body: trans.__("Do you want to restart the kernel of %1? All variables will be lost.", sessionContext.name),
          buttons: [
            Dialog.cancelButton({ ariaLabel: trans.__("Cancel Kernel Restart") }),
            restartBtn
          ]
        });
        if (kernel.isDisposed) {
          return false;
        }
        if (result2.button.accept) {
          await sessionContext.restartKernel();
          return true;
        }
        return false;
      }
    };
    (function(Private20) {
      class KernelSelector extends Widget {
        /**
         * Create a new kernel selector widget.
         */
        constructor(sessionContext, translator) {
          super({ node: createSelectorNode(sessionContext, translator) });
        }
        /**
         * Get the value of the kernel selector widget.
         */
        getValue() {
          const selector = this.node.querySelector("select");
          return JSON.parse(selector.value);
        }
      }
      Private20.KernelSelector = KernelSelector;
      function createSelectorNode(sessionContext, translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const body = document.createElement("div");
        const text = document.createElement("label");
        text.textContent = `${trans.__("Select kernel for:")} "${sessionContext.name}"`;
        body.appendChild(text);
        const options = getKernelSearch(sessionContext);
        const selector = document.createElement("select");
        populateKernelSelect(selector, options, translator, !sessionContext.hasNoKernel ? sessionContext.kernelDisplayName : null);
        body.appendChild(selector);
        return body;
      }
      function getDefaultKernel(options) {
        var _a;
        const { specs, preference } = options;
        const { name, language, canStart, autoStartDefault } = preference;
        if (!specs || canStart === false) {
          return null;
        }
        const defaultName = autoStartDefault ? specs.default : null;
        if (!name && !language) {
          return defaultName;
        }
        for (const specName in specs.kernelspecs) {
          if (specName === name) {
            return name;
          }
        }
        if (!language) {
          return defaultName;
        }
        const matches = [];
        for (const specName in specs.kernelspecs) {
          const kernelLanguage = (_a = specs.kernelspecs[specName]) === null || _a === void 0 ? void 0 : _a.language;
          if (language === kernelLanguage) {
            matches.push(specName);
          }
        }
        if (matches.length === 1) {
          const specName = matches[0];
          console.warn("No exact match found for " + specName + ", using kernel " + specName + " that matches language=" + language);
          return specName;
        }
        return defaultName;
      }
      Private20.getDefaultKernel = getDefaultKernel;
      function populateKernelSelect(node, options, translator, currentKernelDisplayName = null) {
        var _a;
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        const { preference, sessions, specs } = options;
        const { name, id, language, canStart, shouldStart } = preference;
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        if (!specs || canStart === false) {
          node.appendChild(optionForNone(translator));
          node.value = "null";
          node.disabled = true;
          return;
        }
        node.disabled = false;
        const displayNames = /* @__PURE__ */ Object.create(null);
        const languages = /* @__PURE__ */ Object.create(null);
        for (const name2 in specs.kernelspecs) {
          const spec = specs.kernelspecs[name2];
          displayNames[name2] = spec.display_name;
          languages[name2] = spec.language;
        }
        const names = [];
        if (name && name in specs.kernelspecs) {
          names.push(name);
        }
        if (name && names.length > 0 && language) {
          for (const specName in specs.kernelspecs) {
            if (name !== specName && languages[specName] === language) {
              names.push(specName);
            }
          }
        }
        if (!names.length) {
          names.push(specs.default);
        }
        const preferred = document.createElement("optgroup");
        preferred.label = trans.__("Start Preferred Kernel");
        names.sort((a4, b4) => displayNames[a4].localeCompare(displayNames[b4]));
        for (const name2 of names) {
          preferred.appendChild(optionForName(name2, displayNames[name2]));
        }
        if (preferred.firstChild) {
          node.appendChild(preferred);
        }
        node.appendChild(optionForNone(translator));
        const other = document.createElement("optgroup");
        other.label = trans.__("Start Other Kernel");
        const otherNames = [];
        for (const specName in specs.kernelspecs) {
          if (names.indexOf(specName) !== -1) {
            continue;
          }
          otherNames.push(specName);
        }
        otherNames.sort((a4, b4) => displayNames[a4].localeCompare(displayNames[b4]));
        for (const otherName of otherNames) {
          other.appendChild(optionForName(otherName, displayNames[otherName]));
        }
        if (otherNames.length) {
          node.appendChild(other);
        }
        if (shouldStart === false) {
          node.value = "null";
        } else {
          let selectedIndex = 0;
          if (currentKernelDisplayName) {
            selectedIndex = [...node.options].findIndex((option) => option.text === currentKernelDisplayName);
            selectedIndex = Math.max(selectedIndex, 0);
          }
          node.selectedIndex = selectedIndex;
        }
        if (!sessions) {
          return;
        }
        const matchingSessions = [];
        const otherSessions = [];
        for (const session of sessions) {
          if (language && session.kernel && languages[session.kernel.name] === language && session.kernel.id !== id) {
            matchingSessions.push(session);
          } else if (((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            otherSessions.push(session);
          }
        }
        const matching = document.createElement("optgroup");
        matching.label = trans.__("Use Kernel from Preferred Session");
        node.appendChild(matching);
        if (matchingSessions.length) {
          matchingSessions.sort((a4, b4) => {
            return a4.path.localeCompare(b4.path);
          });
          for (const session of matchingSessions) {
            const name2 = session.kernel ? displayNames[session.kernel.name] : "";
            matching.appendChild(optionForSession(session, name2, translator));
          }
        }
        const otherSessionsNode = document.createElement("optgroup");
        otherSessionsNode.label = trans.__("Use Kernel from Other Session");
        node.appendChild(otherSessionsNode);
        if (otherSessions.length) {
          otherSessions.sort((a4, b4) => {
            return a4.path.localeCompare(b4.path);
          });
          for (const session of otherSessions) {
            const name2 = session.kernel ? displayNames[session.kernel.name] || session.kernel.name : "";
            otherSessionsNode.appendChild(optionForSession(session, name2, translator));
          }
        }
      }
      Private20.populateKernelSelect = populateKernelSelect;
      function getKernelSearch(sessionContext) {
        return {
          specs: sessionContext.specsManager.specs,
          sessions: sessionContext.sessionManager.running(),
          preference: sessionContext.kernelPreference
        };
      }
      function optionForName(name, displayName) {
        const option = document.createElement("option");
        option.text = displayName;
        option.value = JSON.stringify({ name });
        return option;
      }
      function optionForNone(translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const group2 = document.createElement("optgroup");
        group2.label = trans.__("Use No Kernel");
        const option = document.createElement("option");
        option.text = trans.__("No Kernel");
        option.value = "null";
        group2.appendChild(option);
        return group2;
      }
      function optionForSession(session, displayName, translator) {
        var _a, _b;
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const option = document.createElement("option");
        const sessionName = session.name || import_coreutils3.PathExt.basename(session.path);
        option.text = sessionName;
        option.value = JSON.stringify({ id: (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id });
        option.title = `${trans.__("Path:")} ${session.path}
${trans.__("Name:")} ${sessionName}
${trans.__("Kernel Name:")} ${displayName}
${trans.__("Kernel Id:")} ${(_b = session.kernel) === null || _b === void 0 ? void 0 : _b.id}`;
        return option;
      }
    })(Private4 || (Private4 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/kernelstatuses.js
function translateKernelStatuses(translator) {
  translator = translator || nullTranslator;
  const trans = translator.load("jupyterlab");
  const translated = {
    unknown: trans.__("Unknown"),
    starting: trans.__("Starting"),
    idle: trans.__("Idle"),
    busy: trans.__("Busy"),
    terminating: trans.__("Terminating"),
    restarting: trans.__("Restarting"),
    autorestarting: trans.__("Autorestarting"),
    dead: trans.__("Dead"),
    connected: trans.__("Connected"),
    connecting: trans.__("Connecting"),
    disconnected: trans.__("Disconnected"),
    initializing: trans.__("Initializing"),
    "": ""
  };
  return translated;
}
function KernelStatusComponent(props) {
  const translator = props.translator || nullTranslator;
  const trans = translator.load("jupyterlab");
  let statusText = "";
  if (props.status) {
    statusText = ` | ${props.status}`;
  }
  return import_react39.default.createElement(TextItem, { onClick: props.handleClick, source: `${props.kernelName}${statusText}`, title: trans.__("Change kernel for %1", props.activityName) });
}
var import_coreutils5, import_react39, KernelStatus;
var init_kernelstatuses = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/kernelstatuses.js"() {
    init_lib4();
    init_lib();
    init_lib2();
    import_coreutils5 = __toESM(require_dist());
    import_react39 = __toESM(require_react());
    KernelStatus = class extends VDomRenderer {
      /**
       * Construct the kernel status widget.
       */
      constructor(opts, translator) {
        super(new KernelStatus.Model(translator));
        this.translator = translator || nullTranslator;
        this._handleClick = opts.onClick;
        this.addClass("jp-mod-highlighted");
      }
      /**
       * Render the kernel status item.
       */
      render() {
        if (this.model === null) {
          return null;
        } else {
          return import_react39.default.createElement(KernelStatusComponent, { status: this.model.status, kernelName: this.model.kernelName, activityName: this.model.activityName, handleClick: this._handleClick, translator: this.translator });
        }
      }
    };
    (function(KernelStatus2) {
      class Model2 extends VDomModel {
        constructor(translator) {
          super();
          this._activityName = "";
          this._kernelName = "";
          this._kernelStatus = "";
          this._sessionContext = null;
          translator = translator !== null && translator !== void 0 ? translator : nullTranslator;
          this._trans = translator.load("jupyterlab");
          this._statusNames = translateKernelStatuses(translator);
        }
        /**
         * The name of the kernel.
         */
        get kernelName() {
          return this._kernelName;
        }
        /**
         * The current status of the kernel.
         */
        get status() {
          return this._kernelStatus ? this._statusNames[this._kernelStatus] : void 0;
        }
        /**
         * A display name for the activity.
         */
        get activityName() {
          return this._activityName;
        }
        set activityName(val) {
          const oldVal = this._activityName;
          if (oldVal === val) {
            return;
          }
          this._activityName = val;
          this.stateChanged.emit();
        }
        /**
         * The current client session associated with the kernel status indicator.
         */
        get sessionContext() {
          return this._sessionContext;
        }
        set sessionContext(sessionContext) {
          var _a, _b, _c, _d;
          (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.statusChanged.disconnect(this._onKernelStatusChanged, this);
          (_b = this._sessionContext) === null || _b === void 0 ? void 0 : _b.connectionStatusChanged.disconnect(this._onKernelStatusChanged, this);
          (_c = this._sessionContext) === null || _c === void 0 ? void 0 : _c.kernelChanged.disconnect(this._onKernelChanged, this);
          const oldState = this._getAllState();
          this._sessionContext = sessionContext;
          this._kernelStatus = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayStatus;
          this._kernelName = (_d = sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName) !== null && _d !== void 0 ? _d : this._trans.__("No Kernel");
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.statusChanged.connect(this._onKernelStatusChanged, this);
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.connectionStatusChanged.connect(this._onKernelStatusChanged, this);
          sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelChanged.connect(this._onKernelChanged, this);
          this._triggerChange(oldState, this._getAllState());
        }
        /**
         * React to changes to the kernel status.
         */
        _onKernelStatusChanged() {
          var _a;
          this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
          this.stateChanged.emit(void 0);
        }
        /**
         * React to changes in the kernel.
         */
        _onKernelChanged(_sessionContext, change) {
          var _a;
          const oldState = this._getAllState();
          this._kernelStatus = (_a = this._sessionContext) === null || _a === void 0 ? void 0 : _a.kernelDisplayStatus;
          this._kernelName = _sessionContext.kernelDisplayName;
          this._triggerChange(oldState, this._getAllState());
        }
        _getAllState() {
          return [this._kernelName, this._kernelStatus, this._activityName];
        }
        _triggerChange(oldState, newState) {
          if (import_coreutils5.JSONExt.deepEqual(oldState, newState)) {
            this.stateChanged.emit(void 0);
          }
        }
      }
      KernelStatus2.Model = Model2;
    })(KernelStatus || (KernelStatus = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/widget.js
var React64, TOOLBAR_KERNEL_NAME_CLASS, TOOLBAR_KERNEL_STATUS_CLASS, Toolbar2, Private5;
var init_widget = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/widget.js"() {
    init_lib();
    init_lib2();
    init_index_es63();
    React64 = __toESM(require_react());
    init_sessioncontext();
    init_kernelstatuses();
    TOOLBAR_KERNEL_NAME_CLASS = "jp-Toolbar-kernelName";
    TOOLBAR_KERNEL_STATUS_CLASS = "jp-Toolbar-kernelStatus";
    (function(Toolbar4) {
      function createInterruptButton(sessionContext, translator) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        return new ToolbarButton({
          icon: stopIcon,
          onClick: () => {
            var _a, _b;
            void ((_b = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.interrupt());
          },
          tooltip: trans.__("Interrupt the kernel")
        });
      }
      Toolbar4.createInterruptButton = createInterruptButton;
      function createRestartButton(sessionContext, dialogs, translator) {
        translator = translator !== null && translator !== void 0 ? translator : nullTranslator;
        const trans = translator.load("jupyterlab");
        return new ToolbarButton({
          icon: refreshIcon,
          onClick: () => {
            void (dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator })).restart(sessionContext);
          },
          tooltip: trans.__("Restart the kernel")
        });
      }
      Toolbar4.createRestartButton = createRestartButton;
      function createKernelNameItem(sessionContext, dialogs, translator) {
        const el = ReactWidget.create(React64.createElement(Private5.KernelNameComponent, { sessionContext, dialogs: dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator }), translator }));
        el.addClass("jp-KernelName");
        return el;
      }
      Toolbar4.createKernelNameItem = createKernelNameItem;
      function createKernelStatusItem(sessionContext, translator) {
        return new Private5.KernelStatus(sessionContext, translator);
      }
      Toolbar4.createKernelStatusItem = createKernelStatusItem;
    })(Toolbar2 || (Toolbar2 = {}));
    (function(Private20) {
      function KernelNameComponent(props) {
        const translator = props.translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        const callback = () => {
          void props.dialogs.selectKernel(props.sessionContext);
        };
        return React64.createElement(UseSignal, { signal: props.sessionContext.kernelChanged, initialSender: props.sessionContext }, (sessionContext) => React64.createElement(ToolbarButtonComponent, { className: TOOLBAR_KERNEL_NAME_CLASS, onClick: callback, tooltip: trans.__("Switch kernel"), label: sessionContext === null || sessionContext === void 0 ? void 0 : sessionContext.kernelDisplayName }));
      }
      Private20.KernelNameComponent = KernelNameComponent;
      class KernelStatus2 extends Widget {
        /**
         * Construct a new kernel status widget.
         */
        constructor(sessionContext, translator) {
          super();
          this.translator = translator || nullTranslator;
          this._trans = this.translator.load("jupyterlab");
          this.addClass(TOOLBAR_KERNEL_STATUS_CLASS);
          this._statusNames = translateKernelStatuses(this.translator);
          this._onStatusChanged(sessionContext);
          sessionContext.statusChanged.connect(this._onStatusChanged, this);
          sessionContext.connectionStatusChanged.connect(this._onStatusChanged, this);
        }
        /**
         * Handle a status on a kernel.
         */
        _onStatusChanged(sessionContext) {
          if (this.isDisposed) {
            return;
          }
          const status = sessionContext.kernelDisplayStatus;
          const circleIconProps = {
            container: this.node,
            title: this._trans.__("Kernel %1", this._statusNames[status] || status),
            stylesheet: "toolbarButton",
            alignSelf: "normal",
            height: "24px"
          };
          LabIcon.remove(this.node);
          if (status === "busy" || status === "starting" || status === "terminating" || status === "restarting" || status === "initializing") {
            circleIcon.element(circleIconProps);
          } else if (status === "connecting" || status === "disconnected" || status === "unknown") {
            offlineBoltIcon.element(circleIconProps);
          } else {
            circleEmptyIcon.element(circleIconProps);
          }
        }
      }
      Private20.KernelStatus = KernelStatus2;
    })(Private5 || (Private5 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/toolbar/index.js
var init_toolbar = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/toolbar/index.js"() {
    init_factory();
    init_registry();
    init_widget();
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/clipboard.js
var import_coreutils6, Clipboard, Private6;
var init_clipboard = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/clipboard.js"() {
    import_coreutils6 = __toESM(require_dist());
    (function(Clipboard2) {
      function getInstance() {
        return Private6.instance;
      }
      Clipboard2.getInstance = getInstance;
      function setInstance(value) {
        Private6.instance = value;
      }
      Clipboard2.setInstance = setInstance;
      function copyToSystem(clipboardData) {
        const node = document.body;
        const handler = (event) => {
          const data = event.clipboardData || window.clipboardData;
          if (typeof clipboardData === "string") {
            data.setData("text", clipboardData);
          } else {
            clipboardData.types().map((mimeType) => {
              data.setData(mimeType, clipboardData.getData(mimeType));
            });
          }
          event.preventDefault();
          node.removeEventListener("copy", handler);
        };
        node.addEventListener("copy", handler);
        generateEvent(node);
      }
      Clipboard2.copyToSystem = copyToSystem;
      function generateEvent(node, type2 = "copy") {
        let sel = window.getSelection();
        const savedRanges = [];
        for (let i5 = 0, len = (sel === null || sel === void 0 ? void 0 : sel.rangeCount) || 0; i5 < len; ++i5) {
          savedRanges[i5] = sel.getRangeAt(i5).cloneRange();
        }
        const range2 = document.createRange();
        range2.selectNodeContents(node);
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(range2);
        }
        document.execCommand(type2);
        sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
          for (let i5 = 0, len = savedRanges.length; i5 < len; ++i5) {
            sel.addRange(savedRanges[i5]);
          }
        }
      }
      Clipboard2.generateEvent = generateEvent;
    })(Clipboard || (Clipboard = {}));
    (function(Private20) {
      Private20.instance = new import_coreutils6.MimeData();
    })(Private6 || (Private6 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/commandlinker.js
var import_coreutils7;
var init_commandlinker = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/commandlinker.js"() {
    import_coreutils7 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/commandpalette.js
var init_commandpalette = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/commandpalette.js"() {
    init_index_es63();
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt, ElementExt, Platform2, Selector, Private7;
var init_index_es610 = __esm({
  "../../node_modules/@jupyterlab/apputils/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt2) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt2.copyText = copyText;
    })(ClipboardExt || (ClipboardExt = {}));
    (function(ElementExt2) {
      function boxSizing(element2) {
        let style = window.getComputedStyle(element2);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt2.boxSizing = boxSizing;
      function sizeLimits(element2) {
        let style = window.getComputedStyle(element2);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt2.sizeLimits = sizeLimits;
      function hitTest(element2, clientX, clientY) {
        let rect = element2.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt2.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element2) {
        let ar = area.getBoundingClientRect();
        let er = element2.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt2.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt || (ElementExt = {}));
    (function(Platform3) {
      Platform3.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform3.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform3.IS_IE = /Trident/.test(navigator.userAgent);
      Platform3.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform3.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform3.accelKey = accelKey;
    })(Platform2 || (Platform2 = {}));
    (function(Selector2) {
      function calculateSpecificity(selector) {
        if (selector in Private7.specificityCache) {
          return Private7.specificityCache[selector];
        }
        let result2 = Private7.calculateSingle(selector);
        return Private7.specificityCache[selector] = result2;
      }
      Selector2.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private7.validityCache) {
          return Private7.validityCache[selector];
        }
        let result2 = true;
        try {
          Private7.testElem.querySelector(selector);
        } catch (err) {
          result2 = false;
        }
        return Private7.validityCache[selector] = result2;
      }
      Selector2.isValid = isValid;
      function matches(element2, selector) {
        return Private7.protoMatchFunc.call(element2, selector);
      }
      Selector2.matches = matches;
    })(Selector || (Selector = {}));
    (function(Private20) {
      Private20.specificityCache = /* @__PURE__ */ Object.create(null);
      Private20.validityCache = /* @__PURE__ */ Object.create(null);
      Private20.testElem = document.createElement("div");
      Private20.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a4 = 0;
        let b4 = 0;
        let c6 = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a4++;
            continue;
          }
          if (match(CLASS_RE)) {
            b4++;
            continue;
          }
          if (match(ATTR_RE)) {
            b4++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c6++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b4++;
            continue;
          }
          if (match(TYPE_RE)) {
            c6++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a4 = Math.min(a4, 255);
        b4 = Math.min(b4, 255);
        c6 = Math.min(c6, 255);
        return a4 << 16 | b4 << 8 | c6;
      }
      Private20.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private7 || (Private7 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/domutils.js
var import_coreutils8, DOMUtils;
var init_domutils = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/domutils.js"() {
    init_index_es67();
    import_coreutils8 = __toESM(require_dist());
    init_index_es610();
    (function(DOMUtils2) {
      function hitTestNodes(nodes, x4, y3) {
        return ArrayExt2.findFirstIndex(nodes, (node) => {
          return ElementExt.hitTest(node, x4, y3);
        });
      }
      DOMUtils2.hitTestNodes = hitTestNodes;
      function findElement(parent, className) {
        return parent.querySelector(`.${className}`);
      }
      DOMUtils2.findElement = findElement;
      function findElements(parent, className) {
        return parent.getElementsByClassName(className);
      }
      DOMUtils2.findElements = findElements;
      function createDomID() {
        return `id-${import_coreutils8.UUID.uuid4()}`;
      }
      DOMUtils2.createDomID = createDomID;
    })(DOMUtils || (DOMUtils = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/inputdialog.js
var INPUT_DIALOG_CLASS, INPUT_BOOLEAN_DIALOG_CLASS, InputDialog, InputDialogBase, InputBooleanDialog, InputNumberDialog, InputTextDialog, InputPasswordDialog, InputItemsDialog, InputMultipleItemsDialog;
var init_inputdialog = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/inputdialog.js"() {
    init_index_es63();
    init_dialog();
    INPUT_DIALOG_CLASS = "jp-Input-Dialog";
    INPUT_BOOLEAN_DIALOG_CLASS = "jp-Input-Boolean-Dialog";
    (function(InputDialog2) {
      function getBoolean(options) {
        return showDialog({
          ...options,
          body: new InputBooleanDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getBoolean = getBoolean;
      function getNumber(options) {
        return showDialog({
          ...options,
          body: new InputNumberDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getNumber = getNumber;
      function getItem(options) {
        return showDialog({
          ...options,
          body: new InputItemsDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: options.editable ? "input" : "select"
        });
      }
      InputDialog2.getItem = getItem;
      function getMultipleItems(options) {
        return showDialog({
          ...options,
          body: new InputMultipleItemsDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ]
        });
      }
      InputDialog2.getMultipleItems = getMultipleItems;
      function getText(options) {
        return showDialog({
          ...options,
          body: new InputTextDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getText = getText;
      function getPassword(options) {
        return showDialog({
          ...options,
          body: new InputPasswordDialog(options),
          buttons: [
            Dialog.cancelButton({ label: options.cancelLabel }),
            Dialog.okButton({ label: options.okLabel })
          ],
          focusNodeSelector: "input"
        });
      }
      InputDialog2.getPassword = getPassword;
    })(InputDialog || (InputDialog = {}));
    InputDialogBase = class extends Widget {
      /**
       * InputDialog constructor
       *
       * @param label Input field label
       */
      constructor(label) {
        super();
        this.addClass(INPUT_DIALOG_CLASS);
        this._input = document.createElement("input");
        this._input.classList.add("jp-mod-styled");
        this._input.id = "jp-dialog-input-id";
        if (label !== void 0) {
          const labelElement = document.createElement("label");
          labelElement.textContent = label;
          labelElement.htmlFor = this._input.id;
          this.node.appendChild(labelElement);
        }
        this.node.appendChild(this._input);
      }
    };
    InputBooleanDialog = class extends InputDialogBase {
      /**
       * InputBooleanDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this.addClass(INPUT_BOOLEAN_DIALOG_CLASS);
        this._input.type = "checkbox";
        this._input.checked = options.value ? true : false;
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.checked;
      }
    };
    InputNumberDialog = class extends InputDialogBase {
      /**
       * InputNumberDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._input.type = "number";
        this._input.value = options.value ? options.value.toString() : "0";
      }
      /**
       * Get the number specified by the user.
       */
      getValue() {
        if (this._input.value) {
          return Number(this._input.value);
        } else {
          return Number.NaN;
        }
      }
    };
    InputTextDialog = class extends InputDialogBase {
      /**
       * InputTextDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        var _a;
        super(options.label);
        this._input.type = "text";
        this._input.value = options.text ? options.text : "";
        if (options.placeholder) {
          this._input.placeholder = options.placeholder;
        }
        this._initialSelectionRange = Math.min(this._input.value.length, Math.max(0, (_a = options.selectionRange) !== null && _a !== void 0 ? _a : this._input.value.length));
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._initialSelectionRange > 0 && this._input.value) {
          this._input.setSelectionRange(0, this._initialSelectionRange);
        }
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.value;
      }
    };
    InputPasswordDialog = class extends InputDialogBase {
      /**
       * InputPasswordDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._input.type = "password";
        this._input.value = options.text ? options.text : "";
        if (options.placeholder) {
          this._input.placeholder = options.placeholder;
        }
      }
      /**
       *  A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._input.value) {
          this._input.select();
        }
      }
      /**
       * Get the text specified by the user
       */
      getValue() {
        return this._input.value;
      }
    };
    InputItemsDialog = class extends InputDialogBase {
      /**
       * InputItemsDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        this._editable = options.editable || false;
        let current = options.current || 0;
        let defaultIndex;
        if (typeof current === "number") {
          defaultIndex = Math.max(0, Math.min(current, options.items.length - 1));
          current = "";
        }
        this._list = document.createElement("select");
        options.items.forEach((item, index2) => {
          const option = document.createElement("option");
          if (index2 === defaultIndex) {
            option.selected = true;
            current = item;
          }
          option.value = item;
          option.textContent = item;
          this._list.appendChild(option);
        });
        if (options.editable) {
          const data = document.createElement("datalist");
          data.id = "input-dialog-items";
          data.appendChild(this._list);
          this._input.type = "list";
          this._input.value = current;
          this._input.setAttribute("list", data.id);
          if (options.placeholder) {
            this._input.placeholder = options.placeholder;
          }
          this.node.appendChild(data);
        } else {
          this._input.remove();
          this.node.appendChild(this._list);
        }
      }
      /**
       * Get the user choice
       */
      getValue() {
        if (this._editable) {
          return this._input.value;
        } else {
          return this._list.value;
        }
      }
    };
    InputMultipleItemsDialog = class extends InputDialogBase {
      /**
       * InputMultipleItemsDialog constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        super(options.label);
        let defaults = options.defaults || [];
        this._list = document.createElement("select");
        this._list.setAttribute("multiple", "");
        options.items.forEach((item) => {
          const option = document.createElement("option");
          option.value = item;
          option.textContent = item;
          this._list.appendChild(option);
        });
        this._input.remove();
        this.node.appendChild(this._list);
        const htmlOptions = this._list.options;
        for (let i5 = 0; i5 < htmlOptions.length; i5++) {
          const option = htmlOptions[i5];
          if (defaults.includes(option.value)) {
            option.selected = true;
          } else {
            option.selected = false;
          }
        }
      }
      /**
       * Get the user choices
       */
      getValue() {
        let result2 = [];
        for (let opt of this._list.options) {
          if (opt.selected && !opt.classList.contains("hidden")) {
            result2.push(opt.value || opt.text);
          }
        }
        return result2;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/printing.js
var import_services2, Printing;
var init_printing = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/printing.js"() {
    import_services2 = __toESM(require_lib());
    (function(Printing2) {
      Printing2.symbol = Symbol("printable");
      function isPrintable2(a4) {
        if (typeof a4 !== "object" || !a4) {
          return false;
        }
        return Printing2.symbol in a4;
      }
      Printing2.isPrintable = isPrintable2;
      function getPrintFunction(val) {
        if (isPrintable2(val)) {
          return val[Printing2.symbol]();
        }
        return null;
      }
      Printing2.getPrintFunction = getPrintFunction;
      function printWidget(widget) {
        return printContent(widget.node);
      }
      Printing2.printWidget = printWidget;
      async function printURL(url) {
        const settings = import_services2.ServerConnection.makeSettings();
        const text = await (await import_services2.ServerConnection.makeRequest(url, {}, settings)).text();
        return printContent(text);
      }
      Printing2.printURL = printURL;
      async function printContent(textOrEl) {
        const isText = typeof textOrEl === "string";
        const iframe = createIFrame();
        const parent = window.document.body;
        parent.appendChild(iframe);
        if (isText) {
          iframe.srcdoc = textOrEl;
          await resolveWhenLoaded(iframe);
        } else {
          iframe.src = "about:blank";
          await resolveWhenLoaded(iframe);
          setIFrameNode(iframe, textOrEl);
        }
        const printed = resolveAfterEvent();
        launchPrint(iframe.contentWindow);
        await printed;
        parent.removeChild(iframe);
      }
      function createIFrame() {
        const el = window.document.createElement("iframe");
        el.setAttribute("sandbox", "allow-modals allow-same-origin");
        const css = "visibility:hidden;width:0;height:0;position:absolute;z-index:-9999;bottom:0;";
        el.setAttribute("style", css);
        el.setAttribute("width", "0");
        el.setAttribute("height", "0");
        return el;
      }
      function setIFrameNode(iframe, node) {
        iframe.contentDocument.body.appendChild(node.cloneNode(true));
        iframe.contentDocument.close();
      }
      function resolveWhenLoaded(iframe) {
        return new Promise((resolve) => {
          iframe.onload = () => resolve();
        });
      }
      function resolveAfterEvent() {
        return new Promise((resolve) => {
          const onEvent = () => {
            document.removeEventListener("mousemove", onEvent, true);
            document.removeEventListener("mousedown", onEvent, true);
            document.removeEventListener("keydown", onEvent, true);
            resolve();
          };
          document.addEventListener("mousemove", onEvent, true);
          document.addEventListener("mousedown", onEvent, true);
          document.addEventListener("keydown", onEvent, true);
        });
      }
      function launchPrint(contentWindow) {
        const result2 = contentWindow.document.execCommand("print", false);
        if (!result2) {
          contentWindow.print();
        }
      }
    })(Printing || (Printing = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/mainareawidget.js
var USE_CAPTURE, MainAreaWidget;
var init_mainareawidget = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/mainareawidget.js"() {
    init_lib();
    init_lib2();
    init_index_es69();
    init_index_es63();
    init_domutils();
    init_printing();
    USE_CAPTURE = true;
    MainAreaWidget = class extends Widget {
      /**
       * Construct a new main area widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._changeGuard = false;
        this._spinner = new Spinner();
        this._isRevealed = false;
        this._evtMouseDown = () => {
          if (!this.node.contains(document.activeElement)) {
            this._focusContent();
          }
        };
        this.addClass("jp-MainAreaWidget");
        this.addClass("jp-MainAreaWidget-ContainStrict");
        this.id = DOMUtils.createDomID();
        const trans = (options.translator || nullTranslator).load("jupyterlab");
        const content = this._content = options.content;
        content.node.setAttribute("role", "region");
        content.node.setAttribute("aria-label", trans.__("notebook content"));
        const toolbar = this._toolbar = options.toolbar || new ReactiveToolbar();
        toolbar.node.setAttribute("role", "navigation");
        toolbar.node.setAttribute("aria-label", trans.__("notebook actions"));
        const contentHeader = this._contentHeader = options.contentHeader || new BoxPanel({
          direction: "top-to-bottom",
          spacing: 0
        });
        const layout = this.layout = new BoxLayout({ spacing: 0 });
        layout.direction = "top-to-bottom";
        BoxLayout.setStretch(toolbar, 0);
        BoxLayout.setStretch(contentHeader, 0);
        BoxLayout.setStretch(content, 1);
        layout.addWidget(toolbar);
        layout.addWidget(contentHeader);
        layout.addWidget(content);
        if (!content.id) {
          content.id = DOMUtils.createDomID();
        }
        content.node.tabIndex = -1;
        this._updateTitle();
        content.title.changed.connect(this._updateTitle, this);
        this.title.closable = true;
        this.title.changed.connect(this._updateContentTitle, this);
        if (options.reveal) {
          this.node.appendChild(this._spinner.node);
          this._revealed = options.reveal.then(() => {
            if (content.isDisposed) {
              this.dispose();
              return;
            }
            content.disposed.connect(() => this.dispose());
            const active = document.activeElement === this._spinner.node;
            this._disposeSpinner();
            this._isRevealed = true;
            if (active) {
              this._focusContent();
            }
          }).catch((e4) => {
            const error = new Widget();
            error.addClass("jp-MainAreaWidget-error");
            const pre = document.createElement("pre");
            pre.textContent = String(e4);
            error.node.appendChild(pre);
            BoxLayout.setStretch(error, 1);
            this._disposeSpinner();
            content.dispose();
            this._content = null;
            toolbar.dispose();
            this._toolbar = null;
            layout.addWidget(error);
            this._isRevealed = true;
            throw error;
          });
        } else {
          this._spinner.dispose();
          this.removeClass("jp-MainAreaWidget-ContainStrict");
          content.disposed.connect(() => this.dispose());
          this._isRevealed = true;
          this._revealed = Promise.resolve(void 0);
        }
      }
      /**
       * Print method. Deferred to content.
       */
      [Printing.symbol]() {
        if (!this._content) {
          return null;
        }
        return Printing.getPrintFunction(this._content);
      }
      /**
       * The content hosted by the widget.
       */
      get content() {
        return this._content;
      }
      /**
       * The toolbar hosted by the widget.
       */
      get toolbar() {
        return this._toolbar;
      }
      /**
       * A panel for widgets that sit between the toolbar and the content.
       * Imagine a formatting toolbar, notification headers, etc.
       */
      get contentHeader() {
        return this._contentHeader;
      }
      /**
       * Whether the content widget or an error is revealed.
       */
      get isRevealed() {
        return this._isRevealed;
      }
      /**
       * A promise that resolves when the widget is revealed.
       */
      get revealed() {
        return this._revealed;
      }
      /**
       * Handle `'activate-request'` messages.
       */
      onActivateRequest(msg) {
        if (this._isRevealed) {
          this._focusContent();
        } else {
          this._spinner.node.focus();
        }
      }
      /**
       * Handle `after-attach` messages for the widget.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.node.addEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
      }
      /**
       * Handle `before-detach` messages for the widget.
       */
      onBeforeDetach(msg) {
        this.node.removeEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
        super.onBeforeDetach(msg);
      }
      /**
       * Handle `'close-request'` messages.
       */
      onCloseRequest(msg) {
        this.dispose();
      }
      /**
       * Handle `'update-request'` messages by forwarding them to the content.
       */
      onUpdateRequest(msg) {
        if (this._content) {
          MessageLoop2.sendMessage(this._content, msg);
        }
      }
      _disposeSpinner() {
        this.node.removeChild(this._spinner.node);
        this._spinner.dispose();
        this.removeClass("jp-MainAreaWidget-ContainStrict");
      }
      /**
       * Update the title based on the attributes of the child widget.
       */
      _updateTitle() {
        if (this._changeGuard || !this.content) {
          return;
        }
        this._changeGuard = true;
        const content = this.content;
        this.title.label = content.title.label;
        this.title.mnemonic = content.title.mnemonic;
        this.title.icon = content.title.icon;
        this.title.iconClass = content.title.iconClass;
        this.title.iconLabel = content.title.iconLabel;
        this.title.caption = content.title.caption;
        this.title.className = content.title.className;
        this.title.dataset = content.title.dataset;
        this._changeGuard = false;
      }
      /**
       * Update the content title based on attributes of the main widget.
       */
      _updateContentTitle() {
        if (this._changeGuard || !this.content) {
          return;
        }
        this._changeGuard = true;
        const content = this.content;
        content.title.label = this.title.label;
        content.title.mnemonic = this.title.mnemonic;
        content.title.icon = this.title.icon;
        content.title.iconClass = this.title.iconClass;
        content.title.iconLabel = this.title.iconLabel;
        content.title.caption = this.title.caption;
        content.title.className = this.title.className;
        content.title.dataset = this.title.dataset;
        this._changeGuard = false;
      }
      /**
       * Give focus to the content.
       */
      _focusContent() {
        if (!this.content) {
          return;
        }
        if (!this.content.node.contains(document.activeElement)) {
          this.content.node.focus();
        }
        this.content.activate();
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/menufactory.js
var import_coreutils9, import_coreutils10, MenuFactory;
var init_menufactory = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/menufactory.js"() {
    import_coreutils9 = __toESM(require_lib2());
    init_lib2();
    import_coreutils10 = __toESM(require_dist());
    (function(MenuFactory2) {
      function createMenus(data, menuFactory) {
        return data.filter((item) => !item.disabled).sort((a4, b4) => {
          var _a, _b;
          return ((_a = a4.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b4.rank) !== null && _b !== void 0 ? _b : Infinity);
        }).map((menuItem) => {
          return dataToMenu(menuItem, menuFactory);
        });
      }
      MenuFactory2.createMenus = createMenus;
      function dataToMenu(item, menuFactory) {
        var _a, _b;
        const menu = menuFactory(item);
        menu.id = item.id;
        if (!menu.title.label) {
          menu.title.label = (_a = item.label) !== null && _a !== void 0 ? _a : import_coreutils9.Text.titleCase(menu.id.trim());
        }
        if (item.icon) {
          menu.title.icon = LabIcon.resolve({ icon: item.icon });
        }
        if (item.mnemonic !== void 0) {
          menu.title.mnemonic = item.mnemonic;
        }
        (_b = item.items) === null || _b === void 0 ? void 0 : _b.filter((item2) => !item2.disabled).sort((a4, b4) => {
          var _a2, _b2;
          return ((_a2 = a4.rank) !== null && _a2 !== void 0 ? _a2 : Infinity) - ((_b2 = b4.rank) !== null && _b2 !== void 0 ? _b2 : Infinity);
        }).map((item2) => {
          addItem(item2, menu, menuFactory);
        });
        return menu;
      }
      function addContextItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        menu.addItem({
          ...newItem,
          submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
      }
      MenuFactory2.addContextItem = addContextItem;
      function addItem(item, menu, menuFactory) {
        const { submenu, ...newItem } = item;
        menu.addItem({
          ...newItem,
          submenu: submenu ? dataToMenu(submenu, menuFactory) : null
        });
      }
      function updateMenus(menus, data, menuFactory) {
        const newMenus = [];
        data.forEach((item) => {
          const menu = menus.find((menu2) => menu2.id === item.id);
          if (menu) {
            mergeMenus(item, menu, menuFactory);
          } else {
            if (!item.disabled) {
              newMenus.push(dataToMenu(item, menuFactory));
            }
          }
        });
        menus.push(...newMenus);
        return newMenus;
      }
      MenuFactory2.updateMenus = updateMenus;
      function mergeMenus(item, menu, menuFactory) {
        var _a;
        if (item.disabled) {
          menu.dispose();
        } else {
          (_a = item.items) === null || _a === void 0 ? void 0 : _a.forEach((entry) => {
            var _a2, _b;
            const existingItem = menu === null || menu === void 0 ? void 0 : menu.items.find((i5, idx) => {
              var _a3, _b2, _c;
              return i5.type === entry.type && i5.command === ((_a3 = entry.command) !== null && _a3 !== void 0 ? _a3 : "") && ((_b2 = i5.submenu) === null || _b2 === void 0 ? void 0 : _b2.id) === ((_c = entry.submenu) === null || _c === void 0 ? void 0 : _c.id);
            });
            if (existingItem && entry.type !== "separator") {
              if (entry.disabled) {
                menu.removeItem(existingItem);
              } else {
                switch ((_a2 = entry.type) !== null && _a2 !== void 0 ? _a2 : "command") {
                  case "command":
                    if (entry.command) {
                      if (!import_coreutils10.JSONExt.deepEqual(existingItem.args, (_b = entry.args) !== null && _b !== void 0 ? _b : {})) {
                        addItem(entry, menu, menuFactory);
                      }
                    }
                    break;
                  case "submenu":
                    if (entry.submenu) {
                      mergeMenus(entry.submenu, existingItem.submenu, menuFactory);
                    }
                }
              }
            } else {
              addItem(entry, menu, menuFactory);
            }
          });
        }
      }
    })(MenuFactory || (MenuFactory = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/notification.js
var import_coreutils11, NotificationManager, Notification;
var init_notification = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/notification.js"() {
    import_coreutils11 = __toESM(require_dist());
    init_index_es6();
    NotificationManager = class {
      constructor() {
        this._isDisposed = false;
        this._queue = [];
        this._changed = new Signal(this);
      }
      /**
       * Signal emitted whenever a notification changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Total number of notifications.
       */
      get count() {
        return this._queue.length;
      }
      /**
       * Whether the manager is disposed or not.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The list of notifications.
       */
      get notifications() {
        return this._queue.slice();
      }
      /**
       * Dismiss one notification (specified by its id) or all if no id provided.
       *
       * @param id Notification id
       */
      dismiss(id) {
        if (typeof id === "undefined") {
          const q2 = this._queue.slice();
          this._queue.length = 0;
          for (const notification of q2) {
            this._changed.emit({
              type: "removed",
              notification
            });
          }
        } else {
          const notificationIndex = this._queue.findIndex((n4) => n4.id === id);
          if (notificationIndex > -1) {
            const notification = this._queue.splice(notificationIndex, 1)[0];
            this._changed.emit({
              type: "removed",
              notification
            });
          }
        }
      }
      /**
       * Dispose the manager.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
      /**
       * Test whether a notification exists or not.
       *
       * @param id Notification id
       * @returns Notification status
       */
      has(id) {
        return this._queue.findIndex((n4) => n4.id === id) > -1;
      }
      /**
       * Add a new notification.
       *
       * This will trigger the `changed` signal with an `added` event.
       *
       * @param message Notification message
       * @param type Notification type
       * @param options Notification option
       * @returns Notification unique id
       */
      notify(message, type2, options) {
        const now = Date.now();
        const { progress, ...othersOptions } = options;
        const notification = Object.freeze({
          id: import_coreutils11.UUID.uuid4(),
          createdAt: now,
          modifiedAt: now,
          message,
          type: type2,
          options: {
            // By default notification will be silent
            autoClose: 0,
            progress: typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress,
            ...othersOptions
          }
        });
        this._queue.unshift(notification);
        this._changed.emit({
          type: "added",
          notification
        });
        return notification.id;
      }
      /**
       * Update an existing notification.
       *
       * If the notification does not exists this won't do anything.
       *
       * Once updated the notification will be moved at the begin
       * of the notification stack.
       *
       * @param args Update options
       * @returns Whether the update was successful or not.
       */
      update(args) {
        const { id, message, actions, autoClose, data, progress, type: type2 } = args;
        const newProgress = typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress;
        const notificationIndex = this._queue.findIndex((n4) => n4.id === id);
        if (notificationIndex > -1) {
          const oldNotification = this._queue[notificationIndex];
          const notification = Object.freeze({
            ...oldNotification,
            message: message !== null && message !== void 0 ? message : oldNotification.message,
            type: type2 !== null && type2 !== void 0 ? type2 : oldNotification.type,
            options: {
              actions: actions !== null && actions !== void 0 ? actions : oldNotification.options.actions,
              autoClose: autoClose !== null && autoClose !== void 0 ? autoClose : oldNotification.options.autoClose,
              data: data !== null && data !== void 0 ? data : oldNotification.options.data,
              progress: newProgress !== null && newProgress !== void 0 ? newProgress : oldNotification.options.progress
            },
            modifiedAt: Date.now()
          });
          this._queue.splice(notificationIndex, 1);
          this._queue.unshift(notification);
          this._changed.emit({
            type: "updated",
            notification
          });
          return true;
        }
        return false;
      }
    };
    (function(Notification2) {
      Notification2.manager = new NotificationManager();
      function dismiss(id) {
        Notification2.manager.dismiss(id);
      }
      Notification2.dismiss = dismiss;
      function emit(message, type2 = "default", options = {}) {
        return Notification2.manager.notify(message, type2, options);
      }
      Notification2.emit = emit;
      function error(message, options = {}) {
        return Notification2.manager.notify(message, "error", options);
      }
      Notification2.error = error;
      function info(message, options = {}) {
        return Notification2.manager.notify(message, "info", options);
      }
      Notification2.info = info;
      function promise(promise2, options) {
        var _a;
        const { pending, error: error2, success: success2 } = options;
        const id = Notification2.manager.notify(pending.message, "in-progress", (_a = pending.options) !== null && _a !== void 0 ? _a : {});
        promise2.then((result2) => {
          var _a2, _b, _c;
          Notification2.manager.update({
            id,
            message: success2.message(result2, (_a2 = success2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
            type: "success",
            ...success2.options,
            data: (_c = (_b = success2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : result2
          });
        }).catch((reason) => {
          var _a2, _b, _c;
          Notification2.manager.update({
            id,
            message: error2.message(reason, (_a2 = error2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
            type: "error",
            ...error2.options,
            data: (_c = (_b = error2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : reason
          });
        });
        return id;
      }
      Notification2.promise = promise;
      function success(message, options = {}) {
        return Notification2.manager.notify(message, "success", options);
      }
      Notification2.success = success;
      function update(args) {
        return Notification2.manager.update(args);
      }
      Notification2.update = update;
      function warning(message, options = {}) {
        return Notification2.manager.notify(message, "warning", options);
      }
      Notification2.warning = warning;
    })(Notification || (Notification = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/runningSessions.js
function RunningSessionsComponent(props) {
  return import_react40.default.createElement(
    GroupItem,
    { spacing: HALF_SPACING, onClick: props.handleClick },
    import_react40.default.createElement(
      GroupItem,
      { spacing: HALF_SPACING },
      import_react40.default.createElement(TextItem, { source: props.terminals }),
      import_react40.default.createElement(terminalIcon.react, { left: "1px", top: "3px", stylesheet: "statusBar" })
    ),
    import_react40.default.createElement(
      GroupItem,
      { spacing: HALF_SPACING },
      import_react40.default.createElement(TextItem, { source: props.sessions }),
      import_react40.default.createElement(kernelIcon.react, { top: "2px", stylesheet: "statusBar" })
    )
  );
}
var import_react40, HALF_SPACING, RunningSessions;
var init_runningSessions = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/runningSessions.js"() {
    init_lib();
    init_lib2();
    import_react40 = __toESM(require_react());
    init_lib4();
    HALF_SPACING = 4;
    RunningSessions = class extends VDomRenderer {
      /**
       * Create a new RunningSessions widget.
       */
      constructor(opts) {
        super(new RunningSessions.Model());
        this._serviceManager = opts.serviceManager;
        this._handleClick = opts.onClick;
        this.translator = opts.translator || nullTranslator;
        this._trans = this.translator.load("jupyterlab");
        this._serviceManager.sessions.runningChanged.connect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.connect(this._onTerminalsRunningChanged, this);
        this.addClass("jp-mod-highlighted");
      }
      /**
       * Render the running sessions widget.
       */
      render() {
        if (!this.model) {
          return null;
        }
        this.title.caption = this._trans.__("%1 Terminals, %2 Kernel sessions", this.model.terminals, this.model.sessions);
        return import_react40.default.createElement(RunningSessionsComponent, { sessions: this.model.sessions, terminals: this.model.terminals, handleClick: this._handleClick });
      }
      /**
       * Dispose of the status item.
       */
      dispose() {
        super.dispose();
        this._serviceManager.sessions.runningChanged.disconnect(this._onSessionsRunningChanged, this);
        this._serviceManager.terminals.runningChanged.disconnect(this._onTerminalsRunningChanged, this);
      }
      /**
       * Set the number of kernel sessions when the list changes.
       */
      _onSessionsRunningChanged(manager, sessions) {
        this.model.sessions = sessions.length;
      }
      /**
       * Set the number of terminal sessions when the list changes.
       */
      _onTerminalsRunningChanged(manager, terminals) {
        this.model.terminals = terminals.length;
      }
    };
    (function(RunningSessions2) {
      class Model2 extends VDomModel {
        constructor() {
          super(...arguments);
          this._terminals = 0;
          this._sessions = 0;
        }
        /**
         * The number of active kernel sessions.
         */
        get sessions() {
          return this._sessions;
        }
        set sessions(sessions) {
          const oldSessions = this._sessions;
          this._sessions = sessions;
          if (oldSessions !== this._sessions) {
            this.stateChanged.emit(void 0);
          }
        }
        /**
         * The number of active terminal sessions.
         */
        get terminals() {
          return this._terminals;
        }
        set terminals(terminals) {
          const oldTerminals = this._terminals;
          this._terminals = terminals;
          if (oldTerminals !== this._terminals) {
            this.stateChanged.emit(void 0);
          }
        }
      }
      RunningSessions2.Model = Model2;
    })(RunningSessions || (RunningSessions = {}));
  }
});

// ../../node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "../../node_modules/entities/lib/maps/decode.json"(exports, module) {
    module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// ../../node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../../node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
    exports.default = decodeCodePoint;
  }
});

// ../../node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "../../node_modules/entities/lib/maps/legacy.json"(exports, module) {
    module.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// ../../node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "../../node_modules/entities/lib/maps/xml.json"(exports, module) {
    module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    function whitespace(c6) {
      return c6 === " " || c6 === "\n" || c6 === "	" || c6 === "\f" || c6 === "\r";
    }
    function isASCIIAlpha(c6) {
      return c6 >= "a" && c6 <= "z" || c6 >= "A" && c6 <= "Z";
    }
    function ifElseState(upper, SUCCESS, FAILURE) {
      var lower = upper.toLowerCase();
      if (upper === lower) {
        return function(t10, c6) {
          if (c6 === lower) {
            t10._state = SUCCESS;
          } else {
            t10._state = FAILURE;
            t10._index--;
          }
        };
      }
      return function(t10, c6) {
        if (c6 === lower || c6 === upper) {
          t10._state = SUCCESS;
        } else {
          t10._state = FAILURE;
          t10._index--;
        }
      };
    }
    function consumeSpecialNameChar(upper, NEXT_STATE) {
      var lower = upper.toLowerCase();
      return function(t10, c6) {
        if (c6 === lower || c6 === upper) {
          t10._state = NEXT_STATE;
        } else {
          t10._state = 3;
          t10._index--;
        }
      };
    }
    var stateBeforeCdata1 = ifElseState(
      "C",
      24,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata2 = ifElseState(
      "D",
      25,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata3 = ifElseState(
      "A",
      26,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata4 = ifElseState(
      "T",
      27,
      16
      /* InDeclaration */
    );
    var stateBeforeCdata5 = ifElseState(
      "A",
      28,
      16
      /* InDeclaration */
    );
    var stateBeforeScript1 = consumeSpecialNameChar(
      "R",
      35
      /* BeforeScript2 */
    );
    var stateBeforeScript2 = consumeSpecialNameChar(
      "I",
      36
      /* BeforeScript3 */
    );
    var stateBeforeScript3 = consumeSpecialNameChar(
      "P",
      37
      /* BeforeScript4 */
    );
    var stateBeforeScript4 = consumeSpecialNameChar(
      "T",
      38
      /* BeforeScript5 */
    );
    var stateAfterScript1 = ifElseState(
      "R",
      40,
      1
      /* Text */
    );
    var stateAfterScript2 = ifElseState(
      "I",
      41,
      1
      /* Text */
    );
    var stateAfterScript3 = ifElseState(
      "P",
      42,
      1
      /* Text */
    );
    var stateAfterScript4 = ifElseState(
      "T",
      43,
      1
      /* Text */
    );
    var stateBeforeStyle1 = consumeSpecialNameChar(
      "Y",
      45
      /* BeforeStyle2 */
    );
    var stateBeforeStyle2 = consumeSpecialNameChar(
      "L",
      46
      /* BeforeStyle3 */
    );
    var stateBeforeStyle3 = consumeSpecialNameChar(
      "E",
      47
      /* BeforeStyle4 */
    );
    var stateAfterStyle1 = ifElseState(
      "Y",
      49,
      1
      /* Text */
    );
    var stateAfterStyle2 = ifElseState(
      "L",
      50,
      1
      /* Text */
    );
    var stateAfterStyle3 = ifElseState(
      "E",
      51,
      1
      /* Text */
    );
    var stateBeforeSpecialT = consumeSpecialNameChar(
      "I",
      54
      /* BeforeTitle1 */
    );
    var stateBeforeTitle1 = consumeSpecialNameChar(
      "T",
      55
      /* BeforeTitle2 */
    );
    var stateBeforeTitle2 = consumeSpecialNameChar(
      "L",
      56
      /* BeforeTitle3 */
    );
    var stateBeforeTitle3 = consumeSpecialNameChar(
      "E",
      57
      /* BeforeTitle4 */
    );
    var stateAfterSpecialTEnd = ifElseState(
      "I",
      58,
      1
      /* Text */
    );
    var stateAfterTitle1 = ifElseState(
      "T",
      59,
      1
      /* Text */
    );
    var stateAfterTitle2 = ifElseState(
      "L",
      60,
      1
      /* Text */
    );
    var stateAfterTitle3 = ifElseState(
      "E",
      61,
      1
      /* Text */
    );
    var stateBeforeEntity = ifElseState(
      "#",
      63,
      64
      /* InNamedEntity */
    );
    var stateBeforeNumericEntity = ifElseState(
      "X",
      66,
      65
      /* InNumericEntity */
    );
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(options, cbs) {
          var _a;
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.special = 1;
          this.running = true;
          this.ended = false;
          this.cbs = cbs;
          this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
          this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
        }
        Tokenizer2.prototype.reset = function() {
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.special = 1;
          this.running = true;
          this.ended = false;
        };
        Tokenizer2.prototype.write = function(chunk2) {
          if (this.ended)
            this.cbs.onerror(Error(".write() after done!"));
          this.buffer += chunk2;
          this.parse();
        };
        Tokenizer2.prototype.end = function(chunk2) {
          if (this.ended)
            this.cbs.onerror(Error(".end() after done!"));
          if (chunk2)
            this.write(chunk2);
          this.ended = true;
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this._index < this.buffer.length) {
            this.parse();
          }
          if (this.ended) {
            this.finish();
          }
        };
        Tokenizer2.prototype.getAbsoluteIndex = function() {
          return this.bufferOffset + this._index;
        };
        Tokenizer2.prototype.stateText = function(c6) {
          if (c6 === "<") {
            if (this._index > this.sectionStart) {
              this.cbs.ontext(this.getSection());
            }
            this._state = 2;
            this.sectionStart = this._index;
          } else if (this.decodeEntities && c6 === "&" && (this.special === 1 || this.special === 4)) {
            if (this._index > this.sectionStart) {
              this.cbs.ontext(this.getSection());
            }
            this.baseState = 1;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c6) {
          return isASCIIAlpha(c6) || this.xmlMode && !whitespace(c6) && c6 !== "/" && c6 !== ">";
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c6) {
          if (c6 === "/") {
            this._state = 5;
          } else if (c6 === "<") {
            this.cbs.ontext(this.getSection());
            this.sectionStart = this._index;
          } else if (c6 === ">" || this.special !== 1 || whitespace(c6)) {
            this._state = 1;
          } else if (c6 === "!") {
            this._state = 15;
            this.sectionStart = this._index + 1;
          } else if (c6 === "?") {
            this._state = 17;
            this.sectionStart = this._index + 1;
          } else if (!this.isTagStartChar(c6)) {
            this._state = 1;
          } else {
            this._state = !this.xmlMode && (c6 === "s" || c6 === "S") ? 32 : !this.xmlMode && (c6 === "t" || c6 === "T") ? 52 : 3;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c6) {
          if (c6 === "/" || c6 === ">" || whitespace(c6)) {
            this.emitToken("onopentagname");
            this._state = 8;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c6) {
          if (whitespace(c6)) {
          } else if (c6 === ">") {
            this._state = 1;
          } else if (this.special !== 1) {
            if (this.special !== 4 && (c6 === "s" || c6 === "S")) {
              this._state = 33;
            } else if (this.special === 4 && (c6 === "t" || c6 === "T")) {
              this._state = 53;
            } else {
              this._state = 1;
              this._index--;
            }
          } else if (!this.isTagStartChar(c6)) {
            this._state = 20;
            this.sectionStart = this._index;
          } else {
            this._state = 6;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c6) {
          if (c6 === ">" || whitespace(c6)) {
            this.emitToken("onclosetag");
            this._state = 7;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c6) {
          if (c6 === ">") {
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c6) {
          if (c6 === ">") {
            this.cbs.onopentagend();
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c6 === "/") {
            this._state = 4;
          } else if (!whitespace(c6)) {
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c6) {
          if (c6 === ">") {
            this.cbs.onselfclosingtag();
            this._state = 1;
            this.sectionStart = this._index + 1;
            this.special = 1;
          } else if (!whitespace(c6)) {
            this._state = 8;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c6) {
          if (c6 === "=" || c6 === "/" || c6 === ">" || whitespace(c6)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c6) {
          if (c6 === "=") {
            this._state = 11;
          } else if (c6 === "/" || c6 === ">") {
            this.cbs.onattribend(void 0);
            this._state = 8;
            this._index--;
          } else if (!whitespace(c6)) {
            this.cbs.onattribend(void 0);
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c6) {
          if (c6 === '"') {
            this._state = 12;
            this.sectionStart = this._index + 1;
          } else if (c6 === "'") {
            this._state = 13;
            this.sectionStart = this._index + 1;
          } else if (!whitespace(c6)) {
            this._state = 14;
            this.sectionStart = this._index;
            this._index--;
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c6, quote) {
          if (c6 === quote) {
            this.emitToken("onattribdata");
            this.cbs.onattribend(quote);
            this._state = 8;
          } else if (this.decodeEntities && c6 === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c6) {
          this.handleInAttributeValue(c6, '"');
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c6) {
          this.handleInAttributeValue(c6, "'");
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c6) {
          if (whitespace(c6) || c6 === ">") {
            this.emitToken("onattribdata");
            this.cbs.onattribend(null);
            this._state = 8;
            this._index--;
          } else if (this.decodeEntities && c6 === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c6) {
          this._state = c6 === "[" ? 23 : c6 === "-" ? 18 : 16;
        };
        Tokenizer2.prototype.stateInDeclaration = function(c6) {
          if (c6 === ">") {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c6) {
          if (c6 === ">") {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c6) {
          if (c6 === "-") {
            this._state = 19;
            this.sectionStart = this._index + 1;
          } else {
            this._state = 16;
          }
        };
        Tokenizer2.prototype.stateInComment = function(c6) {
          if (c6 === "-")
            this._state = 21;
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c6) {
          if (c6 === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateAfterComment1 = function(c6) {
          if (c6 === "-") {
            this._state = 22;
          } else {
            this._state = 19;
          }
        };
        Tokenizer2.prototype.stateAfterComment2 = function(c6) {
          if (c6 === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c6 !== "-") {
            this._state = 19;
          }
        };
        Tokenizer2.prototype.stateBeforeCdata6 = function(c6) {
          if (c6 === "[") {
            this._state = 29;
            this.sectionStart = this._index + 1;
          } else {
            this._state = 16;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInCdata = function(c6) {
          if (c6 === "]")
            this._state = 30;
        };
        Tokenizer2.prototype.stateAfterCdata1 = function(c6) {
          if (c6 === "]")
            this._state = 31;
          else
            this._state = 29;
        };
        Tokenizer2.prototype.stateAfterCdata2 = function(c6) {
          if (c6 === ">") {
            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1;
            this.sectionStart = this._index + 1;
          } else if (c6 !== "]") {
            this._state = 29;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c6) {
          if (c6 === "c" || c6 === "C") {
            this._state = 34;
          } else if (c6 === "t" || c6 === "T") {
            this._state = 44;
          } else {
            this._state = 3;
            this._index--;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialSEnd = function(c6) {
          if (this.special === 2 && (c6 === "c" || c6 === "C")) {
            this._state = 39;
          } else if (this.special === 3 && (c6 === "t" || c6 === "T")) {
            this._state = 48;
          } else
            this._state = 1;
        };
        Tokenizer2.prototype.stateBeforeSpecialLast = function(c6, special) {
          if (c6 === "/" || c6 === ">" || whitespace(c6)) {
            this.special = special;
          }
          this._state = 3;
          this._index--;
        };
        Tokenizer2.prototype.stateAfterSpecialLast = function(c6, sectionStartOffset) {
          if (c6 === ">" || whitespace(c6)) {
            this.special = 1;
            this._state = 6;
            this.sectionStart = this._index - sectionStartOffset;
            this._index--;
          } else
            this._state = 1;
        };
        Tokenizer2.prototype.parseFixedEntity = function(map4) {
          if (map4 === void 0) {
            map4 = this.xmlMode ? xml_json_1.default : entities_json_1.default;
          }
          if (this.sectionStart + 1 < this._index) {
            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
            if (Object.prototype.hasOwnProperty.call(map4, entity)) {
              this.emitPartial(map4[entity]);
              this.sectionStart = this._index + 1;
            }
          }
        };
        Tokenizer2.prototype.parseLegacyEntity = function() {
          var start = this.sectionStart + 1;
          var limit = Math.min(this._index - start, 6);
          while (limit >= 2) {
            var entity = this.buffer.substr(start, limit);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
              this.emitPartial(legacy_json_1.default[entity]);
              this.sectionStart += limit + 1;
              return;
            }
            limit--;
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c6) {
          if (c6 === ";") {
            this.parseFixedEntity();
            if (this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode) {
              this.parseLegacyEntity();
            }
            this._state = this.baseState;
          } else if ((c6 < "0" || c6 > "9") && !isASCIIAlpha(c6)) {
            if (this.xmlMode || this.sectionStart + 1 === this._index) {
            } else if (this.baseState !== 1) {
              if (c6 !== "=") {
                this.parseFixedEntity(legacy_json_1.default);
              }
            } else {
              this.parseLegacyEntity();
            }
            this._state = this.baseState;
            this._index--;
          }
        };
        Tokenizer2.prototype.decodeNumericEntity = function(offset2, base, strict) {
          var sectionStart = this.sectionStart + offset2;
          if (sectionStart !== this._index) {
            var entity = this.buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial(decode_codepoint_1.default(parsed));
            this.sectionStart = strict ? this._index + 1 : this._index;
          }
          this._state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c6) {
          if (c6 === ";") {
            this.decodeNumericEntity(2, 10, true);
          } else if (c6 < "0" || c6 > "9") {
            if (!this.xmlMode) {
              this.decodeNumericEntity(2, 10, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c6) {
          if (c6 === ";") {
            this.decodeNumericEntity(3, 16, true);
          } else if ((c6 < "a" || c6 > "f") && (c6 < "A" || c6 > "F") && (c6 < "0" || c6 > "9")) {
            if (!this.xmlMode) {
              this.decodeNumericEntity(3, 16, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          }
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.sectionStart < 0) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else if (this.running) {
            if (this._state === 1) {
              if (this.sectionStart !== this._index) {
                this.cbs.ontext(this.buffer.substr(this.sectionStart));
              }
              this.buffer = "";
              this.bufferOffset += this._index;
              this._index = 0;
            } else if (this.sectionStart === this._index) {
              this.buffer = "";
              this.bufferOffset += this._index;
              this._index = 0;
            } else {
              this.buffer = this.buffer.substr(this.sectionStart);
              this._index -= this.sectionStart;
              this.bufferOffset += this.sectionStart;
            }
            this.sectionStart = 0;
          }
        };
        Tokenizer2.prototype.parse = function() {
          while (this._index < this.buffer.length && this.running) {
            var c6 = this.buffer.charAt(this._index);
            if (this._state === 1) {
              this.stateText(c6);
            } else if (this._state === 12) {
              this.stateInAttributeValueDoubleQuotes(c6);
            } else if (this._state === 9) {
              this.stateInAttributeName(c6);
            } else if (this._state === 19) {
              this.stateInComment(c6);
            } else if (this._state === 20) {
              this.stateInSpecialComment(c6);
            } else if (this._state === 8) {
              this.stateBeforeAttributeName(c6);
            } else if (this._state === 3) {
              this.stateInTagName(c6);
            } else if (this._state === 6) {
              this.stateInClosingTagName(c6);
            } else if (this._state === 2) {
              this.stateBeforeTagName(c6);
            } else if (this._state === 10) {
              this.stateAfterAttributeName(c6);
            } else if (this._state === 13) {
              this.stateInAttributeValueSingleQuotes(c6);
            } else if (this._state === 11) {
              this.stateBeforeAttributeValue(c6);
            } else if (this._state === 5) {
              this.stateBeforeClosingTagName(c6);
            } else if (this._state === 7) {
              this.stateAfterClosingTagName(c6);
            } else if (this._state === 32) {
              this.stateBeforeSpecialS(c6);
            } else if (this._state === 21) {
              this.stateAfterComment1(c6);
            } else if (this._state === 14) {
              this.stateInAttributeValueNoQuotes(c6);
            } else if (this._state === 4) {
              this.stateInSelfClosingTag(c6);
            } else if (this._state === 16) {
              this.stateInDeclaration(c6);
            } else if (this._state === 15) {
              this.stateBeforeDeclaration(c6);
            } else if (this._state === 22) {
              this.stateAfterComment2(c6);
            } else if (this._state === 18) {
              this.stateBeforeComment(c6);
            } else if (this._state === 33) {
              this.stateBeforeSpecialSEnd(c6);
            } else if (this._state === 53) {
              stateAfterSpecialTEnd(this, c6);
            } else if (this._state === 39) {
              stateAfterScript1(this, c6);
            } else if (this._state === 40) {
              stateAfterScript2(this, c6);
            } else if (this._state === 41) {
              stateAfterScript3(this, c6);
            } else if (this._state === 34) {
              stateBeforeScript1(this, c6);
            } else if (this._state === 35) {
              stateBeforeScript2(this, c6);
            } else if (this._state === 36) {
              stateBeforeScript3(this, c6);
            } else if (this._state === 37) {
              stateBeforeScript4(this, c6);
            } else if (this._state === 38) {
              this.stateBeforeSpecialLast(
                c6,
                2
                /* Script */
              );
            } else if (this._state === 42) {
              stateAfterScript4(this, c6);
            } else if (this._state === 43) {
              this.stateAfterSpecialLast(c6, 6);
            } else if (this._state === 44) {
              stateBeforeStyle1(this, c6);
            } else if (this._state === 29) {
              this.stateInCdata(c6);
            } else if (this._state === 45) {
              stateBeforeStyle2(this, c6);
            } else if (this._state === 46) {
              stateBeforeStyle3(this, c6);
            } else if (this._state === 47) {
              this.stateBeforeSpecialLast(
                c6,
                3
                /* Style */
              );
            } else if (this._state === 48) {
              stateAfterStyle1(this, c6);
            } else if (this._state === 49) {
              stateAfterStyle2(this, c6);
            } else if (this._state === 50) {
              stateAfterStyle3(this, c6);
            } else if (this._state === 51) {
              this.stateAfterSpecialLast(c6, 5);
            } else if (this._state === 52) {
              stateBeforeSpecialT(this, c6);
            } else if (this._state === 54) {
              stateBeforeTitle1(this, c6);
            } else if (this._state === 55) {
              stateBeforeTitle2(this, c6);
            } else if (this._state === 56) {
              stateBeforeTitle3(this, c6);
            } else if (this._state === 57) {
              this.stateBeforeSpecialLast(
                c6,
                4
                /* Title */
              );
            } else if (this._state === 58) {
              stateAfterTitle1(this, c6);
            } else if (this._state === 59) {
              stateAfterTitle2(this, c6);
            } else if (this._state === 60) {
              stateAfterTitle3(this, c6);
            } else if (this._state === 61) {
              this.stateAfterSpecialLast(c6, 5);
            } else if (this._state === 17) {
              this.stateInProcessingInstruction(c6);
            } else if (this._state === 64) {
              this.stateInNamedEntity(c6);
            } else if (this._state === 23) {
              stateBeforeCdata1(this, c6);
            } else if (this._state === 62) {
              stateBeforeEntity(this, c6);
            } else if (this._state === 24) {
              stateBeforeCdata2(this, c6);
            } else if (this._state === 25) {
              stateBeforeCdata3(this, c6);
            } else if (this._state === 30) {
              this.stateAfterCdata1(c6);
            } else if (this._state === 31) {
              this.stateAfterCdata2(c6);
            } else if (this._state === 26) {
              stateBeforeCdata4(this, c6);
            } else if (this._state === 27) {
              stateBeforeCdata5(this, c6);
            } else if (this._state === 28) {
              this.stateBeforeCdata6(c6);
            } else if (this._state === 66) {
              this.stateInHexEntity(c6);
            } else if (this._state === 65) {
              this.stateInNumericEntity(c6);
            } else if (this._state === 63) {
              stateBeforeNumericEntity(this, c6);
            } else {
              this.cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.sectionStart < this._index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var data = this.buffer.substr(this.sectionStart);
          if (this._state === 29 || this._state === 30 || this._state === 31) {
            this.cbs.oncdata(data);
          } else if (this._state === 19 || this._state === 21 || this._state === 22) {
            this.cbs.oncomment(data);
          } else if (this._state === 64 && !this.xmlMode) {
            this.parseLegacyEntity();
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state === 65 && !this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state === 66 && !this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
            if (this.sectionStart < this._index) {
              this._state = this.baseState;
              this.handleTrailingData();
            }
          } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
            this.cbs.ontext(data);
          }
        };
        Tokenizer2.prototype.getSection = function() {
          return this.buffer.substring(this.sectionStart, this._index);
        };
        Tokenizer2.prototype.emitToken = function(name) {
          this.cbs[name](this.getSection());
          this.sectionStart = -1;
        };
        Tokenizer2.prototype.emitPartial = function(value) {
          if (this.baseState !== 1) {
            this.cbs.onattribdata(value);
          } else {
            this.cbs.ontext(value);
          }
        };
        return Tokenizer2;
      }()
    );
    exports.default = Tokenizer;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_1 = __importDefault(require_Tokenizer());
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var openImpliesClose = {
      tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
      th: /* @__PURE__ */ new Set(["th"]),
      td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
      body: /* @__PURE__ */ new Set(["head", "link", "script"]),
      li: /* @__PURE__ */ new Set(["li"]),
      p: pTag,
      h1: pTag,
      h2: pTag,
      h3: pTag,
      h4: pTag,
      h5: pTag,
      h6: pTag,
      select: formTags,
      input: formTags,
      output: formTags,
      button: formTags,
      datalist: formTags,
      textarea: formTags,
      option: /* @__PURE__ */ new Set(["option"]),
      optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
      dd: /* @__PURE__ */ new Set(["dt", "dd"]),
      dt: /* @__PURE__ */ new Set(["dt", "dd"]),
      address: pTag,
      article: pTag,
      aside: pTag,
      blockquote: pTag,
      details: pTag,
      div: pTag,
      dl: pTag,
      fieldset: pTag,
      figcaption: pTag,
      figure: pTag,
      footer: pTag,
      form: pTag,
      header: pTag,
      hr: pTag,
      main: pTag,
      nav: pTag,
      ol: pTag,
      pre: pTag,
      section: pTag,
      table: pTag,
      ul: pTag,
      rt: /* @__PURE__ */ new Set(["rt", "rp"]),
      rp: /* @__PURE__ */ new Set(["rt", "rp"]),
      tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
      tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
    };
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = (
      /** @class */
      function() {
        function Parser2(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a, _b, _c, _d, _e;
          this.startIndex = 0;
          this.endIndex = null;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.options = options;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.updatePosition = function(initialOffset) {
          if (this.endIndex === null) {
            if (this.tokenizer.sectionStart <= initialOffset) {
              this.startIndex = 0;
            } else {
              this.startIndex = this.tokenizer.sectionStart - initialOffset;
            }
          } else {
            this.startIndex = this.endIndex + 1;
          }
          this.endIndex = this.tokenizer.getAbsoluteIndex();
        };
        Parser2.prototype.ontext = function(data) {
          var _a, _b;
          this.updatePosition(1);
          this.endIndex--;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        };
        Parser2.prototype.onopentagname = function(name) {
          var _a, _b;
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.tagname = name;
          if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
            var el = void 0;
            while (this.stack.length > 0 && openImpliesClose[name].has(el = this.stack[this.stack.length - 1])) {
              this.onclosetag(el);
            }
          }
          if (this.options.xmlMode || !voidElements.has(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.onopentagend = function() {
          var _a, _b;
          this.updatePosition(1);
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
            this.attribs = null;
          }
          if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
            this.cbs.onclosetag(this.tagname);
          }
          this.tagname = "";
        };
        Parser2.prototype.onclosetag = function(name) {
          this.updatePosition(1);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
          }
          if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                pos = this.stack.length - pos;
                while (pos--) {
                  this.cbs.onclosetag(this.stack.pop());
                }
              } else
                this.stack.length = pos;
            } else if (name === "p" && !this.options.xmlMode) {
              this.onopentagname(name);
              this.closeCurrentTag();
            }
          } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
            this.onopentagname(name);
            this.closeCurrentTag();
          }
        };
        Parser2.prototype.onselfclosingtag = function() {
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag();
          } else {
            this.onopentagend();
          }
        };
        Parser2.prototype.closeCurrentTag = function() {
          var _a, _b;
          var name = this.tagname;
          this.onopentagend();
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(name) {
          if (this.lowerCaseAttributeNames) {
            name = name.toLowerCase();
          }
          this.attribname = name;
        };
        Parser2.prototype.onattribdata = function(value) {
          this.attribvalue += value;
        };
        Parser2.prototype.onattribend = function(quote) {
          var _a, _b;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribname = "";
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var idx = value.search(reNameEnd);
          var name = idx < 0 ? value : value.substr(0, idx);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser2.prototype.ondeclaration = function(value) {
          if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
          }
        };
        Parser2.prototype.onprocessinginstruction = function(value) {
          if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
          }
        };
        Parser2.prototype.oncomment = function(value) {
          var _a, _b, _c, _d;
          this.updatePosition(4);
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        };
        Parser2.prototype.oncdata = function(value) {
          var _a, _b, _c, _d, _e, _f;
          this.updatePosition(1);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            this.oncomment("[CDATA[" + value + "]]");
          }
        };
        Parser2.prototype.onerror = function(err) {
          var _a, _b;
          (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            for (var i5 = this.stack.length; i5 > 0; this.cbs.onclosetag(this.stack[--i5]))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack = [];
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.write = function(chunk2) {
          this.tokenizer.write(chunk2);
        };
        Parser2.prototype.end = function(chunk2) {
          this.tokenizer.end(chunk2);
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
        };
        Parser2.prototype.parseChunk = function(chunk2) {
          this.write(chunk2);
        };
        Parser2.prototype.done = function(chunk2) {
          this.end(chunk2);
        };
        return Parser2;
      }()
    );
    exports.Parser = Parser;
  }
});

// ../../node_modules/domelementtype/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType.Root;
    exports.Text = ElementType.Text;
    exports.Directive = ElementType.Directive;
    exports.Comment = ElementType.Comment;
    exports.Script = ElementType.Script;
    exports.Style = ElementType.Style;
    exports.Tag = ElementType.Tag;
    exports.CDATA = ElementType.CDATA;
    exports.Doctype = ElementType.Doctype;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d6, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
          d7.__proto__ = b5;
        } || function(d7, b5) {
          for (var p3 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p3))
              d7[p3] = b5[p3];
        };
        return extendStatics(d6, b4);
      };
      return function(d6, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d6, b4);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib4();
    var nodeTypes = /* @__PURE__ */ new Map([
      [domelementtype_1.ElementType.Tag, 1],
      [domelementtype_1.ElementType.Script, 1],
      [domelementtype_1.ElementType.Style, 1],
      [domelementtype_1.ElementType.Directive, 1],
      [domelementtype_1.ElementType.Text, 3],
      [domelementtype_1.ElementType.CDATA, 4],
      [domelementtype_1.ElementType.Comment, 8],
      [domelementtype_1.ElementType.Root, 9]
    ]);
    var Node2 = (
      /** @class */
      function() {
        function Node3(type2) {
          this.type = type2;
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "nodeType", {
          // Read-only aliases
          /**
           * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
           * node {@link type}.
           */
          get: function() {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(type2, data) {
          var _this = _super.call(this, type2) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports.DataNode = DataNode;
    var Text2 = (
      /** @class */
      function(_super) {
        __extends(Text3, _super);
        function Text3(data) {
          return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
        }
        return Text3;
      }(DataNode)
    );
    exports.Text = Text2;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2(data) {
          return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
        }
        return Comment2;
      }(DataNode)
    );
    exports.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
          _this.name = name;
          return _this;
        }
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(type2, children) {
          var _this = _super.call(this, type2) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3(children) {
          return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
        }
        return Document3;
      }(NodeWithChildren)
    );
    exports.Document = Document2;
    var Element2 = (
      /** @class */
      function(_super) {
        __extends(Element3, _super);
        function Element3(name, attribs, children, type2) {
          if (children === void 0) {
            children = [];
          }
          if (type2 === void 0) {
            type2 = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, type2, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren)
    );
    exports.Element = Element2;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result2;
      if (isText(node)) {
        result2 = new Text2(node.data);
      } else if (isComment(node)) {
        result2 = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element2(node.name, __assign2({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign2({}, node["x-attribsPrefix"]);
        }
        result2 = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result2 = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document2(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result2 = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result2 = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result2.startIndex = node.startIndex;
      result2.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result2.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result2;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i5 = 1; i5 < children.length; i5++) {
        children[i5].prev = children[i5 - 1];
        children[i5 - 1].next = children[i5];
      }
      return children;
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m4, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib4();
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type2 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element2 = new node_1.Element(name, attribs, void 0, type2);
          this.addNode(element2);
          this.tagStack.push(element2);
        };
        DomHandler2.prototype.ontext = function(data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_1.Text("");
          var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// ../../node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "../../node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map4) {
      var keys2 = Object.keys(map4).join("|");
      var replace = getReplacer(map4);
      keys2 += "|#[xX][\\da-fA-F]+|#\\d+";
      var re = new RegExp("&(?:" + keys2 + ");", "g");
      return function(str2) {
        return String(str2).replace(re, replace);
      };
    }
    var sorter = function(a4, b4) {
      return a4 < b4 ? 1 : -1;
    };
    exports.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys2 = Object.keys(entities_json_1.default).sort(sorter);
      for (var i5 = 0, j2 = 0; i5 < keys2.length; i5++) {
        if (legacy[j2] === keys2[i5]) {
          keys2[i5] += ";?";
          j2++;
        } else {
          keys2[i5] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str2) {
        if (str2.substr(-1) !== ";")
          str2 += ";";
        return replace(str2);
      }
      return function(str2) {
        return String(str2).replace(re, replacer);
      };
    }();
    function getReplacer(map4) {
      return function replace(str2) {
        if (str2.charAt(1) === "#") {
          var secondChar = str2.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str2.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str2.substr(2), 10));
        }
        return map4[str2.slice(1, -1)];
      };
    }
  }
});

// ../../node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escape = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getInverse(inverseXML, xmlReplacer);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count = 1 + end - start;
        if (count < 3)
          continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    function singleCharReplacer(c6) {
      return "&#x" + c6.codePointAt(0).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reXmlChars = getInverseReplacer(inverseXML);
    function escape2(data) {
      return data.replace(reXmlChars, singleCharReplacer).replace(reNonASCII, singleCharReplacer);
    }
    exports.escape = escape2;
  }
});

// ../../node_modules/entities/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escape = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = /* @__PURE__ */ new Map([
      ["altglyph", "altGlyph"],
      ["altglyphdef", "altGlyphDef"],
      ["altglyphitem", "altGlyphItem"],
      ["animatecolor", "animateColor"],
      ["animatemotion", "animateMotion"],
      ["animatetransform", "animateTransform"],
      ["clippath", "clipPath"],
      ["feblend", "feBlend"],
      ["fecolormatrix", "feColorMatrix"],
      ["fecomponenttransfer", "feComponentTransfer"],
      ["fecomposite", "feComposite"],
      ["feconvolvematrix", "feConvolveMatrix"],
      ["fediffuselighting", "feDiffuseLighting"],
      ["fedisplacementmap", "feDisplacementMap"],
      ["fedistantlight", "feDistantLight"],
      ["fedropshadow", "feDropShadow"],
      ["feflood", "feFlood"],
      ["fefunca", "feFuncA"],
      ["fefuncb", "feFuncB"],
      ["fefuncg", "feFuncG"],
      ["fefuncr", "feFuncR"],
      ["fegaussianblur", "feGaussianBlur"],
      ["feimage", "feImage"],
      ["femerge", "feMerge"],
      ["femergenode", "feMergeNode"],
      ["femorphology", "feMorphology"],
      ["feoffset", "feOffset"],
      ["fepointlight", "fePointLight"],
      ["fespecularlighting", "feSpecularLighting"],
      ["fespotlight", "feSpotLight"],
      ["fetile", "feTile"],
      ["feturbulence", "feTurbulence"],
      ["foreignobject", "foreignObject"],
      ["glyphref", "glyphRef"],
      ["lineargradient", "linearGradient"],
      ["radialgradient", "radialGradient"],
      ["textpath", "textPath"]
    ]);
    exports.attributeNames = /* @__PURE__ */ new Map([
      ["definitionurl", "definitionURL"],
      ["attributename", "attributeName"],
      ["attributetype", "attributeType"],
      ["basefrequency", "baseFrequency"],
      ["baseprofile", "baseProfile"],
      ["calcmode", "calcMode"],
      ["clippathunits", "clipPathUnits"],
      ["diffuseconstant", "diffuseConstant"],
      ["edgemode", "edgeMode"],
      ["filterunits", "filterUnits"],
      ["glyphref", "glyphRef"],
      ["gradienttransform", "gradientTransform"],
      ["gradientunits", "gradientUnits"],
      ["kernelmatrix", "kernelMatrix"],
      ["kernelunitlength", "kernelUnitLength"],
      ["keypoints", "keyPoints"],
      ["keysplines", "keySplines"],
      ["keytimes", "keyTimes"],
      ["lengthadjust", "lengthAdjust"],
      ["limitingconeangle", "limitingConeAngle"],
      ["markerheight", "markerHeight"],
      ["markerunits", "markerUnits"],
      ["markerwidth", "markerWidth"],
      ["maskcontentunits", "maskContentUnits"],
      ["maskunits", "maskUnits"],
      ["numoctaves", "numOctaves"],
      ["pathlength", "pathLength"],
      ["patterncontentunits", "patternContentUnits"],
      ["patterntransform", "patternTransform"],
      ["patternunits", "patternUnits"],
      ["pointsatx", "pointsAtX"],
      ["pointsaty", "pointsAtY"],
      ["pointsatz", "pointsAtZ"],
      ["preservealpha", "preserveAlpha"],
      ["preserveaspectratio", "preserveAspectRatio"],
      ["primitiveunits", "primitiveUnits"],
      ["refx", "refX"],
      ["refy", "refY"],
      ["repeatcount", "repeatCount"],
      ["repeatdur", "repeatDur"],
      ["requiredextensions", "requiredExtensions"],
      ["requiredfeatures", "requiredFeatures"],
      ["specularconstant", "specularConstant"],
      ["specularexponent", "specularExponent"],
      ["spreadmethod", "spreadMethod"],
      ["startoffset", "startOffset"],
      ["stddeviation", "stdDeviation"],
      ["stitchtiles", "stitchTiles"],
      ["surfacescale", "surfaceScale"],
      ["systemlanguage", "systemLanguage"],
      ["tablevalues", "tableValues"],
      ["targetx", "targetX"],
      ["targety", "targetY"],
      ["textlength", "textLength"],
      ["viewbox", "viewBox"],
      ["viewtarget", "viewTarget"],
      ["xchannelselector", "xChannelSelector"],
      ["ychannelselector", "yChannelSelector"],
      ["zoomandpan", "zoomAndPan"]
    ]);
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o10, k2, { enumerable: true, get: function() {
        return m4[k];
      } });
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ElementType = __importStar(require_lib4());
    var entities_1 = require_lib6();
    var foreignNames_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function formatAttributes(attributes, opts) {
      if (!attributes)
        return;
      return Object.keys(attributes).map(function(key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return key + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i5 = 0; i5 < nodes.length; i5++) {
        output += renderNode(nodes[i5], options);
      }
      return output;
    }
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText2(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign2(__assign2({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign2(__assign2({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<" + elem.name;
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText2(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib5();
    var dom_serializer_1 = __importDefault(require_lib7());
    var domelementtype_1 = require_lib4();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib5();
    var emptyArray = [];
    function getChildren2(elem) {
      var _a;
      return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
    }
    exports.getChildren = getChildren2;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren2(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib5();
    function filter2(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find3(test, node, recurse, limit);
    }
    exports.filter = filter2;
    function find3(test, nodes, recurse, limit) {
      var result2 = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result2.push(elem);
          if (--limit <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children = find3(test, elem.children, recurse, limit);
          result2.push.apply(result2, children);
          limit -= children.length;
          if (limit <= 0)
            break;
        }
      }
      return result2;
    }
    exports.find = find3;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i5 = 0; i5 < nodes.length && !elem; i5++) {
        var checked = nodes[i5];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a;
      var result2 = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
          stack.unshift.apply(stack, children);
        }
        if (test(elem))
          result2.push(elem);
      }
      return result2;
    }
    exports.findAll = findAll;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib5();
    var querying_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type2) {
        if (typeof type2 === "function") {
          return function(elem) {
            return type2(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type2;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a4, b4) {
      return function(elem) {
        return a4(elem) || b4(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type2, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_type(type2), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib5();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return 1;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return 4 | 16;
        }
        return 4;
      }
      if (sharedParent === nodeA) {
        return 2 | 8;
      }
      return 2;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i5, arr) {
        return !arr.includes(node, i5 + 1);
      });
      nodes.sort(function(a4, b4) {
        var relative = compareDocumentPosition(a4, b4);
        if (relative & 2) {
          return -1;
        } else if (relative & 4) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_1 = require_stringify();
    var legacy_1 = require_legacy2();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children) || fetch2("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch2("pubDate", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where2) {
      return (0, legacy_1.getElementsByTagName)("media:content", where2).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs.medium,
          isDefault: !!attribs.isDefault
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs.expression) {
          media.expression = attribs.expression;
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where2, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where2, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/index.js
var require_lib8 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o10, k2, { enumerable: true, get: function() {
        return m4[k];
      } });
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m4, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy2(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib5();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/FeedHandler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d6, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
          d7.__proto__ = b5;
        } || function(d7, b5) {
          for (var p3 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p3))
              d7[p3] = b5[p3];
        };
        return extendStatics(d6, b4);
      };
      return function(d6, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d6, b4);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o10, k2, { enumerable: true, get: function() {
        return m4[k];
      } });
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFeed = exports.FeedHandler = void 0;
    var domhandler_1 = __importDefault(require_lib5());
    var DomUtils = __importStar(require_lib8());
    var Parser_1 = require_Parser();
    var FeedItemMediaMedium;
    (function(FeedItemMediaMedium2) {
      FeedItemMediaMedium2[FeedItemMediaMedium2["image"] = 0] = "image";
      FeedItemMediaMedium2[FeedItemMediaMedium2["audio"] = 1] = "audio";
      FeedItemMediaMedium2[FeedItemMediaMedium2["video"] = 2] = "video";
      FeedItemMediaMedium2[FeedItemMediaMedium2["document"] = 3] = "document";
      FeedItemMediaMedium2[FeedItemMediaMedium2["executable"] = 4] = "executable";
    })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
    var FeedItemMediaExpression;
    (function(FeedItemMediaExpression2) {
      FeedItemMediaExpression2[FeedItemMediaExpression2["sample"] = 0] = "sample";
      FeedItemMediaExpression2[FeedItemMediaExpression2["full"] = 1] = "full";
      FeedItemMediaExpression2[FeedItemMediaExpression2["nonstop"] = 2] = "nonstop";
    })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
    var FeedHandler = (
      /** @class */
      function(_super) {
        __extends(FeedHandler2, _super);
        function FeedHandler2(callback, options) {
          var _this = this;
          if (typeof callback === "object") {
            callback = void 0;
            options = callback;
          }
          _this = _super.call(this, callback, options) || this;
          return _this;
        }
        FeedHandler2.prototype.onend = function() {
          var _a, _b;
          var feedRoot = getOneElement(isValidFeed, this.dom);
          if (!feedRoot) {
            this.handleCallback(new Error("couldn't find root of feed"));
            return;
          }
          var feed = {};
          if (feedRoot.name === "feed") {
            var childs = feedRoot.children;
            feed.type = "atom";
            addConditionally(feed, "id", "id", childs);
            addConditionally(feed, "title", "title", childs);
            var href = getAttribute("href", getOneElement("link", childs));
            if (href) {
              feed.link = href;
            }
            addConditionally(feed, "description", "subtitle", childs);
            var updated = fetch2("updated", childs);
            if (updated) {
              feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "email", childs, true);
            feed.items = getElements("entry", childs).map(function(item) {
              var entry = {};
              var children = item.children;
              addConditionally(entry, "id", "id", children);
              addConditionally(entry, "title", "title", children);
              var href2 = getAttribute("href", getOneElement("link", children));
              if (href2) {
                entry.link = href2;
              }
              var description = fetch2("summary", children) || fetch2("content", children);
              if (description) {
                entry.description = description;
              }
              var pubDate = fetch2("updated", children);
              if (pubDate) {
                entry.pubDate = new Date(pubDate);
              }
              entry.media = getMediaElements(children);
              return entry;
            });
          } else {
            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = "";
            addConditionally(feed, "title", "title", childs);
            addConditionally(feed, "link", "link", childs);
            addConditionally(feed, "description", "description", childs);
            var updated = fetch2("lastBuildDate", childs);
            if (updated) {
              feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "managingEditor", childs, true);
            feed.items = getElements("item", feedRoot.children).map(function(item) {
              var entry = {};
              var children = item.children;
              addConditionally(entry, "id", "guid", children);
              addConditionally(entry, "title", "title", children);
              addConditionally(entry, "link", "link", children);
              addConditionally(entry, "description", "description", children);
              var pubDate = fetch2("pubDate", children);
              if (pubDate)
                entry.pubDate = new Date(pubDate);
              entry.media = getMediaElements(children);
              return entry;
            });
          }
          this.feed = feed;
          this.handleCallback(null);
        };
        return FeedHandler2;
      }(domhandler_1.default)
    );
    exports.FeedHandler = FeedHandler;
    function getMediaElements(where2) {
      return getElements("media:content", where2).map(function(elem) {
        var media = {
          medium: elem.attribs.medium,
          isDefault: !!elem.attribs.isDefault
        };
        if (elem.attribs.url) {
          media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
          media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
          media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
          media.expression = elem.attribs.expression;
        }
        if (elem.attribs.bitrate) {
          media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
          media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
          media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
          media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
          media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
          media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
          media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
          media.lang = elem.attribs.lang;
        }
        return media;
      });
    }
    function getElements(tagName, where2) {
      return DomUtils.getElementsByTagName(tagName, where2, true);
    }
    function getOneElement(tagName, node) {
      return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where2, recurse, 1)).trim();
    }
    function getAttribute(name, elem) {
      if (!elem) {
        return null;
      }
      var attribs = elem.attribs;
      return attribs[name];
    }
    function addConditionally(obj, prop, what, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var tmp = fetch2(what, where2, recurse);
      if (tmp)
        obj[prop] = tmp;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = { xmlMode: true };
      }
      var handler = new FeedHandler(options);
      new Parser_1.Parser(handler, options).end(feed);
      return handler.feed;
    }
    exports.parseFeed = parseFeed;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/index.js
var require_lib9 = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/htmlparser2/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o10, k2, { enumerable: true, get: function() {
        return m4[k];
      } });
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m4, p3);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
    var Parser_1 = require_Parser();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var domhandler_1 = require_lib5();
    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    function createDomStream(cb2, options, elementCb) {
      var handler = new domhandler_1.DomHandler(cb2, options, elementCb);
      return new Parser_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;
    var Tokenizer_1 = require_Tokenizer();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_1).default;
    } });
    var ElementType = __importStar(require_lib4());
    exports.ElementType = ElementType;
    __exportStar(require_FeedHandler(), exports);
    exports.DomUtils = __importStar(require_lib8());
    var FeedHandler_1 = require_FeedHandler();
    Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function() {
      return FeedHandler_1.FeedHandler;
    } });
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../../node_modules/is-plain-object/dist/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject5(o10) {
      return Object.prototype.toString.call(o10) === "[object Object]";
    }
    function isPlainObject(o10) {
      var ctor2, prot;
      if (isObject5(o10) === false)
        return false;
      ctor2 = o10.constructor;
      if (ctor2 === void 0)
        return true;
      prot = ctor2.prototype;
      if (isObject5(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    exports.isPlainObject = isPlainObject;
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element2) {
        return cloneUnlessOtherwiseSpecified(element2, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property2) {
      try {
        return property2 in object2;
      } catch (_5) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// ../../node_modules/parse-srcset/src/parse-srcset.js
var require_parse_srcset = __commonJS({
  "../../node_modules/parse-srcset/src/parse-srcset.js"(exports, module) {
    (function(root2, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root2.parseSrcset = factory();
      }
    })(exports, function() {
      return function(input) {
        function isSpace(c7) {
          return c7 === " " || // space
          c7 === "	" || // horizontal tab
          c7 === "\n" || // new line
          c7 === "\f" || // form feed
          c7 === "\r";
        }
        function collectCharacters(regEx) {
          var chars, match = regEx.exec(input.substring(pos));
          if (match) {
            chars = match[0];
            pos += chars.length;
            return chars;
          }
        }
        var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c6, pos = 0, candidates = [];
        while (true) {
          collectCharacters(regexLeadingCommasOrSpaces);
          if (pos >= inputLength) {
            return candidates;
          }
          url = collectCharacters(regexLeadingNotSpaces);
          descriptors = [];
          if (url.slice(-1) === ",") {
            url = url.replace(regexTrailingCommas, "");
            parseDescriptors();
          } else {
            tokenize();
          }
        }
        function tokenize() {
          collectCharacters(regexLeadingSpaces);
          currentDescriptor = "";
          state = "in descriptor";
          while (true) {
            c6 = input.charAt(pos);
            if (state === "in descriptor") {
              if (isSpace(c6)) {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                  currentDescriptor = "";
                  state = "after descriptor";
                }
              } else if (c6 === ",") {
                pos += 1;
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else if (c6 === "(") {
                currentDescriptor = currentDescriptor + c6;
                state = "in parens";
              } else if (c6 === "") {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c6;
              }
            } else if (state === "in parens") {
              if (c6 === ")") {
                currentDescriptor = currentDescriptor + c6;
                state = "in descriptor";
              } else if (c6 === "") {
                descriptors.push(currentDescriptor);
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c6;
              }
            } else if (state === "after descriptor") {
              if (isSpace(c6)) {
              } else if (c6 === "") {
                parseDescriptors();
                return;
              } else {
                state = "in descriptor";
                pos -= 1;
              }
            }
            pos += 1;
          }
        }
        function parseDescriptors() {
          var pError = false, w4, d6, h4, i5, candidate = {}, desc, lastChar, value, intVal, floatVal;
          for (i5 = 0; i5 < descriptors.length; i5++) {
            desc = descriptors[i5];
            lastChar = desc[desc.length - 1];
            value = desc.substring(0, desc.length - 1);
            intVal = parseInt(value, 10);
            floatVal = parseFloat(value);
            if (regexNonNegativeInteger.test(value) && lastChar === "w") {
              if (w4 || d6) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                w4 = intVal;
              }
            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              if (w4 || d6 || h4) {
                pError = true;
              }
              if (floatVal < 0) {
                pError = true;
              } else {
                d6 = floatVal;
              }
            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              if (h4 || d6) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                h4 = intVal;
              }
            } else {
              pError = true;
            }
          }
          if (!pError) {
            candidate.url = url;
            if (w4) {
              candidate.w = w4;
            }
            if (d6) {
              candidate.d = d6;
            }
            if (h4) {
              candidate.h = h4;
            }
            candidates.push(candidate);
          } else if (console && console.log) {
            console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        }
      };
    });
  }
});

// ../../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../../node_modules/picocolors/picocolors.browser.js"(exports, module) {
    var x4 = String;
    var create2 = function() {
      return { isColorSupported: false, reset: x4, bold: x4, dim: x4, italic: x4, underline: x4, inverse: x4, hidden: x4, strikethrough: x4, black: x4, red: x4, green: x4, yellow: x4, blue: x4, magenta: x4, cyan: x4, white: x4, gray: x4, bgBlack: x4, bgRed: x4, bgGreen: x4, bgYellow: x4, bgBlue: x4, bgMagenta: x4, bgCyan: x4, bgWhite: x4 };
    };
    module.exports = create2();
    module.exports.createColors = create2;
  }
});

// (disabled):../../node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):../../node_modules/postcss/lib/terminal-highlight"() {
  }
});

// ../../node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "../../node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
    "use strict";
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class extends Error {
      constructor(message, line, column, source, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color2) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color2 == null)
          color2 = pico.isColorSupported;
        if (terminalHighlight) {
          if (color2)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color2) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark = aside = (str2) => str2;
        }
        return lines.slice(start, end).map((line, index2) => {
          let number = start + 1 + index2;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code3 = this.showSourceCode();
        if (code3) {
          code3 = "\n\n" + code3 + "\n";
        }
        return this.name + ": " + this.message + code3;
      }
    };
    module.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// ../../node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/postcss/lib/symbols.js"(exports, module) {
    "use strict";
    module.exports.isClean = Symbol("isClean");
    module.exports.my = Symbol("my");
  }
});

// ../../node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "../../node_modules/postcss/lib/stringifier.js"(exports, module) {
    "use strict";
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize2(str2) {
      return str2[0].toUpperCase() + str2.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node, semicolon) {
        let name = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name += node.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node);
        }
      }
      beforeAfter(node, detect) {
        let value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value += indent;
          }
        }
        return value;
      }
      block(node, start) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        let after2;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after2 = this.raw(node, "after");
        } else {
          after2 = this.raw(node, "after", "emptyBody");
        }
        if (after2)
          this.builder(after2);
        this.builder("}", node, "end");
      }
      body(node) {
        let last2 = node.nodes.length - 1;
        while (last2 > 0) {
          if (node.nodes[last2].type !== "comment")
            break;
          last2 -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i5 = 0; i5 < node.nodes.length; i5++) {
          let child = node.nodes[i5];
          let before2 = this.raw(child, "before");
          if (before2)
            this.builder(before2);
          this.stringify(child, last2 !== i5 || semicolon);
        }
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string += node.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node);
      }
      document(node) {
        this.body(node);
      }
      raw(node, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root2 = node.root();
        if (!root2.rawCache)
          root2.rawCache = {};
        if (typeof root2.rawCache[detect] !== "undefined") {
          return root2.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize2(detect);
          if (this[method]) {
            value = this[method](root2, node);
          } else {
            root2.walk((i5) => {
              value = i5.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root2.rawCache[detect] = value;
        return value;
      }
      rawBeforeClose(root2) {
        let value;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length > 0) {
            if (typeof i5.raws.after !== "undefined") {
              value = i5.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeComment(root2, node) {
        let value;
        root2.walkComments((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value = i5.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root2, node) {
        let value;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value = i5.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeOpen(root2) {
        let value;
        root2.walk((i5) => {
          if (i5.type !== "decl") {
            value = i5.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawBeforeRule(root2) {
        let value;
        root2.walk((i5) => {
          if (i5.nodes && (i5.parent !== root2 || root2.first !== i5)) {
            if (typeof i5.raws.before !== "undefined") {
              value = i5.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawColon(root2) {
        let value;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.between !== "undefined") {
            value = i5.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      rawEmptyBody(root2) {
        let value;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length === 0) {
            value = i5.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root2) {
        if (root2.raws.indent)
          return root2.raws.indent;
        let value;
        root2.walk((i5) => {
          let p3 = i5.parent;
          if (p3 && p3 !== root2 && p3.parent && p3.parent === root2) {
            if (typeof i5.raws.before !== "undefined") {
              let parts = i5.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawSemicolon(root2) {
        let value;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length && i5.last.type === "decl") {
            value = i5.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error(
            "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node.type](node, semicolon);
      }
    };
    module.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// ../../node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/postcss/lib/stringify.js"(exports, module) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify(node, builder) {
      let str2 = new Stringifier(builder);
      str2.stringify(node);
    }
    module.exports = stringify;
    stringify.default = stringify;
  }
});

// ../../node_modules/postcss/lib/node.js
var require_node2 = __commonJS({
  "../../node_modules/postcss/lib/node.js"(exports, module) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify = require_stringify2();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i5 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i5)) {
          continue;
        }
        if (i5 === "proxyCache")
          continue;
        let value = obj[i5];
        let type2 = typeof value;
        if (i5 === "parent" && type2 === "object") {
          if (parent)
            cloned[i5] = parent;
        } else if (i5 === "source") {
          cloned[i5] = value;
        } else if (Array.isArray(value)) {
          cloned[i5] = value.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type2 === "object" && value !== null)
            value = cloneNode(value);
          cloned[i5] = value;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node of defaults[name]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults[name];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s7 = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s7.input.from}:${s7.start.line}:${s7.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError(message);
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2, stringRepresentation);
        }
        return pos;
      }
      positionInside(index2, stringRepresentation) {
        let string = stringRepresentation || this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i5 = 0; i5 < index2; i5++) {
          if (string[i5] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { column, line };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1) {
            start = this.positionInside(index2, stringRepresentation);
            end = this.positionInside(index2 + opts.word.length, stringRepresentation);
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (typeof opts.endIndex === "number") {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str2 = new Stringifier();
        return str2.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result2 = this;
        while (result2.parent && result2.parent.type !== "document") {
          result2 = result2.parent;
        }
        return result2;
      }
      toJSON(_5, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i5) => {
              if (typeof i5 === "object" && i5.toJSON) {
                return i5.toJSON(null, inputs);
              } else {
                return i5;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              end: value.end,
              inputId,
              start: value.start
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result2 = "";
        stringifier(this, (i5) => {
          result2 += i5;
        });
        return result2;
      }
      warn(result2, text, opts) {
        let data = { node: this };
        for (let i5 in opts)
          data[i5] = opts[i5];
        return result2.warn(text, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module.exports = Node2;
    Node2.default = Node2;
  }
});

// ../../node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "../../node_modules/postcss/lib/declaration.js"(exports, module) {
    "use strict";
    var Node2 = require_node2();
    var Declaration = class extends Node2 {
      constructor(defaults) {
        if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
          defaults = { ...defaults, value: String(defaults.value) };
        }
        super(defaults);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// (disabled):../../node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "(disabled):../../node_modules/source-map-js/source-map.js"() {
  }
});

// node-modules-polyfills-empty:path
var require_path = __commonJS({
  "node-modules-polyfills-empty:path"(exports, module) {
    module.exports = {};
  }
});

// node-modules-polyfills-empty:url
var require_url = __commonJS({
  "node-modules-polyfills-empty:url"(exports, module) {
    module.exports = {};
  }
});

// ../../node_modules/postcss/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "../../node_modules/postcss/node_modules/nanoid/non-secure/index.cjs"(exports, module) {
    var urlAlphabet2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet2 = (alphabet, defaultSize = 21) => {
      return (size3 = defaultSize) => {
        let id = "";
        let i5 = size3;
        while (i5--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid2 = (size3 = 21) => {
      let id = "";
      let i5 = size3;
      while (i5--) {
        id += urlAlphabet2[Math.random() * 64 | 0];
      }
      return id;
    };
    module.exports = { nanoid: nanoid2, customAlphabet: customAlphabet2 };
  }
});

// node-modules-polyfills-empty:fs
var require_fs = __commonJS({
  "node-modules-polyfills-empty:fs"(exports, module) {
    module.exports = {};
  }
});

// ../../node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "../../node_modules/postcss/lib/previous-map.js"(exports, module) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync, readFileSync } = require_fs();
    var { dirname, join } = require_path();
    function fromBase64(str2) {
      if (Buffer) {
        return Buffer.from(str2, "base64").toString();
      } else {
        return window.atob(str2);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map4) {
        if (typeof map4 !== "object")
          return false;
        return typeof map4.mappings === "string" || typeof map4._mappings === "string" || Array.isArray(map4.sections);
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      loadFile(path) {
        this.root = dirname(path);
        if (existsSync(path)) {
          this.mapFile = path;
          return readFileSync(path, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map4 = this.loadFile(prevPath);
              if (!map4) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map4;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map4 = this.annotation;
          if (file)
            map4 = join(dirname(file), map4);
          return this.loadFile(map4);
        }
      }
      startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// ../../node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "../../node_modules/postcss/lib/input.js"(exports, module) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath, pathToFileURL } = require_url();
    var { isAbsolute, resolve } = require_path();
    var { nanoid: nanoid2 } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve && isAbsolute);
    var Input = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map4 = new PreviousMap(this.css, opts);
          if (map4.text) {
            this.map = map4;
            let file = map4.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid2(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line, column, opts = {}) {
        let result2, endLine, endColumn;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result2 = new CssSyntaxError(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result2 = new CssSyntaxError(
            message,
            endLine === void 0 ? line : { column, line },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result2.input = { column, endColumn, endLine, line, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result2.input.url = pathToFileURL(this.file).toString();
          }
          result2.input.file = this.file;
        }
        return result2;
      }
      fromOffset(offset2) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i5 = 0, l7 = lines.length; i5 < l7; i5++) {
            lineToIndex[i5] = prevIndex;
            prevIndex += lines[i5].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min3 = 0;
        if (offset2 >= lastLine) {
          min3 = lineToIndex.length - 1;
        } else {
          let max3 = lineToIndex.length - 2;
          let mid;
          while (min3 < max3) {
            mid = min3 + (max3 - min3 >> 1);
            if (offset2 < lineToIndex[mid]) {
              max3 = mid - 1;
            } else if (offset2 >= lineToIndex[mid + 1]) {
              min3 = mid + 1;
            } else {
              min3 = mid;
              break;
            }
          }
        }
        return {
          col: offset2 - lineToIndex[min3] + 1,
          line: min3 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ column, line });
        if (!from.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
          );
        }
        let result2 = {
          column: from.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result2.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source)
          result2.source = source;
        return result2;
      }
      toJSON() {
        let json2 = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json2[name] = this[name];
          }
        }
        if (this.map) {
          json2.map = { ...this.map };
          if (json2.map.consumerCache) {
            json2.map.consumerCache = void 0;
          }
        }
        return json2;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// ../../node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "../../node_modules/postcss/lib/map-generator.js"(exports, module) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname, relative, resolve, sep } = require_path();
    var { pathToFileURL } = require_url();
    var Input = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve && relative && sep);
    var MapGenerator = class {
      constructor(stringify, root2, opts, cssString) {
        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root2;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root2 = prev.root || dirname(prev.file);
          let map4;
          if (this.mapOpts.sourcesContent === false) {
            map4 = new SourceMapConsumer(prev.text);
            if (map4.sourcesContent) {
              map4.sourcesContent = null;
            }
          } else {
            map4 = prev.consumer();
          }
          this.map.applySourceMap(map4, from, this.toUrl(this.path(root2)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node;
          for (let i5 = this.root.nodes.length - 1; i5 >= 0; i5--) {
            node = this.root.nodes[i5];
            if (node.type !== "comment")
              continue;
            if (node.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i5);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result2 = "";
          this.stringify(this.root, (i5) => {
            result2 += i5;
          });
          return [result2];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev, {
            ignoreInvalidMapping: true
          });
        } else {
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let lines, last2;
        this.stringify(this.root, (str2, node, type2) => {
          this.css += str2;
          if (node && type2 !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str2.match(/\n/g);
          if (lines) {
            line += lines.length;
            last2 = str2.lastIndexOf("\n");
            column = str2.length - last2;
          } else {
            column += str2.length;
          }
          if (node && type2 !== "start") {
            let p3 = node.parent || { raws: {} };
            let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
            if (!childless || node !== p3.last || p3.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve(from, this.mapOpts.annotation));
        }
        let path = relative(from, file);
        this.memoizedPaths.set(file, path);
        return path;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node) => {
              if (node.source && node.source.input.map) {
                let map4 = node.source.input.map;
                if (!this.previousMaps.includes(map4)) {
                  this.previousMaps.push(map4);
                }
              }
            });
          } else {
            let input = new Input(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node) => {
            if (node.source) {
              let from = node.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from);
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      toBase64(str2) {
        if (Buffer) {
          return Buffer.from(str2).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str2)));
        }
      }
      toFileUrl(path) {
        let cached = this.memoizedFileURLs.get(path);
        if (cached)
          return cached;
        if (pathToFileURL) {
          let fileURL = pathToFileURL(path).toString();
          this.memoizedFileURLs.set(path, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path) {
        let cached = this.memoizedURLs.get(path);
        if (cached)
          return cached;
        if (sep === "\\") {
          path = path.replace(/\\/g, "/");
        }
        let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path, url);
        return url;
      }
    };
    module.exports = MapGenerator;
  }
});

// ../../node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "../../node_modules/postcss/lib/comment.js"(exports, module) {
    "use strict";
    var Node2 = require_node2();
    var Comment = class extends Node2 {
      constructor(defaults) {
        super(defaults);
        this.type = "comment";
      }
    };
    module.exports = Comment;
    Comment.default = Comment;
  }
});

// ../../node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "../../node_modules/postcss/lib/container.js"(exports, module) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment = require_comment();
    var Node2 = require_node2();
    var parse4;
    var Rule;
    var AtRule;
    var Root;
    function cleanSource(nodes) {
      return nodes.map((i5) => {
        if (i5.nodes)
          i5.nodes = cleanSource(i5.nodes);
        delete i5.source;
        return i5;
      });
    }
    function markDirtyUp(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i5 of node.proxyOf.nodes) {
          markDirtyUp(i5);
        }
      }
    }
    var Container = class extends Node2 {
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result2;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result2 = callback(this.proxyOf.nodes[index2], index2);
          if (result2 === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result2;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](
                  ...args.map((i5) => {
                    if (typeof i5 === "function") {
                      return (child, index2) => i5(child.toProxy(), index2);
                    } else {
                      return i5;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb2) => {
                return node[prop](
                  (child, ...other) => cb2(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i5) => i5.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type2 = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type2).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample2) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse4(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i5) => {
          if (!i5[my])
            Container.rebuild(i5);
          i5 = i5.proxyOf;
          if (i5.parent)
            i5.parent.removeChild(i5);
          if (i5[isClean])
            markDirtyUp(i5);
          if (typeof i5.raws.before === "undefined") {
            if (sample2 && typeof sample2.raws.before !== "undefined") {
              i5.raws.before = sample2.raws.before.replace(/\S/g, "");
            }
          }
          i5.parent = this.proxyOf;
          return i5;
        });
        return processed;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i5) => {
          let result2;
          try {
            result2 = callback(child, i5);
          } catch (e4) {
            throw child.addToError(e4);
          }
          if (result2 !== false && child.walk) {
            result2 = child.walk(callback);
          }
          return result2;
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i5) => {
            if (child.type === "atrule") {
              return callback(child, i5);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i5);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i5) => {
          if (child.type === "comment") {
            return callback(child, i5);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i5) => {
            if (child.type === "decl") {
              return callback(child, i5);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i5);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i5) => {
            if (child.type === "rule") {
              return callback(child, i5);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i5);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container.registerParse = (dependant) => {
      parse4 = dependant;
    };
    Container.registerRule = (dependant) => {
      Rule = dependant;
    };
    Container.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    Container.registerRoot = (dependant) => {
      Root = dependant;
    };
    module.exports = Container;
    Container.default = Container;
    Container.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment.prototype);
      } else if (node.type === "root") {
        Object.setPrototypeOf(node, Root.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container.rebuild(child);
        });
      }
    };
  }
});

// ../../node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "../../node_modules/postcss/lib/document.js"(exports, module) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Document2 = class extends Container {
      constructor(defaults) {
        super({ type: "document", ...defaults });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module.exports = Document2;
    Document2.default = Document2;
  }
});

// ../../node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "../../node_modules/postcss/lib/warn-once.js"(exports, module) {
    "use strict";
    var printed = {};
    module.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// ../../node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "../../node_modules/postcss/lib/warning.js"(exports, module) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range2 = opts.node.rangeBy(opts);
          this.line = range2.start.line;
          this.column = range2.start.column;
          this.endLine = range2.end.line;
          this.endColumn = range2.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module.exports = Warning;
    Warning.default = Warning;
  }
});

// ../../node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "../../node_modules/postcss/lib/result.js"(exports, module) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root2, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root2;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i5) => i5.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module.exports = Result;
    Result.default = Result;
  }
});

// ../../node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "../../node_modules/postcss/lib/tokenize.js"(exports, module) {
    "use strict";
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module.exports = function tokenizer(input, options = {}) {
      let css = input.css.valueOf();
      let ignore = options.ignoreErrors;
      let code3, next, quote, content, escape2;
      let escaped, escapePos, prev, n4, currentToken;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code3 = css.charCodeAt(pos);
        switch (code3) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code3 = css.charCodeAt(next);
            } while (code3 === SPACE || code3 === NEWLINE || code3 === TAB || code3 === CR || code3 === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code3);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n4 = css.charCodeAt(pos + 1);
            if (prev === "url" && n4 !== SINGLE_QUOTE && n4 !== DOUBLE_QUOTE && n4 !== SPACE && n4 !== NEWLINE && n4 !== TAB && n4 !== FEED && n4 !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code3 === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape2 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code3 = css.charCodeAt(next + 1);
            if (escape2 && code3 !== SLASH && code3 !== SPACE && code3 !== NEWLINE && code3 !== TAB && code3 !== CR && code3 !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code3 === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position
      };
    };
  }
});

// ../../node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "../../node_modules/postcss/lib/at-rule.js"(exports, module) {
    "use strict";
    var Container = require_container();
    var AtRule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module.exports = AtRule;
    AtRule.default = AtRule;
    Container.registerAtRule(AtRule);
  }
});

// ../../node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "../../node_modules/postcss/lib/root.js"(exports, module) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Root = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample2, type2) {
        let nodes = super.normalize(child);
        if (sample2) {
          if (type2 === "prepend") {
            if (this.nodes.length > 1) {
              sample2.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample2.raws.before;
            }
          } else if (this.first !== sample2) {
            for (let node of nodes) {
              node.raws.before = sample2.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module.exports = Root;
    Root.default = Root;
    Container.registerRoot(Root);
  }
});

// ../../node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "../../node_modules/postcss/lib/list.js"(exports, module) {
    "use strict";
    var list = {
      comma(string) {
        return list.split(string, [","], true);
      },
      space(string) {
        let spaces = [" ", "\n", "	"];
        return list.split(string, spaces);
      },
      split(string, separators, last2) {
        let array = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape2 = false;
        for (let letter of string) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last2 || current !== "")
          array.push(current.trim());
        return array;
      }
    };
    module.exports = list;
    list.default = list;
  }
});

// ../../node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "../../node_modules/postcss/lib/rule.js"(exports, module) {
    "use strict";
    var Container = require_container();
    var list = require_list();
    var Rule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list.comma(this.selector);
      }
      set selectors(values2) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values2.join(sep);
      }
    };
    module.exports = Rule;
    Rule.default = Rule;
    Container.registerRule(Rule);
  }
});

// ../../node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/postcss/lib/parser.js"(exports, module) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer = require_tokenize();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root();
    var Rule = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
        let token = tokens[i5];
        let pos = token[3] || token[2];
        if (pos)
          return pos;
      }
    }
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node = new AtRule();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type2;
        let prev;
        let shift2;
        let last2 = false;
        let open = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type2 = token[0];
          if (type2 === "(" || type2 === "[") {
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (type2 === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type2 === ";") {
              node.source.end = this.getPosition(token[2]);
              node.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type2 === "{") {
              open = true;
              break;
            } else if (type2 === "}") {
              if (params.length > 0) {
                shift2 = params.length - 1;
                prev = params[shift2];
                while (prev && prev[0] === "space") {
                  prev = params[--shift2];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                  node.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last2 = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last2) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            node.source.end.offset++;
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token = tokens[j2];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let token, type2, prev;
        for (let [i5, element2] of tokens.entries()) {
          token = element2;
          type2 = token[0];
          if (type2 === "(") {
            brackets += 1;
          }
          if (type2 === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type2 === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i5;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node = new Comment();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      decl(tokens, customProperty) {
        let node = new Declaration();
        this.init(node, tokens[0][2]);
        let last2 = tokens[tokens.length - 1];
        if (last2[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(
          last2[3] || last2[2] || findLastWithPosition(tokens)
        );
        node.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type2 = tokens[0][0];
          if (type2 === ":" || type2 === "space" || type2 === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
          token = tokens[i5];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string = this.stringFrom(tokens, i5);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node.raws.important = string;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str2 = "";
            for (let j2 = i5; j2 > 0; j2--) {
              let type2 = cache2[j2][0];
              if (str2.trim().indexOf("!") === 0 && type2 !== "space") {
                break;
              }
              str2 = cache2.pop()[1] + str2;
            }
            if (str2.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str2;
              tokens = cache2;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i5) => i5[0] !== "space" && i5[0] !== "comment");
        if (hasWord) {
          node.raws.between += firstSpaces.map((i5) => i5[1]).join("");
          firstSpaces = [];
        }
        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node = new Rule();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset2) {
        let pos = this.input.fromOffset(offset2);
        return {
          column: pos.col,
          line: pos.line,
          offset: offset2
        };
      }
      init(node, offset2) {
        this.current.push(node);
        node.source = {
          input: this.input,
          start: this.getPosition(offset2)
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type2 = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type2 = token[0];
          tokens.push(token);
          if (type2 === "(" || type2 === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (customProperty && colon && type2 === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type2 === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type2 === "{") {
              this.rule(tokens);
              return;
            } else if (type2 === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type2 === ":") {
              colon = true;
            }
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node, prop, tokens, customProperty) {
        let token, type2;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        for (let i5 = 0; i5 < length; i5 += 1) {
          token = tokens[i5];
          type2 = token[0];
          if (type2 === "space" && i5 === length - 1 && !customProperty) {
            clean = false;
          } else if (type2 === "comment") {
            prev = tokens[i5 - 1] ? tokens[i5 - 1][0] : "empty";
            next = tokens[i5 + 1] ? tokens[i5 + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ",") {
                clean = false;
              } else {
                value += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i5) => all + i5[1], "");
          node.raws[prop] = { raw, value };
        }
        node[prop] = value;
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result2 = "";
        for (let i5 = from; i5 < tokens.length; i5++) {
          result2 += tokens[i5][1];
        }
        tokens.splice(from, tokens.length - from);
        return result2;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module.exports = Parser;
  }
});

// ../../node_modules/postcss/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/postcss/lib/parse.js"(exports, module) {
    "use strict";
    var Container = require_container();
    var Parser = require_parser();
    var Input = require_input();
    function parse4(css, opts) {
      let input = new Input(css, opts);
      let parser = new Parser(input);
      try {
        parser.parse();
      } catch (e4) {
        if (true) {
          if (e4.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e4;
      }
      return parser.root;
    }
    module.exports = parse4;
    parse4.default = parse4;
    Container.registerParse(parse4);
  }
});

// ../../node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "../../node_modules/postcss/lib/lazy-result.js"(exports, module) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify = require_stringify2();
    var Container = require_container();
    var Document2 = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse4 = require_parse2();
    var Root = require_root();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node) {
      let key = false;
      let type2 = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key = node.name.toLowerCase();
      }
      if (key && node.append) {
        return [
          type2,
          type2 + "-" + key,
          CHILDREN,
          type2 + "Exit",
          type2 + "Exit-" + key
        ];
      } else if (key) {
        return [type2, type2 + "-" + key, type2 + "Exit", type2 + "Exit-" + key];
      } else if (node.append) {
        return [type2, CHILDREN, type2 + "Exit"];
      } else {
        return [type2, type2 + "Exit"];
      }
    }
    function toStack(node) {
      let events2;
      if (node.type === "document") {
        events2 = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events2 = ["Root", CHILDREN, "RootExit"];
      } else {
        events2 = getEvents(node);
      }
      return {
        eventIndex: 0,
        events: events2,
        iterator: 0,
        node,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i5) => cleanMarks(i5));
      return node;
    }
    var postcss = {};
    var LazyResult = class {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root2;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root2 = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof Result) {
          root2 = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser = parse4;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root2 = parser(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root2 && !root2[my]) {
            Container.rebuild(root2);
          }
        }
        this.result = new Result(processor, root2, opts);
        this.helpers = { ...postcss, postcss, result: this.result };
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return { ...plugin, ...plugin.prepare(this.result) };
          } else {
            return plugin;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin.postcssPlugin;
            error.setMessage();
          } else if (plugin.postcssVersion) {
            if (true) {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a4 = pluginVer.split(".");
              let b4 = runtimeVer.split(".");
              if (a4[0] !== b4[0] || parseInt(a4[1]) > parseInt(b4[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type2, cb2) => {
          if (!this.listeners[type2])
            this.listeners[type2] = [];
          this.listeners[type2].push([plugin, cb2]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter2 in plugin[event]) {
                    if (filter2 === "*") {
                      add(plugin, event, plugin[event][filter2]);
                    } else {
                      add(
                        plugin,
                        event + "-" + filter2.toLowerCase(),
                        plugin[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i5 = 0; i5 < this.plugins.length; i5++) {
          let plugin = this.plugins[i5];
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            let stack = [toStack(root2)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e4) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e4, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root2.type === "document") {
                  let roots = root2.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root2, this.helpers);
                }
              } catch (e4) {
                throw this.handleError(e4);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root2) => plugin.Once(root2, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str2 = stringify;
        if (opts.syntax)
          str2 = opts.syntax.stringify;
        if (opts.stringifier)
          str2 = opts.stringifier;
        if (str2.stringify)
          str2 = str2.stringify;
        let map4 = new MapGenerator(str2, this.result.root, this.result.opts);
        let data = map4.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            this.walkSync(root2);
          }
          if (this.listeners.OnceExit) {
            if (root2.type === "document") {
              for (let subRoot of root2.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root2);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events2 = visit.events;
        while (visit.eventIndex < events2.length) {
          let event = events2[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node) {
        node[isClean] = true;
        let events2 = getEvents(node);
        for (let event of events2) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss = dependant;
    };
    module.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// ../../node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "../../node_modules/postcss/lib/no-work-result.js"(exports, module) {
    "use strict";
    var MapGenerator = require_map_generator();
    var stringify = require_stringify2();
    var warnOnce = require_warn_once();
    var parse4 = require_parse2();
    var Result = require_result();
    var NoWorkResult = class {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root2;
        let str2 = stringify;
        this.result = new Result(this._processor, root2, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map4 = new MapGenerator(str2, root2, this._opts, css);
        if (map4.isMap()) {
          let [generatedCSS, generatedMap] = map4.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map4.clearAnnotation();
          this.result.css = map4.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root2;
        let parser = parse4;
        try {
          root2 = parser(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root2;
          return root2;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// ../../node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "../../node_modules/postcss/lib/processor.js"(exports, module) {
    "use strict";
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document2 = require_document();
    var Root = require_root();
    var Processor = class {
      constructor(plugins = []) {
        this.version = "8.4.38";
        this.plugins = this.normalize(plugins);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i5 of plugins) {
          if (i5.postcss === true) {
            i5 = i5();
          } else if (i5.postcss) {
            i5 = i5.postcss;
          }
          if (typeof i5 === "object" && Array.isArray(i5.plugins)) {
            normalized = normalized.concat(i5.plugins);
          } else if (typeof i5 === "object" && i5.postcssPlugin) {
            normalized.push(i5);
          } else if (typeof i5 === "function") {
            normalized.push(i5);
          } else if (typeof i5 === "object" && (i5.parse || i5.stringify)) {
            if (true) {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i5 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
    };
    module.exports = Processor;
    Processor.default = Processor;
    Root.registerProcessor(Processor);
    Document2.registerProcessor(Processor);
  }
});

// ../../node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "../../node_modules/postcss/lib/fromJSON.js"(exports, module) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root();
    var Rule = require_rule();
    function fromJSON(json2, inputs) {
      if (Array.isArray(json2))
        return json2.map((n4) => fromJSON(n4));
      let { inputs: ownInputs, ...defaults } = json2;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json2.nodes.map((n4) => fromJSON(n4, inputs));
      }
      if (defaults.source) {
        let { inputId, ...source } = defaults.source;
        defaults.source = source;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === "root") {
        return new Root(defaults);
      } else if (defaults.type === "decl") {
        return new Declaration(defaults);
      } else if (defaults.type === "rule") {
        return new Rule(defaults);
      } else if (defaults.type === "comment") {
        return new Comment(defaults);
      } else if (defaults.type === "atrule") {
        return new AtRule(defaults);
      } else {
        throw new Error("Unknown node type: " + json2.type);
      }
    }
    module.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// ../../node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "../../node_modules/postcss/lib/postcss.js"(exports, module) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container = require_container();
    var Processor = require_processor();
    var stringify = require_stringify2();
    var fromJSON = require_fromJSON();
    var Document2 = require_document();
    var Warning = require_warning();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse4 = require_parse2();
    var list = require_list();
    var Rule = require_rule();
    var Root = require_root();
    var Node2 = require_node2();
    function postcss(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor(plugins);
    }
    postcss.plugin = function plugin(name, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (process.env.LANG && process.env.LANG.startsWith("cn")) {
            console.warn(
              name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator();
          return cache2;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss.stringify = stringify;
    postcss.parse = parse4;
    postcss.fromJSON = fromJSON;
    postcss.list = list;
    postcss.comment = (defaults) => new Comment(defaults);
    postcss.atRule = (defaults) => new AtRule(defaults);
    postcss.decl = (defaults) => new Declaration(defaults);
    postcss.rule = (defaults) => new Rule(defaults);
    postcss.root = (defaults) => new Root(defaults);
    postcss.document = (defaults) => new Document2(defaults);
    postcss.CssSyntaxError = CssSyntaxError;
    postcss.Declaration = Declaration;
    postcss.Container = Container;
    postcss.Processor = Processor;
    postcss.Document = Document2;
    postcss.Comment = Comment;
    postcss.Warning = Warning;
    postcss.AtRule = AtRule;
    postcss.Result = Result;
    postcss.Input = Input;
    postcss.Rule = Rule;
    postcss.Root = Root;
    postcss.Node = Node2;
    LazyResult.registerPostcss(postcss);
    module.exports = postcss;
    postcss.default = postcss;
  }
});

// ../../node_modules/@jupyterlab/apputils/node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS({
  "../../node_modules/@jupyterlab/apputils/node_modules/sanitize-html/index.js"(exports, module) {
    var htmlparser = require_lib9();
    var escapeStringRegexp = require_escape_string_regexp();
    var { isPlainObject } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each3(obj, cb2) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          cb2(obj[key], key);
        });
      }
    }
    function has3(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function filter2(a4, cb2) {
      const n4 = [];
      each3(a4, function(v2) {
        if (cb2(v2)) {
          n4.push(v2);
        }
      });
      return n4;
    }
    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has3(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html, options, _recursing) {
      if (html == null) {
        return "";
      }
      let result2 = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result2.length;
        this.text = "";
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);
      vulnerableTags.forEach(function(tag) {
        if (options.allowedTags !== false && (options.allowedTags || []).indexOf(tag) > -1 && !options.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each3(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each3(options.allowedClasses, function(classes, tag) {
        if (allowedAttributesMap) {
          if (!has3(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = [];
        allowedClassesRegexMap[tag] = [];
        const globRegex = [];
        classes.forEach(function(obj) {
          if (typeof obj === "string" && obj.indexOf("*") >= 0) {
            globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
          } else if (obj instanceof RegExp) {
            allowedClassesRegexMap[tag].push(obj);
          } else {
            allowedClassesMap[tag].push(obj);
          }
        });
        if (globRegex.length) {
          allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each3(options.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === "function") {
          transFun = transform;
        } else if (typeof transform === "string") {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name, attribs) {
          if (options.enforceHtmlBoundary && name === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has3(transformTagsMap, name)) {
            transformedTag = transformTagsMap[name](name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (options.allowedTags !== false && (options.allowedTags || []).indexOf(name) === -1 || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === "discard") {
              if (nonTextTagsArray.indexOf(name) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === "discard") {
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          result2 += "<" + name;
          if (name === "script") {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          if (!allowedAttributesMap || has3(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
            each3(attribs, function(value, a4) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a4)) {
                delete frame.attribs[a4];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has3(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a4) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a4) !== -1 || has3(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a4) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a4)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                for (const o10 of allowedAttributesMap[name]) {
                  if (isPlainObject(o10) && o10.name && o10.name === a4) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o10.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s7 of splitStrArray) {
                        if (o10.values.indexOf(s7) !== -1) {
                          if (newValue === "") {
                            newValue = s7;
                          } else {
                            newValue += " " + s7;
                          }
                        }
                      }
                    } else if (o10.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a4) !== -1) {
                  if (naughtyHref(name, value)) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name === "script" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name === "iframe" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has3(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter2(parsed, function(v2) {
                      return !v2.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a4];
                      return;
                    } else {
                      value = stringifySrcset(filter2(parsed, function(v2) {
                        return !v2.evil;
                      }));
                      frame.attribs[a4] = value;
                    }
                  } catch (e4) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex).filter(function(t10) {
                    return t10;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "style") {
                  try {
                    const abstractSyntaxTree = postcssParse(name + " {" + value + "}");
                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                    value = stringifyStyleAttributes(filteredAST);
                    if (value.length === 0) {
                      delete frame.attribs[a4];
                      return;
                    }
                  } catch (e4) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                result2 += " " + a4;
                if (value && value.length) {
                  result2 += '="' + escapeHtml(value, true) + '"';
                }
              } else {
                delete frame.attribs[a4];
              }
            });
          }
          if (options.selfClosing.indexOf(name) !== -1) {
            result2 += " />";
          } else {
            result2 += ">";
            if (frame.innerText && !hasText && !options.textFilter) {
              result2 += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
            result2 += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options.textFilter && !addedText) {
              result2 += options.textFilter(escaped, tag);
            } else if (!addedText) {
              result2 += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name) {
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name) {
            stack.push(frame);
            return;
          }
          skipText = options.enforceHtmlBoundary ? name === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === "discard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          if (transformMap[depth]) {
            name = transformMap[depth];
            delete transformMap[depth];
          }
          if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
            result2 = result2.substr(0, frame.tagPosition);
            return;
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (options.selfClosing.indexOf(name) !== -1) {
            if (skip) {
              result2 = tempResult;
              tempResult = "";
            }
            return;
          }
          result2 += "</" + name + ">";
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html);
      parser.end();
      return result2;
      function initializeState() {
        result2 = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s7, quote) {
        if (typeof s7 !== "string") {
          s7 = s7 + "";
        }
        if (options.parser.decodeEntities) {
          s7 = s7.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s7 = s7.replace(/"/g, "&quot;");
          }
        }
        s7 = s7.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s7 = s7.replace(/"/g, "&quot;");
        }
        return s7;
      }
      function naughtyHref(name, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches) {
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches[1].toLowerCase();
        if (has3(options.allowedSchemesByTag, name)) {
          return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
        }
        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i5 = 0; i5 < 100; i5++) {
          base += `/${i5}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has3(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge2) {
      merge2 = merge2 === void 0 ? true : merge2;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge2) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/sanitizer.js
var import_sanitize_html, CssProp, Sanitizer;
var init_sanitizer = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/sanitizer.js"() {
    import_sanitize_html = __toESM(require_sanitize_html());
    CssProp = class {
      static reg(r4) {
        return new RegExp("^" + r4 + "$", "i");
      }
    };
    CssProp.N = {
      integer: `[+-]?[0-9]+`,
      integer_pos: `[+]?[0-9]+`,
      integer_zero_ff: `([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])`,
      number: `[+-]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
      number_pos: `[+]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
      number_zero_hundred: `[+]?(([0-9]|[1-9][0-9])([.][0-9]+)?|100)`,
      number_zero_one: `[+]?(1([.][0]+)?|0?([.][0-9]+)?)`
    };
    CssProp.B = {
      angle: `(${CssProp.N.number}(deg|rad|grad|turn)|0)`,
      frequency: `${CssProp.N.number}(Hz|kHz)`,
      ident: String.raw`-?([_a-z]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*`,
      len_or_perc: `(0|${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc|%))`,
      length: `(${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
      length_pos: `(${CssProp.N.number_pos}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
      percentage: `${CssProp.N.number}%`,
      percentage_pos: `${CssProp.N.number_pos}%`,
      percentage_zero_hundred: `${CssProp.N.number_zero_hundred}%`,
      string: String.raw`(\"([^\n\r\f\\"]|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\")|(\'([^\n\r\f\\']|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\')`,
      time: `${CssProp.N.number}(s|ms)`,
      url: `url\\(.*?\\)`,
      z_index: `[+-]?[0-9]{1,7}`
    };
    CssProp.A = {
      absolute_size: `xx-small|x-small|small|medium|large|x-large|xx-large`,
      attachment: `scroll|fixed|local`,
      bg_origin: `border-box|padding-box|content-box`,
      border_style: `none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset`,
      box: `border-box|padding-box|content-box`,
      display_inside: `auto|block|table|flex|grid`,
      display_outside: `block-level|inline-level|none|table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption`,
      ending_shape: `circle|ellipse`,
      generic_family: `serif|sans-serif|cursive|fantasy|monospace`,
      generic_voice: `male|female|child`,
      relative_size: `smaller|larger`,
      repeat_style: `repeat-x|repeat-y|((?:repeat|space|round|no-repeat)(?:\\s*(?:repeat|space|round|no-repeat))?)`,
      side_or_corner: `(left|right)?\\s*(top|bottom)?`,
      single_animation_direction: `normal|reverse|alternate|alternate-reverse`,
      single_animation_fill_mode: `none|forwards|backwards|both`,
      single_animation_play_state: `running|paused`
    };
    CssProp._COLOR = {
      hex: `\\#(0x)?[0-9a-f]+`,
      name: `aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|transparent|violet|wheat|white|whitesmoke|yellow|yellowgreen`,
      rgb: String.raw`rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)`,
      rgba: String.raw`rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred})\s*\)`
    };
    CssProp._C = {
      alpha: `${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred}`,
      alphavalue: CssProp.N.number_zero_one,
      bg_position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
      bg_size: `(${CssProp.B.length_pos}|${CssProp.B.percentage}|auto){1,2}|cover|contain`,
      border_width: `thin|medium|thick|${CssProp.B.length}`,
      bottom: `${CssProp.B.length}|auto`,
      color: `${CssProp._COLOR.hex}|${CssProp._COLOR.rgb}|${CssProp._COLOR.rgba}|${CssProp._COLOR.name}`,
      color_stop_length: `(${CssProp.B.len_or_perc}\\s*){1,2}`,
      linear_color_hint: `${CssProp.B.len_or_perc}`,
      family_name: `${CssProp.B.string}|(${CssProp.B.ident}\\s*)+`,
      image_decl: CssProp.B.url,
      left: `${CssProp.B.length}|auto`,
      loose_quotable_words: `(${CssProp.B.ident})+`,
      margin_width: `${CssProp.B.len_or_perc}|auto`,
      padding_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      page_url: CssProp.B.url,
      position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
      right: `${CssProp.B.length}|auto`,
      shadow: "",
      size: `closest-side|farthest-side|closest-corner|farthest-corner|${CssProp.B.length}|(${CssProp.B.len_or_perc})\\s+(${CssProp.B.len_or_perc})`,
      top: `${CssProp.B.length}|auto`
    };
    CssProp._C1 = {
      image_list: `image\\(\\s*(${CssProp.B.url})*\\s*(${CssProp.B.url}|${CssProp._C.color})\\s*\\)`,
      linear_color_stop: `(${CssProp._C.color})(\\s*${CssProp._C.color_stop_length})?`,
      shadow: `((${CssProp._C.color})\\s+((${CssProp.B.length})\\s*){2,4}(s+inset)?)|((inset\\s+)?((${CssProp.B.length})\\s*){2,4}\\s*(${CssProp._C.color})?)`
    };
    CssProp._C2 = {
      color_stop_list: `((${CssProp._C1.linear_color_stop})(\\s*(${CssProp._C.linear_color_hint}))?\\s*,\\s*)+(${CssProp._C1.linear_color_stop})`,
      shape: `rect\\(\\s*(${CssProp._C.top})\\s*,\\s*(${CssProp._C.right})\\s*,\\s*(${CssProp._C.bottom})\\s*,\\s*(${CssProp._C.left})\\s*\\)`
    };
    CssProp._C3 = {
      linear_gradient: `linear-gradient\\((((${CssProp.B.angle})|to\\s+(${CssProp.A.side_or_corner}))\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`,
      radial_gradient: `radial-gradient\\(((((${CssProp.A.ending_shape})|(${CssProp._C.size}))\\s*)*\\s*(at\\s+${CssProp._C.position})?\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`
    };
    CssProp._C4 = {
      image: `${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list}`,
      bg_image: `(${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list})|none`
    };
    CssProp.C = {
      ...CssProp._C,
      ...CssProp._C1,
      ...CssProp._C2,
      ...CssProp._C3,
      ...CssProp._C4
    };
    CssProp.AP = {
      border_collapse: `collapse|separate`,
      box: `normal|none|contents`,
      box_sizing: `content-box|padding-box|border-box`,
      caption_side: `top|bottom`,
      clear: `none|left|right|both`,
      direction: `ltr|rtl`,
      empty_cells: `show|hide`,
      float: `left|right|none`,
      font_stretch: `normal|wider|narrower|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded`,
      font_style: `normal|italic|oblique`,
      font_variant: `normal|small-caps`,
      font_weight: `normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900`,
      list_style_position: `inside|outside`,
      list_style_type: `disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-latin|upper-latin|armenian|georgian|lower-alpha|upper-alpha|none`,
      overflow: `visible|hidden|scroll|auto`,
      overflow_wrap: `normal|break-word`,
      overflow_x: `visible|hidden|scroll|auto|no-display|no-content`,
      page_break_after: `auto|always|avoid|left|right`,
      page_break_before: `auto|always|avoid|left|right`,
      page_break_inside: `avoid|auto`,
      position: `static|relative|absolute`,
      resize: `none|both|horizontal|vertical`,
      speak: `normal|none|spell-out`,
      speak_header: `once|always`,
      speak_numeral: `digits|continuous`,
      speak_punctuation: `code|none`,
      table_layout: `auto|fixed`,
      text_align: `left|right|center|justify`,
      text_decoration: `none|((underline|overline|line-through|blink)\\s*)+`,
      text_transform: `capitalize|uppercase|lowercase|none`,
      text_wrap: `normal|unrestricted|none|suppress`,
      unicode_bidi: `normal|embed|bidi-override`,
      visibility: `visible|hidden|collapse`,
      white_space: `normal|pre|nowrap|pre-wrap|pre-line`,
      word_break: `normal|keep-all|break-all`
    };
    CssProp._CP = {
      background_attachment: `${CssProp.A.attachment}(,\\s*${CssProp.A.attachment})*`,
      background_color: CssProp.C.color,
      background_origin: `${CssProp.A.box}(,\\s*${CssProp.A.box})*`,
      background_repeat: `${CssProp.A.repeat_style}(,\\s*${CssProp.A.repeat_style})*`,
      border: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      border_radius: `((${CssProp.B.len_or_perc})\\s*){1,4}(\\/\\s*((${CssProp.B.len_or_perc})\\s*){1,4})?`,
      border_spacing: `${CssProp.B.length}\\s*(${CssProp.B.length})?`,
      border_top_color: CssProp.C.color,
      border_top_style: CssProp.A.border_style,
      border_width: `((${CssProp.C.border_width})\\s*){1,4}`,
      color: CssProp.C.color,
      cursor: `(${CssProp.B.url}(\\s*,\\s*)?)*(auto|crosshair|default|pointer|move|e-resize|ne-resize|nw-resize|n-resize|se-resize|sw-resize|s-resize|w-resize|text|wait|help|progress|all-scroll|col-resize|hand|no-drop|not-allowed|row-resize|vertical-text)`,
      display: `inline|block|list-item|run-in|inline-list-item|inline-block|table|inline-table|table-cell|table-caption|flex|inline-flex|grid|inline-grid|${CssProp.A.display_inside}|${CssProp.A.display_outside}|inherit|inline-box|inline-stack`,
      display_outside: CssProp.A.display_outside,
      elevation: `${CssProp.B.angle}|below|level|above|higher|lower`,
      font_family: `(${CssProp.C.family_name}|${CssProp.A.generic_family})(,\\s*(${CssProp.C.family_name}|${CssProp.A.generic_family}))*`,
      height: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      letter_spacing: `normal|${CssProp.B.length}`,
      list_style_image: `${CssProp.C.image}|none`,
      margin_right: CssProp.C.margin_width,
      max_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
      min_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
      opacity: CssProp.C.alphavalue,
      outline_color: `${CssProp.C.color}|invert`,
      outline_width: CssProp.C.border_width,
      padding: `((${CssProp.C.padding_width})\\s*){1,4}`,
      padding_top: CssProp.C.padding_width,
      pitch_range: CssProp.N.number,
      right: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      stress: CssProp.N.number,
      text_indent: `${CssProp.B.length}|${CssProp.B.percentage}`,
      text_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
      volume: `${CssProp.N.number_pos}|${CssProp.B.percentage_pos}|silent|x-soft|soft|medium|loud|x-loud`,
      word_wrap: CssProp.AP.overflow_wrap,
      zoom: `normal|${CssProp.N.number_pos}|${CssProp.B.percentage_pos}`,
      backface_visibility: CssProp.AP.visibility,
      background_clip: `${CssProp.A.box}(,\\s*(${CssProp.A.box}))*`,
      background_position: `${CssProp.C.bg_position}(,\\s*(${CssProp.C.bg_position}))*`,
      border_bottom_color: CssProp.C.color,
      border_bottom_style: CssProp.A.border_style,
      border_color: `((${CssProp.C.color})\\s*){1,4}`,
      border_left_color: CssProp.C.color,
      border_right_color: CssProp.C.color,
      border_style: `((${CssProp.A.border_style})\\s*){1,4}`,
      border_top_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_top_width: CssProp.C.border_width,
      box_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
      clip: `${CssProp.C.shape}|auto`,
      display_inside: CssProp.A.display_inside,
      font_size: `${CssProp.A.absolute_size}|${CssProp.A.relative_size}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      line_height: `normal|${CssProp.N.number_pos}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
      margin_left: CssProp.C.margin_width,
      max_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
      outline_style: CssProp.A.border_style,
      padding_bottom: CssProp.C.padding_width,
      padding_right: CssProp.C.padding_width,
      perspective: `none|${CssProp.B.length}`,
      richness: CssProp.N.number,
      text_overflow: `((clip|ellipsis|${CssProp.B.string})\\s*){1,2}`,
      top: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
      width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
      z_index: `auto|${CssProp.B.z_index}`,
      // Simplified background
      background: `(((${CssProp.C.bg_position}\\s*(\\/\\s*${CssProp.C.bg_size})?)|(${CssProp.A.repeat_style})|(${CssProp.A.attachment})|(${CssProp.A.bg_origin})|(${CssProp.C.bg_image})|(${CssProp.C.color}))\\s*)+`,
      background_size: `${CssProp.C.bg_size}(,\\s*${CssProp.C.bg_size})*`,
      border_bottom_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_bottom_width: CssProp.C.border_width,
      border_left_style: CssProp.A.border_style,
      border_right_style: CssProp.A.border_style,
      border_top: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      bottom: `${CssProp.B.len_or_perc}|auto`,
      list_style: `((${CssProp.AP.list_style_type}|${CssProp.AP.list_style_position}|${CssProp.C.image}|none})\\s*){1,3}`,
      margin_top: CssProp.C.margin_width,
      outline: `((${CssProp.C.color}|invert|${CssProp.A.border_style}|${CssProp.C.border_width})\\s*){1,3}`,
      overflow_y: CssProp.AP.overflow_x,
      pitch: `${CssProp.B.frequency}|x-low|low|medium|high|x-high`,
      vertical_align: `baseline|sub|super|top|text-top|middle|bottom|text-bottom|${CssProp.B.len_or_perc}`,
      word_spacing: `normal|${CssProp.B.length}`,
      background_image: `${CssProp.C.bg_image}(,\\s*${CssProp.C.bg_image})*`,
      border_bottom_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      border_left_width: CssProp.C.border_width,
      border_right_width: CssProp.C.border_width,
      left: `${CssProp.B.len_or_perc}|auto`,
      margin_bottom: CssProp.C.margin_width,
      pause_after: `${CssProp.B.time}|${CssProp.B.percentage}`,
      speech_rate: `${CssProp.N.number}|x-slow|slow|medium|fast|x-fast|faster|slower`,
      transition_duration: `${CssProp.B.time}(,\\s*${CssProp.B.time})*`,
      border_bottom: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      border_right: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      margin: `((${CssProp.C.margin_width})\\s*){1,4}`,
      padding_left: CssProp.C.padding_width,
      border_left: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
      quotes: `(${CssProp.B.string}\\s*${CssProp.B.string})+|none`,
      border_top_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
      min_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`
    };
    CssProp._CP1 = {
      font: `(((((${CssProp.AP.font_style}|${CssProp.AP.font_variant}|${CssProp.AP.font_weight})\\s*){1,3})?\\s*(${CssProp._CP.font_size})\\s*(\\/\\s*(${CssProp._CP.line_height}))?\\s+(${CssProp._CP.font_family}))|caption|icon|menu|message-box|small-caption|status-bar)`
    };
    CssProp.CP = { ...CssProp._CP, ...CssProp._CP1 };
    CssProp.BORDER_COLLAPSE = CssProp.reg(CssProp.AP.border_collapse);
    CssProp.BOX = CssProp.reg(CssProp.AP.box);
    CssProp.BOX_SIZING = CssProp.reg(CssProp.AP.box_sizing);
    CssProp.CAPTION_SIDE = CssProp.reg(CssProp.AP.caption_side);
    CssProp.CLEAR = CssProp.reg(CssProp.AP.clear);
    CssProp.DIRECTION = CssProp.reg(CssProp.AP.direction);
    CssProp.EMPTY_CELLS = CssProp.reg(CssProp.AP.empty_cells);
    CssProp.FLOAT = CssProp.reg(CssProp.AP.float);
    CssProp.FONT_STRETCH = CssProp.reg(CssProp.AP.font_stretch);
    CssProp.FONT_STYLE = CssProp.reg(CssProp.AP.font_style);
    CssProp.FONT_VARIANT = CssProp.reg(CssProp.AP.font_variant);
    CssProp.FONT_WEIGHT = CssProp.reg(CssProp.AP.font_weight);
    CssProp.LIST_STYLE_POSITION = CssProp.reg(CssProp.AP.list_style_position);
    CssProp.LIST_STYLE_TYPE = CssProp.reg(CssProp.AP.list_style_type);
    CssProp.OVERFLOW = CssProp.reg(CssProp.AP.overflow);
    CssProp.OVERFLOW_WRAP = CssProp.reg(CssProp.AP.overflow_wrap);
    CssProp.OVERFLOW_X = CssProp.reg(CssProp.AP.overflow_x);
    CssProp.PAGE_BREAK_AFTER = CssProp.reg(CssProp.AP.page_break_after);
    CssProp.PAGE_BREAK_BEFORE = CssProp.reg(CssProp.AP.page_break_before);
    CssProp.PAGE_BREAK_INSIDE = CssProp.reg(CssProp.AP.page_break_inside);
    CssProp.POSITION = CssProp.reg(CssProp.AP.position);
    CssProp.RESIZE = CssProp.reg(CssProp.AP.resize);
    CssProp.SPEAK = CssProp.reg(CssProp.AP.speak);
    CssProp.SPEAK_HEADER = CssProp.reg(CssProp.AP.speak_header);
    CssProp.SPEAK_NUMERAL = CssProp.reg(CssProp.AP.speak_numeral);
    CssProp.SPEAK_PUNCTUATION = CssProp.reg(CssProp.AP.speak_punctuation);
    CssProp.TABLE_LAYOUT = CssProp.reg(CssProp.AP.table_layout);
    CssProp.TEXT_ALIGN = CssProp.reg(CssProp.AP.text_align);
    CssProp.TEXT_DECORATION = CssProp.reg(CssProp.AP.text_decoration);
    CssProp.TEXT_TRANSFORM = CssProp.reg(CssProp.AP.text_transform);
    CssProp.TEXT_WRAP = CssProp.reg(CssProp.AP.text_wrap);
    CssProp.UNICODE_BIDI = CssProp.reg(CssProp.AP.unicode_bidi);
    CssProp.VISIBILITY = CssProp.reg(CssProp.AP.visibility);
    CssProp.WHITE_SPACE = CssProp.reg(CssProp.AP.white_space);
    CssProp.WORD_BREAK = CssProp.reg(CssProp.AP.word_break);
    CssProp.BACKGROUND_ATTACHMENT = CssProp.reg(CssProp.CP.background_attachment);
    CssProp.BACKGROUND_COLOR = CssProp.reg(CssProp.CP.background_color);
    CssProp.BACKGROUND_ORIGIN = CssProp.reg(CssProp.CP.background_origin);
    CssProp.BACKGROUND_REPEAT = CssProp.reg(CssProp.CP.background_repeat);
    CssProp.BORDER = CssProp.reg(CssProp.CP.border);
    CssProp.BORDER_RADIUS = CssProp.reg(CssProp.CP.border_radius);
    CssProp.BORDER_SPACING = CssProp.reg(CssProp.CP.border_spacing);
    CssProp.BORDER_TOP_COLOR = CssProp.reg(CssProp.CP.border_top_color);
    CssProp.BORDER_TOP_STYLE = CssProp.reg(CssProp.CP.border_top_style);
    CssProp.BORDER_WIDTH = CssProp.reg(CssProp.CP.border_width);
    CssProp.COLOR = CssProp.reg(CssProp.CP.color);
    CssProp.CURSOR = CssProp.reg(CssProp.CP.cursor);
    CssProp.DISPLAY = CssProp.reg(CssProp.CP.display);
    CssProp.DISPLAY_OUTSIDE = CssProp.reg(CssProp.CP.display_outside);
    CssProp.ELEVATION = CssProp.reg(CssProp.CP.elevation);
    CssProp.FONT_FAMILY = CssProp.reg(CssProp.CP.font_family);
    CssProp.HEIGHT = CssProp.reg(CssProp.CP.height);
    CssProp.LETTER_SPACING = CssProp.reg(CssProp.CP.letter_spacing);
    CssProp.LIST_STYLE_IMAGE = CssProp.reg(CssProp.CP.list_style_image);
    CssProp.MARGIN_RIGHT = CssProp.reg(CssProp.CP.margin_right);
    CssProp.MAX_HEIGHT = CssProp.reg(CssProp.CP.max_height);
    CssProp.MIN_HEIGHT = CssProp.reg(CssProp.CP.min_height);
    CssProp.OPACITY = CssProp.reg(CssProp.CP.opacity);
    CssProp.OUTLINE_COLOR = CssProp.reg(CssProp.CP.outline_color);
    CssProp.OUTLINE_WIDTH = CssProp.reg(CssProp.CP.outline_width);
    CssProp.PADDING = CssProp.reg(CssProp.CP.padding);
    CssProp.PADDING_TOP = CssProp.reg(CssProp.CP.padding_top);
    CssProp.PITCH_RANGE = CssProp.reg(CssProp.CP.pitch_range);
    CssProp.RIGHT = CssProp.reg(CssProp.CP.right);
    CssProp.STRESS = CssProp.reg(CssProp.CP.stress);
    CssProp.TEXT_INDENT = CssProp.reg(CssProp.CP.text_indent);
    CssProp.TEXT_SHADOW = CssProp.reg(CssProp.CP.text_shadow);
    CssProp.VOLUME = CssProp.reg(CssProp.CP.volume);
    CssProp.WORD_WRAP = CssProp.reg(CssProp.CP.word_wrap);
    CssProp.ZOOM = CssProp.reg(CssProp.CP.zoom);
    CssProp.BACKFACE_VISIBILITY = CssProp.reg(CssProp.CP.backface_visibility);
    CssProp.BACKGROUND_CLIP = CssProp.reg(CssProp.CP.background_clip);
    CssProp.BACKGROUND_POSITION = CssProp.reg(CssProp.CP.background_position);
    CssProp.BORDER_BOTTOM_COLOR = CssProp.reg(CssProp.CP.border_bottom_color);
    CssProp.BORDER_BOTTOM_STYLE = CssProp.reg(CssProp.CP.border_bottom_style);
    CssProp.BORDER_COLOR = CssProp.reg(CssProp.CP.border_color);
    CssProp.BORDER_LEFT_COLOR = CssProp.reg(CssProp.CP.border_left_color);
    CssProp.BORDER_RIGHT_COLOR = CssProp.reg(CssProp.CP.border_right_color);
    CssProp.BORDER_STYLE = CssProp.reg(CssProp.CP.border_style);
    CssProp.BORDER_TOP_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_top_left_radius);
    CssProp.BORDER_TOP_WIDTH = CssProp.reg(CssProp.CP.border_top_width);
    CssProp.BOX_SHADOW = CssProp.reg(CssProp.CP.box_shadow);
    CssProp.CLIP = CssProp.reg(CssProp.CP.clip);
    CssProp.DISPLAY_INSIDE = CssProp.reg(CssProp.CP.display_inside);
    CssProp.FONT_SIZE = CssProp.reg(CssProp.CP.font_size);
    CssProp.LINE_HEIGHT = CssProp.reg(CssProp.CP.line_height);
    CssProp.MARGIN_LEFT = CssProp.reg(CssProp.CP.margin_left);
    CssProp.MAX_WIDTH = CssProp.reg(CssProp.CP.max_width);
    CssProp.OUTLINE_STYLE = CssProp.reg(CssProp.CP.outline_style);
    CssProp.PADDING_BOTTOM = CssProp.reg(CssProp.CP.padding_bottom);
    CssProp.PADDING_RIGHT = CssProp.reg(CssProp.CP.padding_right);
    CssProp.PERSPECTIVE = CssProp.reg(CssProp.CP.perspective);
    CssProp.RICHNESS = CssProp.reg(CssProp.CP.richness);
    CssProp.TEXT_OVERFLOW = CssProp.reg(CssProp.CP.text_overflow);
    CssProp.TOP = CssProp.reg(CssProp.CP.top);
    CssProp.WIDTH = CssProp.reg(CssProp.CP.width);
    CssProp.Z_INDEX = CssProp.reg(CssProp.CP.z_index);
    CssProp.BACKGROUND = CssProp.reg(CssProp.CP.background);
    CssProp.BACKGROUND_SIZE = CssProp.reg(CssProp.CP.background_size);
    CssProp.BORDER_BOTTOM_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_left_radius);
    CssProp.BORDER_BOTTOM_WIDTH = CssProp.reg(CssProp.CP.border_bottom_width);
    CssProp.BORDER_LEFT_STYLE = CssProp.reg(CssProp.CP.border_left_style);
    CssProp.BORDER_RIGHT_STYLE = CssProp.reg(CssProp.CP.border_right_style);
    CssProp.BORDER_TOP = CssProp.reg(CssProp.CP.border_top);
    CssProp.BOTTOM = CssProp.reg(CssProp.CP.bottom);
    CssProp.LIST_STYLE = CssProp.reg(CssProp.CP.list_style);
    CssProp.MARGIN_TOP = CssProp.reg(CssProp.CP.margin_top);
    CssProp.OUTLINE = CssProp.reg(CssProp.CP.outline);
    CssProp.OVERFLOW_Y = CssProp.reg(CssProp.CP.overflow_y);
    CssProp.PITCH = CssProp.reg(CssProp.CP.pitch);
    CssProp.VERTICAL_ALIGN = CssProp.reg(CssProp.CP.vertical_align);
    CssProp.WORD_SPACING = CssProp.reg(CssProp.CP.word_spacing);
    CssProp.BACKGROUND_IMAGE = CssProp.reg(CssProp.CP.background_image);
    CssProp.BORDER_BOTTOM_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_right_radius);
    CssProp.BORDER_LEFT_WIDTH = CssProp.reg(CssProp.CP.border_left_width);
    CssProp.BORDER_RIGHT_WIDTH = CssProp.reg(CssProp.CP.border_right_width);
    CssProp.LEFT = CssProp.reg(CssProp.CP.left);
    CssProp.MARGIN_BOTTOM = CssProp.reg(CssProp.CP.margin_bottom);
    CssProp.PAUSE_AFTER = CssProp.reg(CssProp.CP.pause_after);
    CssProp.SPEECH_RATE = CssProp.reg(CssProp.CP.speech_rate);
    CssProp.TRANSITION_DURATION = CssProp.reg(CssProp.CP.transition_duration);
    CssProp.BORDER_BOTTOM = CssProp.reg(CssProp.CP.border_bottom);
    CssProp.BORDER_RIGHT = CssProp.reg(CssProp.CP.border_right);
    CssProp.MARGIN = CssProp.reg(CssProp.CP.margin);
    CssProp.PADDING_LEFT = CssProp.reg(CssProp.CP.padding_left);
    CssProp.BORDER_LEFT = CssProp.reg(CssProp.CP.border_left);
    CssProp.FONT = CssProp.reg(CssProp.CP.font);
    CssProp.QUOTES = CssProp.reg(CssProp.CP.quotes);
    CssProp.BORDER_TOP_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_top_right_radius);
    CssProp.MIN_WIDTH = CssProp.reg(CssProp.CP.min_width);
    Sanitizer = class {
      constructor() {
        this._autolink = true;
        this._options = {
          // HTML tags that are allowed to be used. Tags were extracted from Google Caja
          allowedTags: [
            "a",
            "abbr",
            "acronym",
            "address",
            "area",
            "article",
            "aside",
            "audio",
            "b",
            "bdi",
            "bdo",
            "big",
            "blockquote",
            "br",
            "button",
            "canvas",
            "caption",
            "center",
            "cite",
            "code",
            "col",
            "colgroup",
            "colspan",
            "command",
            "data",
            "datalist",
            "dd",
            "del",
            "details",
            "dfn",
            "dir",
            "div",
            "dl",
            "dt",
            "em",
            "fieldset",
            "figcaption",
            "figure",
            "font",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "i",
            // 'iframe' is allowed by Google Caja, but disallowed by default by sanitize-html
            // , 'iframe'
            "img",
            "input",
            "ins",
            "kbd",
            "label",
            "legend",
            "li",
            "map",
            "mark",
            "menu",
            "meter",
            "nav",
            "nobr",
            "ol",
            "optgroup",
            "option",
            "output",
            "p",
            "pre",
            "progress",
            "q",
            "rowspan",
            "s",
            "samp",
            "section",
            "select",
            "small",
            "source",
            "span",
            "strike",
            "strong",
            "sub",
            "summary",
            "sup",
            "table",
            "tbody",
            "td",
            "textarea",
            "tfoot",
            "th",
            "thead",
            "time",
            "tr",
            "track",
            "tt",
            "u",
            "ul",
            "var",
            "video",
            "wbr"
          ],
          // Attributes that HTML tags are allowed to have, extracted from Google Caja.
          // See https://github.com/jupyterlab/jupyterlab/issues/1812#issuecomment-285848435
          allowedAttributes: {
            "*": [
              "class",
              "dir",
              "draggable",
              "hidden",
              "id",
              "inert",
              "itemprop",
              "itemref",
              "itemscope",
              "lang",
              "spellcheck",
              "style",
              "title",
              "translate"
            ],
            // 'rel' and 'target' were *not* allowed by Google Caja
            a: [
              "accesskey",
              "coords",
              "href",
              "hreflang",
              "name",
              "rel",
              "shape",
              "tabindex",
              "target",
              "type"
            ],
            area: [
              "accesskey",
              "alt",
              "coords",
              "href",
              "nohref",
              "shape",
              "tabindex"
            ],
            // 'autoplay' was *not* allowed by Google Caja
            audio: [
              "autoplay",
              "controls",
              "loop",
              "mediagroup",
              "muted",
              "preload",
              "src"
            ],
            bdo: ["dir"],
            blockquote: ["cite"],
            br: ["clear"],
            button: [
              "accesskey",
              "data-commandlinker-args",
              "data-commandlinker-command",
              "disabled",
              "name",
              "tabindex",
              "type",
              "value"
            ],
            canvas: ["height", "width"],
            caption: ["align"],
            col: ["align", "char", "charoff", "span", "valign", "width"],
            colgroup: ["align", "char", "charoff", "span", "valign", "width"],
            command: [
              "checked",
              "command",
              "disabled",
              "icon",
              "label",
              "radiogroup",
              "type"
            ],
            data: ["value"],
            del: ["cite", "datetime"],
            details: ["open"],
            dir: ["compact"],
            div: ["align"],
            dl: ["compact"],
            fieldset: ["disabled"],
            font: ["color", "face", "size"],
            form: [
              "accept",
              "autocomplete",
              "enctype",
              "method",
              "name",
              "novalidate"
            ],
            h1: ["align"],
            h2: ["align"],
            h3: ["align"],
            h4: ["align"],
            h5: ["align"],
            h6: ["align"],
            hr: ["align", "noshade", "size", "width"],
            iframe: [
              "align",
              "frameborder",
              "height",
              "marginheight",
              "marginwidth",
              "width"
            ],
            img: [
              "align",
              "alt",
              "border",
              "height",
              "hspace",
              "ismap",
              "name",
              "src",
              "usemap",
              "vspace",
              "width"
            ],
            input: [
              "accept",
              "accesskey",
              "align",
              "alt",
              "autocomplete",
              "checked",
              "disabled",
              "inputmode",
              "ismap",
              "list",
              "max",
              "maxlength",
              "min",
              "multiple",
              "name",
              "placeholder",
              "readonly",
              "required",
              "size",
              "src",
              "step",
              "tabindex",
              "type",
              "usemap",
              "value"
            ],
            ins: ["cite", "datetime"],
            label: ["accesskey", "for"],
            legend: ["accesskey", "align"],
            li: ["type", "value"],
            map: ["name"],
            menu: ["compact", "label", "type"],
            meter: ["high", "low", "max", "min", "value"],
            ol: ["compact", "reversed", "start", "type"],
            optgroup: ["disabled", "label"],
            option: ["disabled", "label", "selected", "value"],
            output: ["for", "name"],
            p: ["align"],
            pre: ["width"],
            progress: ["max", "min", "value"],
            q: ["cite"],
            select: [
              "autocomplete",
              "disabled",
              "multiple",
              "name",
              "required",
              "size",
              "tabindex"
            ],
            source: ["type"],
            table: [
              "align",
              "bgcolor",
              "border",
              "cellpadding",
              "cellspacing",
              "frame",
              "rules",
              "summary",
              "width"
            ],
            tbody: ["align", "char", "charoff", "valign"],
            td: [
              "abbr",
              "align",
              "axis",
              "bgcolor",
              "char",
              "charoff",
              "colspan",
              "headers",
              "height",
              "nowrap",
              "rowspan",
              "scope",
              "valign",
              "width"
            ],
            textarea: [
              "accesskey",
              "autocomplete",
              "cols",
              "disabled",
              "inputmode",
              "name",
              "placeholder",
              "readonly",
              "required",
              "rows",
              "tabindex",
              "wrap"
            ],
            tfoot: ["align", "char", "charoff", "valign"],
            th: [
              "abbr",
              "align",
              "axis",
              "bgcolor",
              "char",
              "charoff",
              "colspan",
              "headers",
              "height",
              "nowrap",
              "rowspan",
              "scope",
              "valign",
              "width"
            ],
            thead: ["align", "char", "charoff", "valign"],
            tr: ["align", "bgcolor", "char", "charoff", "valign"],
            track: ["default", "kind", "label", "srclang"],
            ul: ["compact", "type"],
            video: [
              "autoplay",
              "controls",
              "height",
              "loop",
              "mediagroup",
              "muted",
              "poster",
              "preload",
              "src",
              "width"
            ]
          },
          // Inline CSS styles that HTML tags may have (and their allowed values)
          allowedStyles: {
            // To simplify the data, all styles are allowed on all tags that allow the style attribute
            "*": {
              "backface-visibility": [CssProp.BACKFACE_VISIBILITY],
              background: [CssProp.BACKGROUND],
              "background-attachment": [CssProp.BACKGROUND_ATTACHMENT],
              "background-clip": [CssProp.BACKGROUND_CLIP],
              "background-color": [CssProp.BACKGROUND_COLOR],
              "background-image": [CssProp.BACKGROUND_IMAGE],
              "background-origin": [CssProp.BACKGROUND_ORIGIN],
              "background-position": [CssProp.BACKGROUND_POSITION],
              "background-repeat": [CssProp.BACKGROUND_REPEAT],
              "background-size": [CssProp.BACKGROUND_SIZE],
              border: [CssProp.BORDER],
              "border-bottom": [CssProp.BORDER_BOTTOM],
              "border-bottom-color": [CssProp.BORDER_BOTTOM_COLOR],
              "border-bottom-left-radius": [CssProp.BORDER_BOTTOM_LEFT_RADIUS],
              "border-bottom-right-radius": [CssProp.BORDER_BOTTOM_RIGHT_RADIUS],
              "border-bottom-style": [CssProp.BORDER_BOTTOM_STYLE],
              "border-bottom-width": [CssProp.BORDER_BOTTOM_WIDTH],
              "border-collapse": [CssProp.BORDER_COLLAPSE],
              "border-color": [CssProp.BORDER_COLOR],
              "border-left": [CssProp.BORDER_LEFT],
              "border-left-color": [CssProp.BORDER_LEFT_COLOR],
              "border-left-style": [CssProp.BORDER_LEFT_STYLE],
              "border-left-width": [CssProp.BORDER_LEFT_WIDTH],
              "border-radius": [CssProp.BORDER_RADIUS],
              "border-right": [CssProp.BORDER_RIGHT],
              "border-right-color": [CssProp.BORDER_RIGHT_COLOR],
              "border-right-style": [CssProp.BORDER_RIGHT_STYLE],
              "border-right-width": [CssProp.BORDER_RIGHT_WIDTH],
              "border-spacing": [CssProp.BORDER_SPACING],
              "border-style": [CssProp.BORDER_STYLE],
              "border-top": [CssProp.BORDER_TOP],
              "border-top-color": [CssProp.BORDER_TOP_COLOR],
              "border-top-left-radius": [CssProp.BORDER_TOP_LEFT_RADIUS],
              "border-top-right-radius": [CssProp.BORDER_TOP_RIGHT_RADIUS],
              "border-top-style": [CssProp.BORDER_TOP_STYLE],
              "border-top-width": [CssProp.BORDER_TOP_WIDTH],
              "border-width": [CssProp.BORDER_WIDTH],
              bottom: [CssProp.BOTTOM],
              box: [CssProp.BOX],
              "box-shadow": [CssProp.BOX_SHADOW],
              "box-sizing": [CssProp.BOX_SIZING],
              "caption-side": [CssProp.CAPTION_SIDE],
              clear: [CssProp.CLEAR],
              clip: [CssProp.CLIP],
              color: [CssProp.COLOR],
              cursor: [CssProp.CURSOR],
              direction: [CssProp.DIRECTION],
              display: [CssProp.DISPLAY],
              "display-inside": [CssProp.DISPLAY_INSIDE],
              "display-outside": [CssProp.DISPLAY_OUTSIDE],
              elevation: [CssProp.ELEVATION],
              "empty-cells": [CssProp.EMPTY_CELLS],
              float: [CssProp.FLOAT],
              font: [CssProp.FONT],
              "font-family": [CssProp.FONT_FAMILY],
              "font-size": [CssProp.FONT_SIZE],
              "font-stretch": [CssProp.FONT_STRETCH],
              "font-style": [CssProp.FONT_STYLE],
              "font-variant": [CssProp.FONT_VARIANT],
              "font-weight": [CssProp.FONT_WEIGHT],
              height: [CssProp.HEIGHT],
              left: [CssProp.LEFT],
              "letter-spacing": [CssProp.LETTER_SPACING],
              "line-height": [CssProp.LINE_HEIGHT],
              "list-style": [CssProp.LIST_STYLE],
              "list-style-image": [CssProp.LIST_STYLE_IMAGE],
              "list-style-position": [CssProp.LIST_STYLE_POSITION],
              "list-style-type": [CssProp.LIST_STYLE_TYPE],
              margin: [CssProp.MARGIN],
              "margin-bottom": [CssProp.MARGIN_BOTTOM],
              "margin-left": [CssProp.MARGIN_LEFT],
              "margin-right": [CssProp.MARGIN_RIGHT],
              "margin-top": [CssProp.MARGIN_TOP],
              "max-height": [CssProp.MAX_HEIGHT],
              "max-width": [CssProp.MAX_WIDTH],
              "min-height": [CssProp.MIN_HEIGHT],
              "min-width": [CssProp.MIN_WIDTH],
              opacity: [CssProp.OPACITY],
              outline: [CssProp.OUTLINE],
              "outline-color": [CssProp.OUTLINE_COLOR],
              "outline-style": [CssProp.OUTLINE_STYLE],
              "outline-width": [CssProp.OUTLINE_WIDTH],
              overflow: [CssProp.OVERFLOW],
              "overflow-wrap": [CssProp.OVERFLOW_WRAP],
              "overflow-x": [CssProp.OVERFLOW_X],
              "overflow-y": [CssProp.OVERFLOW_Y],
              padding: [CssProp.PADDING],
              "padding-bottom": [CssProp.PADDING_BOTTOM],
              "padding-left": [CssProp.PADDING_LEFT],
              "padding-right": [CssProp.PADDING_RIGHT],
              "padding-top": [CssProp.PADDING_TOP],
              "page-break-after": [CssProp.PAGE_BREAK_AFTER],
              "page-break-before": [CssProp.PAGE_BREAK_BEFORE],
              "page-break-inside": [CssProp.PAGE_BREAK_INSIDE],
              "pause-after": [CssProp.PAUSE_AFTER],
              perspective: [CssProp.PERSPECTIVE],
              pitch: [CssProp.PITCH],
              "pitch-range": [CssProp.PITCH_RANGE],
              position: [CssProp.POSITION],
              quotes: [CssProp.QUOTES],
              resize: [CssProp.RESIZE],
              richness: [CssProp.RICHNESS],
              right: [CssProp.RIGHT],
              speak: [CssProp.SPEAK],
              "speak-header": [CssProp.SPEAK_HEADER],
              "speak-numeral": [CssProp.SPEAK_NUMERAL],
              "speak-punctuation": [CssProp.SPEAK_PUNCTUATION],
              "speech-rate": [CssProp.SPEECH_RATE],
              stress: [CssProp.STRESS],
              "table-layout": [CssProp.TABLE_LAYOUT],
              "text-align": [CssProp.TEXT_ALIGN],
              "text-decoration": [CssProp.TEXT_DECORATION],
              "text-indent": [CssProp.TEXT_INDENT],
              "text-overflow": [CssProp.TEXT_OVERFLOW],
              "text-shadow": [CssProp.TEXT_SHADOW],
              "text-transform": [CssProp.TEXT_TRANSFORM],
              "text-wrap": [CssProp.TEXT_WRAP],
              top: [CssProp.TOP],
              "unicode-bidi": [CssProp.UNICODE_BIDI],
              "vertical-align": [CssProp.VERTICAL_ALIGN],
              visibility: [CssProp.VISIBILITY],
              volume: [CssProp.VOLUME],
              "white-space": [CssProp.WHITE_SPACE],
              width: [CssProp.WIDTH],
              "word-break": [CssProp.WORD_BREAK],
              "word-spacing": [CssProp.WORD_SPACING],
              "word-wrap": [CssProp.WORD_WRAP],
              "z-index": [CssProp.Z_INDEX],
              zoom: [CssProp.ZOOM]
            }
          },
          transformTags: {
            // Set the "rel" attribute for <a> tags to "nofollow".
            a: import_sanitize_html.default.simpleTransform("a", { rel: "nofollow" }),
            // Set the "disabled" attribute for <input> tags.
            input: import_sanitize_html.default.simpleTransform("input", { disabled: "disabled" })
          },
          allowedSchemes: [...import_sanitize_html.default.defaults.allowedSchemes],
          allowedSchemesByTag: {
            // Allow 'attachment:' img src (used for markdown cell attachments).
            img: import_sanitize_html.default.defaults.allowedSchemes.concat(["attachment"])
          },
          // Override of the default option, so we can skip 'src' attribute validation.
          // 'src' Attributes are validated to be URIs, which does not allow for embedded (image) data.
          // Since embedded data is no longer deemed to be a threat, validation can be skipped.
          // See https://github.com/jupyterlab/jupyterlab/issues/5183
          allowedSchemesAppliedToAttributes: ["href", "cite"]
        };
      }
      /**
       * Sanitize an HTML string.
       *
       * @param dirty - The dirty text.
       *
       * @param options - The optional sanitization options.
       *
       * @returns The sanitized string.
       */
      sanitize(dirty, options) {
        return (0, import_sanitize_html.default)(dirty, { ...this._options, ...options || {} });
      }
      /**
       * @returns Whether to replace URLs by HTML anchors.
       */
      getAutolink() {
        return this._autolink;
      }
      /**
       * Set the allowed schemes
       *
       * @param scheme Allowed schemes
       */
      setAllowedSchemes(scheme) {
        this._options.allowedSchemes = [...scheme];
      }
      /**
       * Set the URL replacement boolean.
       *
       * @param autolink URL replacement boolean.
       */
      setAutolink(autolink2) {
        this._autolink = autolink2;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/semanticCommand.js
var SemanticCommand;
var init_semanticCommand = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/semanticCommand.js"() {
    SemanticCommand = class {
      constructor() {
        this._commands = new Array();
      }
      /**
       * Add a command to the semantic group
       *
       * @param command Command to add
       */
      add(command) {
        if (this._commands.map((c6) => c6.id).includes(command.id)) {
          throw Error(`Command ${command.id} is already defined.`);
        }
        this._commands.push({
          isEnabled: () => true,
          rank: SemanticCommand.DEFAULT_RANK,
          ...command
        });
      }
      /**
       * Get the command id of the enabled command from this group
       * for the given widget.
       *
       * @param widget Widget
       * @returns Command id
       */
      getActiveCommandId(widget) {
        var _a;
        const commands = this._commands.filter((c6) => c6.isEnabled(widget)).sort((a4, b4) => {
          const rankDelta = a4.rank - b4.rank;
          return rankDelta || (a4.id < b4.id ? -1 : 1);
        });
        const command = (_a = commands[0]) !== null && _a !== void 0 ? _a : { id: null };
        return command.id;
      }
    };
    SemanticCommand.DEFAULT_RANK = 500;
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/thememanager.js
var Private8;
var init_thememanager = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/thememanager.js"() {
    init_lib();
    init_index_es62();
    init_index_es6();
    (function(Private20) {
      function fitAll(widget) {
        for (const child of widget.children()) {
          fitAll(child);
        }
        widget.fit();
      }
      Private20.fitAll = fitAll;
    })(Private8 || (Private8 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/tokens.js
var import_coreutils12, ICommandPalette, IKernelStatusModel, ISessionContextDialogs, IThemeManager, ISanitizer, ISplashScreen, IWindowResolver, IToolbarWidgetRegistry;
var init_tokens = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/tokens.js"() {
    import_coreutils12 = __toESM(require_dist());
    ICommandPalette = new import_coreutils12.Token("@jupyterlab/apputils:ICommandPalette", `A service for the application command palette
  in the left panel. Use this to add commands to the palette.`);
    IKernelStatusModel = new import_coreutils12.Token("@jupyterlab/apputils:IKernelStatusModel", "A service to register kernel session provider to the kernel status indicator.");
    ISessionContextDialogs = new import_coreutils12.Token("@jupyterlab/apputils:ISessionContextDialogs", "A service for handling the session dialogs.");
    IThemeManager = new import_coreutils12.Token("@jupyterlab/apputils:IThemeManager", "A service for the theme manager for the application. This is used primarily in theme extensions to register new themes.");
    ISanitizer = new import_coreutils12.Token("@jupyterlab/apputils:ISanitizer", "A service for sanitizing HTML strings.");
    ISplashScreen = new import_coreutils12.Token("@jupyterlab/apputils:ISplashScreen", `A service for the splash screen for the application.
  Use this if you want to show the splash screen for your own purposes.`);
    IWindowResolver = new import_coreutils12.Token("@jupyterlab/apputils:IWindowResolver", `A service for a window resolver for the
  application. JupyterLab workspaces are given a name, which are determined using
  the window resolver. Require this if you want to use the name of the current workspace.`);
    IToolbarWidgetRegistry = new import_coreutils12.Token("@jupyterlab/apputils:IToolbarWidgetRegistry", `A registry for toolbar widgets. Require this
  if you want to build the toolbar dynamically from a data definition (stored in settings for example).`);
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/windowresolver.js
var import_coreutils13, Private9;
var init_windowresolver = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/windowresolver.js"() {
    import_coreutils13 = __toESM(require_dist());
    (function(Private20) {
      const PREFIX = "@jupyterlab/statedb:StateDB";
      const BEACON = `${PREFIX}:beacon`;
      const TIMEOUT = Math.floor(200 + Math.random() * 300);
      const WINDOW = `${PREFIX}:window`;
      let currentBeaconRequest = null;
      let candidate = null;
      const delegate = new import_coreutils13.PromiseDelegate();
      const known = {};
      let name = null;
      let resolved = false;
      function initialize() {
        window.addEventListener("storage", (event) => {
          const { key, newValue } = event;
          if (newValue === null) {
            return;
          }
          if (key === BEACON && newValue !== currentBeaconRequest && candidate !== null) {
            ping(resolved ? name : candidate);
            return;
          }
          if (resolved || key !== WINDOW) {
            return;
          }
          const reported = newValue.replace(/\-\d+$/, "");
          known[reported] = null;
          if (!candidate || candidate in known) {
            reject4();
          }
        });
      }
      function ping(payload) {
        if (payload === null) {
          return;
        }
        const { localStorage } = window;
        localStorage.setItem(WINDOW, `${payload}-${(/* @__PURE__ */ new Date()).getTime()}`);
      }
      function reject4() {
        resolved = true;
        currentBeaconRequest = null;
        delegate.reject(`Window name candidate "${candidate}" already exists`);
      }
      function resolve(potential) {
        if (resolved) {
          return delegate.promise;
        }
        candidate = potential;
        if (candidate in known) {
          reject4();
          return delegate.promise;
        }
        const { localStorage, setTimeout: setTimeout2 } = window;
        setTimeout2(() => {
          if (resolved) {
            return;
          }
          if (!candidate || candidate in known) {
            return reject4();
          }
          resolved = true;
          currentBeaconRequest = null;
          delegate.resolve(name = candidate);
          ping(name);
        }, TIMEOUT);
        currentBeaconRequest = `${Math.random()}-${(/* @__PURE__ */ new Date()).getTime()}`;
        localStorage.setItem(BEACON, currentBeaconRequest);
        return delegate.promise;
      }
      Private20.resolve = resolve;
      (() => {
        initialize();
      })();
    })(Private9 || (Private9 = {}));
  }
});

// ../../node_modules/@jupyterlab/apputils/lib/index.js
var Toolbar3;
var init_lib5 = __esm({
  "../../node_modules/@jupyterlab/apputils/lib/index.js"() {
    init_lib2();
    init_toolbar();
    init_clipboard();
    init_commandlinker();
    init_commandpalette();
    init_dialog();
    init_domutils();
    init_inputdialog();
    init_kernelstatuses();
    init_mainareawidget();
    init_menufactory();
    init_notification();
    init_printing();
    init_runningSessions();
    init_sanitizer();
    init_semanticCommand();
    init_sessioncontext();
    init_thememanager();
    init_tokens();
    init_widgettracker();
    init_windowresolver();
    Toolbar3 = class extends Toolbar {
    };
    (function(Toolbar4) {
      Toolbar4.createInterruptButton = Toolbar2.createInterruptButton;
      Toolbar4.createKernelNameItem = Toolbar2.createKernelNameItem;
      Toolbar4.createKernelStatusItem = Toolbar2.createKernelStatusItem;
      Toolbar4.createRestartButton = Toolbar2.createRestartButton;
      Toolbar4.createSpacerItem = Toolbar.createSpacerItem;
    })(Toolbar3 || (Toolbar3 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js
var init_lib6 = __esm({
  "../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js"() {
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js
var import_coreutils14, AttachmentModel, Private10;
var init_attachmentmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js"() {
    init_lib3();
    import_coreutils14 = __toESM(require_dist());
    init_index_es6();
    AttachmentModel = class {
      /**
       * Construct a new attachment model.
       */
      constructor(options) {
        this.trusted = false;
        this._changed = new Signal(this);
        this._raw = {};
        const data = Private10.getData(options.value);
        this._data = new ObservableJSON({ values: data });
        this._rawData = data;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
              break;
            default:
              this._raw[key] = Private10.extract(value, key);
          }
        }
      }
      /**
       * A signal emitted when the attachment model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the attachment model.
       */
      dispose() {
        this._data.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._rawData;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return {};
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._updateObservable(this._data, options.data);
          this._rawData = options.data;
        }
        this._changed.emit(void 0);
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const attachment = {};
        for (const key in this._raw) {
          attachment[key] = Private10.extract(this._raw, key);
        }
        return attachment;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(AttachmentModel2) {
      function getData(bundle) {
        return Private10.getData(bundle);
      }
      AttachmentModel2.getData = getData;
    })(AttachmentModel || (AttachmentModel = {}));
    (function(Private20) {
      function getData(bundle) {
        return convertBundle(bundle);
      }
      Private20.getData = getData;
      function getBundleOptions(options) {
        const data = getData(options.value);
        return { data };
      }
      Private20.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils14.JSONExt.isPrimitive(item)) {
          return item;
        }
        return import_coreutils14.JSONExt.deepCopy(item);
      }
      Private20.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private10 || (Private10 = {}));
  }
});

// ../../node_modules/lodash.escape/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.escape/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reUnescapedHtml = /[&<>"'`]/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#96;"
    };
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    function escape2(string) {
      string = toString3(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape2;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/latex.js
function removeMath(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = text.includes("`") || text.includes("~~~");
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/^(?<fence>`{3,}|(~T){3,})[^`\n]*\n([\s\S]*?)^\k<fence>`*$/gm, (wholematch) => wholematch.replace(/\$/g, "~D")).replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline2);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT);
  for (let i5 = 1, m4 = blocks.length; i5 < m4; i5 += 2) {
    const block = blocks[i5];
    if (block.charAt(0) === "@") {
      blocks[i5] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i5;
        } else {
          blocks = processMath(start, i5, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i5 = last2;
          blocks = processMath(start, i5, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline2 || block === "$$") {
        start = i5;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i5;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i5;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath(text, math) {
  const process2 = (match, n4) => {
    let group2 = math[n4];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath(i5, j2, preProcess, math, blocks) {
  let block = blocks.slice(i5, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i5) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i5] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline2, MATHSPLIT;
var init_latex = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/latex.js"() {
    inline2 = "$";
    MATHSPLIT = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/renderers.js
function renderHTML(options) {
  let { host, source, trusted, sanitizer, resolver, linkHandler, shouldTypeset, latexTypesetter, translator } = options;
  translator = translator || nullTranslator;
  const trans = translator === null || translator === void 0 ? void 0 : translator.load("jupyterlab");
  let originalSource = source;
  if (!source) {
    host.textContent = "";
    return Promise.resolve(void 0);
  }
  if (!trusted) {
    originalSource = `${source}`;
    source = sanitizer.sanitize(source);
  }
  host.innerHTML = source;
  if (host.getElementsByTagName("script").length > 0) {
    if (trusted) {
      Private11.evalInnerHTMLScriptTags(host);
    } else {
      const container = document.createElement("div");
      const warning = document.createElement("pre");
      warning.textContent = trans.__("This HTML output contains inline scripts. Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
      const runButton = document.createElement("button");
      runButton.textContent = trans.__("Run");
      runButton.onclick = (event) => {
        host.innerHTML = originalSource;
        Private11.evalInnerHTMLScriptTags(host);
        if (host.firstChild) {
          host.removeChild(host.firstChild);
        }
      };
      container.appendChild(warning);
      container.appendChild(runButton);
      host.insertBefore(container, host.firstChild);
    }
  }
  Private11.handleDefaults(host, resolver);
  let promise;
  if (resolver) {
    promise = Private11.handleUrls(host, resolver, linkHandler);
  } else {
    promise = Promise.resolve(void 0);
  }
  return promise.then(() => {
    if (shouldTypeset && latexTypesetter) {
      latexTypesetter.typeset(host);
    }
  });
}
function renderImage(options) {
  const { host, mimeType, source, width, height, needsBackground, unconfined } = options;
  host.textContent = "";
  const img = document.createElement("img");
  img.src = `data:${mimeType};base64,${source}`;
  if (typeof height === "number") {
    img.height = height;
  }
  if (typeof width === "number") {
    img.width = width;
  }
  if (needsBackground === "light") {
    img.classList.add("jp-needs-light-background");
  } else if (needsBackground === "dark") {
    img.classList.add("jp-needs-dark-background");
  }
  if (unconfined === true) {
    img.classList.add("jp-mod-unconfined");
  }
  host.appendChild(img);
  return Promise.resolve(void 0);
}
function renderLatex(options) {
  const { host, source, shouldTypeset, latexTypesetter } = options;
  host.textContent = source;
  if (shouldTypeset && latexTypesetter) {
    latexTypesetter.typeset(host);
  }
  return Promise.resolve(void 0);
}
async function renderMarkdown(options) {
  const { host, source, markdownParser, ...others } = options;
  if (!source) {
    host.textContent = "";
    return;
  }
  let html = "";
  if (markdownParser) {
    const parts = removeMath(source);
    html = await markdownParser.render(parts["text"]);
    html = replaceMath(html, parts["math"]);
  } else {
    html = `<pre>${source}</pre>`;
  }
  await renderHTML({
    host,
    source: html,
    ...others
  });
  Private11.headerAnchors(host);
}
function renderSVG(options) {
  let { host, source, trusted, unconfined } = options;
  if (!source) {
    host.textContent = "";
    return Promise.resolve(void 0);
  }
  if (!trusted) {
    host.textContent = "Cannot display an untrusted SVG. Maybe you need to run the cell?";
    return Promise.resolve(void 0);
  }
  const patt = "<svg[^>]+xmlns=[^>]+svg";
  if (source.search(patt) < 0) {
    source = source.replace("<svg", '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const img = new Image();
  img.src = `data:image/svg+xml,${encodeURIComponent(source)}`;
  host.appendChild(img);
  if (unconfined === true) {
    host.classList.add("jp-mod-unconfined");
  }
  return Promise.resolve();
}
function autolink(content) {
  const controlCodes = "\\u0000-\\u0020\\u007f-\\u009f";
  const webLinkRegex = new RegExp("(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s" + controlCodes + '"]{2,}[^\\s' + controlCodes + `"'(){}\\[\\],:;.!?]`, "ug");
  const nodes = [];
  let lastIndex = 0;
  let match;
  while (null != (match = webLinkRegex.exec(content))) {
    if (match.index !== lastIndex) {
      nodes.push(document.createTextNode(content.slice(lastIndex, match.index)));
    }
    let url = match[0];
    const lastChars = url.slice(-1);
    const endsWithGtLt = [">", "<"].indexOf(lastChars) !== -1;
    const len = endsWithGtLt ? url.length - 1 : url.length;
    const anchor = document.createElement("a");
    url = url.slice(0, len);
    anchor.href = url.startsWith("www.") ? "https://" + url : url;
    anchor.rel = "noopener";
    anchor.target = "_blank";
    anchor.appendChild(document.createTextNode(url.slice(0, len)));
    nodes.push(anchor);
    lastIndex = match.index + len;
  }
  if (lastIndex !== content.length) {
    nodes.push(document.createTextNode(content.slice(lastIndex, content.length)));
  }
  return nodes;
}
function splitShallowNode(node, at) {
  var _a, _b;
  const pre = node.cloneNode();
  pre.textContent = (_a = node.textContent) === null || _a === void 0 ? void 0 : _a.slice(0, at);
  const post = node.cloneNode();
  post.textContent = (_b = node.textContent) === null || _b === void 0 ? void 0 : _b.slice(at);
  return {
    pre,
    post
  };
}
function* nodeIter(nodes) {
  var _a;
  let start = 0;
  let end;
  for (let node of nodes) {
    end = start + (((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
    yield {
      node,
      start,
      end,
      isText: node.nodeType === Node.TEXT_NODE
    };
    start = end;
  }
}
function* alignedNodes(a4, b4) {
  var _a, _b;
  let iterA = nodeIter(a4);
  let iterB = nodeIter(b4);
  let nA = iterA.next();
  let nB = iterB.next();
  while (!nA.done && !nB.done) {
    let A = nA.value;
    let B2 = nB.value;
    if (A.isText && A.start <= B2.start && A.end >= B2.end) {
      yield [null, B2.node];
      nB = iterB.next();
    } else if (B2.isText && B2.start <= A.start && B2.end >= A.end) {
      yield [A.node, null];
      nA = iterA.next();
    } else {
      if (A.end === B2.end && A.start === B2.start) {
        yield [A.node, B2.node];
        nA = iterA.next();
        nB = iterB.next();
      } else if (A.end > B2.end) {
        let { pre, post } = splitShallowNode(A.node, B2.end - A.start);
        if (B2.start < A.start) {
          B2.node.textContent = (_a = B2.node.textContent) === null || _a === void 0 ? void 0 : _a.slice(A.start - B2.start);
        }
        yield [pre, B2.node];
        A.node = post;
        A.start = B2.end;
        nB = iterB.next();
      } else if (B2.end > A.end) {
        let { pre, post } = splitShallowNode(B2.node, A.end - B2.start);
        if (A.start < B2.start) {
          A.node.textContent = (_b = A.node.textContent) === null || _b === void 0 ? void 0 : _b.slice(B2.start - A.start);
        }
        yield [A.node, pre];
        B2.node = post;
        B2.start = A.end;
        nA = iterA.next();
      } else {
        throw new Error(`Unexpected intersection: ${JSON.stringify(A)} ${JSON.stringify(B2)}`);
      }
    }
  }
}
function renderText(options) {
  var _a, _b;
  const { host, sanitizer, source } = options;
  const content = sanitizer.sanitize(Private11.ansiSpan(source), {
    allowedTags: ["span"]
  });
  const ret = document.createElement("pre");
  const pre = document.createElement("pre");
  pre.innerHTML = content;
  const preTextContent = pre.textContent;
  if (preTextContent) {
    const linkedNodes = ((_b = (_a = sanitizer.getAutolink) === null || _a === void 0 ? void 0 : _a.call(sanitizer)) !== null && _b !== void 0 ? _b : true) ? autolink(preTextContent) : [document.createTextNode(content)];
    let inAnchorElement = false;
    const combinedNodes = [];
    const preNodes = Array.from(pre.childNodes);
    for (let nodes of alignedNodes(preNodes, linkedNodes)) {
      if (!nodes[0]) {
        combinedNodes.push(nodes[1]);
        inAnchorElement = nodes[1].nodeType !== Node.TEXT_NODE;
        continue;
      } else if (!nodes[1]) {
        combinedNodes.push(nodes[0]);
        inAnchorElement = false;
        continue;
      }
      let [preNode, linkNode] = nodes;
      const lastCombined = combinedNodes[combinedNodes.length - 1];
      if (inAnchorElement && linkNode.href === lastCombined.href) {
        lastCombined.appendChild(preNode);
      } else {
        const isAnchor = linkNode.nodeType !== Node.TEXT_NODE;
        if (!isAnchor) {
          combinedNodes.push(preNode);
          inAnchorElement = false;
        } else {
          linkNode.textContent = "";
          linkNode.appendChild(preNode);
          combinedNodes.push(linkNode);
          inAnchorElement = true;
        }
      }
    }
    for (const child of combinedNodes) {
      ret.appendChild(child);
    }
  }
  host.appendChild(ret);
  return Promise.resolve(void 0);
}
var import_coreutils15, import_lodash, Private11;
var init_renderers = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/renderers.js"() {
    import_coreutils15 = __toESM(require_lib2());
    init_lib();
    import_lodash = __toESM(require_lodash());
    init_latex();
    (function(renderMarkdown2) {
      function createHeaderId(header) {
        var _a;
        return ((_a = header.textContent) !== null && _a !== void 0 ? _a : "").replace(/ /g, "-");
      }
      renderMarkdown2.createHeaderId = createHeaderId;
    })(renderMarkdown || (renderMarkdown = {}));
    (function(Private20) {
      function evalInnerHTMLScriptTags(host) {
        const scripts = Array.from(host.getElementsByTagName("script"));
        for (const script of scripts) {
          if (!script.parentNode) {
            continue;
          }
          const clone2 = document.createElement("script");
          const attrs = script.attributes;
          for (let i5 = 0, n4 = attrs.length; i5 < n4; ++i5) {
            const { name, value } = attrs[i5];
            clone2.setAttribute(name, value);
          }
          clone2.textContent = script.textContent;
          script.parentNode.replaceChild(clone2, script);
        }
      }
      Private20.evalInnerHTMLScriptTags = evalInnerHTMLScriptTags;
      function handleDefaults(node, resolver) {
        const anchors = node.getElementsByTagName("a");
        for (let i5 = 0; i5 < anchors.length; i5++) {
          const el = anchors[i5];
          if (!(el instanceof HTMLAnchorElement)) {
            continue;
          }
          const path = el.href;
          const isLocal = resolver && resolver.isLocal ? resolver.isLocal(path) : import_coreutils15.URLExt.isLocal(path);
          if (!el.target) {
            el.target = isLocal ? "_self" : "_blank";
          }
          if (!isLocal) {
            el.rel = "noopener";
          }
        }
        const imgs = node.getElementsByTagName("img");
        for (let i5 = 0; i5 < imgs.length; i5++) {
          if (!imgs[i5].alt) {
            imgs[i5].alt = "Image";
          }
        }
      }
      Private20.handleDefaults = handleDefaults;
      function handleUrls(node, resolver, linkHandler) {
        const promises = [];
        const nodes = node.querySelectorAll("*[src]");
        for (let i5 = 0; i5 < nodes.length; i5++) {
          promises.push(handleAttr(nodes[i5], "src", resolver));
        }
        const anchors = node.getElementsByTagName("a");
        for (let i5 = 0; i5 < anchors.length; i5++) {
          promises.push(handleAnchor(anchors[i5], resolver, linkHandler));
        }
        const links = node.getElementsByTagName("link");
        for (let i5 = 0; i5 < links.length; i5++) {
          promises.push(handleAttr(links[i5], "href", resolver));
        }
        return Promise.all(promises).then(() => void 0);
      }
      Private20.handleUrls = handleUrls;
      function headerAnchors(node) {
        const headerNames = ["h1", "h2", "h3", "h4", "h5", "h6"];
        for (const headerType of headerNames) {
          const headers = node.getElementsByTagName(headerType);
          for (let i5 = 0; i5 < headers.length; i5++) {
            const header = headers[i5];
            header.id = renderMarkdown.createHeaderId(header);
            const anchor = document.createElement("a");
            anchor.target = "_self";
            anchor.textContent = "\xB6";
            anchor.href = "#" + header.id;
            anchor.classList.add("jp-InternalAnchorLink");
            header.appendChild(anchor);
          }
        }
      }
      Private20.headerAnchors = headerAnchors;
      async function handleAttr(node, name, resolver) {
        const source = node.getAttribute(name) || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(source) : import_coreutils15.URLExt.isLocal(source);
        if (!source || !isLocal) {
          return;
        }
        try {
          const urlPath = await resolver.resolveUrl(source);
          let url = await resolver.getDownloadUrl(urlPath);
          if (import_coreutils15.URLExt.parse(url).protocol !== "data:") {
            url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
          }
          node.setAttribute(name, url);
        } catch (err) {
          node.setAttribute(name, "");
          throw err;
        }
      }
      function handleAnchor(anchor, resolver, linkHandler) {
        let href = anchor.getAttribute("href") || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(href) : import_coreutils15.URLExt.isLocal(href);
        if (!href || !isLocal) {
          return Promise.resolve(void 0);
        }
        const hash = anchor.hash;
        if (hash) {
          if (hash === href) {
            anchor.target = "_self";
            return Promise.resolve(void 0);
          }
          href = href.replace(hash, "");
        }
        return resolver.resolveUrl(href).then((urlPath) => {
          const path = decodeURIComponent(urlPath);
          if (linkHandler) {
            linkHandler.handleLink(anchor, path, hash);
          }
          return resolver.getDownloadUrl(urlPath);
        }).then((url) => {
          anchor.href = url + hash;
        }).catch((err) => {
          anchor.href = "";
        });
      }
      const ANSI_COLORS = [
        "ansi-black",
        "ansi-red",
        "ansi-green",
        "ansi-yellow",
        "ansi-blue",
        "ansi-magenta",
        "ansi-cyan",
        "ansi-white",
        "ansi-black-intense",
        "ansi-red-intense",
        "ansi-green-intense",
        "ansi-yellow-intense",
        "ansi-blue-intense",
        "ansi-magenta-intense",
        "ansi-cyan-intense",
        "ansi-white-intense"
      ];
      function pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out) {
        if (chunk2) {
          const classes = [];
          const styles = [];
          if (bold && typeof fg === "number" && 0 <= fg && fg < 8) {
            fg += 8;
          }
          if (inverse) {
            [fg, bg] = [bg, fg];
          }
          if (typeof fg === "number") {
            classes.push(ANSI_COLORS[fg] + "-fg");
          } else if (fg.length) {
            styles.push(`color: rgb(${fg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-fg");
          }
          if (typeof bg === "number") {
            classes.push(ANSI_COLORS[bg] + "-bg");
          } else if (bg.length) {
            styles.push(`background-color: rgb(${bg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-bg");
          }
          if (bold) {
            classes.push("ansi-bold");
          }
          if (underline) {
            classes.push("ansi-underline");
          }
          if (classes.length || styles.length) {
            out.push("<span");
            if (classes.length) {
              out.push(` class="${classes.join(" ")}"`);
            }
            if (styles.length) {
              out.push(` style="${styles.join("; ")}"`);
            }
            out.push(">");
            out.push(chunk2);
            out.push("</span>");
          } else {
            out.push(chunk2);
          }
        }
      }
      function getExtendedColors(numbers) {
        let r4;
        let g4;
        let b4;
        const n4 = numbers.shift();
        if (n4 === 2 && numbers.length >= 3) {
          r4 = numbers.shift();
          g4 = numbers.shift();
          b4 = numbers.shift();
          if ([r4, g4, b4].some((c6) => c6 < 0 || 255 < c6)) {
            throw new RangeError("Invalid range for RGB colors");
          }
        } else if (n4 === 5 && numbers.length >= 1) {
          const idx = numbers.shift();
          if (idx < 0) {
            throw new RangeError("Color index must be >= 0");
          } else if (idx < 16) {
            return idx;
          } else if (idx < 232) {
            r4 = Math.floor((idx - 16) / 36);
            r4 = r4 > 0 ? 55 + r4 * 40 : 0;
            g4 = Math.floor((idx - 16) % 36 / 6);
            g4 = g4 > 0 ? 55 + g4 * 40 : 0;
            b4 = (idx - 16) % 6;
            b4 = b4 > 0 ? 55 + b4 * 40 : 0;
          } else if (idx < 256) {
            r4 = g4 = b4 = (idx - 232) * 10 + 8;
          } else {
            throw new RangeError("Color index must be < 256");
          }
        } else {
          throw new RangeError("Invalid extended color specification");
        }
        return [r4, g4, b4];
      }
      function ansiSpan(str2) {
        const ansiRe = /\x1b\[(.*?)([@-~])/g;
        let fg = [];
        let bg = [];
        let bold = false;
        let underline = false;
        let inverse = false;
        let match;
        const out = [];
        const numbers = [];
        let start = 0;
        str2 = (0, import_lodash.default)(str2);
        str2 += "\x1B[m";
        while (match = ansiRe.exec(str2)) {
          if (match[2] === "m") {
            const items = match[1].split(";");
            for (let i5 = 0; i5 < items.length; i5++) {
              const item = items[i5];
              if (item === "") {
                numbers.push(0);
              } else if (item.search(/^\d+$/) !== -1) {
                numbers.push(parseInt(item, 10));
              } else {
                numbers.length = 0;
                break;
              }
            }
          } else {
          }
          const chunk2 = str2.substring(start, match.index);
          pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out);
          start = ansiRe.lastIndex;
          while (numbers.length) {
            const n4 = numbers.shift();
            switch (n4) {
              case 0:
                fg = bg = [];
                bold = false;
                underline = false;
                inverse = false;
                break;
              case 1:
              case 5:
                bold = true;
                break;
              case 4:
                underline = true;
                break;
              case 7:
                inverse = true;
                break;
              case 21:
              case 22:
                bold = false;
                break;
              case 24:
                underline = false;
                break;
              case 27:
                inverse = false;
                break;
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
                fg = n4 - 30;
                break;
              case 38:
                try {
                  fg = getExtendedColors(numbers);
                } catch (e4) {
                  numbers.length = 0;
                }
                break;
              case 39:
                fg = [];
                break;
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 47:
                bg = n4 - 40;
                break;
              case 48:
                try {
                  bg = getExtendedColors(numbers);
                } catch (e4) {
                  numbers.length = 0;
                }
                break;
              case 49:
                bg = [];
                break;
              case 90:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 97:
                fg = n4 - 90 + 8;
                break;
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
                bg = n4 - 100 + 8;
                break;
              default:
            }
          }
        }
        return out.join("");
      }
      Private20.ansiSpan = ansiSpan;
    })(Private11 || (Private11 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/widgets.js
var RenderedCommon, RenderedHTMLCommon, RenderedHTML, RenderedLatex, RenderedImage, RenderedMarkdown, RenderedSVG, RenderedText, RenderedJavaScript;
var init_widgets = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/widgets.js"() {
    init_lib();
    init_index_es63();
    init_renderers();
    RenderedCommon = class extends Widget {
      /**
       * Construct a new rendered common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        var _a, _b;
        super();
        this.mimeType = options.mimeType;
        this.sanitizer = options.sanitizer;
        this.resolver = options.resolver;
        this.linkHandler = options.linkHandler;
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.latexTypesetter = options.latexTypesetter;
        this.markdownParser = (_b = options.markdownParser) !== null && _b !== void 0 ? _b : null;
        this.node.dataset["mimeType"] = this.mimeType;
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @param keepExisting - Whether to keep the existing rendering.
       *
       * @returns A promise which resolves when rendering is complete.
       *
       * #### Notes
       * By default, if the DOM node for this widget already has content, it
       * is emptied before rendering. Subclasses that do not want this behavior
       * (if, for instance, they are using DOM diffing), should override this
       * method or call `super.renderModel(model, true)`.
       */
      async renderModel(model, keepExisting) {
        if (!keepExisting) {
          while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
          }
        }
        this.toggleClass("jp-mod-trusted", model.trusted);
        await this.render(model);
        const { fragment } = model.metadata;
        if (fragment) {
          this.setFragment(fragment);
        }
      }
      /**
       * Set the URI fragment identifier.
       *
       * @param fragment - The URI fragment identifier.
       */
      setFragment(fragment) {
      }
    };
    RenderedHTMLCommon = class extends RenderedCommon {
      /**
       * Construct a new rendered HTML common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedHTMLCommon");
      }
      setFragment(fragment) {
        let el;
        try {
          el = this.node.querySelector(fragment.startsWith("#") ? `#${CSS.escape(fragment.slice(1))}` : fragment);
        } catch (error) {
          console.warn("Unable to set URI fragment identifier.", error);
        }
        if (el) {
          el.scrollIntoView();
        }
      }
    };
    RenderedHTML = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered HTML widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedHTML");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderHTML({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        if (this.latexTypesetter) {
          this.latexTypesetter.typeset(this.node);
        }
      }
    };
    RenderedLatex = class extends RenderedCommon {
      /**
       * Construct a new rendered LaTeX widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedLatex");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderLatex({
          host: this.node,
          source: String(model.data[this.mimeType]),
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        if (this.latexTypesetter) {
          this.latexTypesetter.typeset(this.node);
        }
      }
    };
    RenderedImage = class extends RenderedCommon {
      /**
       * Construct a new rendered image widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedImage");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return renderImage({
          host: this.node,
          mimeType: this.mimeType,
          source: String(model.data[this.mimeType]),
          width: metadata && metadata.width,
          height: metadata && metadata.height,
          needsBackground: model.metadata["needs_background"],
          unconfined: metadata && metadata.unconfined
        });
      }
    };
    RenderedMarkdown = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered markdown widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedMarkdown");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderMarkdown({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      async renderModel(model) {
        await super.renderModel(model, true);
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        if (this.latexTypesetter) {
          this.latexTypesetter.typeset(this.node);
        }
      }
    };
    RenderedSVG = class extends RenderedCommon {
      /**
       * Construct a new rendered SVG widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedSVG");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return renderSVG({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          unconfined: metadata && metadata.unconfined,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        if (this.latexTypesetter) {
          this.latexTypesetter.typeset(this.node);
        }
      }
    };
    RenderedText = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedText");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: String(model.data[this.mimeType]),
          translator: this.translator
        });
      }
    };
    RenderedJavaScript = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedJavaScript");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const trans = this.translator.load("jupyterlab");
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: trans.__("JavaScript output is disabled in JupyterLab"),
          translator: this.translator
        });
      }
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/factories.js
var htmlRendererFactory, imageRendererFactory, latexRendererFactory, markdownRendererFactory, svgRendererFactory, textRendererFactory;
var init_factories = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/factories.js"() {
    init_widgets();
    htmlRendererFactory = {
      safe: true,
      mimeTypes: ["text/html"],
      defaultRank: 50,
      createRenderer: (options) => new RenderedHTML(options)
    };
    imageRendererFactory = {
      safe: true,
      mimeTypes: [
        "image/bmp",
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/webp"
      ],
      defaultRank: 90,
      createRenderer: (options) => new RenderedImage(options)
    };
    latexRendererFactory = {
      safe: true,
      mimeTypes: ["text/latex"],
      defaultRank: 70,
      createRenderer: (options) => new RenderedLatex(options)
    };
    markdownRendererFactory = {
      safe: true,
      mimeTypes: ["text/markdown"],
      defaultRank: 60,
      createRenderer: (options) => new RenderedMarkdown(options)
    };
    svgRendererFactory = {
      safe: false,
      mimeTypes: ["image/svg+xml"],
      defaultRank: 80,
      createRenderer: (options) => new RenderedSVG(options)
    };
    textRendererFactory = {
      safe: true,
      mimeTypes: [
        "text/plain",
        "application/vnd.jupyter.stdout",
        "application/vnd.jupyter.stderr"
      ],
      defaultRank: 120,
      createRenderer: (options) => new RenderedText(options)
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js
var MimeModel, Private12;
var init_mimemodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js"() {
    MimeModel = class {
      /**
       * Construct a new mime model.
       */
      constructor(options = {}) {
        this.trusted = !!options.trusted;
        this._data = options.data || {};
        this._metadata = options.metadata || {};
        this._callback = options.callback || Private12.noOp;
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._data;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._metadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        this._data = options.data || this._data;
        this._metadata = options.metadata || this._metadata;
        this._callback(options);
      }
    };
    (function(Private20) {
      function noOp() {
      }
      Private20.noOp = noOp;
    })(Private12 || (Private12 = {}));
  }
});

// ../../node_modules/@jupyterlab/nbformat/lib/index.js
function isExecuteResult(output) {
  return output.output_type === "execute_result";
}
function isDisplayData(output) {
  return output.output_type === "display_data";
}
function isDisplayUpdate(output) {
  return output.output_type === "update_display_data";
}
function isStream(output) {
  return output.output_type === "stream";
}
function isError(output) {
  return output.output_type === "error";
}
var import_coreutils16;
var init_lib7 = __esm({
  "../../node_modules/@jupyterlab/nbformat/lib/index.js"() {
    import_coreutils16 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js
var import_coreutils17, OutputModel, Private13;
var init_outputmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js"() {
    init_lib7();
    init_lib3();
    import_coreutils17 = __toESM(require_dist());
    init_index_es6();
    OutputModel = class {
      /**
       * Construct a new output model.
       */
      constructor(options) {
        this._changed = new Signal(this);
        this._raw = {};
        const { data, metadata, trusted } = Private13.getBundleOptions(options);
        this._data = new ObservableJSON({ values: data });
        this._rawData = data;
        this._metadata = new ObservableJSON({ values: metadata });
        this._rawMetadata = metadata;
        this.trusted = trusted;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
            case "metadata":
              break;
            default:
              this._raw[key] = Private13.extract(value, key);
          }
        }
        this.type = value.output_type;
        if (isExecuteResult(value)) {
          this.executionCount = value.execution_count;
        } else {
          this.executionCount = null;
        }
      }
      /**
       * A signal emitted when the output model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the output model.
       */
      dispose() {
        this._data.dispose();
        this._metadata.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._rawData;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._rawMetadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._updateObservable(this._data, options.data);
          this._rawData = options.data;
        }
        if (options.metadata) {
          this._updateObservable(this._metadata, options.metadata);
          this._rawMetadata = options.metadata;
        }
        this._changed.emit();
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const output = {};
        for (const key in this._raw) {
          output[key] = Private13.extract(this._raw, key);
        }
        switch (this.type) {
          case "display_data":
          case "execute_result":
          case "update_display_data":
            output["data"] = this.data;
            output["metadata"] = this.metadata;
            break;
          default:
            break;
        }
        delete output["transient"];
        return output;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(OutputModel4) {
      function getData(output) {
        return Private13.getData(output);
      }
      OutputModel4.getData = getData;
      function getMetadata(output) {
        return Private13.getMetadata(output);
      }
      OutputModel4.getMetadata = getMetadata;
    })(OutputModel || (OutputModel = {}));
    (function(Private20) {
      function getData(output) {
        let bundle = {};
        if (isExecuteResult(output) || isDisplayData(output) || isDisplayUpdate(output)) {
          bundle = output.data;
        } else if (isStream(output)) {
          if (output.name === "stderr") {
            bundle["application/vnd.jupyter.stderr"] = output.text;
          } else {
            bundle["application/vnd.jupyter.stdout"] = output.text;
          }
        } else if (isError(output)) {
          bundle["application/vnd.jupyter.error"] = output;
          const traceback = output.traceback.join("\n");
          bundle["application/vnd.jupyter.stderr"] = traceback || `${output.ename}: ${output.evalue}`;
        }
        return convertBundle(bundle);
      }
      Private20.getData = getData;
      function getMetadata(output) {
        const value = /* @__PURE__ */ Object.create(null);
        if (isExecuteResult(output) || isDisplayData(output)) {
          for (const key in output.metadata) {
            value[key] = extract(output.metadata, key);
          }
        }
        return value;
      }
      Private20.getMetadata = getMetadata;
      function getBundleOptions(options) {
        const data = getData(options.value);
        const metadata = getMetadata(options.value);
        const trusted = !!options.trusted;
        return { data, metadata, trusted };
      }
      Private20.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils17.JSONExt.isPrimitive(item)) {
          return item;
        }
        return JSON.parse(JSON.stringify(item));
      }
      Private20.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private13 || (Private13 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/registry.js
var import_coreutils18, RenderMimeRegistry, Private14;
var init_registry2 = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/registry.js"() {
    init_lib5();
    import_coreutils18 = __toESM(require_lib2());
    init_lib();
    init_mimemodel();
    RenderMimeRegistry = class {
      /**
       * Construct a new rendermime.
       *
       * @param options - The options for initializing the instance.
       */
      constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f;
        this._id = 0;
        this._ranks = {};
        this._types = null;
        this._factories = {};
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.resolver = (_b = options.resolver) !== null && _b !== void 0 ? _b : null;
        this.linkHandler = (_c = options.linkHandler) !== null && _c !== void 0 ? _c : null;
        this.latexTypesetter = (_d = options.latexTypesetter) !== null && _d !== void 0 ? _d : null;
        this.markdownParser = (_e = options.markdownParser) !== null && _e !== void 0 ? _e : null;
        this.sanitizer = (_f = options.sanitizer) !== null && _f !== void 0 ? _f : new Sanitizer();
        if (options.initialFactories) {
          for (const factory of options.initialFactories) {
            this.addFactory(factory);
          }
        }
      }
      /**
       * The ordered list of mimeTypes.
       */
      get mimeTypes() {
        return this._types || (this._types = Private14.sortedTypes(this._ranks));
      }
      /**
       * Find the preferred mime type for a mime bundle.
       *
       * @param bundle - The bundle of mime data.
       *
       * @param safe - How to consider safe/unsafe factories. If 'ensure',
       *   it will only consider safe factories. If 'any', any factory will be
       *   considered. If 'prefer', unsafe factories will be considered, but
       *   only after the safe options have been exhausted.
       *
       * @returns The preferred mime type from the available factories,
       *   or `undefined` if the mime type cannot be rendered.
       */
      preferredMimeType(bundle, safe = "ensure") {
        if (safe === "ensure" || safe === "prefer") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle && this._factories[mt].safe) {
              return mt;
            }
          }
        }
        if (safe !== "ensure") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle) {
              return mt;
            }
          }
        }
        return void 0;
      }
      /**
       * Create a renderer for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns A new renderer for the given mime type.
       *
       * @throws An error if no factory exists for the mime type.
       */
      createRenderer(mimeType) {
        if (!(mimeType in this._factories)) {
          throw new Error(`No factory for mime type: '${mimeType}'`);
        }
        return this._factories[mimeType].createRenderer({
          mimeType,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Create a new mime model.  This is a convenience method.
       *
       * @options - The options used to create the model.
       *
       * @returns A new mime model.
       */
      createModel(options = {}) {
        return new MimeModel(options);
      }
      /**
       * Create a clone of this rendermime instance.
       *
       * @param options - The options for configuring the clone.
       *
       * @returns A new independent clone of the rendermime.
       */
      clone(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const clone2 = new RenderMimeRegistry({
          resolver: (_b = (_a = options.resolver) !== null && _a !== void 0 ? _a : this.resolver) !== null && _b !== void 0 ? _b : void 0,
          sanitizer: (_d = (_c = options.sanitizer) !== null && _c !== void 0 ? _c : this.sanitizer) !== null && _d !== void 0 ? _d : void 0,
          linkHandler: (_f = (_e = options.linkHandler) !== null && _e !== void 0 ? _e : this.linkHandler) !== null && _f !== void 0 ? _f : void 0,
          latexTypesetter: (_h = (_g = options.latexTypesetter) !== null && _g !== void 0 ? _g : this.latexTypesetter) !== null && _h !== void 0 ? _h : void 0,
          markdownParser: (_k = (_j = options.markdownParser) !== null && _j !== void 0 ? _j : this.markdownParser) !== null && _k !== void 0 ? _k : void 0,
          translator: this.translator
        });
        clone2._factories = { ...this._factories };
        clone2._ranks = { ...this._ranks };
        clone2._id = this._id;
        return clone2;
      }
      /**
       * Get the renderer factory registered for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The factory for the mime type, or `undefined`.
       */
      getFactory(mimeType) {
        return this._factories[mimeType];
      }
      /**
       * Add a renderer factory to the rendermime.
       *
       * @param factory - The renderer factory of interest.
       *
       * @param rank - The rank of the renderer. A lower rank indicates
       *   a higher priority for rendering. If not given, the rank will
       *   defer to the `defaultRank` of the factory.  If no `defaultRank`
       *   is given, it will default to 100.
       *
       * #### Notes
       * The renderer will replace an existing renderer for the given
       * mimeType.
       */
      addFactory(factory, rank) {
        if (rank === void 0) {
          rank = factory.defaultRank;
          if (rank === void 0) {
            rank = 100;
          }
        }
        for (const mt of factory.mimeTypes) {
          this._factories[mt] = factory;
          this._ranks[mt] = { rank, id: this._id++ };
        }
        this._types = null;
      }
      /**
       * Remove a mime type.
       *
       * @param mimeType - The mime type of interest.
       */
      removeMimeType(mimeType) {
        delete this._factories[mimeType];
        delete this._ranks[mimeType];
        this._types = null;
      }
      /**
       * Get the rank for a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The rank of the mime type or undefined.
       */
      getRank(mimeType) {
        const rank = this._ranks[mimeType];
        return rank && rank.rank;
      }
      /**
       * Set the rank of a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @param rank - The new rank to assign.
       *
       * #### Notes
       * This is a no-op if the mime type is not registered.
       */
      setRank(mimeType, rank) {
        if (!this._ranks[mimeType]) {
          return;
        }
        const id = this._id++;
        this._ranks[mimeType] = { rank, id };
        this._types = null;
      }
    };
    (function(RenderMimeRegistry2) {
      class UrlResolver {
        /**
         * Create a new url resolver.
         */
        constructor(options) {
          this._path = options.path;
          this._contents = options.contents;
        }
        /**
         * The path of the object, from which local urls can be derived.
         */
        get path() {
          return this._path;
        }
        set path(value) {
          this._path = value;
        }
        /**
         * Resolve a relative url to an absolute url path.
         */
        async resolveUrl(url) {
          if (this.isLocal(url)) {
            const cwd = encodeURI(import_coreutils18.PathExt.dirname(this.path));
            url = import_coreutils18.PathExt.resolve(cwd, url);
          }
          return url;
        }
        /**
         * Get the download url of a given absolute url path.
         *
         * #### Notes
         * The returned URL may include a query parameter.
         */
        async getDownloadUrl(urlPath) {
          if (this.isLocal(urlPath)) {
            return this._contents.getDownloadUrl(decodeURIComponent(urlPath));
          }
          return urlPath;
        }
        /**
         * Whether the URL should be handled by the resolver
         * or not.
         *
         * #### Notes
         * This is similar to the `isLocal` check in `URLExt`,
         * but it also checks whether the path points to any
         * of the `IDrive`s that may be registered with the contents
         * manager.
         */
        isLocal(url) {
          if (this.isMalformed(url)) {
            return false;
          }
          return import_coreutils18.URLExt.isLocal(url) || !!this._contents.driveName(decodeURI(url));
        }
        /**
         * Whether the URL can be decoded using `decodeURI`.
         */
        isMalformed(url) {
          try {
            decodeURI(url);
            return false;
          } catch (error) {
            if (error instanceof URIError) {
              return true;
            }
            throw error;
          }
        }
      }
      RenderMimeRegistry2.UrlResolver = UrlResolver;
    })(RenderMimeRegistry || (RenderMimeRegistry = {}));
    (function(Private20) {
      function sortedTypes(map4) {
        return Object.keys(map4).sort((a4, b4) => {
          const p1 = map4[a4];
          const p22 = map4[b4];
          if (p1.rank !== p22.rank) {
            return p1.rank - p22.rank;
          }
          return p1.id - p22.id;
        });
      }
      Private20.sortedTypes = sortedTypes;
    })(Private14 || (Private14 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/tokens.js
var import_coreutils19, IRenderMimeRegistry, ILatexTypesetter, IMarkdownParser;
var init_tokens2 = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/tokens.js"() {
    import_coreutils19 = __toESM(require_dist());
    IRenderMimeRegistry = new import_coreutils19.Token("@jupyterlab/rendermime:IRenderMimeRegistry", 'A service for the rendermime registry for the application. Use this to create renderers for various mime-types in your extension. Many times it will be easier to create a "mime renderer extension" rather than using this service directly.');
    ILatexTypesetter = new import_coreutils19.Token("@jupyterlab/rendermime:ILatexTypesetter", "A service for the LaTeX typesetter for the application. Use this if you want to typeset math in your extension.");
    IMarkdownParser = new import_coreutils19.Token("@jupyterlab/rendermime:IMarkdownParser", "A service for rendering markdown syntax as HTML content.");
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/index.js
var init_lib8 = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/index.js"() {
    init_lib6();
    init_attachmentmodel();
    init_factories();
    init_latex();
    init_mimemodel();
    init_outputmodel();
    init_registry2();
    init_renderers();
    init_tokens2();
    init_widgets();
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/algorithm/dist/index.es6.js
function* map(object2, fn) {
  let index2 = 0;
  for (const value of object2) {
    yield fn(value, index2++);
  }
}
var ArrayExt3, Private15, StringExt2;
var init_index_es611 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt4) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n4 - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (array[j2] === value) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          let j2 = (start + i5) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n4 = array.length;
        if (n4 === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let d6;
        if (start < stop) {
          d6 = start + 1 + (n4 - stop);
        } else {
          d6 = start - stop + 1;
        }
        for (let i5 = 0; i5 < d6; ++i5) {
          let j2 = (start - i5 + n4) % n4;
          if (fn(array[j2], j2)) {
            return j2;
          }
        }
        return -1;
      }
      ArrayExt4.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index2 = findFirstIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index2 = findLastIndex(array, fn, start, stop);
        return index2 !== -1 ? array[index2] : void 0;
      }
      ArrayExt4.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt4.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt4.upperBound = upperBound;
      function shallowEqual(a4, b4, fn) {
        if (a4 === b4) {
          return true;
        }
        if (a4.length !== b4.length) {
          return false;
        }
        for (let i5 = 0, n4 = a4.length; i5 < n4; ++i5) {
          if (fn ? !fn(a4[i5], b4[i5]) : a4[i5] !== b4[i5]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt4.shallowEqual = shallowEqual;
      function slice2(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n4 = array.length;
        if (start === void 0) {
          start = step < 0 ? n4 - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n4, step < 0 ? -1 : 0);
        } else if (start >= n4) {
          start = step < 0 ? n4 - 1 : n4;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n4;
        } else if (stop < 0) {
          stop = Math.max(stop + n4, step < 0 ? -1 : 0);
        } else if (stop >= n4) {
          stop = step < 0 ? n4 - 1 : n4;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result2 = [];
        for (let i5 = 0; i5 < length; ++i5) {
          result2[i5] = array[start + i5 * step];
        }
        return result2;
      }
      ArrayExt4.slice = slice2;
      function move(array, fromIndex, toIndex) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n4);
        } else {
          fromIndex = Math.min(fromIndex, n4 - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n4);
        } else {
          toIndex = Math.min(toIndex, n4 - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d6 = fromIndex < toIndex ? 1 : -1;
        for (let i5 = fromIndex; i5 !== toIndex; i5 += d6) {
          array[i5] = array[i5 + d6];
        }
        array[toIndex] = value;
      }
      ArrayExt4.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        while (start < stop) {
          let a4 = array[start];
          let b4 = array[stop];
          array[start++] = b4;
          array[stop--] = a4;
        }
      }
      ArrayExt4.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt4.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n4 - start);
        } else {
          span = stop - start + 1;
        }
        for (let i5 = 0; i5 < span; ++i5) {
          array[(start + i5) % n4] = value;
        }
      }
      ArrayExt4.fill = fill;
      function insert(array, index2, value) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 = Math.max(0, index2 + n4);
        } else {
          index2 = Math.min(index2, n4);
        }
        for (let i5 = n4; i5 > index2; --i5) {
          array[i5] = array[i5 - 1];
        }
        array[index2] = value;
      }
      ArrayExt4.insert = insert;
      function removeAt(array, index2) {
        let n4 = array.length;
        if (index2 < 0) {
          index2 += n4;
        }
        if (index2 < 0 || index2 >= n4) {
          return void 0;
        }
        let value = array[index2];
        for (let i5 = index2 + 1; i5 < n4; ++i5) {
          array[i5 - 1] = array[i5];
        }
        array.length = n4 - 1;
        return value;
      }
      ArrayExt4.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index2 = firstIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index2 = lastIndexOf(array, value, start, stop);
        if (index2 !== -1) {
          removeAt(array, index2);
        }
        return index2;
      }
      ArrayExt4.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && array[i5] === value) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && array[i5] === value) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index2 = findFirstIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index2 = findLastIndex(array, fn, start, stop);
        if (index2 !== -1) {
          value = removeAt(array, index2);
        }
        return { index: index2, value };
      }
      ArrayExt4.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n4 = array.length;
        if (n4 === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n4);
        } else {
          start = Math.min(start, n4 - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n4);
        } else {
          stop = Math.min(stop, n4 - 1);
        }
        let count = 0;
        for (let i5 = 0; i5 < n4; ++i5) {
          if (start <= stop && i5 >= start && i5 <= stop && fn(array[i5], i5)) {
            count++;
          } else if (stop < start && (i5 <= stop || i5 >= start) && fn(array[i5], i5)) {
            count++;
          } else if (count > 0) {
            array[i5 - count] = array[i5];
          }
        }
        if (count > 0) {
          array.length = n4 - count;
        }
        return count;
      }
      ArrayExt4.removeAllWhere = removeAllWhere;
    })(ArrayExt3 || (ArrayExt3 = {}));
    (function(Private20) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private20.rangeLength = rangeLength;
    })(Private15 || (Private15 = {}));
    (function(StringExt3) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i5 = 0, j2 = start, n4 = query.length; i5 < n4; ++i5, ++j2) {
          j2 = source.indexOf(query[i5], j2);
          if (j2 === -1) {
            return null;
          }
          indices[i5] = j2;
        }
        return indices;
      }
      StringExt3.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5] - start;
          score += j2 * j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last2 = start - 1;
        for (let i5 = 0, n4 = indices.length; i5 < n4; ++i5) {
          let j2 = indices[i5];
          score += j2 - last2 - 1;
          last2 = j2;
        }
        return { score, indices };
      }
      StringExt3.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result2 = [];
        let k = 0;
        let last2 = 0;
        let n4 = indices.length;
        while (k < n4) {
          let i5 = indices[k];
          let j2 = indices[k];
          while (++k < n4 && indices[k] === j2 + 1) {
            j2++;
          }
          if (last2 < i5) {
            result2.push(source.slice(last2, i5));
          }
          if (i5 < j2 + 1) {
            result2.push(fn(source.slice(i5, j2 + 1)));
          }
          last2 = j2 + 1;
        }
        if (last2 < source.length) {
          result2.push(source.slice(last2));
        }
        return result2;
      }
      StringExt3.highlight = highlight;
      function cmp(a4, b4) {
        return a4 < b4 ? -1 : a4 > b4 ? 1 : 0;
      }
      StringExt3.cmp = cmp;
    })(StringExt2 || (StringExt2 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/model.js
var import_coreutils20, OutputAreaModel, Private16;
var init_model = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/model.js"() {
    init_lib7();
    init_lib3();
    init_lib8();
    init_index_es611();
    import_coreutils20 = __toESM(require_dist());
    init_index_es6();
    OutputAreaModel = class {
      /**
       * Construct a new observable outputs instance.
       */
      constructor(options = {}) {
        this.clearNext = false;
        this._lastStream = "";
        this._trusted = false;
        this._isDisposed = false;
        this._stateChanged = new Signal(this);
        this._changed = new Signal(this);
        this._trusted = !!options.trusted;
        this.contentFactory = options.contentFactory || OutputAreaModel.defaultContentFactory;
        this.list = new ObservableList();
        if (options.values) {
          for (const value of options.values) {
            const index2 = this._add(value) - 1;
            const item = this.list.get(index2);
            item.changed.connect(this._onGenericChange, this);
          }
        }
        this.list.changed.connect(this._onListChanged, this);
      }
      /**
       * A signal emitted when an item changes.
       */
      get stateChanged() {
        return this._stateChanged;
      }
      /**
       * A signal emitted when the list of items changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the length of the items in the model.
       */
      get length() {
        return this.list ? this.list.length : 0;
      }
      /**
       * Get whether the model is trusted.
       */
      get trusted() {
        return this._trusted;
      }
      /**
       * Set whether the model is trusted.
       *
       * #### Notes
       * Changing the value will cause all of the models to re-set.
       */
      set trusted(value) {
        if (value === this._trusted) {
          return;
        }
        const trusted = this._trusted = value;
        for (let i5 = 0; i5 < this.list.length; i5++) {
          const oldItem = this.list.get(i5);
          const value2 = oldItem.toJSON();
          const item = this._createItem({ value: value2, trusted });
          this.list.set(i5, item);
          oldItem.dispose();
        }
      }
      /**
       * Test whether the model is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the model.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.list.dispose();
        Signal.clearData(this);
      }
      /**
       * Get an item at the specified index.
       */
      get(index2) {
        return this.list.get(index2);
      }
      /**
       * Set the value at the specified index.
       */
      set(index2, value) {
        value = import_coreutils20.JSONExt.deepCopy(value);
        Private16.normalize(value);
        const item = this._createItem({ value, trusted: this._trusted });
        this.list.set(index2, item);
      }
      /**
       * Add an output, which may be combined with previous output.
       *
       * @returns The total number of outputs.
       *
       * #### Notes
       * The output bundle is copied.
       * Contiguous stream outputs of the same `name` are combined.
       */
      add(output) {
        if (this.clearNext) {
          this.clear();
          this.clearNext = false;
        }
        return this._add(output);
      }
      /**
       * Clear all of the output.
       *
       * @param wait Delay clearing the output until the next message is added.
       */
      clear(wait = false) {
        this._lastStream = "";
        if (wait) {
          this.clearNext = true;
          return;
        }
        for (const item of this.list) {
          item.dispose();
        }
        this.list.clear();
      }
      /**
       * Deserialize the model from JSON.
       *
       * #### Notes
       * This will clear any existing data.
       */
      fromJSON(values2) {
        this.clear();
        for (const value of values2) {
          this._add(value);
        }
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        return Array.from(map(this.list, (output) => output.toJSON()));
      }
      /**
       * Add a copy of the item to the list.
       *
       * @returns The list length
       */
      _add(value) {
        const trusted = this._trusted;
        value = import_coreutils20.JSONExt.deepCopy(value);
        Private16.normalize(value);
        if (isStream(value) && this._lastStream && value.name === this._lastName && this.shouldCombine({
          value,
          lastModel: this.list.get(this.length - 1)
        })) {
          this._lastStream += value.text;
          this._lastStream = Private16.removeOverwrittenChars(this._lastStream);
          value.text = this._lastStream;
          const item2 = this._createItem({ value, trusted });
          const index2 = this.length - 1;
          const prev = this.list.get(index2);
          this.list.set(index2, item2);
          prev.dispose();
          return this.length;
        }
        if (isStream(value)) {
          value.text = Private16.removeOverwrittenChars(value.text);
        }
        const item = this._createItem({ value, trusted });
        if (isStream(value)) {
          this._lastStream = value.text;
          this._lastName = value.name;
        } else {
          this._lastStream = "";
        }
        return this.list.push(item);
      }
      /**
       * Whether a new value should be consolidated with the previous output.
       *
       * This will only be called if the minimal criteria of both being stream
       * messages of the same type.
       */
      shouldCombine(options) {
        return true;
      }
      /**
       * Create an output item and hook up its signals.
       */
      _createItem(options) {
        const factory = this.contentFactory;
        const item = factory.createOutputModel(options);
        return item;
      }
      /**
       * Handle a change to the list.
       */
      _onListChanged(sender, args) {
        switch (args.type) {
          case "add":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            break;
          case "remove":
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
          case "set":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
        }
        this._changed.emit(args);
      }
      /**
       * Handle a change to an item.
       */
      _onGenericChange(itemModel) {
        let idx;
        let item = null;
        for (idx = 0; idx < this.list.length; idx++) {
          item = this.list.get(idx);
          if (item === itemModel) {
            break;
          }
        }
        if (item != null) {
          this._stateChanged.emit(idx);
          this._changed.emit({
            type: "set",
            newIndex: idx,
            oldIndex: idx,
            oldValues: [item],
            newValues: [item]
          });
        }
      }
    };
    (function(OutputAreaModel2) {
      class ContentFactory {
        /**
         * Create an output model.
         */
        createOutputModel(options) {
          return new OutputModel(options);
        }
      }
      OutputAreaModel2.ContentFactory = ContentFactory;
      OutputAreaModel2.defaultContentFactory = new ContentFactory();
    })(OutputAreaModel || (OutputAreaModel = {}));
    (function(Private20) {
      function normalize2(value) {
        if (isStream(value)) {
          if (Array.isArray(value.text)) {
            value.text = value.text.join("\n");
          }
        }
      }
      Private20.normalize = normalize2;
      function fixBackspace2(txt) {
        let tmp = txt;
        do {
          txt = tmp;
          tmp = txt.replace(/[^\n]\x08/gm, "");
        } while (tmp.length < txt.length);
        return txt;
      }
      function fixCarriageReturn(txt) {
        txt = txt.replace(/\r+\n/gm, "\n");
        while (txt.search(/\r[^$]/g) > -1) {
          const base = txt.match(/^(.*)\r+/m)[1];
          let insert = txt.match(/\r+(.*)$/m)[1];
          insert = insert + base.slice(insert.length, base.length);
          txt = txt.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, insert);
        }
        return txt;
      }
      function removeOverwrittenChars(text) {
        return fixCarriageReturn(fixBackspace2(text));
      }
      Private20.removeOverwrittenChars = removeOverwrittenChars;
    })(Private16 || (Private16 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/properties/dist/index.es6.js
var AttachedProperty, Private17;
var init_index_es612 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private17.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map4 = Private17.ensureMap(owner);
        if (this._pid in map4) {
          value = map4[this._pid];
        } else {
          value = map4[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map4 = Private17.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map4 = Private17.ensureMap(owner);
        if (this._pid in map4) {
          oldValue = map4[this._pid];
        } else {
          oldValue = map4[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map4[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare2 = this._compare;
        return compare2 ? compare2(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty2) {
      function clearData(owner) {
        Private17.ownerData.delete(owner);
      }
      AttachedProperty2.clearData = clearData;
    })(AttachedProperty || (AttachedProperty = {}));
    (function(Private20) {
      Private20.ownerData = /* @__PURE__ */ new WeakMap();
      Private20.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map4 = Private20.ownerData.get(owner);
        if (map4) {
          return map4;
        }
        map4 = /* @__PURE__ */ Object.create(null);
        Private20.ownerData.set(owner, map4);
        return map4;
      }
      Private20.ensureMap = ensureMap;
    })(Private17 || (Private17 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/widget.js
var import_services3, import_coreutils21, OUTPUT_AREA_CLASS, OUTPUT_AREA_ITEM_CLASS, OUTPUT_AREA_OUTPUT_CLASS, OUTPUT_AREA_PROMPT_CLASS, OUTPUT_PROMPT_CLASS, EXECUTE_CLASS, OUTPUT_AREA_STDIN_ITEM_CLASS, STDIN_CLASS, STDIN_PROMPT_CLASS, STDIN_INPUT_CLASS, OUTPUT_PROMPT_OVERLAY, OutputArea, OutputPrompt, Stdin, Private18;
var init_widget2 = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/widget.js"() {
    init_lib5();
    import_services3 = __toESM(require_lib());
    init_lib();
    import_coreutils21 = __toESM(require_dist());
    init_index_es612();
    init_index_es6();
    init_index_es63();
    OUTPUT_AREA_CLASS = "jp-OutputArea";
    OUTPUT_AREA_ITEM_CLASS = "jp-OutputArea-child";
    OUTPUT_AREA_OUTPUT_CLASS = "jp-OutputArea-output";
    OUTPUT_AREA_PROMPT_CLASS = "jp-OutputArea-prompt";
    OUTPUT_PROMPT_CLASS = "jp-OutputPrompt";
    EXECUTE_CLASS = "jp-OutputArea-executeResult";
    OUTPUT_AREA_STDIN_ITEM_CLASS = "jp-OutputArea-stdin-item";
    STDIN_CLASS = "jp-Stdin";
    STDIN_PROMPT_CLASS = "jp-Stdin-prompt";
    STDIN_INPUT_CLASS = "jp-Stdin-input";
    OUTPUT_PROMPT_OVERLAY = "jp-OutputArea-promptOverlay";
    OutputArea = class extends Widget {
      /**
       * Construct an output area widget.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this.outputLengthChanged = new Signal(this);
        this._onIOPub = (msg) => {
          const model2 = this.model;
          const msgType = msg.header.msg_type;
          let output;
          const transient = msg.content.transient || {};
          const displayId = transient["display_id"];
          let targets;
          switch (msgType) {
            case "execute_result":
            case "display_data":
            case "stream":
            case "error":
              output = { ...msg.content, output_type: msgType };
              model2.add(output);
              break;
            case "clear_output": {
              const wait = msg.content.wait;
              model2.clear(wait);
              break;
            }
            case "update_display_data":
              output = { ...msg.content, output_type: "display_data" };
              targets = this._displayIdMap.get(displayId);
              if (targets) {
                for (const index2 of targets) {
                  model2.set(index2, output);
                }
              }
              break;
            default:
              break;
          }
          if (displayId && msgType === "display_data") {
            targets = this._displayIdMap.get(displayId) || [];
            targets.push(model2.length - 1);
            this._displayIdMap.set(displayId, targets);
          }
        };
        this._onExecuteReply = (msg) => {
          const model2 = this.model;
          const content = msg.content;
          if (content.status !== "ok") {
            return;
          }
          const payload = content && content.payload;
          if (!payload || !payload.length) {
            return;
          }
          const pages = payload.filter((i5) => i5.source === "page");
          if (!pages.length) {
            return;
          }
          const page = JSON.parse(JSON.stringify(pages[0]));
          const output = {
            output_type: "display_data",
            data: page.data,
            metadata: {}
          };
          model2.add(output);
        };
        this._displayIdMap = /* @__PURE__ */ new Map();
        this._minHeightTimeout = null;
        this._inputRequested = new Signal(this);
        this._toggleScrolling = new Signal(this);
        this._outputTracker = new WidgetTracker({
          namespace: import_coreutils21.UUID.uuid4()
        });
        this._inputHistoryScope = "global";
        super.layout = new PanelLayout();
        this.addClass(OUTPUT_AREA_CLASS);
        this.contentFactory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : OutputArea.defaultContentFactory;
        this.rendermime = options.rendermime;
        this._maxNumberOutputs = (_b = options.maxNumberOutputs) !== null && _b !== void 0 ? _b : Infinity;
        this._translator = (_c = options.translator) !== null && _c !== void 0 ? _c : nullTranslator;
        this._inputHistoryScope = (_d = options.inputHistoryScope) !== null && _d !== void 0 ? _d : "global";
        const model = this.model = options.model;
        for (let i5 = 0; i5 < Math.min(model.length, this._maxNumberOutputs + 1); i5++) {
          const output = model.get(i5);
          this._insertOutput(i5, output);
        }
        model.changed.connect(this.onModelChanged, this);
        model.stateChanged.connect(this.onStateChanged, this);
        if (options.promptOverlay) {
          this._addPromptOverlay();
        }
      }
      /**
       * Narrow the type of OutputArea's layout prop
       */
      get layout() {
        return super.layout;
      }
      /**
       * A read-only sequence of the children widgets in the output area.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * The kernel future associated with the output area.
       */
      get future() {
        return this._future;
      }
      set future(value) {
        if (this.model.isDisposed) {
          throw Error("Model is disposed");
        }
        if (this._future === value) {
          return;
        }
        if (this._future) {
          this._future.dispose();
        }
        this._future = value;
        this.model.clear();
        if (this.widgets.length) {
          this._clear();
          this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
        }
        value.onIOPub = this._onIOPub;
        value.onReply = this._onExecuteReply;
        value.onStdin = (msg) => {
          if (import_services3.KernelMessage.isInputRequestMsg(msg)) {
            this.onInputRequest(msg, value);
          }
        };
      }
      /**
       * Signal emitted when an output area is requesting an input.
       */
      get inputRequested() {
        return this._inputRequested;
      }
      /**
       * The maximum number of output items to display on top and bottom of cell output.
       *
       * ### Notes
       * It is set to Infinity if no trim is applied.
       */
      get maxNumberOutputs() {
        return this._maxNumberOutputs;
      }
      set maxNumberOutputs(limit) {
        if (limit <= 0) {
          console.warn(`OutputArea.maxNumberOutputs must be strictly positive.`);
          return;
        }
        const lastShown = this._maxNumberOutputs;
        this._maxNumberOutputs = limit;
        if (lastShown < limit) {
          this._showTrimmedOutputs(lastShown);
        }
      }
      /**
       * Dispose of the resources used by the output area.
       */
      dispose() {
        if (this._future) {
          this._future.dispose();
          this._future = null;
        }
        this._displayIdMap.clear();
        this._outputTracker.dispose();
        super.dispose();
      }
      /**
       * Follow changes on the model state.
       */
      onModelChanged(sender, args) {
        switch (args.type) {
          case "add":
            this._insertOutput(args.newIndex, args.newValues[0]);
            break;
          case "remove":
            if (this.widgets.length) {
              if (this.model.length === 0) {
                this._clear();
              } else {
                const startIndex = args.oldIndex;
                for (let i5 = 0; i5 < args.oldValues.length && startIndex < this.widgets.length; ++i5) {
                  const widget = this.widgets[startIndex];
                  widget.parent = null;
                  widget.dispose();
                }
                this._moveDisplayIdIndices(startIndex, args.oldValues.length);
                this._preventHeightChangeJitter();
              }
            }
            break;
          case "set":
            this._setOutput(args.newIndex, args.newValues[0]);
            break;
          default:
            break;
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Emitted when user requests toggling of the output scrolling mode.
       */
      get toggleScrolling() {
        return this._toggleScrolling;
      }
      /**
       * Add overlay allowing to toggle scrolling.
       */
      _addPromptOverlay() {
        const overlay = document.createElement("div");
        overlay.className = OUTPUT_PROMPT_OVERLAY;
        const trans = this._translator.load("jupyterlab");
        overlay.title = trans.__("Toggle output scrolling");
        overlay.addEventListener("click", () => {
          this._toggleScrolling.emit();
        });
        this.node.appendChild(overlay);
      }
      /**
       * Update indices in _displayIdMap in response to element remove from model items
       *
       * @param startIndex - The index of first element removed
       *
       * @param count - The number of elements removed from model items
       *
       */
      _moveDisplayIdIndices(startIndex, count) {
        this._displayIdMap.forEach((indices) => {
          const rangeEnd = startIndex + count;
          const numIndices = indices.length;
          for (let i5 = numIndices - 1; i5 >= 0; --i5) {
            const index2 = indices[i5];
            if (index2 >= startIndex && index2 < rangeEnd) {
              indices.splice(i5, 1);
            } else if (index2 >= rangeEnd) {
              indices[i5] -= count;
            }
          }
        });
      }
      /**
       * Follow changes on the output model state.
       */
      onStateChanged(sender, change) {
        const outputLength = Math.min(this.model.length, this._maxNumberOutputs);
        if (change) {
          if (change >= this._maxNumberOutputs) {
            return;
          }
          this._setOutput(change, this.model.get(change));
        } else {
          for (let i5 = 0; i5 < outputLength; i5++) {
            this._setOutput(i5, this.model.get(i5));
          }
        }
        this.outputLengthChanged.emit(outputLength);
      }
      /**
       * Clear the widget outputs.
       */
      _clear() {
        if (!this.widgets.length) {
          return;
        }
        const length = this.widgets.length;
        for (let i5 = 0; i5 < length; i5++) {
          const widget = this.widgets[0];
          widget.parent = null;
          widget.dispose();
        }
        this._displayIdMap.clear();
        this._preventHeightChangeJitter();
      }
      _preventHeightChangeJitter() {
        const rect = this.node.getBoundingClientRect();
        this.node.style.minHeight = `${rect.height}px`;
        if (this._minHeightTimeout) {
          window.clearTimeout(this._minHeightTimeout);
        }
        this._minHeightTimeout = window.setTimeout(() => {
          if (this.isDisposed) {
            return;
          }
          this.node.style.minHeight = "";
        }, 50);
      }
      /**
       * Handle an input request from a kernel.
       */
      onInputRequest(msg, future) {
        const factory = this.contentFactory;
        const stdinPrompt = msg.content.prompt;
        const password = msg.content.password;
        const panel = new Panel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        panel.addClass(OUTPUT_AREA_STDIN_ITEM_CLASS);
        const prompt = factory.createOutputPrompt();
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        const input = factory.createStdin({
          parent_header: msg.header,
          prompt: stdinPrompt,
          password,
          future,
          translator: this._translator,
          inputHistoryScope: this._inputHistoryScope
        });
        input.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(input);
        if (this.model.length >= this.maxNumberOutputs) {
          this.maxNumberOutputs = this.model.length;
        }
        this.layout.addWidget(panel);
        this._inputRequested.emit();
        void input.value.then((value) => {
          if (this.model.length >= this.maxNumberOutputs) {
            this.maxNumberOutputs = this.model.length + 1;
          }
          this.model.add({
            output_type: "stream",
            name: "stdin",
            text: value + "\n"
          });
          panel.dispose();
        });
      }
      /**
       * Update an output in the layout in place.
       */
      _setOutput(index2, model) {
        if (index2 >= this._maxNumberOutputs) {
          return;
        }
        const panel = this.layout.widgets[index2];
        const renderer = panel.widgets ? panel.widgets[1] : panel;
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (Private18.currentPreferredMimetype.get(renderer) === mimeType && OutputArea.isIsolated(mimeType, model.metadata) === renderer instanceof Private18.IsolatedRenderer) {
          void renderer.renderModel(model);
        } else {
          this.layout.widgets[index2].dispose();
          this._insertOutput(index2, model);
        }
      }
      /**
       * Render and insert a single output into the layout.
       *
       * @param index - The index of the output to be inserted.
       * @param model - The model of the output to be inserted.
       */
      _insertOutput(index2, model) {
        if (index2 > this._maxNumberOutputs) {
          return;
        }
        const layout = this.layout;
        if (index2 === this._maxNumberOutputs) {
          const warning = new Private18.TrimmedOutputs(this._maxNumberOutputs, () => {
            const lastShown = this._maxNumberOutputs;
            this._maxNumberOutputs = Infinity;
            this._showTrimmedOutputs(lastShown);
          });
          layout.insertWidget(index2, this._wrappedOutput(warning));
        } else {
          let output = this.createOutputItem(model);
          if (output) {
            output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
          } else {
            output = new Widget();
          }
          if (!this._outputTracker.has(output)) {
            void this._outputTracker.add(output);
          }
          layout.insertWidget(index2, output);
        }
      }
      /**
       * A widget tracker for individual output widgets in the output area.
       */
      get outputTracker() {
        return this._outputTracker;
      }
      /**
       * Dispose information message and show output models from the given
       * index to maxNumberOutputs
       *
       * @param lastShown Starting model index to insert.
       */
      _showTrimmedOutputs(lastShown) {
        this.widgets[lastShown].dispose();
        for (let idx = lastShown; idx < this.model.length; idx++) {
          this._insertOutput(idx, this.model.get(idx));
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Create an output item with a prompt and actual output
       *
       * @returns a rendered widget, or null if we cannot render
       * #### Notes
       */
      createOutputItem(model) {
        const output = this.createRenderedMimetype(model);
        if (!output) {
          return null;
        }
        return this._wrappedOutput(output, model.executionCount);
      }
      /**
       * Render a mimetype
       */
      createRenderedMimetype(model) {
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (!mimeType) {
          return null;
        }
        let output = this.rendermime.createRenderer(mimeType);
        const isolated = OutputArea.isIsolated(mimeType, model.metadata);
        if (isolated === true) {
          output = new Private18.IsolatedRenderer(output);
        }
        Private18.currentPreferredMimetype.set(output, mimeType);
        output.renderModel(model).catch((error) => {
          const pre = document.createElement("pre");
          const trans = this._translator.load("jupyterlab");
          pre.textContent = trans.__("Javascript Error: %1", error.message);
          output.node.appendChild(pre);
          output.node.className = "lm-Widget jp-RenderedText";
          output.node.setAttribute("data-mime-type", "application/vnd.jupyter.stderr");
        });
        return output;
      }
      /**
       * Wrap a output widget within a output panel
       *
       * @param output Output widget to wrap
       * @param executionCount Execution count
       * @returns The output panel
       */
      _wrappedOutput(output, executionCount = null) {
        const panel = new Private18.OutputPanel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        const prompt = this.contentFactory.createOutputPrompt();
        prompt.executionCount = executionCount;
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(output);
        return panel;
      }
    };
    (function(OutputArea2) {
      async function execute(code3, output, sessionContext, metadata) {
        var _a;
        let stopOnError = true;
        if (metadata && Array.isArray(metadata.tags) && metadata.tags.indexOf("raises-exception") !== -1) {
          stopOnError = false;
        }
        const content = {
          code: code3,
          stop_on_error: stopOnError
        };
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
          throw new Error("Session has no kernel.");
        }
        const future = kernel.requestExecute(content, false, metadata);
        output.future = future;
        return future.done;
      }
      OutputArea2.execute = execute;
      function isIsolated(mimeType, metadata) {
        const mimeMd = metadata[mimeType];
        if (mimeMd && mimeMd["isolated"] !== void 0) {
          return !!mimeMd["isolated"];
        } else {
          return !!metadata["isolated"];
        }
      }
      OutputArea2.isIsolated = isIsolated;
      class ContentFactory {
        /**
         * Create the output prompt for the widget.
         */
        createOutputPrompt() {
          return new OutputPrompt();
        }
        /**
         * Create an stdin widget.
         */
        createStdin(options) {
          return new Stdin(options);
        }
      }
      OutputArea2.ContentFactory = ContentFactory;
      OutputArea2.defaultContentFactory = new ContentFactory();
    })(OutputArea || (OutputArea = {}));
    OutputPrompt = class extends Widget {
      /*
       * Create an output prompt widget.
       */
      constructor() {
        super();
        this._executionCount = null;
        this.addClass(OUTPUT_PROMPT_CLASS);
      }
      /**
       * The execution count for the prompt.
       */
      get executionCount() {
        return this._executionCount;
      }
      set executionCount(value) {
        this._executionCount = value;
        if (value === null) {
          this.node.textContent = "";
        } else {
          this.node.textContent = `[${value}]:`;
        }
      }
    };
    Stdin = class extends Widget {
      static _historyIx(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        if (ix <= 0) {
          return len + ix;
        }
      }
      static _historyAt(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        if (ixpos !== void 0 && ixpos < len) {
          return history2[ixpos];
        }
      }
      static _historyPush(key, line) {
        const history2 = Stdin._history.get(key);
        history2.push(line);
        if (history2.length > 1e3) {
          history2.shift();
        }
      }
      static _historySearch(key, pat, ix, reverse = true) {
        const history2 = Stdin._history.get(key);
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        const substrFound = (x4) => x4.search(pat) !== -1;
        if (ixpos === void 0) {
          return;
        }
        if (reverse) {
          if (ixpos === 0) {
            return;
          }
          const ixFound = history2.slice(0, ixpos).findLastIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len;
          }
        } else {
          if (ixpos >= len - 1) {
            return;
          }
          const ixFound = history2.slice(ixpos + 1).findIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len + ixpos + 1;
          }
        }
      }
      /**
       * Construct a new input widget.
       */
      constructor(options) {
        var _a;
        super({
          node: Private18.createInputWidgetNode(options.prompt, options.password)
        });
        this._promise = new import_coreutils21.PromiseDelegate();
        this.addClass(STDIN_CLASS);
        this._future = options.future;
        this._historyIndex = 0;
        this._historyKey = options.inputHistoryScope === "session" ? options.parent_header.session : "";
        this._historyPat = "";
        this._parentHeader = options.parent_header;
        this._password = options.password;
        this._trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
        this._value = options.prompt + " ";
        this._input = this.node.getElementsByTagName("input")[0];
        this._input.placeholder = this._trans.__("\u2191\u2193 for history. Search history with c-\u2191/c-\u2193");
        if (!Stdin._history.has(this._historyKey)) {
          Stdin._history.set(this._historyKey, []);
        }
      }
      /**
       * The value of the widget.
       */
      get value() {
        return this._promise.promise.then(() => this._value);
      }
      /**
       * Handle the DOM events for the widget.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the dock panel's node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        const input = this._input;
        if (event.type === "keydown") {
          if (event.key === "Enter") {
            this.resetSearch();
            this._future.sendInputReply({
              status: "ok",
              value: input.value
            }, this._parentHeader);
            if (this._password) {
              this._value += "\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7";
            } else {
              this._value += input.value;
              Stdin._historyPush(this._historyKey, input.value);
            }
            this._promise.resolve(void 0);
          } else if (event.key === "Escape") {
            this.resetSearch();
            input.blur();
          } else if (event.ctrlKey && (event.key === "ArrowUp" || event.key === "ArrowDown")) {
            if (this._historyPat === "") {
              this._historyPat = input.value;
            }
            const reverse = event.key === "ArrowUp";
            const searchHistoryIx = Stdin._historySearch(this._historyKey, this._historyPat, this._historyIndex, reverse);
            if (searchHistoryIx !== void 0) {
              const historyLine = Stdin._historyAt(this._historyKey, searchHistoryIx);
              if (historyLine !== void 0) {
                if (this._historyIndex === 0) {
                  this._valueCache = input.value;
                }
                this._setInputValue(historyLine);
                this._historyIndex = searchHistoryIx;
                event.preventDefault();
              }
            }
          } else if (event.key === "ArrowUp") {
            this.resetSearch();
            const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex - 1);
            if (historyLine) {
              if (this._historyIndex === 0) {
                this._valueCache = input.value;
              }
              this._setInputValue(historyLine);
              --this._historyIndex;
              event.preventDefault();
            }
          } else if (event.key === "ArrowDown") {
            this.resetSearch();
            if (this._historyIndex === 0) {
            } else if (this._historyIndex === -1) {
              this._setInputValue(this._valueCache);
              ++this._historyIndex;
            } else {
              const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex + 1);
              if (historyLine) {
                this._setInputValue(historyLine);
                ++this._historyIndex;
              }
            }
          }
        }
      }
      resetSearch() {
        this._historyPat = "";
      }
      /**
       * Handle `after-attach` messages sent to the widget.
       */
      onAfterAttach(msg) {
        this._input.addEventListener("keydown", this);
        this._input.focus();
      }
      /**
       * Handle `before-detach` messages sent to the widget.
       */
      onBeforeDetach(msg) {
        this._input.removeEventListener("keydown", this);
      }
      _setInputValue(value) {
        this._input.value = value;
        this._input.setSelectionRange(value.length, value.length);
      }
    };
    Stdin._history = /* @__PURE__ */ new Map();
    (function(Private20) {
      function createInputWidgetNode(prompt, password) {
        const node = document.createElement("div");
        const promptNode = document.createElement("pre");
        promptNode.className = STDIN_PROMPT_CLASS;
        promptNode.textContent = prompt;
        const input = document.createElement("input");
        input.className = STDIN_INPUT_CLASS;
        if (password) {
          input.type = "password";
        }
        node.appendChild(promptNode);
        promptNode.appendChild(input);
        return node;
      }
      Private20.createInputWidgetNode = createInputWidgetNode;
      class IsolatedRenderer extends Widget {
        /**
         * Create an isolated renderer.
         */
        constructor(wrapped) {
          super({ node: document.createElement("iframe") });
          this.addClass("jp-mod-isolated");
          this._wrapped = wrapped;
          const iframe = this.node;
          iframe.frameBorder = "0";
          iframe.scrolling = "auto";
          iframe.addEventListener("load", () => {
            iframe.contentDocument.open();
            iframe.contentDocument.write(this._wrapped.node.innerHTML);
            iframe.contentDocument.close();
            const body = iframe.contentDocument.body;
            iframe.style.height = `${body.scrollHeight}px`;
            iframe.heightChangeObserver = new ResizeObserver(() => {
              iframe.style.height = `${body.scrollHeight}px`;
            });
            iframe.heightChangeObserver.observe(body);
          });
        }
        /**
         * Render a mime model.
         *
         * @param model - The mime model to render.
         *
         * @returns A promise which resolves when rendering is complete.
         *
         * #### Notes
         * This method may be called multiple times during the lifetime
         * of the widget to update it if and when new data is available.
         */
        renderModel(model) {
          return this._wrapped.renderModel(model);
        }
      }
      Private20.IsolatedRenderer = IsolatedRenderer;
      Private20.currentPreferredMimetype = new AttachedProperty({
        name: "preferredMimetype",
        create: (owner) => ""
      });
      class OutputPanel extends Panel {
        /**
         * Construct a new `OutputPanel` widget.
         */
        constructor(options) {
          super(options);
        }
        /**
         * A callback that focuses on the widget.
         */
        _onContext(_5) {
          this.node.focus();
        }
        /**
         * Handle `after-attach` messages sent to the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("contextmenu", this._onContext.bind(this));
        }
        /**
         * Handle `before-detach` messages sent to the widget.
         */
        onBeforeDetach(msg) {
          super.onAfterDetach(msg);
          this.node.removeEventListener("contextmenu", this._onContext.bind(this));
        }
      }
      Private20.OutputPanel = OutputPanel;
      class TrimmedOutputs extends Widget {
        /**
         * Widget constructor
         *
         * ### Notes
         * The widget will be disposed on click after calling the callback.
         *
         * @param maxNumberOutputs Maximal number of outputs to display
         * @param _onClick Callback on click event on the widget
         */
        constructor(maxNumberOutputs, onClick) {
          const node = document.createElement("div");
          const title = `The first ${maxNumberOutputs} are displayed`;
          const msg = "Show more outputs";
          node.insertAdjacentHTML("afterbegin", `<a title=${title}>
          <pre>${msg}</pre>
        </a>`);
          super({
            node
          });
          this._onClick = onClick;
          this.addClass("jp-TrimmedOutputs");
          this.addClass("jp-RenderedHTMLCommon");
        }
        /**
         * Handle the DOM events for widget.
         *
         * @param event - The DOM event sent to the widget.
         *
         * #### Notes
         * This method implements the DOM `EventListener` interface and is
         * called in response to events on the widget's DOM node. It should
         * not be called directly by user code.
         */
        handleEvent(event) {
          if (event.type === "click") {
            this._onClick(event);
          }
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("click", this);
        }
        /**
         * A message handler invoked on a `'before-detach'`
         * message
         */
        onBeforeDetach(msg) {
          super.onBeforeDetach(msg);
          this.node.removeEventListener("click", this);
        }
      }
      Private20.TrimmedOutputs = TrimmedOutputs;
    })(Private18 || (Private18 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/index.js
var init_lib9 = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/index.js"() {
    init_model();
    init_widget2();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js
var import_coreutils22, WidgetRenderer;
var init_renderer = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js"() {
    import_coreutils22 = __toESM(require_dist());
    init_index_es63();
    WidgetRenderer = class extends Panel {
      constructor(options, manager) {
        super();
        this._manager = new import_coreutils22.PromiseDelegate();
        this._rerenderMimeModel = null;
        this.mimeType = options.mimeType;
        if (manager) {
          this.manager = manager;
        }
      }
      /**
       * The widget manager.
       */
      set manager(value) {
        value.restored.connect(this._rerender, this);
        this._manager.resolve(value);
      }
      async renderModel(model) {
        const source = model.data[this.mimeType];
        this.node.textContent = "Loading widget...";
        const manager = await this._manager.promise;
        if (source.model_id === "") {
          this.hide();
          return Promise.resolve();
        }
        let wModel;
        try {
          wModel = await manager.get_model(source.model_id);
        } catch (err) {
          if (manager.restoredStatus) {
            this.node.textContent = "Error displaying widget: model not found";
            this.addClass("jupyter-widgets");
            console.error(err);
            return;
          }
          this._rerenderMimeModel = model;
          return;
        }
        this._rerenderMimeModel = null;
        let widget;
        try {
          widget = (await manager.create_view(wModel)).luminoWidget;
        } catch (err) {
          this.node.textContent = "Error displaying widget";
          this.addClass("jupyter-widgets");
          console.error(err);
          return;
        }
        this.node.textContent = "";
        this.addWidget(widget);
        widget.disposed.connect(() => {
          this.hide();
          source.model_id = "";
        });
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._manager = null;
        super.dispose();
      }
      _rerender() {
        if (this._rerenderMimeModel) {
          this.node.textContent = "";
          this.removeClass("jupyter-widgets");
          this.renderModel(this._rerenderMimeModel);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/utils.js
function difference(a4, b4) {
  return a4.filter((v2) => b4.indexOf(v2) === -1);
}
function isEqual(a4, b4) {
  return (0, import_isEqual.default)(a4, b4);
}
function uuid() {
  return import_coreutils23.UUID.uuid4();
}
function resolvePromisesDict(d6) {
  const keys2 = Object.keys(d6);
  const values2 = [];
  keys2.forEach(function(key) {
    values2.push(d6[key]);
  });
  return Promise.all(values2).then((v2) => {
    const d7 = {};
    for (let i5 = 0; i5 < keys2.length; i5++) {
      d7[keys2[i5]] = v2[i5];
    }
    return d7;
  });
}
function reject(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
function put_buffers(state, buffer_paths, buffers) {
  for (let i5 = 0; i5 < buffer_paths.length; i5++) {
    const buffer_path = buffer_paths[i5];
    let buffer = buffers[i5];
    if (!(buffer instanceof DataView)) {
      buffer = new DataView(buffer instanceof ArrayBuffer ? buffer : buffer.buffer);
    }
    let obj = state;
    for (let j2 = 0; j2 < buffer_path.length - 1; j2++) {
      obj = obj[buffer_path[j2]];
    }
    obj[buffer_path[buffer_path.length - 1]] = buffer;
  }
}
function isSerializable(object2) {
  var _a;
  return (_a = typeof object2 === "object" && object2 && "toJSON" in object2) !== null && _a !== void 0 ? _a : false;
}
function isObject(data) {
  return import_coreutils23.JSONExt.isObject(data);
}
function remove_buffers(state) {
  const buffers = [];
  const buffer_paths = [];
  function remove2(obj, path) {
    if (isSerializable(obj)) {
      obj = obj.toJSON();
    }
    if (Array.isArray(obj)) {
      let is_cloned = false;
      for (let i5 = 0; i5 < obj.length; i5++) {
        const value = obj[i5];
        if (value) {
          if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            if (!is_cloned) {
              obj = obj.slice();
              is_cloned = true;
            }
            buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
            buffer_paths.push(path.concat([i5]));
            obj[i5] = null;
          } else {
            const new_value = remove2(value, path.concat([i5]));
            if (new_value !== value) {
              if (!is_cloned) {
                obj = obj.slice();
                is_cloned = true;
              }
              obj[i5] = new_value;
            }
          }
        }
      }
    } else if (isObject(obj)) {
      for (const key in obj) {
        let is_cloned = false;
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (value) {
            if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
              if (!is_cloned) {
                obj = Object.assign({}, obj);
                is_cloned = true;
              }
              buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
              buffer_paths.push(path.concat([key]));
              delete obj[key];
            } else {
              const new_value = remove2(value, path.concat([key]));
              if (new_value !== value) {
                if (!is_cloned) {
                  obj = Object.assign({}, obj);
                  is_cloned = true;
                }
                obj[key] = new_value;
              }
            }
          }
        }
      }
    }
    return obj;
  }
  const new_state = remove2(state, []);
  return { state: new_state, buffers, buffer_paths };
}
var import_coreutils23, import_isEqual, assign, BROKEN_FILE_SVG_ICON;
var init_utils = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/utils.js"() {
    import_coreutils23 = __toESM(require_dist());
    import_isEqual = __toESM(require_isEqual());
    assign = Object.assign || function(t10, ...args) {
      for (let i5 = 1; i5 < args.length; i5++) {
        const s7 = args[i5];
        for (const p3 in s7) {
          if (Object.prototype.hasOwnProperty.call(s7, p3)) {
            t10[p3] = s7[p3];
          }
        }
      }
      return t10;
    };
    BROKEN_FILE_SVG_ICON = `<svg style="height:50%;max-height: 50px;" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
<g >
  <g transform="translate(0.24520123,0.93464292)">
    <path  d="M 8.2494641,21.074514 V 5.6225142 c 0,-0.314 0.254,-0.567 0.57,-0.567 H 29.978464 c 2.388,0 9.268,5.8269998 9.268,8.3029998 v 5.5835 l -3.585749,4.407396 -2.772971,-3.535534 -5.126524,3.414213 -5.944543,-3.237436 -5.722718,3.06066 z m 30.9969999,3.8675 v 15.5835 c 0,0.314 -0.254,0.567 -0.57,0.567 H 8.8194641 c -0.315,0.002 -0.57,-0.251 -0.57,-0.566 v -15.452 l 7.8444949,2.628449 5.656854,-2.65165 4.24264,3.005204 5.833631,-3.237437 3.712311,3.944543 z" style="fill:url(#linearGradient3448);stroke:#888a85"  />
    <path d="m 30.383464,12.110514 c 4.108,0.159 7.304,-0.978 8.867,1.446 0.304,-3.9679998 -7.254,-8.8279998 -9.285,-8.4979998 0.813,0.498 0.418,7.0519998 0.418,7.0519998 z" style="fill:url(#linearGradient3445);stroke:#868a84" />
    <path enable-background="new" d="m 31.443464,11.086514 c 2.754,-0.019 4.106,-0.49 5.702,0.19 -1.299,-1.8809998 -4.358,-3.3439998 -5.728,-4.0279998 0.188,0.775 0.026,3.8379998 0.026,3.8379998 z" style="opacity:0.36930003;fill:none;stroke:url(#linearGradient3442)" />
  </g>
</g>
</svg>`;
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js
function set(key, val, options) {
  if (key == null) {
    return this;
  }
  let attrs;
  if (import_coreutils24.JSONExt.isObject(key)) {
    attrs = key;
    options = val;
  } else {
    (attrs = {})[key] = val;
  }
  options || (options = {});
  if (!this._validate(attrs, options)) {
    return false;
  }
  const unset = options.unset;
  const silent = options.silent;
  const changes = [];
  const changing = this._changing;
  this._changing = true;
  try {
    if (!changing) {
      this._previousAttributes = Object.assign({}, this.attributes);
      this.changed = {};
    }
    const current = this.attributes;
    const changed = this.changed;
    const prev = this._previousAttributes;
    for (const attr in attrs) {
      val = attrs[attr];
      if (!isEqual(current[attr], val)) {
        changes.push(attr);
      }
      if (!isEqual(prev[attr], val)) {
        changed[attr] = val;
      } else {
        delete changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }
    this.id = this.get(this.idAttribute);
    if (!silent) {
      if (changes.length) {
        this._pending = options;
      }
      for (let i5 = 0; i5 < changes.length; i5++) {
        this.trigger("change:" + changes[i5], this, current[changes[i5]], options);
      }
    }
    if (changing) {
      return this;
    }
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger("change", this, options);
      }
    }
  } finally {
    this._pending = false;
    this._changing = false;
  }
  return this;
}
var import_coreutils24;
var init_backbone_patch = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js"() {
    init_utils();
    import_coreutils24 = __toESM(require_dist());
  }
});

// ../../node_modules/underscore/modules/_setup.js
var VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "../../node_modules/underscore/modules/_setup.js"() {
    VERSION = "1.13.6";
    root = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// ../../node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
    for (; index2 < length; index2++) {
      rest2[index2] = arguments[index2 + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index2 = 0; index2 < startIndex; index2++) {
      args[index2] = arguments[index2];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "../../node_modules/underscore/modules/restArguments.js"() {
  }
});

// ../../node_modules/underscore/modules/isObject.js
function isObject2(obj) {
  var type2 = typeof obj;
  return type2 === "function" || type2 === "object" && !!obj;
}
var init_isObject = __esm({
  "../../node_modules/underscore/modules/isObject.js"() {
  }
});

// ../../node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}
var init_isNull = __esm({
  "../../node_modules/underscore/modules/isNull.js"() {
  }
});

// ../../node_modules/underscore/modules/isUndefined.js
function isUndefined2(obj) {
  return obj === void 0;
}
var init_isUndefined = __esm({
  "../../node_modules/underscore/modules/isUndefined.js"() {
  }
});

// ../../node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "../../node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isElement.js
function isElement2(obj) {
  return !!(obj && obj.nodeType === 1);
}
var init_isElement = __esm({
  "../../node_modules/underscore/modules/isElement.js"() {
  }
});

// ../../node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var init_tagTester = __esm({
  "../../node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "../../node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// ../../node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "../../node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// ../../node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "../../node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// ../../node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "../../node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// ../../node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "../../node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// ../../node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "../../node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// ../../node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "../../node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// ../../node_modules/underscore/modules/isFunction.js
var isFunction2, nodelist, isFunction_default;
var init_isFunction = __esm({
  "../../node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction2 = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction2 = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    isFunction_default = isFunction2;
  }
});

// ../../node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "../../node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// ../../node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug, isIE11;
var init_stringTagBug = __esm({
  "../../node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// ../../node_modules/underscore/modules/isDataView.js
function ie10IsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "../../node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;
  }
});

// ../../node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "../../node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// ../../node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var init_has = __esm({
  "../../node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "../../node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has(obj, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// ../../node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
var init_isFinite = __esm({
  "../../node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// ../../node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}
var init_isNaN = __esm({
  "../../node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// ../../node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "../../node_modules/underscore/modules/constant.js"() {
  }
});

// ../../node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "../../node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var init_shallowProperty = __esm({
  "../../node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// ../../node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "../../node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// ../../node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "../../node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// ../../node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "../../node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// ../../node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "../../node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// ../../node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l7 = keys2.length, i5 = 0; i5 < l7; ++i5)
    hash[keys2[i5]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "../../node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// ../../node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject2(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_keys = __esm({
  "../../node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj)))
    return length === 0;
  return getLength_default(keys(obj)) === 0;
}
var init_isEmpty = __esm({
  "../../node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i5 = 0; i5 < length; i5++) {
    var key = _keys[i5];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}
var init_isMatch = __esm({
  "../../node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _)
    return obj;
  if (!(this instanceof _))
    return new _(obj);
  this._wrapped = obj;
}
var init_underscore = __esm({
  "../../node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// ../../node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "../../node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// ../../node_modules/underscore/modules/isEqual.js
function eq(a4, b4, aStack, bStack) {
  if (a4 === b4)
    return a4 !== 0 || 1 / a4 === 1 / b4;
  if (a4 == null || b4 == null)
    return false;
  if (a4 !== a4)
    return b4 !== b4;
  var type2 = typeof a4;
  if (type2 !== "function" && type2 !== "object" && typeof b4 != "object")
    return false;
  return deepEq(a4, b4, aStack, bStack);
}
function deepEq(a4, b4, aStack, bStack) {
  if (a4 instanceof _)
    a4 = a4._wrapped;
  if (b4 instanceof _)
    b4 = b4._wrapped;
  var className = toString.call(a4);
  if (className !== toString.call(b4))
    return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a4)) {
    if (!isDataView_default(b4))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a4 === "" + b4;
    case "[object Number]":
      if (+a4 !== +a4)
        return +b4 !== +b4;
      return +a4 === 0 ? 1 / +a4 === 1 / b4 : +a4 === +b4;
    case "[object Date]":
    case "[object Boolean]":
      return +a4 === +b4;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a4) === SymbolProto.valueOf.call(b4);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a4), toBufferView(b4), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a4)) {
    var byteLength = getByteLength_default(a4);
    if (byteLength !== getByteLength_default(b4))
      return false;
    if (a4.buffer === b4.buffer && a4.byteOffset === b4.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a4 != "object" || typeof b4 != "object")
      return false;
    var aCtor = a4.constructor, bCtor = b4.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a4 && "constructor" in b4)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a4)
      return bStack[length] === b4;
  }
  aStack.push(a4);
  bStack.push(b4);
  if (areArrays) {
    length = a4.length;
    if (length !== b4.length)
      return false;
    while (length--) {
      if (!eq(a4[length], b4[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a4), key;
    length = _keys.length;
    if (keys(b4).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b4, key) && eq(a4[key], b4[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual2(a4, b4) {
  return eq(a4, b4);
}
var tagDataView;
var init_isEqual = __esm({
  "../../node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// ../../node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject2(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "../../node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2))
      return false;
    for (var i5 = 0; i5 < length; i5++) {
      if (!isFunction_default(obj[methods[i5]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "../../node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// ../../node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "../../node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// ../../node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "../../node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// ../../node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "../../node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// ../../node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "../../node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// ../../node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i5 = 0; i5 < length; i5++) {
    values2[i5] = obj[_keys[i5]];
  }
  return values2;
}
var init_values = __esm({
  "../../node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs3 = Array(length);
  for (var i5 = 0; i5 < length; i5++) {
    pairs3[i5] = [_keys[i5], obj[_keys[i5]]];
  }
  return pairs3;
}
var init_pairs = __esm({
  "../../node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i5 = 0, length = _keys.length; i5 < length; i5++) {
    result2[obj[_keys[i5]]] = _keys[i5];
  }
  return result2;
}
var init_invert = __esm({
  "../../node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key]))
      names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "../../node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// ../../node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index2 = 1; index2 < length; index2++) {
      var source = arguments[index2], keys2 = keysFunc(source), l7 = keys2.length;
      for (var i5 = 0; i5 < l7; i5++) {
        var key = keys2[i5];
        if (!defaults || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}
var init_createAssigner = __esm({
  "../../node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// ../../node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "../../node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// ../../node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "../../node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// ../../node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "../../node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// ../../node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject2(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "../../node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// ../../node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "../../node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// ../../node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject2(obj))
    return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}
var init_clone = __esm({
  "../../node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// ../../node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
var init_tap = __esm({
  "../../node_modules/underscore/modules/tap.js"() {
  }
});

// ../../node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
var init_toPath = __esm({
  "../../node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// ../../node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _.toPath(path);
}
var init_toPath2 = __esm({
  "../../node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// ../../node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path) {
  var length = path.length;
  for (var i5 = 0; i5 < length; i5++) {
    if (obj == null)
      return void 0;
    obj = obj[path[i5]];
  }
  return length ? obj : void 0;
}
var init_deepGet = __esm({
  "../../node_modules/underscore/modules/_deepGet.js"() {
  }
});

// ../../node_modules/underscore/modules/get.js
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined2(value) ? defaultValue : value;
}
var init_get = __esm({
  "../../node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// ../../node_modules/underscore/modules/has.js
function has2(obj, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i5 = 0; i5 < length; i5++) {
    var key = path[i5];
    if (!has(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "../../node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "../../node_modules/underscore/modules/identity.js"() {
  }
});

// ../../node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
var init_matcher = __esm({
  "../../node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// ../../node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}
var init_property = __esm({
  "../../node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index2, collection) {
        return func.call(context, value, index2, collection);
      };
    case 4:
      return function(accumulator, value, index2, collection) {
        return func.call(context, accumulator, value, index2, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "../../node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// ../../node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction_default(value))
    return optimizeCb(value, context, argCount);
  if (isObject2(value) && !isArray_default(value))
    return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "../../node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "../../node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// ../../node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee)
    return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "../../node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// ../../node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys[index2];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_mapObject = __esm({
  "../../node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/noop.js
function noop2() {
}
var init_noop = __esm({
  "../../node_modules/underscore/modules/noop.js"() {
  }
});

// ../../node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null)
    return noop2;
  return function(path) {
    return get(obj, path);
  };
}
var init_propertyOf = __esm({
  "../../node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// ../../node_modules/underscore/modules/times.js
function times(n4, iteratee2, context) {
  var accum = Array(Math.max(0, n4));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i5 = 0; i5 < n4; i5++)
    accum[i5] = iteratee2(i5);
  return accum;
}
var init_times = __esm({
  "../../node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/random.js
function random(min3, max3) {
  if (max3 == null) {
    max3 = min3;
    min3 = 0;
  }
  return min3 + Math.floor(Math.random() * (max3 - min3 + 1));
}
var init_random = __esm({
  "../../node_modules/underscore/modules/random.js"() {
  }
});

// ../../node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "../../node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// ../../node_modules/underscore/modules/_createEscaper.js
function createEscaper(map4) {
  var escaper = function(match) {
    return map4[match];
  };
  var source = "(?:" + keys(map4).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "../../node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "../../node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// ../../node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "../../node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "../../node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "../../node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// ../../node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "../../node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// ../../node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index2 = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate2, offset2) {
    source += text.slice(index2, offset2).replace(escapeRegExp, escapeChar);
    index2 = offset2 + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate2) {
      source += "';\n" + evaluate2 + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e4) {
    e4.source = source;
    throw e4;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "../../node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// ../../node_modules/underscore/modules/result.js
function result(obj, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i5 = 0; i5 < length; i5++) {
    var prop = obj == null ? void 0 : obj[path[i5]];
    if (prop === void 0) {
      prop = fallback;
      i5 = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var init_result = __esm({
  "../../node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "../../node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// ../../node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "../../node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject2(result2))
    return result2;
  return self2;
}
var init_executeBound = __esm({
  "../../node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// ../../node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "../../node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder2 = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i5 = 0; i5 < length; i5++) {
          args[i5] = boundArgs[i5] === placeholder2 ? arguments[position++] : boundArgs[i5];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// ../../node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "../../node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// ../../node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "../../node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// ../../node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i5 = 0, length = getLength_default(input); i5 < length; i5++) {
    var value = input[i5];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j2 = 0, len = value.length;
        while (j2 < len)
          output[idx++] = value[j2++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "../../node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// ../../node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "../../node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj, keys2) {
      keys2 = flatten(keys2, false, false);
      var index2 = keys2.length;
      if (index2 < 1)
        throw new Error("bindAll must be passed function names");
      while (index2--) {
        var key = keys2[index2];
        obj[key] = bind_default(obj[key], obj);
      }
      return obj;
    });
  }
});

// ../../node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache2 = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache2, address))
      cache2[address] = func.apply(this, arguments);
    return cache2[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "../../node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// ../../node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "../../node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// ../../node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "../../node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// ../../node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "../../node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// ../../node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "../../node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// ../../node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "../../node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// ../../node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "../../node_modules/underscore/modules/negate.js"() {
  }
});

// ../../node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i5 = start;
    var result2 = args[start].apply(this, arguments);
    while (i5--)
      result2 = args[i5].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "../../node_modules/underscore/modules/compose.js"() {
  }
});

// ../../node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "../../node_modules/underscore/modules/after.js"() {
  }
});

// ../../node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}
var init_before = __esm({
  "../../node_modules/underscore/modules/before.js"() {
  }
});

// ../../node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "../../node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// ../../node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i5 = 0, length = _keys.length; i5 < length; i5++) {
    key = _keys[i5];
    if (predicate(obj[key], key, obj))
      return key;
  }
}
var init_findKey = __esm({
  "../../node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index2 = dir > 0 ? 0 : length - 1;
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      if (predicate(array[index2], index2, array))
        return index2;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "../../node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// ../../node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "../../node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// ../../node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "../../node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i5 = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i5 = idx >= 0 ? idx : Math.max(idx + length, i5);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i5, length), isNaN2);
      return idx >= 0 ? idx + i5 : -1;
    }
    for (idx = dir > 0 ? i5 : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// ../../node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "../../node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// ../../node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "../../node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// ../../node_modules/underscore/modules/find.js
function find2(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}
var init_find = __esm({
  "../../node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// ../../node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find2(obj, matcher(attrs));
}
var init_findWhere = __esm({
  "../../node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/each.js
function each2(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i5, length;
  if (isArrayLike_default(obj)) {
    for (i5 = 0, length = obj.length; i5 < length; i5++) {
      iteratee2(obj[i5], i5, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i5 = 0, length = _keys.length; i5 < length; i5++) {
      iteratee2(obj[_keys[i5]], _keys[i5], obj);
    }
  }
  return obj;
}
var init_each = __esm({
  "../../node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/map.js
function map2(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    results[index2] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_map = __esm({
  "../../node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer3 = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index2] : index2];
      index2 += dir;
    }
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      var currentKey = _keys ? _keys[index2] : index2;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer3(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "../../node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "../../node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// ../../node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "../../node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// ../../node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each2(obj, function(value, index2, list) {
    if (predicate(value, index2, list))
      results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "../../node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/reject.js
function reject2(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "../../node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// ../../node_modules/underscore/modules/every.js
function every2(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}
var init_every = __esm({
  "../../node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/some.js
function some2(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}
var init_some = __esm({
  "../../node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "../../node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// ../../node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "../../node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction_default(path)) {
        func = path;
      } else {
        path = toPath2(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map2(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null)
            return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// ../../node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map2(obj, property(key));
}
var init_pluck = __esm({
  "../../node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// ../../node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
var init_where = __esm({
  "../../node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/max.js
function max2(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i5 = 0, length = obj.length; i5 < length; i5++) {
      value = obj[i5];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v2, index2, list) {
      computed = iteratee2(v2, index2, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v2;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "../../node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/min.js
function min2(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i5 = 0, length = obj.length; i5 < length; i5++) {
      value = obj[i5];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v2, index2, list) {
      computed = iteratee2(v2, index2, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v2;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "../../node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/toArray.js
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray_default(obj))
    return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj))
    return map2(obj, identity);
  return values(obj);
}
var reStrSymbol;
var init_toArray = __esm({
  "../../node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// ../../node_modules/underscore/modules/sample.js
function sample(obj, n4, guard) {
  if (n4 == null || guard) {
    if (!isArrayLike_default(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n4 = Math.max(Math.min(n4, length), 0);
  var last2 = length - 1;
  for (var index2 = 0; index2 < n4; index2++) {
    var rand = random(index2, last2);
    var temp = sample2[index2];
    sample2[index2] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n4);
}
var init_sample = __esm({
  "../../node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// ../../node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}
var init_shuffle = __esm({
  "../../node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// ../../node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index2 = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map2(obj, function(value, key, list) {
    return {
      value,
      index: index2++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a4 = left.criteria;
    var b4 = right.criteria;
    if (a4 !== b4) {
      if (a4 > b4 || a4 === void 0)
        return 1;
      if (a4 < b4 || b4 === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "../../node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// ../../node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(value, index2) {
      var key = iteratee2(value, index2, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "../../node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "../../node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key].push(value);
      else
        result2[key] = [value];
    });
  }
});

// ../../node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "../../node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// ../../node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "../../node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
  }
});

// ../../node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "../../node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// ../../node_modules/underscore/modules/size.js
function size2(obj) {
  if (obj == null)
    return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}
var init_size = __esm({
  "../../node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}
var init_keyInObj = __esm({
  "../../node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// ../../node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "../../node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null)
        return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj = Object(obj);
      }
      for (var i5 = 0, length = keys2.length; i5 < length; i5++) {
        var key = keys2[i5];
        var value = obj[key];
        if (iteratee2(value, key, obj))
          result2[key] = value;
      }
      return result2;
    });
  }
});

// ../../node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "../../node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context = keys2[1];
      } else {
        keys2 = map2(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj, iteratee2, context);
    });
  }
});

// ../../node_modules/underscore/modules/initial.js
function initial(array, n4, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n4 == null || guard ? 1 : n4)));
}
var init_initial = __esm({
  "../../node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/first.js
function first(array, n4, guard) {
  if (array == null || array.length < 1)
    return n4 == null || guard ? void 0 : [];
  if (n4 == null || guard)
    return array[0];
  return initial(array, array.length - n4);
}
var init_first = __esm({
  "../../node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// ../../node_modules/underscore/modules/rest.js
function rest(array, n4, guard) {
  return slice.call(array, n4 == null || guard ? 1 : n4);
}
var init_rest = __esm({
  "../../node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/last.js
function last(array, n4, guard) {
  if (array == null || array.length < 1)
    return n4 == null || guard ? void 0 : [];
  if (n4 == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n4));
}
var init_last = __esm({
  "../../node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// ../../node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "../../node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// ../../node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "../../node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// ../../node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "../../node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// ../../node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "../../node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// ../../node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i5 = 0, length = getLength_default(array); i5 < length; i5++) {
    var value = array[i5], computed = iteratee2 ? iteratee2(value, i5, array) : value;
    if (isSorted && !iteratee2) {
      if (!i5 || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "../../node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "../../node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// ../../node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i5 = 0, length = getLength_default(array); i5 < length; i5++) {
    var item = array[i5];
    if (contains(result2, item))
      continue;
    var j2;
    for (j2 = 1; j2 < argsLength; j2++) {
      if (!contains(arguments[j2], item))
        break;
    }
    if (j2 === argsLength)
      result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "../../node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max2(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    result2[index2] = pluck(array, index2);
  }
  return result2;
}
var init_unzip = __esm({
  "../../node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// ../../node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "../../node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// ../../node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i5 = 0, length = getLength_default(list); i5 < length; i5++) {
    if (values2) {
      result2[list[i5]] = values2[i5];
    } else {
      result2[list[i5][0]] = list[i5][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "../../node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "../../node_modules/underscore/modules/range.js"() {
  }
});

// ../../node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1)
    return [];
  var result2 = [];
  var i5 = 0, length = array.length;
  while (i5 < length) {
    result2.push(slice.call(array, i5, i5 += count));
  }
  return result2;
}
var init_chunk = __esm({
  "../../node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}
var init_chainResult = __esm({
  "../../node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each2(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "../../node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// ../../node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "../../node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each2(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each2(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null)
          obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    underscore_array_methods_default = _;
  }
});

// ../../node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every2,
  allKeys: () => allKeys,
  any: () => some2,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find2,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every2,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find2,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop2,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size2,
  some: () => some2,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "../../node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// ../../node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "../../node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// ../../node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every2,
  allKeys: () => allKeys,
  any: () => some2,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find2,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every2,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find2,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop2,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size2,
  some: () => some2,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "../../node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// ../../node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "../../node_modules/jquery/dist/jquery.js"(exports, module) {
    (function(global2, factory) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global2.document ? factory(global2, true) : function(w4) {
          if (!w4.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w4);
        };
      } else {
        factory(global2);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice2 = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push2 = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString3 = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction3 = function isFunction4(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code3, node, doc) {
        doc = doc || document2;
        var i5, val, script = doc.createElement("script");
        script.text = code3;
        if (node) {
          for (i5 in preservedScriptAttributes) {
            val = node[i5] || node.getAttribute && node.getAttribute(i5);
            if (val) {
              script.setAttribute(i5, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
      }
      var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      };
      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version2,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice2.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice2.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i5) {
            return callback.call(elem, i5, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice2.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i5) {
            return (i5 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i5) {
            return i5 % 2;
          }));
        },
        eq: function(i5) {
          var len = this.length, j2 = +i5 + (i5 < 0 ? len : 0);
          return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push2,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i5 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i5] || {};
          i5++;
        }
        if (typeof target !== "object" && !isFunction3(target)) {
          target = {};
        }
        if (i5 === length) {
          target = this;
          i5--;
        }
        for (; i5 < length; i5++) {
          if ((options = arguments[i5]) != null) {
            for (name in options) {
              copy = options[name];
              if (name === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone2 = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone2 = {};
                } else {
                  clone2 = src;
                }
                copyIsArray = false;
                target[name] = jQuery.extend(deep, clone2, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString3.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code3, options, doc) {
          DOMEval(code3, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i5 = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i5 < length; i5++) {
              if (callback.call(obj[i5], i5, obj[i5]) === false) {
                break;
              }
            }
          } else {
            for (i5 in obj) {
              if (callback.call(obj[i5], i5, obj[i5]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i5 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i5++]) {
              ret += jQuery.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push2.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i5) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i5);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first2, second) {
          var len = +second.length, j2 = 0, i5 = first2.length;
          for (; j2 < len; j2++) {
            first2[i5++] = second[j2];
          }
          first2.length = i5;
          return first2;
        },
        grep: function(elems, callback, invert2) {
          var callbackInverse, matches = [], i5 = 0, length = elems.length, callbackExpect = !invert2;
          for (; i5 < length; i5++) {
            callbackInverse = !callback(elems[i5], i5);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i5]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value, i5 = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i5 < length; i5++) {
              value = callback(elems[i5], i5, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i5 in elems) {
              value = callback(elems[i5], i5, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type2 = toType(obj);
        if (isFunction3(obj) || isWindow(obj)) {
          return false;
        }
        return type2 === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery.contains = function(a4, b4) {
        var bup = b4 && b4.parentNode;
        return a4 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a4.contains ? a4.contains(bup) : a4.compareDocumentPosition && a4.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push2;
      (function() {
        var i5, Expr, outermostContext, sortInput, hasDuplicate, push3 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a4, b4) {
          if (a4 === b4) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push3.apply(
            arr = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e4) {
          push3 = {
            apply: function(target, els) {
              pushNative.apply(target, slice2.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice2.call(arguments, 1));
            }
          };
        }
        function find3(selector, context, results, seed) {
          var m4, i6, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m4 = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m4)) {
                      if (elem.id === m4) {
                        push3.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m4)) && find3.contains(context, elem) && elem.id === m4) {
                      push3.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push3.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m4 = match[3]) && context.getElementsByClassName) {
                  push3.apply(results, context.getElementsByClassName(m4));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i6 = groups.length;
                  while (i6--) {
                    groups[i6] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i6]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push3.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select2(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys2 = [];
          function cache2(key, value) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache2[keys2.shift()];
            }
            return cache2[key + " "] = value;
          }
          return cache2;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e4) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type2) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type2;
          };
        }
        function createButtonPseudo(type2) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type2;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j2, matchIndexes = fn([], seed.length, argument), i6 = matchIndexes.length;
              while (i6--) {
                if (seed[j2 = matchIndexes[i6]]) {
                  seed[j2] = !(matches2[j2] = seed[j2]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e4) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i6, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i6 = 0;
                  while (elem = elems[i6++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a4, b4) {
            if (a4 === b4) {
              hasDuplicate = true;
              return 0;
            }
            var compare2 = !a4.compareDocumentPosition - !b4.compareDocumentPosition;
            if (compare2) {
              return compare2;
            }
            compare2 = (a4.ownerDocument || a4) == (b4.ownerDocument || b4) ? a4.compareDocumentPosition(b4) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare2 & 1 || !support.sortDetached && b4.compareDocumentPosition(a4) === compare2) {
              if (a4 === document3 || a4.ownerDocument == preferredDoc && find3.contains(preferredDoc, a4)) {
                return -1;
              }
              if (b4 === document3 || b4.ownerDocument == preferredDoc && find3.contains(preferredDoc, b4)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a4) - indexOf.call(sortInput, b4) : 0;
            }
            return compare2 & 4 ? -1 : 1;
          };
          return document3;
        }
        find3.matches = function(expr, elements) {
          return find3(expr, null, null, elements);
        };
        find3.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e4) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find3(expr, document3, null, [elem]).length > 0;
        };
        find3.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery.contains(context, elem);
        };
        find3.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name);
        };
        find3.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery.uniqueSort = function(results) {
          var elem, duplicates = [], j2 = 0, i6 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice2.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i6++]) {
              if (elem === results[i6]) {
                j2 = duplicates.push(i6);
              }
            }
            while (j2--) {
              splice.call(results, duplicates[j2], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery.fn.uniqueSort = function() {
          return this.pushStack(jQuery.uniqueSort(slice2.apply(this)));
        };
        Expr = jQuery.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find3.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find3.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name, operator, check) {
              return function(elem) {
                var result2 = find3.attr(elem, name);
                if (result2 == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result2 += "";
                if (operator === "=") {
                  return result2 === check;
                }
                if (operator === "!=") {
                  return result2 !== check;
                }
                if (operator === "^=") {
                  return check && result2.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result2.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result2.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result2 === check || result2.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type2, what, _argument, first2, last2) {
              var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last2 === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache2, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type2 === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache2 = outerCache[type2] || [];
                    nodeIndex = cache2[0] === dirruns && cache2[1];
                    diff = nodeIndex && cache2[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type2] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache2 = outerCache[type2] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type2] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last2;
                  return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find3.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i6 = matched.length;
                  while (i6--) {
                    idx = indexOf.call(seed, matched[i6]);
                    seed[idx] = !(matches2[idx] = matched[i6]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher2 = compile(selector.replace(rtrimCSS, "$1"));
              return matcher2[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher2(seed, null, xml, []), i6 = seed.length;
                while (i6--) {
                  if (elem = unmatched[i6]) {
                    seed[i6] = !(matches2[i6] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher2(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find3(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find3.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i6 = 0;
              for (; i6 < length; i6 += 2) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i6 = 1;
              for (; i6 < length; i6 += 2) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i6;
              if (argument < 0) {
                i6 = argument + length;
              } else if (argument > length) {
                i6 = length;
              } else {
                i6 = argument;
              }
              for (; --i6 >= 0; ) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i6 = argument < 0 ? argument + length : argument;
              for (; ++i6 < length; ) {
                matchIndexes.push(i6);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i5 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i5] = createInputPseudo(i5);
        }
        for (i5 in { submit: true, reset: true }) {
          Expr.pseudos[i5] = createButtonPseudo(i5);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match, tokens, type2, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type2 in Expr.filter) {
              if ((match = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match = preFilters[type2](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type2,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find3.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i6 = 0, len = tokens.length, selector = "";
          for (; i6 < len; i6++) {
            selector += tokens[i6].value;
          }
          return selector;
        }
        function addCombinator(matcher2, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher2(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher2(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher2(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i6 = matchers.length;
            while (i6--) {
              if (!matchers[i6](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i6 = 0, len = contexts.length;
          for (; i6 < len; i6++) {
            find3(selector, contexts[i6], results);
          }
          return results;
        }
        function condense(unmatched, map4, filter2, context, xml) {
          var elem, newUnmatched = [], i6 = 0, len = unmatched.length, mapped = map4 != null;
          for (; i6 < len; i6++) {
            if (elem = unmatched[i6]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map4.push(i6);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher2, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i6, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher2) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher2(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i6 = temp.length;
              while (i6--) {
                if (elem = temp[i6]) {
                  matcherOut[postMap[i6]] = !(matcherIn[postMap[i6]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i6 = matcherOut.length;
                  while (i6--) {
                    if (elem = matcherOut[i6]) {
                      temp.push(matcherIn[i6] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i6 = matcherOut.length;
                while (i6--) {
                  if ((elem = matcherOut[i6]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i6]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push3.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher2, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i6 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i6 < len; i6++) {
            if (matcher2 = Expr.relative[tokens[i6].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher2)];
            } else {
              matcher2 = Expr.filter[tokens[i6].type].apply(null, tokens[i6].matches);
              if (matcher2[expando]) {
                j2 = ++i6;
                for (; j2 < len; j2++) {
                  if (Expr.relative[tokens[j2].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i6 > 1 && elementMatcher(matchers),
                  i6 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i6 - 1).concat({ value: tokens[i6 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher2,
                  i6 < j2 && matcherFromTokens(tokens.slice(i6, j2)),
                  j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                  j2 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher2);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j2, matcher2, matchedCount = 0, i6 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i6 !== len && (elem = elems[i6]) != null; i6++) {
              if (byElement && elem) {
                j2 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher2 = elementMatchers[j2++]) {
                  if (matcher2(elem, context || document3, xml)) {
                    push3.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher2 && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i6;
            if (bySet && i6 !== matchedCount) {
              j2 = 0;
              while (matcher2 = setMatchers[j2++]) {
                matcher2(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i6--) {
                    if (!(unmatched[i6] || setMatched[i6])) {
                      setMatched[i6] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push3.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i6, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i6 = match.length;
            while (i6--) {
              cached = matcherFromTokens(match[i6]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select2(selector, context, results, seed) {
          var i6, tokens, token, type2, find4, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i6 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i6--) {
              token = tokens[i6];
              if (Expr.relative[type2 = token.type]) {
                break;
              }
              if (find4 = Expr.find[type2]) {
                if (seed = find4(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i6, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push3.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery.find = find3;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = jQuery.uniqueSort;
        find3.compile = compile;
        find3.select = select2;
        find3.setDocument = setDocument;
        find3.tokenize = tokenize;
        find3.escape = jQuery.escapeSelector;
        find3.getText = jQuery.text;
        find3.isXML = jQuery.isXMLDoc;
        find3.selectors = jQuery.expr;
        find3.support = jQuery.support;
        find3.uniqueSort = jQuery.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n4, elem) {
        var matched = [];
        for (; n4; n4 = n4.nextSibling) {
          if (n4.nodeType === 1 && n4 !== elem) {
            matched.push(n4);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction3(qualifier)) {
          return jQuery.grep(elements, function(elem, i5) {
            return !!qualifier.call(elem, i5, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery.filter(qualifier, elements, not);
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i5, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i5 = 0; i5 < len; i5++) {
                if (jQuery.contains(self2[i5], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i5 = 0; i5 < len; i5++) {
            jQuery.find(selector, self2[i5], ret);
          }
          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root2) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root2 = root2 || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction3(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root2).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction3(selector)) {
          return root2.ready !== void 0 ? root2.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery)
          );
        }
        return jQuery.makeArray(selector, this);
      };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this), l7 = targets.length;
          return this.filter(function() {
            var i5 = 0;
            for (; i5 < l7; i5++) {
              if (jQuery.contains(this, targets[i5])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i5 = 0, l7 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i5 < l7; i5++) {
              for (cur = this[i5]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery.uniqueSort(
              jQuery.merge(this.get(), jQuery(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object2 = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_5, flag) {
          object2[flag] = true;
        });
        return object2;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_5, arg) {
                  if (isFunction3(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery.each(arguments, function(_5, arg) {
              var index2;
              while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
                list.splice(index2, 1);
                if (index2 <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v2) {
        return v2;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject4, noValue) {
        var method;
        try {
          if (value && isFunction3(method = value.promise)) {
            method.call(value).done(resolve).fail(reject4);
          } else if (value && isFunction3(method = value.then)) {
            method.call(value, resolve, reject4);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject4.apply(void 0, [value2]);
        }
      }
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery.Callbacks("memory"),
              jQuery.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(_i, tuple) {
                  var fn = isFunction3(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction3(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction3(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e4) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(
                          e4,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e4];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery.Deferred.getErrorHook) {
                      process2.error = jQuery.Deferred.getErrorHook();
                    } else if (jQuery.Deferred.getStackHook) {
                      process2.error = jQuery.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction3(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery.each(tuples, function(i5, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i5][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i5][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i5 = remaining, resolveContexts = Array(i5), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i6) {
            return function(value) {
              resolveContexts[i6] = this;
              resolveValues[i6] = arguments.length > 1 ? slice2.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i5)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction3(resolveValues[i5] && resolveValues[i5].then)) {
              return primary.then();
            }
          }
          while (i5--) {
            adoptValue(resolveValues[i5], updateFunc(i5), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery.Deferred();
      jQuery.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery.readyException(error);
        });
        return this;
      };
      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i5 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i5 in key) {
            access(elems, fn, i5, key[i5], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction3(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value2) {
                return bulk.call(jQuery(elem), value2);
              };
            }
          }
          if (fn) {
            for (; i5 < len; i5++) {
              fn(
                elems[i5],
                key,
                raw ? value : value.call(elems[i5], i5, fn(elems[i5], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache2 = this.cache(owner);
          if (typeof data === "string") {
            cache2[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache2[camelCase(prop)] = data[prop];
            }
          }
          return cache2;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i5, cache2 = owner[this.expando];
          if (cache2 === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
            }
            i5 = key.length;
            while (i5--) {
              delete cache2[key[i5]];
            }
          }
          if (key === void 0 || jQuery.isEmptyObject(cache2)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache2 = owner[this.expando];
          return cache2 !== void 0 && !jQuery.isEmptyObject(cache2);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name;
        if (data === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e4) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i5, name, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i5 = attrs.length;
                while (i5--) {
                  if (attrs[i5]) {
                    name = attrs[i5].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type2, data) {
          var queue;
          if (elem) {
            type2 = (type2 || "fx") + "queue";
            queue = dataPriv.get(elem, type2);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type2, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type2) {
          type2 = type2 || "fx";
          var queue = jQuery.queue(elem, type2), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type2), next = function() {
            jQuery.dequeue(elem, type2);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type2 === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type2) {
          var key = type2 + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type2 + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function(type2, data) {
          var setter = 2;
          if (typeof type2 !== "string") {
            data = type2;
            type2 = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type2);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery.queue(this, type2, data);
            jQuery._queueHooks(this, type2);
            if (type2 === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type2);
            }
          });
        },
        dequeue: function(type2) {
          return this.each(function() {
            jQuery.dequeue(this, type2);
          });
        },
        clearQueue: function(type2) {
          return this.queue(type2 || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type2, obj) {
          var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i5 = this.length, resolve = function() {
            if (!--count) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type2 !== "string") {
            obj = type2;
            type2 = void 0;
          }
          type2 = type2 || "fx";
          while (i5--) {
            tmp = dataPriv.get(elements[i5], type2 + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        }, initial2 = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial2) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial2 = initial2 / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial2 || 1;
          while (maxIterations--) {
            jQuery.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial2 || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial2 || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values2 = [], index2 = 0, length = elements.length;
        for (; index2 < length; index2++) {
          elem = elements[index2];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values2[index2] = dataPriv.get(elem, "display") || null;
              if (!values2[index2]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values2[index2] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values2[index2] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index2 = 0; index2 < length; index2++) {
          if (values2[index2] != null) {
            elements[index2].style.display = values2[index2];
          }
        }
        return elements;
      }
      jQuery.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i5 = 0, l7 = elems.length;
        for (; i5 < l7; i5++) {
          dataPriv.set(
            elems[i5],
            "globalEval",
            !refElements || dataPriv.get(refElements[i5], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap2, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i5 = 0, l7 = elems.length;
        for (; i5 < l7; i5++) {
          elem = elems[i5];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap2 = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap2[1] + jQuery.htmlPrefilter(elem) + wrap2[2];
              j2 = wrap2[0];
              while (j2--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i5 = 0;
        while (elem = nodes[i5++]) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j2 = 0;
            while (elem = tmp[j2++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on(elem, types2, selector, data, fn, one) {
        var origFn, type2;
        if (typeof types2 === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type2 in types2) {
            on(elem, type2, selector, data, types2[type2], one);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = void 0;
          } else {
            fn = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types2, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types2, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events2, t10, handleObj, special, handlers, type2, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events2 = elemData.events)) {
            events2 = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e4) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e4.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types2 = (types2 || "").match(rnothtmlwhite) || [""];
          t10 = types2.length;
          while (t10--) {
            tmp = rtypenamespace.exec(types2[t10]) || [];
            type2 = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type2) {
              continue;
            }
            special = jQuery.event.special[type2] || {};
            type2 = (selector ? special.delegateType : special.bindType) || type2;
            special = jQuery.event.special[type2] || {};
            handleObj = jQuery.extend({
              type: type2,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events2[type2])) {
              handlers = events2[type2] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type2, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type2] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types2, handler, selector, mappedTypes) {
          var j2, origCount, tmp, events2, t10, handleObj, special, handlers, type2, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events2 = elemData.events)) {
            return;
          }
          types2 = (types2 || "").match(rnothtmlwhite) || [""];
          t10 = types2.length;
          while (t10--) {
            tmp = rtypenamespace.exec(types2[t10]) || [];
            type2 = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type2) {
              for (type2 in events2) {
                jQuery.event.remove(elem, type2 + types2[t10], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type2] || {};
            type2 = (selector ? special.delegateType : special.bindType) || type2;
            handlers = events2[type2] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j2 = handlers.length;
            while (j2--) {
              handleObj = handlers[j2];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j2, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type2, elemData.handle);
              }
              delete events2[type2];
            }
          }
          if (jQuery.isEmptyObject(events2)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i5, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
          args[0] = event;
          for (i5 = 1; i5 < arguments.length; i5++) {
            args[i5] = arguments[i5];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i5 = 0;
          while ((matched = handlerQueue[i5++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j2 = 0;
            while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i5, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i5 = 0; i5 < delegateCount; i5++) {
                  handleObj = handlers[i5];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction3(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type2, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type2) === void 0) {
            jQuery.event.add(el, type2, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type2, false);
        jQuery.event.add(el, type2, {
          namespace: false,
          handler: function(event) {
            var result2, saved = dataPriv.get(this, type2);
            if (event.isTrigger & 1 && this[type2]) {
              if (!saved) {
                saved = slice2.call(arguments);
                dataPriv.set(this, type2, saved);
                this[type2]();
                result2 = dataPriv.get(this, type2);
                dataPriv.set(this, type2, false);
                if (saved !== result2) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result2;
                }
              } else if ((jQuery.event.special[type2] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type2, jQuery.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery.removeEvent = function(elem, type2, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type2, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e4 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.preventDefault();
          }
        },
        stopPropagation: function() {
          var e4 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e4 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(type2, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery.event.fix(nativeEvent)
            );
          }
        }
        jQuery.event.special[type2] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type2, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type2);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type2);
          },
          delegateType
        };
        jQuery.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type2, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type2, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types2, selector, data, fn) {
          return on(this, types2, selector, data, fn);
        },
        one: function(types2, selector, data, fn) {
          return on(this, types2, selector, data, fn, 1);
        },
        off: function(types2, selector, fn) {
          var handleObj, type2;
          if (types2 && types2.preventDefault && types2.handleObj) {
            handleObj = types2.handleObj;
            jQuery(types2.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types2 === "object") {
            for (type2 in types2) {
              this.off(type2, selector, types2[type2]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types2, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i5, l7, type2, pdataOld, udataOld, udataCur, events2;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events2 = pdataOld.events;
          if (events2) {
            dataPriv.remove(dest, "handle events");
            for (type2 in events2) {
              for (i5 = 0, l7 = events2[type2].length; i5 < l7; i5++) {
                jQuery.event.add(dest, type2, events2[type2][i5]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first2, scripts, hasScripts, node, doc, i5 = 0, l7 = collection.length, iNoClone = l7 - 1, value = args[0], valueIsFunction = isFunction3(value);
        if (valueIsFunction || l7 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index2) {
            var self2 = collection.eq(index2);
            if (valueIsFunction) {
              args[0] = value.call(this, index2, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l7) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first2 = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first2;
          }
          if (first2 || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i5 < l7; i5++) {
              node = fragment;
              if (i5 !== iNoClone) {
                node = jQuery.clone(node, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i5], node, i5);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i5 = 0; i5 < hasScripts; i5++) {
                node = scripts[i5];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove2(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i5 = 0;
        for (; (node = nodes[i5]) != null; i5++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i5, l7, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone2);
            srcElements = getAll(elem);
            for (i5 = 0, l7 = srcElements.length; i5 < l7; i5++) {
              fixInput(srcElements[i5], destElements[i5]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone2);
              for (i5 = 0, l7 = srcElements.length; i5 < l7; i5++) {
                cloneCopyEvent(srcElements[i5], destElements[i5]);
              }
            } else {
              cloneCopyEvent(elem, clone2);
            }
          }
          destElements = getAll(clone2, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone2;
        },
        cleanData: function(elems) {
          var data, elem, type2, special = jQuery.event.special, i5 = 0;
          for (; (elem = elems[i5]) !== void 0; i5++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type2 in data.events) {
                    if (special[type2]) {
                      jQuery.event.remove(elem, type2);
                    } else {
                      jQuery.removeEvent(elem, type2, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function(selector) {
          return remove2(this, selector, true);
        },
        remove: function(selector) {
          return remove2(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i5 = 0;
          for (; (elem = this[i5]) != null; i5++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i5 = 0, l7 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery.htmlPrefilter(value2);
              try {
                for (; i5 < l7; i5++) {
                  elem = this[i5] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e4) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery(selector), last2 = insert.length - 1, i5 = 0;
          for (; i5 <= last2; i5++) {
            elems = i5 === last2 ? this : this.clone(true);
            jQuery(insert[i5])[original](elems);
            push2.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles2 = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name, old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table2, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table2 = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table2.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "box-sizing:content-box;border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table2).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table2);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
        computed = computed || getStyles2(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i5 = cssPrefixes.length;
        while (i5--) {
          name = cssPrefixes[i5] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i5 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i5 < 4; i5 += 2) {
          if (box === "margin") {
            marginDelta += jQuery.css(elem, box + cssExpand[i5], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery.css(elem, "padding" + cssExpand[i5], true, styles);
            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i5], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i5] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles2(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type2, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== void 0) {
            type2 = typeof value;
            if (type2 === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type2 = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type2 === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles = getStyles2(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i5 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i5 < 4; i5++) {
              expanded[prefix + cssExpand[i5] + suffix] = parts[i5] || parts[i5 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name2, value2) {
            var styles, len, map4 = {}, i5 = 0;
            if (Array.isArray(name2)) {
              styles = getStyles2(elem);
              len = name2.length;
              for (; i5 < len; i5++) {
                map4[name2[i5]] = jQuery.css(elem, name2[i5], false, styles);
              }
              return map4;
            }
            return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
          }, name, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result2;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result2 = jQuery.css(tween.elem, tween.prop, "");
            return !result2 || result2 === "auto" ? 0 : result2;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function(p3) {
          return p3;
        },
        swing: function(p3) {
          return 0.5 - Math.cos(p3 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery.fx.interval);
          }
          jQuery.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type2, includeWidth) {
        var which, i5 = 0, attrs = { height: type2 };
        includeWidth = includeWidth ? 1 : 0;
        for (; i5 < 4; i5 += 2 - includeWidth) {
          which = cssExpand[i5];
          attrs["margin" + which] = attrs["padding" + which] = type2;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type2;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
        for (; index2 < length; index2++) {
          if (tween = collection[index2].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index2, name, easing, value, hooks;
        for (index2 in props) {
          name = camelCase(index2);
          easing = specialEasing[name];
          value = props[index2];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index2] = value[0];
          }
          if (index2 !== name) {
            props[name] = value;
            delete props[index2];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index2 in value) {
              if (!(index2 in props)) {
                props[index2] = value[index2];
                specialEasing[index2] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result2, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
          for (; index3 < length2; index3++) {
            animation.tweens[index3].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index2 < length; index2++) {
          result2 = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
          if (result2) {
            if (isFunction3(result2.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result2.stop.bind(result2);
            }
            return result2;
          }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction3(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(
          jQuery.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction3(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index2 = 0, length = props.length;
          for (; index2 < length; index2++) {
            prop = props[index2];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction3(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction3(easing) && easing
        };
        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction3(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type2, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type2 !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type2;
            type2 = void 0;
          }
          if (clearQueue) {
            this.queue(type2 || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index2 = type2 != null && type2 + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
            if (index2) {
              if (data[index2] && data[index2].stop) {
                stopQueue(data[index2]);
              }
            } else {
              for (index2 in data) {
                if (data[index2] && data[index2].stop && rrun.test(index2)) {
                  stopQueue(data[index2]);
                }
              }
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && (type2 == null || timers[index2].queue === type2)) {
                timers[index2].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index2, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type2);
            }
          });
        },
        finish: function(type2) {
          if (type2 !== false) {
            type2 = type2 || "fx";
          }
          return this.each(function() {
            var index2, data = dataPriv.get(this), queue = data[type2 + "queue"], hooks = data[type2 + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type2, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && timers[index2].queue === type2) {
                timers[index2].anim.stop(true);
                timers.splice(index2, 1);
              }
            }
            for (index2 = 0; index2 < length; index2++) {
              if (queue[index2] && queue[index2].finish) {
                queue[index2].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer, i5 = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i5 < timers.length; i5++) {
          timer = timers[i5];
          if (!timer() && timers[i5] === timer) {
            timers.splice(i5--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery.fx.stop = function() {
        inProgress = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery.fn.delay = function(time, type2) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type2 = type2 || "fx";
        return this.queue(type2, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select2 = document2.createElement("select"), opt = select2.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name, i5 = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i5++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each(
        [
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ],
        function() {
          jQuery.propFix[this.toLowerCase()] = this;
        }
      );
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classNames40, cur, curValue, className, i5, finalValue;
          if (isFunction3(value)) {
            return this.each(function(j2) {
              jQuery(this).addClass(value.call(this, j2, getClass(this)));
            });
          }
          classNames40 = classesToArray(value);
          if (classNames40.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i5 = 0; i5 < classNames40.length; i5++) {
                  className = classNames40[i5];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames40, cur, curValue, className, i5, finalValue;
          if (isFunction3(value)) {
            return this.each(function(j2) {
              jQuery(this).removeClass(value.call(this, j2, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames40 = classesToArray(value);
          if (classNames40.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i5 = 0; i5 < classNames40.length; i5++) {
                  className = classNames40[i5];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames40, className, i5, self2, type2 = typeof value, isValidValue = type2 === "string" || Array.isArray(value);
          if (isFunction3(value)) {
            return this.each(function(i6) {
              jQuery(this).toggleClass(
                value.call(this, i6, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames40 = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery(this);
              for (i5 = 0; i5 < classNames40.length; i5++) {
                className = classNames40[i5];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type2 === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i5 = 0;
          className = " " + selector + " ";
          while (elem = this[i5++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction3(value);
          return this.each(function(i5) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i5, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i5, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max3 = one ? index2 + 1 : options.length;
              if (index2 < 0) {
                i5 = max3;
              } else {
                i5 = one ? index2 : 0;
              }
              for (; i5 < max3; i5++) {
                option = options[i5];
                if ((option.selected || i5 === index2) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values2.push(value);
                }
              }
              return values2;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values2 = jQuery.makeArray(value), i5 = options.length;
              while (i5--) {
                option = options[i5];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values2) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values2;
            }
          }
        }
      });
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location2 = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e4) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery.error(
            "Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data)
          );
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e4) {
        e4.stopPropagation();
      };
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i5, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type2 = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type2 + jQuery.event.triggered)) {
            return;
          }
          if (type2.indexOf(".") > -1) {
            namespaces = type2.split(".");
            type2 = namespaces.shift();
            namespaces.sort();
          }
          ontype = type2.indexOf(":") < 0 && "on" + type2;
          event = event[jQuery.expando] ? event : new jQuery.Event(type2, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type2] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type2;
            if (!rfocusMorph.test(bubbleType + type2)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i5 = 0;
          while ((cur = eventPath[i5++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i5 > 1 ? bubbleType : special.bindType || type2;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type2;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction3(elem[type2]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type2;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type2, stopPropagationCallback);
                }
                elem[type2]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type2, stopPropagationCallback);
                }
                jQuery.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type2, elem, event) {
          var e4 = jQuery.extend(
            new jQuery.Event(),
            event,
            {
              type: type2,
              isSimulated: true
            }
          );
          jQuery.event.trigger(e4, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function(type2, data) {
          return this.each(function() {
            jQuery.event.trigger(type2, data, this);
          });
        },
        triggerHandler: function(type2, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type2, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
          jQuery.each(obj, function(i5, v2) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v2);
            } else {
              buildParams(
                prefix + "[" + (typeof v2 === "object" && v2 != null ? i5 : "") + "]",
                v2,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a4, traditional) {
        var prefix, s7 = [], add = function(key, valueOrFunction) {
          var value = isFunction3(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s7[s7.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a4 == null) {
          return "";
        }
        if (Array.isArray(a4) || a4.jquery && !jQuery.isPlainObject(a4)) {
          jQuery.each(a4, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a4) {
            buildParams(prefix, a4[prefix], traditional, add);
          }
        }
        return s7.join("&");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type2 = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type2) && (this.checked || !rcheckableType.test(type2));
          }).map(function(_i, elem) {
            var val = jQuery(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location2.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i5 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction3(func)) {
            while (dataType = dataTypes[i5++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_5, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s7, jqXHR, responses) {
        var ct, type2, finalDataType, firstDataType, contents = s7.contents, dataTypes = s7.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s7.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type2 in contents) {
            if (contents[type2] && contents[type2].test(ct)) {
              dataTypes.unshift(type2);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type2 in responses) {
            if (!dataTypes[0] || s7.converters[type2 + " " + dataTypes[0]]) {
              finalDataType = type2;
              break;
            }
            if (!firstDataType) {
              firstDataType = type2;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s7, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s7.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s7.converters) {
            converters[conv.toLowerCase()] = s7.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s7.responseFields[current]) {
            jqXHR[s7.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s7.dataFilter) {
            response = s7.dataFilter(response, s7.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s7.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e4) {
                    return {
                      state: "parsererror",
                      error: conv ? e4 : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location2.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location2.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i5, uncached, s7 = jQuery.ajaxSetup({}, options), callbackContext = s7.context || s7, globalEventContext = s7.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s7.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name, value) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type2) {
              if (completed2 == null) {
                s7.mimeType = type2;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map4) {
              var code3;
              if (map4) {
                if (completed2) {
                  jqXHR.always(map4[jqXHR.status]);
                } else {
                  for (code3 in map4) {
                    statusCode[code3] = [statusCode[code3], map4[code3]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s7.url = ((url || s7.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
          s7.type = options.method || options.type || s7.method || s7.type;
          s7.dataTypes = (s7.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s7.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s7.url;
              urlAnchor.href = urlAnchor.href;
              s7.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e4) {
              s7.crossDomain = true;
            }
          }
          if (s7.data && s7.processData && typeof s7.data !== "string") {
            s7.data = jQuery.param(s7.data, s7.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s7, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s7.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s7.type = s7.type.toUpperCase();
          s7.hasContent = !rnoContent.test(s7.type);
          cacheURL = s7.url.replace(rhash, "");
          if (!s7.hasContent) {
            uncached = s7.url.slice(cacheURL.length);
            if (s7.data && (s7.processData || typeof s7.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s7.data;
              delete s7.data;
            }
            if (s7.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s7.url = cacheURL + uncached;
          } else if (s7.data && s7.processData && (s7.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s7.data = s7.data.replace(r20, "+");
          }
          if (s7.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s7.data && s7.hasContent && s7.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s7.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s7.dataTypes[0] && s7.accepts[s7.dataTypes[0]] ? s7.accepts[s7.dataTypes[0]] + (s7.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s7.accepts["*"]
          );
          for (i5 in s7.headers) {
            jqXHR.setRequestHeader(i5, s7.headers[i5]);
          }
          if (s7.beforeSend && (s7.beforeSend.call(callbackContext, jqXHR, s7) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s7.complete);
          jqXHR.done(s7.success);
          jqXHR.fail(s7.error);
          transport = inspectPrefiltersOrTransports(transports, s7, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s7]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s7.async && s7.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s7.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e4) {
              if (completed2) {
                throw e4;
              }
              done(-1, e4);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s7, jqXHR, responses);
            }
            if (!isSuccess && jQuery.inArray("script", s7.dataTypes) > -1 && jQuery.inArray("json", s7.dataTypes) < 0) {
              s7.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s7, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s7.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s7.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s7, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s7]);
              if (!--jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, void 0, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(_i, method) {
        jQuery[method] = function(url, data, callback, type2) {
          if (isFunction3(data)) {
            type2 = type2 || callback;
            callback = data;
            data = void 0;
          }
          return jQuery.ajax(jQuery.extend({
            url,
            type: method,
            dataType: type2,
            data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function(s7) {
        var i5;
        for (i5 in s7.headers) {
          if (i5.toLowerCase() === "content-type") {
            s7.contentType = s7.headers[i5] || "";
          }
        }
      });
      jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap2;
          if (this[0]) {
            if (isFunction3(html)) {
              html = html.call(this[0]);
            }
            wrap2 = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap2.insertBefore(this[0]);
            }
            wrap2.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction3(html)) {
            return this.each(function(i5) {
              jQuery(this).wrapInner(html.call(this, i5));
            });
          }
          return this.each(function() {
            var self2 = jQuery(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction3(html);
          return this.each(function(i5) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i5) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };
      jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e4) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i5, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i5 in options.xhrFields) {
                  xhr[i5] = options.xhrFields[i5];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i5 in headers) {
                xhr.setRequestHeader(i5, headers[i5]);
              }
              callback = function(type2) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type2 === "abort") {
                      xhr.abort();
                    } else if (type2 === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e4) {
                if (callback) {
                  throw e4;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxPrefilter(function(s7) {
        if (s7.crossDomain) {
          s7.contents.script = false;
        }
      });
      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      });
      jQuery.ajaxPrefilter("script", function(s7) {
        if (s7.cache === void 0) {
          s7.cache = false;
        }
        if (s7.crossDomain) {
          s7.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s7) {
        if (s7.crossDomain || s7.scriptAttrs) {
          var script, callback;
          return {
            send: function(_5, complete) {
              script = jQuery("<script>").attr(s7.scriptAttrs || {}).prop({ charset: s7.scriptCharset, src: s7.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s7, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s7.jsonp !== false && (rjsonp.test(s7.url) ? "url" : typeof s7.data === "string" && (s7.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s7.data) && "data");
        if (jsonProp || s7.dataTypes[0] === "jsonp") {
          callbackName = s7.jsonpCallback = isFunction3(s7.jsonpCallback) ? s7.jsonpCallback() : s7.jsonpCallback;
          if (jsonProp) {
            s7[jsonProp] = s7[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s7.jsonp !== false) {
            s7.url += (rquery.test(s7.url) ? "&" : "?") + s7.jsonp + "=" + callbackName;
          }
          s7.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s7.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s7[callbackName]) {
              s7.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction3(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      jQuery.fn.load = function(url, params, callback) {
        var selector, type2, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction3(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type2 = "POST";
        }
        if (self2.length > 0) {
          jQuery.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type2 || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery.offset = {
        setOffset: function(elem, options, i5) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction3(options)) {
            options = options.call(elem, i5, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i5) {
              jQuery.offset.setOffset(this, options, i5);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery.css(elem, "position") === "fixed") {
            offset2 = elem.getBoundingClientRect();
          } else {
            offset2 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery.each({ Height: "height", Width: "width" }, function(name, type2) {
        jQuery.each({
          padding: "inner" + name,
          content: type2,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type3, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css(elem, type3, extra)
              ) : (
                // Set width or height on the element
                jQuery.style(elem, type3, value2, extra)
              );
            }, type2, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery.each(
        [
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ],
        function(_i, type2) {
          jQuery.fn[type2] = function(fn) {
            return this.on(type2, fn);
          };
        }
      );
      jQuery.fn.extend({
        bind: function(types2, data, fn) {
          return this.on(types2, null, data, fn);
        },
        unbind: function(types2, fn) {
          return this.off(types2, null, fn);
        },
        delegate: function(selector, types2, data, fn) {
          return this.on(types2, selector, data, fn);
        },
        undelegate: function(selector, types2, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types2, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i, name) {
          jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction3(fn)) {
          return void 0;
        }
        args = slice2.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice2.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };
      jQuery.holdReady = function(hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction3;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;
      jQuery.isNumeric = function(obj) {
        var type2 = jQuery.type(obj);
        return (type2 === "number" || type2 === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery.noConflict = function(deep) {
        if (window2.$ === jQuery) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery) {
          window2.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery;
      }
      return jQuery;
    });
  }
});

// ../../node_modules/backbone/backbone.js
var require_backbone = __commonJS({
  "../../node_modules/backbone/backbone.js"(exports) {
    (function(factory) {
      var root2 = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis;
      if (typeof define === "function" && define.amd) {
        define(["underscore", "jquery", "exports"], function(_6, $9, exports2) {
          root2.Backbone = factory(root2, exports2, _6, $9);
        });
      } else if (typeof exports !== "undefined") {
        var _5 = (init_index_all(), __toCommonJS(index_all_exports)), $8;
        try {
          $8 = require_jquery();
        } catch (e4) {
        }
        factory(root2, exports, _5, $8);
      } else {
        root2.Backbone = factory(root2, {}, root2._, root2.jQuery || root2.Zepto || root2.ender || root2.$);
      }
    })(function(root2, Backbone3, _5, $8) {
      var previousBackbone = root2.Backbone;
      var slice2 = Array.prototype.slice;
      Backbone3.VERSION = "1.4.0";
      Backbone3.$ = $8;
      Backbone3.noConflict = function() {
        root2.Backbone = previousBackbone;
        return this;
      };
      Backbone3.emulateHTTP = false;
      Backbone3.emulateJSON = false;
      var Events = Backbone3.Events = {};
      var eventSplitter = /\s+/;
      var _listening;
      var eventsApi = function(iteratee2, events2, name, callback, opts) {
        var i5 = 0, names;
        if (name && typeof name === "object") {
          if (callback !== void 0 && "context" in opts && opts.context === void 0)
            opts.context = callback;
          for (names = _5.keys(name); i5 < names.length; i5++) {
            events2 = eventsApi(iteratee2, events2, names[i5], name[names[i5]], opts);
          }
        } else if (name && eventSplitter.test(name)) {
          for (names = name.split(eventSplitter); i5 < names.length; i5++) {
            events2 = iteratee2(events2, names[i5], callback, opts);
          }
        } else {
          events2 = iteratee2(events2, name, callback, opts);
        }
        return events2;
      };
      Events.on = function(name, callback, context) {
        this._events = eventsApi(onApi, this._events || {}, name, callback, {
          context,
          ctx: this,
          listening: _listening
        });
        if (_listening) {
          var listeners = this._listeners || (this._listeners = {});
          listeners[_listening.id] = _listening;
          _listening.interop = false;
        }
        return this;
      };
      Events.listenTo = function(obj, name, callback) {
        if (!obj)
          return this;
        var id = obj._listenId || (obj._listenId = _5.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = _listening = listeningTo[id];
        if (!listening) {
          this._listenId || (this._listenId = _5.uniqueId("l"));
          listening = _listening = listeningTo[id] = new Listening(this, obj);
        }
        var error = tryCatchOn(obj, name, callback, this);
        _listening = void 0;
        if (error)
          throw error;
        if (listening.interop)
          listening.on(name, callback);
        return this;
      };
      var onApi = function(events2, name, callback, options) {
        if (callback) {
          var handlers = events2[name] || (events2[name] = []);
          var context = options.context, ctx = options.ctx, listening = options.listening;
          if (listening)
            listening.count++;
          handlers.push({ callback, context, ctx: context || ctx, listening });
        }
        return events2;
      };
      var tryCatchOn = function(obj, name, callback, context) {
        try {
          obj.on(name, callback, context);
        } catch (e4) {
          return e4;
        }
      };
      Events.off = function(name, callback, context) {
        if (!this._events)
          return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
          context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
          return this;
        var ids = obj ? [obj._listenId] : _5.keys(listeningTo);
        for (var i5 = 0; i5 < ids.length; i5++) {
          var listening = listeningTo[ids[i5]];
          if (!listening)
            break;
          listening.obj.off(name, callback, this);
          if (listening.interop)
            listening.off(name, callback);
        }
        if (_5.isEmpty(listeningTo))
          this._listeningTo = void 0;
        return this;
      };
      var offApi = function(events2, name, callback, options) {
        if (!events2)
          return;
        var context = options.context, listeners = options.listeners;
        var i5 = 0, names;
        if (!name && !context && !callback) {
          for (names = _5.keys(listeners); i5 < names.length; i5++) {
            listeners[names[i5]].cleanup();
          }
          return;
        }
        names = name ? [name] : _5.keys(events2);
        for (; i5 < names.length; i5++) {
          name = names[i5];
          var handlers = events2[name];
          if (!handlers)
            break;
          var remaining = [];
          for (var j2 = 0; j2 < handlers.length; j2++) {
            var handler = handlers[j2];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              var listening = handler.listening;
              if (listening)
                listening.off(name, callback);
            }
          }
          if (remaining.length) {
            events2[name] = remaining;
          } else {
            delete events2[name];
          }
        }
        return events2;
      };
      Events.once = function(name, callback, context) {
        var events2 = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
        if (typeof name === "string" && context == null)
          callback = void 0;
        return this.on(events2, callback, context);
      };
      Events.listenToOnce = function(obj, name, callback) {
        var events2 = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
        return this.listenTo(obj, events2);
      };
      var onceMap = function(map4, name, callback, offer) {
        if (callback) {
          var once = map4[name] = _5.once(function() {
            offer(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map4;
      };
      Events.trigger = function(name) {
        if (!this._events)
          return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i5 = 0; i5 < length; i5++)
          args[i5] = arguments[i5 + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
          var events2 = objEvents[name];
          var allEvents = objEvents.all;
          if (events2 && allEvents)
            allEvents = allEvents.slice();
          if (events2)
            triggerEvents(events2, args);
          if (allEvents)
            triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events2, args) {
        var ev, i5 = -1, l7 = events2.length, a1 = args[0], a22 = args[1], a32 = args[2];
        switch (args.length) {
          case 0:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1, a22);
            return;
          case 3:
            while (++i5 < l7)
              (ev = events2[i5]).callback.call(ev.ctx, a1, a22, a32);
            return;
          default:
            while (++i5 < l7)
              (ev = events2[i5]).callback.apply(ev.ctx, args);
            return;
        }
      };
      var Listening = function(listener, obj) {
        this.id = listener._listenId;
        this.listener = listener;
        this.obj = obj;
        this.interop = true;
        this.count = 0;
        this._events = void 0;
      };
      Listening.prototype.on = Events.on;
      Listening.prototype.off = function(name, callback) {
        var cleanup;
        if (this.interop) {
          this._events = eventsApi(offApi, this._events, name, callback, {
            context: void 0,
            listeners: void 0
          });
          cleanup = !this._events;
        } else {
          this.count--;
          cleanup = this.count === 0;
        }
        if (cleanup)
          this.cleanup();
      };
      Listening.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId];
        if (!this.interop)
          delete this.obj._listeners[this.id];
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _5.extend(Backbone3, Events);
      var Model2 = Backbone3.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        this.cid = _5.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection)
          this.collection = options.collection;
        if (options.parse)
          attrs = this.parse(attrs, options) || {};
        var defaults = _5.result(this, "defaults");
        attrs = _5.defaults(_5.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      _5.extend(Model2.prototype, Events, {
        // A hash of attributes whose current and previous value differ.
        changed: null,
        // The value returned during the last failed validation.
        validationError: null,
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: "id",
        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: "c",
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Model.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return _5.clone(this.attributes);
        },
        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },
        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
          return _5.escape(this.get(attr));
        },
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },
        // Special-cased proxy to underscore's `_.matches` method.
        matches: function(attrs) {
          return !!_5.iteratee(attrs, this)(this.attributes);
        },
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null)
            return this;
          var attrs;
          if (typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          var unset = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _5.clone(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr in attrs) {
            val = attrs[attr];
            if (!_5.isEqual(current[attr], val))
              changes.push(attr);
            if (!_5.isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i5 = 0; i5 < changes.length; i5++) {
              this.trigger("change:" + changes[i5], this, current[changes[i5]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger("change", this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, _5.extend({}, options, { unset: true }));
        },
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _5.extend({}, options, { unset: true }));
        },
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null)
            return !_5.isEmpty(this.changed);
          return _5.has(this.changed, attr);
        },
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff)
            return this.hasChanged() ? _5.clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          var hasChanged;
          for (var attr in diff) {
            var val = diff[attr];
            if (_5.isEqual(old[attr], val))
              continue;
            changed[attr] = val;
            hasChanged = true;
          }
          return hasChanged ? changed : false;
        },
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return _5.clone(this._previousAttributes);
        },
        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function(options) {
          options = _5.extend({ parse: true }, options);
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (!model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
          var attrs;
          if (key == null || typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _5.extend({ validate: true, parse: true }, options);
          var wait = options.wait;
          if (attrs && !wait) {
            if (!this.set(attrs, options))
              return false;
          } else if (!this._validate(attrs, options)) {
            return false;
          }
          var model = this;
          var success = options.success;
          var attributes = this.attributes;
          options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (wait)
              serverAttrs = _5.extend({}, attrs, serverAttrs);
            if (serverAttrs && !model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          if (attrs && wait)
            this.attributes = _5.extend({}, attributes, attrs);
          var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
          if (method === "patch" && !options.attrs)
            options.attrs = attrs;
          var xhr = this.sync(method, this, options);
          this.attributes = attributes;
          return xhr;
        },
        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
          options = options ? _5.clone(options) : {};
          var model = this;
          var success = options.success;
          var wait = options.wait;
          var destroy = function() {
            model.stopListening();
            model.trigger("destroy", model, model.collection, options);
          };
          options.success = function(resp) {
            if (wait)
              destroy();
            if (success)
              success.call(options.context, model, resp, options);
            if (!model.isNew())
              model.trigger("sync", model, resp, options);
          };
          var xhr = false;
          if (this.isNew()) {
            _5.defer(options.success);
          } else {
            wrapError(this, options);
            xhr = this.sync("delete", this, options);
          }
          if (!wait)
            destroy();
          return xhr;
        },
        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
          var base = _5.result(this, "urlRoot") || _5.result(this.collection, "url") || urlError();
          if (this.isNew())
            return base;
          var id = this.get(this.idAttribute);
          return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },
        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },
        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, _5.extend({}, options, { validate: true }));
        },
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _5.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger("invalid", this, error, _5.extend(options, { validationError: error }));
          return false;
        }
      });
      var Collection = Backbone3.Collection = function(models, options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.model)
          this.model = options.model;
        if (options.comparator !== void 0)
          this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
          this.reset(models, _5.extend({ silent: true }, options));
      };
      var setOptions = { add: true, remove: true, merge: true };
      var addOptions = { add: true, remove: false };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i5;
        for (i5 = 0; i5 < tail.length; i5++)
          tail[i5] = array[i5 + at];
        for (i5 = 0; i5 < length; i5++)
          array[i5 + at] = insert[i5];
        for (i5 = 0; i5 < tail.length; i5++)
          array[i5 + length + at] = tail[i5];
      };
      _5.extend(Collection.prototype, Events, {
        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model2,
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Collection.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        // Proxy `Backbone.sync` by default.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
          return this.set(models, _5.extend({ merge: false }, options, addOptions));
        },
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          options = _5.extend({}, options);
          var singular = !_5.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = { added: [], merged: [], removed };
            this.trigger("update", this, options);
          }
          return singular ? removed[0] : removed;
        },
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          if (models == null)
            return;
          options = _5.extend({}, setOptions, options);
          if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
          }
          var singular = !_5.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null)
            at = +at;
          if (at > this.length)
            at = this.length;
          if (at < 0)
            at += this.length + 1;
          var set3 = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge2 = options.merge;
          var remove2 = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _5.isString(this.comparator) ? this.comparator : null;
          var model, i5;
          for (i5 = 0; i5 < models.length; i5++) {
            model = models[i5];
            var existing = this.get(model);
            if (existing) {
              if (merge2 && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort)
                  sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set3.push(existing);
              }
              models[i5] = existing;
            } else if (add) {
              model = models[i5] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set3.push(model);
              }
            }
          }
          if (remove2) {
            for (i5 = 0; i5 < this.length; i5++) {
              model = this.models[i5];
              if (!modelMap[model.cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove2;
          if (set3.length && replace) {
            orderChanged = this.length !== set3.length || _5.some(this.models, function(m4, index2) {
              return m4 !== set3[index2];
            });
            this.models.length = 0;
            splice(this.models, set3, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable)
              sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort)
            this.sort({ silent: true });
          if (!options.silent) {
            for (i5 = 0; i5 < toAdd.length; i5++) {
              if (at != null)
                options.index = at + i5;
              model = toAdd[i5];
              model.trigger("add", model, this, options);
            }
            if (sort || orderChanged)
              this.trigger("sort", this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger("update", this, options);
            }
          }
          return singular ? models[0] : models;
        },
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options = options ? _5.clone(options) : {};
          for (var i5 = 0; i5 < this.models.length; i5++) {
            this._removeReference(this.models[i5], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _5.extend({ silent: true }, options));
          if (!options.silent)
            this.trigger("reset", this, options);
          return models;
        },
        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, _5.extend({ at: this.length }, options));
        },
        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, _5.extend({ at: 0 }, options));
        },
        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        // Slice out a sub-array of models from the collection.
        slice: function() {
          return slice2.apply(this.models, arguments);
        },
        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function(obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid && this._byId[obj.cid];
        },
        // Returns `true` if the model is in the collection.
        has: function(obj) {
          return this.get(obj) != null;
        },
        // Get the model at the given index.
        at: function(index2) {
          if (index2 < 0)
            index2 += this.length;
          return this.models[index2];
        },
        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first2) {
          return this[first2 ? "find" : "filter"](attrs);
        },
        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator)
            throw new Error("Cannot sort a set without a comparator");
          options || (options = {});
          var length = comparator.length;
          if (_5.isFunction(comparator))
            comparator = comparator.bind(this);
          if (length === 1 || _5.isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent)
            this.trigger("sort", this, options);
          return this;
        },
        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
          return this.map(attr + "");
        },
        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
          options = _5.extend({ parse: true }, options);
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? "reset" : "set";
            collection[method](resp, options);
            if (success)
              success.call(options.context, collection, resp, options);
            collection.trigger("sync", collection, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
          options = options ? _5.clone(options) : {};
          var wait = options.wait;
          model = this._prepareModel(model, options);
          if (!model)
            return false;
          if (!wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(m4, resp, callbackOpts) {
            if (wait)
              collection.add(m4, callbackOpts);
            if (success)
              success.call(callbackOpts.context, m4, resp, callbackOpts);
          };
          model.save(null, options);
          return model;
        },
        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        // Define how to uniquely identify models in the collection.
        modelId: function(attrs) {
          return attrs[this.model.prototype.idAttribute || "id"];
        },
        // Get an iterator of all models in this collection.
        values: function() {
          return new CollectionIterator(this, ITERATOR_VALUES);
        },
        // Get an iterator of all model IDs in this collection.
        keys: function() {
          return new CollectionIterator(this, ITERATOR_KEYS);
        },
        // Get an iterator of all [ID, model] tuples in this collection.
        entries: function() {
          return new CollectionIterator(this, ITERATOR_KEYSVALUES);
        },
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!attrs.collection)
              attrs.collection = this;
            return attrs;
          }
          options = options ? _5.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger("invalid", this, model.validationError, options);
          return false;
        },
        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
          var removed = [];
          for (var i5 = 0; i5 < models.length; i5++) {
            var model = this.get(models[i5]);
            if (!model)
              continue;
            var index2 = this.indexOf(model);
            this.models.splice(index2, 1);
            this.length--;
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null)
              delete this._byId[id];
            if (!options.silent) {
              options.index = index2;
              model.trigger("remove", model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          return removed;
        },
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
          return model instanceof Model2;
        },
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          var id = this.modelId(model.attributes);
          if (id != null)
            this._byId[id] = model;
          model.on("all", this._onModelEvent, this);
        },
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (this === model.collection)
            delete model.collection;
          model.off("all", this._onModelEvent, this);
        },
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === "add" || event === "remove") && collection !== this)
              return;
            if (event === "destroy")
              this.remove(model, options);
            if (event === "change") {
              var prevId = this.modelId(model.previousAttributes());
              var id = this.modelId(model.attributes);
              if (prevId !== id) {
                if (prevId != null)
                  delete this._byId[prevId];
                if (id != null)
                  this._byId[id] = model;
              }
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var $$iterator = typeof Symbol === "function" && Symbol.iterator;
      if ($$iterator) {
        Collection.prototype[$$iterator] = Collection.prototype.values;
      }
      var CollectionIterator = function(collection, kind) {
        this._collection = collection;
        this._kind = kind;
        this._index = 0;
      };
      var ITERATOR_VALUES = 1;
      var ITERATOR_KEYS = 2;
      var ITERATOR_KEYSVALUES = 3;
      if ($$iterator) {
        CollectionIterator.prototype[$$iterator] = function() {
          return this;
        };
      }
      CollectionIterator.prototype.next = function() {
        if (this._collection) {
          if (this._index < this._collection.length) {
            var model = this._collection.at(this._index);
            this._index++;
            var value;
            if (this._kind === ITERATOR_VALUES) {
              value = model;
            } else {
              var id = this._collection.modelId(model.attributes);
              if (this._kind === ITERATOR_KEYS) {
                value = id;
              } else {
                value = [id, model];
              }
            }
            return { value, done: false };
          }
          this._collection = void 0;
        }
        return { value: void 0, done: true };
      };
      var View2 = Backbone3.View = function(options) {
        this.cid = _5.uniqueId("view");
        this.preinitialize.apply(this, arguments);
        _5.extend(this, _5.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
      _5.extend(View2.prototype, Events, {
        // The default `tagName` of a View's element is `"div"`.
        tagName: "div",
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the View
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
          return this;
        },
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
          this.$el.remove();
        },
        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element2) {
          this.undelegateEvents();
          this._setElement(element2);
          this.delegateEvents();
          return this;
        },
        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
          this.$el = el instanceof Backbone3.$ ? el : Backbone3.$(el);
          this.el = this.$el[0];
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events2) {
          events2 || (events2 = _5.result(this, "events"));
          if (!events2)
            return this;
          this.undelegateEvents();
          for (var key in events2) {
            var method = events2[key];
            if (!_5.isFunction(method))
              method = this[method];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], method.bind(this));
          }
          return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
          if (this.$el)
            this.$el.off(".delegateEvents" + this.cid);
          return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _5.extend({}, _5.result(this, "attributes"));
            if (this.id)
              attrs.id = _5.result(this, "id");
            if (this.className)
              attrs["class"] = _5.result(this, "className");
            this.setElement(this._createElement(_5.result(this, "tagName")));
            this._setAttributes(attrs);
          } else {
            this.setElement(_5.result(this, "el"));
          }
        },
        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes) {
          this.$el.attr(attributes);
        }
      });
      var addMethod = function(base, length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
              return base[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return base[method](this[attribute], value);
            };
          case 3:
            return function(iteratee2, context) {
              return base[method](this[attribute], cb2(iteratee2, this), context);
            };
          case 4:
            return function(iteratee2, defaultVal, context) {
              return base[method](this[attribute], cb2(iteratee2, this), defaultVal, context);
            };
          default:
            return function() {
              var args = slice2.call(arguments);
              args.unshift(this[attribute]);
              return base[method].apply(base, args);
            };
        }
      };
      var addUnderscoreMethods = function(Class, base, methods, attribute) {
        _5.each(methods, function(length, method) {
          if (base[method])
            Class.prototype[method] = addMethod(base, length, method, attribute);
        });
      };
      var cb2 = function(iteratee2, instance) {
        if (_5.isFunction(iteratee2))
          return iteratee2;
        if (_5.isObject(iteratee2) && !instance._isModel(iteratee2))
          return modelMatcher(iteratee2);
        if (_5.isString(iteratee2))
          return function(model) {
            return model.get(iteratee2);
          };
        return iteratee2;
      };
      var modelMatcher = function(attrs) {
        var matcher2 = _5.matches(attrs);
        return function(model) {
          return matcher2(model.attributes);
        };
      };
      var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
      };
      var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
      };
      _5.each([
        [Collection, collectionMethods, "models"],
        [Model2, modelMethods, "attributes"]
      ], function(config) {
        var Base = config[0], methods = config[1], attribute = config[2];
        Base.mixin = function(obj) {
          var mappings = _5.reduce(_5.functions(obj), function(memo, name) {
            memo[name] = 0;
            return memo;
          }, {});
          addUnderscoreMethods(Base, obj, mappings, attribute);
        };
        addUnderscoreMethods(Base, _5, methods, attribute);
      });
      Backbone3.sync = function(method, model, options) {
        var type2 = methodMap[method];
        _5.defaults(options || (options = {}), {
          emulateHTTP: Backbone3.emulateHTTP,
          emulateJSON: Backbone3.emulateJSON
        });
        var params = { type: type2, dataType: "json" };
        if (!options.url) {
          params.url = _5.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
          params.contentType = "application/json";
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = "application/x-www-form-urlencoded";
          params.data = params.data ? { model: params.data } : {};
        }
        if (options.emulateHTTP && (type2 === "PUT" || type2 === "DELETE" || type2 === "PATCH")) {
          params.type = "POST";
          if (options.emulateJSON)
            params.data._method = type2;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr2) {
            xhr2.setRequestHeader("X-HTTP-Method-Override", type2);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
          params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr2, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error)
            error.call(options.context, xhr2, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone3.ajax(_5.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
      };
      var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        delete: "DELETE",
        read: "GET"
      };
      Backbone3.ajax = function() {
        return Backbone3.$.ajax.apply(Backbone3.$, arguments);
      };
      var Router = Backbone3.Router = function(options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.routes)
          this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp2 = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _5.extend(Router.prototype, Events, {
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Router.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
          if (!_5.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_5.isFunction(name)) {
            callback = name;
            name = "";
          }
          if (!callback)
            callback = this[name];
          var router = this;
          Backbone3.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name) !== false) {
              router.trigger.apply(router, ["route:" + name].concat(args));
              router.trigger("route", name, args);
              Backbone3.history.trigger("route", router, name, args);
            }
          });
          return this;
        },
        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name) {
          if (callback)
            callback.apply(this, args);
        },
        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
          Backbone3.history.navigate(fragment, options);
          return this;
        },
        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
          if (!this.routes)
            return;
          this.routes = _5.result(this, "routes");
          var route, routes = _5.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp2, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
            return optional ? match : "([^/?]+)";
          }).replace(splatParam, "([^?]*?)");
          return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _5.map(params, function(param, i5) {
            if (i5 === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone3.History = function() {
        this.handlers = [];
        this.checkUrl = this.checkUrl.bind(this);
        if (typeof window !== "undefined") {
          this.location = window.location;
          this.history = window.history;
        }
      };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var pathStripper = /#.*$/;
      History.started = false;
      _5.extend(History.prototype, Events, {
        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,
        // Are we at the app root?
        atRoot: function() {
          var path = this.location.pathname.replace(/[^\/]$/, "$&/");
          return path === this.root && !this.getSearch();
        },
        // Does the pathname match the root?
        matchRoot: function() {
          var path = this.decodeFragment(this.location.pathname);
          var rootPath = path.slice(0, this.root.length - 1) + "/";
          return rootPath === this.root;
        },
        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function(fragment) {
          return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
          return match ? match[0] : "";
        },
        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window2) {
          var match = (window2 || this).location.href.match(/#(.*)$/);
          return match ? match[1] : "";
        },
        // Get the pathname and search params, without the root.
        getPath: function() {
          var path = this.decodeFragment(
            this.location.pathname + this.getSearch()
          ).slice(this.root.length - 1);
          return path.charAt(0) === "/" ? path.slice(1) : path;
        },
        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment) {
          if (fragment == null) {
            if (this._usePushState || !this._wantsHashChange) {
              fragment = this.getPath();
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, "");
        },
        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
          if (History.started)
            throw new Error("Backbone.history has already been started");
          History.started = true;
          this.options = _5.extend({ root: "/" }, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
          this._useHashChange = this._wantsHashChange && this._hasHashChange;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.history && this.history.pushState);
          this._usePushState = this._wantsPushState && this._hasPushState;
          this.fragment = this.getFragment();
          this.root = ("/" + this.root + "/").replace(rootStripper, "/");
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              var rootPath = this.root.slice(0, -1) || "/";
              this.location.replace(rootPath + "#" + this.getPath());
              return true;
            } else if (this._hasPushState && this.atRoot()) {
              this.navigate(this.getHash(), { replace: true });
            }
          }
          if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
            this.iframe = document.createElement("iframe");
            this.iframe.src = "javascript:0";
            this.iframe.style.display = "none";
            this.iframe.tabIndex = -1;
            var body = document.body;
            var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
            iWindow.document.open();
            iWindow.document.close();
            iWindow.location.hash = "#" + this.fragment;
          }
          var addEventListener = window.addEventListener || function(eventName, listener) {
            return attachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            addEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            addEventListener("hashchange", this.checkUrl, false);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
          var removeEventListener = window.removeEventListener || function(eventName, listener) {
            return detachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            removeEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            removeEventListener("hashchange", this.checkUrl, false);
          }
          if (this.iframe) {
            document.body.removeChild(this.iframe);
            this.iframe = null;
          }
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
          this.handlers.unshift({ route, callback });
        },
        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e4) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe.contentWindow);
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
          if (!this.matchRoot())
            return false;
          fragment = this.fragment = this.getFragment(fragment);
          return _5.some(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = { trigger: !!options };
          fragment = this.getFragment(fragment || "");
          var rootPath = this.root;
          if (fragment === "" || fragment.charAt(0) === "?") {
            rootPath = rootPath.slice(0, -1) || "/";
          }
          var url = rootPath + fragment;
          fragment = fragment.replace(pathStripper, "");
          var decodedFragment = this.decodeFragment(fragment);
          if (this.fragment === decodedFragment)
            return;
          this.fragment = decodedFragment;
          if (this._usePushState) {
            this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
              var iWindow = this.iframe.contentWindow;
              if (!options.replace) {
                iWindow.document.open();
                iWindow.document.close();
              }
              this._updateHash(iWindow.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location2, fragment, replace) {
          if (replace) {
            var href = location2.href.replace(/(javascript:|#).*$/, "");
            location2.replace(href + "#" + fragment);
          } else {
            location2.hash = "#" + fragment;
          }
        }
      });
      Backbone3.history = new History();
      var extend3 = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _5.has(protoProps, "constructor")) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        _5.extend(child, parent, staticProps);
        child.prototype = _5.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
      };
      Model2.extend = Collection.extend = Router.extend = View2.extend = History.extend = extend3;
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error)
            error.call(options.context, model, resp, options);
          model.trigger("error", model, resp, options);
        };
      };
      return Backbone3;
    });
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/nativeview.js
function matchesFallback(selector) {
  const matches = (this.document || this.ownerDocument).querySelectorAll(selector);
  let i5 = matches.length;
  while (--i5 >= 0 && matches.item(i5) !== this) {
    continue;
  }
  return i5 > -1;
}
var Backbone, ElementProto, matchesSelector, NativeView;
var init_nativeview = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/nativeview.js"() {
    Backbone = __toESM(require_backbone());
    ElementProto = typeof Element !== "undefined" ? Element.prototype : void 0;
    matchesSelector = ElementProto ? ElementProto.matches || ElementProto["webkitMatchesSelector"] || ElementProto["mozMatchesSelector"] || ElementProto["msMatchesSelector"] || ElementProto["oMatchesSelector"] || matchesFallback : matchesFallback;
    NativeView = class extends Backbone.View {
      _removeElement() {
        this.undelegateEvents();
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
      // Apply the `element` to the view.
      _setElement(element2) {
        this.el = element2;
      }
      // Set a hash of attributes to the view's `el`. We use the "prop" version
      // if available, falling back to `setAttribute` for the catch-all.
      _setAttributes(attrs) {
        for (const attr in attrs) {
          attr in this.el ? this.el[attr] = attrs[attr] : this.el.setAttribute(attr, attrs[attr]);
        }
      }
      delegate(eventName, selector, listener) {
        if (typeof selector !== "string") {
          listener = selector;
          selector = null;
        }
        if (this._domEvents === void 0) {
          this._domEvents = [];
        }
        const root2 = this.el;
        const handler = selector ? function(e4) {
          let node = e4.target || e4.srcElement;
          for (; node && node !== root2; node = node.parentNode) {
            if (matchesSelector.call(node, selector)) {
              e4.delegateTarget = node;
              if (listener.handleEvent) {
                return listener.handleEvent(e4);
              } else {
                return listener(e4);
              }
            }
          }
        } : listener;
        this.el.addEventListener(eventName, handler, false);
        this._domEvents.push({ eventName, handler, listener, selector });
        return handler;
      }
      undelegate(eventName, selector, listener) {
        if (typeof selector === "function") {
          listener = selector;
          selector = null;
        }
        if (this.el && this._domEvents) {
          const handlers = this._domEvents.slice();
          let i5 = handlers.length;
          while (i5--) {
            const item = handlers[i5];
            const match = item.eventName === eventName && (listener ? item.listener === listener : true) && (selector ? item.selector === selector : true);
            if (!match) {
              continue;
            }
            this.el.removeEventListener(item.eventName, item.handler, false);
            this._domEvents.splice(i5, 1);
          }
        }
        return this;
      }
      // Remove all events created with `delegate` from `el`
      undelegateEvents() {
        if (this.el && this._domEvents) {
          const len = this._domEvents.length;
          for (let i5 = 0; i5 < len; i5++) {
            const item = this._domEvents[i5];
            this.el.removeEventListener(item.eventName, item.handler, false);
          }
          this._domEvents.length = 0;
        }
        return this;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/version.js
var JUPYTER_WIDGETS_VERSION, PROTOCOL_VERSION;
var init_version = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/version.js"() {
    JUPYTER_WIDGETS_VERSION = "2.0.0";
    PROTOCOL_VERSION = "2.1.0";
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget.js
function unpack_models(value, manager) {
  if (Array.isArray(value)) {
    const unpacked = [];
    for (const sub_value of value) {
      unpacked.push(unpack_models(sub_value, manager));
    }
    return Promise.all(unpacked);
  } else if (value instanceof Object && typeof value !== "string") {
    const unpacked = {};
    for (const [key, sub_value] of Object.entries(value)) {
      unpacked[key] = unpack_models(sub_value, manager);
    }
    return resolvePromisesDict(unpacked);
  } else if (typeof value === "string" && value.slice(0, 10) === IPY_MODEL_) {
    return manager.get_model(value.slice(10, value.length));
  } else {
    return Promise.resolve(value);
  }
}
function pack_models(value, widget) {
  if (Array.isArray(value)) {
    const model_ids = [];
    for (const model of value) {
      model_ids.push(pack_models(model, widget));
    }
    return model_ids;
  } else if (value instanceof WidgetModel) {
    return `${IPY_MODEL_}${value.model_id}`;
  } else if (value instanceof Object && typeof value !== "string") {
    const packed = {};
    for (const [key, sub_value] of Object.entries(value)) {
      packed[key] = pack_models(sub_value, widget);
    }
  } else {
    return value;
  }
}
var Backbone2, import_jquery, import_coreutils25, IPY_MODEL_, WidgetModel, DOMWidgetModel, WidgetView, JupyterLuminoWidget, JupyterPhosphorWidget, JupyterLuminoPanelWidget, DOMWidgetView;
var init_widget3 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget.js"() {
    init_utils();
    init_backbone_patch();
    Backbone2 = __toESM(require_backbone());
    import_jquery = __toESM(require_jquery());
    init_nativeview();
    import_coreutils25 = __toESM(require_dist());
    init_index_es65();
    init_index_es63();
    init_version();
    IPY_MODEL_ = "IPY_MODEL_";
    WidgetModel = class extends Backbone2.Model {
      /**
       * The default attributes.
       */
      defaults() {
        return {
          _model_module: "@jupyter-widgets/base",
          _model_name: "WidgetModel",
          _model_module_version: JUPYTER_WIDGETS_VERSION,
          _view_module: "@jupyter-widgets/base",
          _view_name: null,
          _view_module_version: JUPYTER_WIDGETS_VERSION,
          _view_count: null
        };
      }
      /**
       * Test to see if the model has been synced with the server.
       *
       * #### Notes
       * As of backbone 1.1, backbone ignores `patch` if it thinks the
       * model has never been pushed.
       */
      isNew() {
        return false;
      }
      /**
       * Constructor
       *
       * Initializes a WidgetModel instance. Called by the Backbone constructor.
       *
       * Parameters
       * ----------
       * widget_manager : WidgetManager instance
       * model_id : string
       *      An ID unique to this model.
       * comm : Comm instance (optional)
       */
      initialize(attributes, options) {
        this._expectedEchoMsgIds = /* @__PURE__ */ new Map();
        this._attrsToUpdate = /* @__PURE__ */ new Set();
        super.initialize(attributes, options);
        this.widget_manager = options.widget_manager;
        this.model_id = options.model_id;
        const comm = options.comm;
        this.views = /* @__PURE__ */ Object.create(null);
        this.state_change = Promise.resolve();
        this._closed = false;
        this._state_lock = null;
        this._msg_buffer = null;
        this._msg_buffer_callbacks = null;
        this._pending_msgs = 0;
        this._buffered_state_diff = {};
        if (comm) {
          this.comm = comm;
          comm.on_close(this._handle_comm_closed.bind(this));
          comm.on_msg(this._handle_comm_msg.bind(this));
          this.comm_live = true;
        } else {
          this.comm_live = false;
        }
      }
      get comm_live() {
        return this._comm_live;
      }
      set comm_live(x4) {
        this._comm_live = x4;
        this.trigger("comm_live_update");
      }
      /**
       * Send a custom msg over the comm.
       */
      send(content, callbacks, buffers) {
        if (this.comm !== void 0) {
          const data = { method: "custom", content };
          this.comm.send(data, callbacks, {}, buffers);
        }
      }
      /**
       * Close model
       *
       * @param comm_closed - true if the comm is already being closed. If false, the comm will be closed.
       *
       * @returns - a promise that is fulfilled when all the associated views have been removed.
       */
      close(comm_closed = false) {
        if (this._closed) {
          return Promise.resolve();
        }
        this._closed = true;
        if (this.comm && !comm_closed) {
          this.comm.close();
        }
        this.stopListening();
        this.trigger("destroy", this);
        if (this.comm) {
          delete this.comm;
        }
        if (this.views) {
          const views = Object.keys(this.views).map((id) => {
            return this.views[id].then((view) => view.remove());
          });
          delete this.views;
          return Promise.all(views).then(() => {
            return;
          });
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget comm is closed.
       */
      _handle_comm_closed(msg) {
        this.trigger("comm:close");
        this.close(true);
      }
      /**
       * Handle incoming comm msg.
       */
      _handle_comm_msg(msg) {
        const data = msg.content.data;
        const method = data.method;
        switch (method) {
          case "update":
          case "echo_update":
            this.state_change = this.state_change.then(() => {
              var _a, _b, _c;
              const state = data.state;
              const buffer_paths = (_a = data.buffer_paths) !== null && _a !== void 0 ? _a : [];
              const buffers = (_c = (_b = msg.buffers) === null || _b === void 0 ? void 0 : _b.slice(0, buffer_paths.length)) !== null && _c !== void 0 ? _c : [];
              put_buffers(state, buffer_paths, buffers);
              if (msg.parent_header && method === "echo_update") {
                const msgId = msg.parent_header.msg_id;
                const expectedEcho = Object.keys(state).filter((attrName) => this._expectedEchoMsgIds.has(attrName));
                expectedEcho.forEach((attrName) => {
                  const isOldMessage = this._expectedEchoMsgIds.get(attrName) !== msgId;
                  if (isOldMessage) {
                    delete state[attrName];
                  } else {
                    this._expectedEchoMsgIds.delete(attrName);
                    if (this._msg_buffer !== null && Object.prototype.hasOwnProperty.call(this._msg_buffer, attrName)) {
                      delete state[attrName];
                    }
                  }
                });
              }
              return this.constructor._deserialize_state(
                // Combine the state updates, with preference for kernel updates
                state,
                this.widget_manager
              );
            }).then((state) => {
              this.set_state(state);
            }).catch(reject(`Could not process update msg for model id: ${this.model_id}`, true));
            return this.state_change;
          case "custom":
            this.trigger("msg:custom", data.content, msg.buffers);
            return Promise.resolve();
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget is updated from the backend.
       *
       * This function is meant for internal use only. Values set here will not be propagated on a sync.
       */
      set_state(state) {
        this._state_lock = state;
        try {
          this.set(state);
        } catch (e4) {
          console.error(`Error setting state: ${e4 instanceof Error ? e4.message : e4}`);
        } finally {
          this._state_lock = null;
        }
      }
      /**
       * Get the serializable state of the model.
       *
       * If drop_default is truthy, attributes that are equal to their default
       * values are dropped.
       */
      get_state(drop_defaults) {
        const fullState = this.attributes;
        if (drop_defaults) {
          const d6 = this.defaults;
          const defaults = typeof d6 === "function" ? d6.call(this) : d6;
          const state = {};
          Object.keys(fullState).forEach((key) => {
            if (!isEqual(fullState[key], defaults[key])) {
              state[key] = fullState[key];
            }
          });
          return state;
        } else {
          return Object.assign({}, fullState);
        }
      }
      /**
       * Handle status msgs.
       *
       * execution_state : ('busy', 'idle', 'starting')
       */
      _handle_status(msg) {
        if (this.comm !== void 0) {
          if (msg.content.execution_state === "idle") {
            this._pending_msgs--;
            if (this._pending_msgs < 0) {
              console.error(`Jupyter Widgets message throttle: Pending messages < 0 (=${this._pending_msgs}), which is unexpected. Resetting to 0 to continue.`);
              this._pending_msgs = 0;
            }
            if (this._msg_buffer !== null && this._pending_msgs < 1) {
              const msgId = this.send_sync_message(this._msg_buffer, this._msg_buffer_callbacks);
              this.rememberLastUpdateFor(msgId);
              this._msg_buffer = null;
              this._msg_buffer_callbacks = null;
            }
          }
        }
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks(view) {
        return this.widget_manager.callbacks(view);
      }
      /**
       * Set one or more values.
       *
       * We just call the super method, in which val and options are optional.
       * Handles both "key", value and {key: value} -style arguments.
       */
      set(key, val, options) {
        const return_value = set.call(this, key, val, options);
        if (this._buffered_state_diff !== void 0) {
          const attrs = this.changedAttributes() || {};
          if (this._state_lock) {
            for (const key2 of Object.keys(this._state_lock)) {
              if (attrs[key2] === this._state_lock[key2]) {
                delete attrs[key2];
              }
            }
          }
          if (this._buffered_state_diff_synced) {
            for (const key2 of Object.keys(this._buffered_state_diff_synced)) {
              if (attrs[key2] === this._buffered_state_diff_synced[key2]) {
                delete attrs[key2];
              }
            }
          }
          this._buffered_state_diff = assign(this._buffered_state_diff, attrs);
        }
        if (this._changing === false) {
          this._buffered_state_diff_synced = {};
        }
        return return_value;
      }
      /**
       * Handle sync to the back-end.  Called when a model.save() is called.
       *
       * Make sure a comm exists.
       *
       * Parameters
       * ----------
       * method : create, update, patch, delete, read
       *   create/update always send the full attribute set
       *   patch - only send attributes listed in options.attrs, and if we
       *   are queuing up messages, combine with previous messages that have
       *   not been sent yet
       * model : the model we are syncing
       *   will normally be the same as `this`
       * options : dict
       *   the `attrs` key, if it exists, gives an {attr: value} dict that
       *   should be synced, otherwise, sync all attributes.
       *
       */
      sync(method, model, options = {}) {
        if (this.comm === void 0) {
          throw "Syncing error: no comm channel defined";
        }
        const attrs = method === "patch" ? options.attrs : model.get_state(options.drop_defaults);
        if (this._state_lock) {
          for (const key of Object.keys(this._state_lock)) {
            if (attrs[key] === this._state_lock[key]) {
              delete attrs[key];
            }
          }
        }
        Object.keys(attrs).forEach((attrName) => {
          this._attrsToUpdate.add(attrName);
        });
        const msgState = this.serialize(attrs);
        if (Object.keys(msgState).length > 0) {
          const callbacks = options.callbacks || this.callbacks();
          if (this._pending_msgs >= 1) {
            switch (method) {
              case "patch":
                this._msg_buffer = assign(this._msg_buffer || {}, msgState);
                break;
              case "update":
              case "create":
                this._msg_buffer = msgState;
                break;
              default:
                throw "unrecognized syncing method";
            }
            this._msg_buffer_callbacks = callbacks;
          } else {
            const msgId = this.send_sync_message(attrs, callbacks);
            this.rememberLastUpdateFor(msgId);
          }
        }
      }
      rememberLastUpdateFor(msgId) {
        this._attrsToUpdate.forEach((attrName) => {
          this._expectedEchoMsgIds.set(attrName, msgId);
        });
        this._attrsToUpdate = /* @__PURE__ */ new Set();
      }
      /**
       * Serialize widget state.
       *
       * A serializer is a function which takes in a state attribute and a widget,
       * and synchronously returns a JSONable object. The returned object will
       * have toJSON called if possible, and the final result should be a
       * primitive object that is a snapshot of the widget state that may have
       * binary array buffers.
       */
      serialize(state) {
        const serializers = this.constructor.serializers || import_coreutils25.JSONExt.emptyObject;
        for (const k of Object.keys(state)) {
          try {
            if (serializers[k] && serializers[k].serialize) {
              state[k] = serializers[k].serialize(state[k], this);
            } else {
              state[k] = JSON.parse(JSON.stringify(state[k]));
            }
            if (state[k] && state[k].toJSON) {
              state[k] = state[k].toJSON();
            }
          } catch (e4) {
            console.error("Error serializing widget state attribute: ", k);
            throw e4;
          }
        }
        return state;
      }
      /**
       * Send a sync message to the kernel.
       *
       * If a message is sent successfully, this returns the message ID of that
       * message. Otherwise it returns an empty string
       */
      send_sync_message(state, callbacks = {}) {
        if (!this.comm) {
          return "";
        }
        try {
          callbacks = {
            shell: Object.assign({}, callbacks.shell),
            iopub: Object.assign({}, callbacks.iopub),
            input: callbacks.input
          };
          const statuscb = callbacks.iopub.status;
          callbacks.iopub.status = (msg) => {
            this._handle_status(msg);
            if (statuscb) {
              statuscb(msg);
            }
          };
          const split = remove_buffers(state);
          const msgId = this.comm.send({
            method: "update",
            state: split.state,
            buffer_paths: split.buffer_paths
          }, callbacks, {}, split.buffers);
          this._pending_msgs++;
          return msgId;
        } catch (e4) {
          console.error("Could not send widget sync message", e4);
        }
        return "";
      }
      /**
       * Push this model's state to the back-end
       *
       * This invokes a Backbone.Sync.
       */
      save_changes(callbacks) {
        if (this.comm_live) {
          const options = { patch: true };
          if (callbacks) {
            options.callbacks = callbacks;
          }
          this.save(this._buffered_state_diff, options);
          if (this._changing) {
            assign(this._buffered_state_diff_synced, this._buffered_state_diff);
          }
          this._buffered_state_diff = {};
        }
      }
      /**
       * on_some_change(['key1', 'key2'], foo, context) differs from
       * on('change:key1 change:key2', foo, context).
       * If the widget attributes key1 and key2 are both modified,
       * the second form will result in foo being called twice
       * while the first will call foo only once.
       */
      on_some_change(keys2, callback, context) {
        this.on("change", (...args) => {
          if (keys2.some(this.hasChanged, this)) {
            callback.apply(context, args);
          }
        }, this);
      }
      /**
       * Serialize the model.  See the deserialization function at the top of this file
       * and the kernel-side serializer/deserializer.
       */
      toJSON(options) {
        return `IPY_MODEL_${this.model_id}`;
      }
      /**
       * Returns a promise for the deserialized state. The second argument
       * is an instance of widget manager, which is required for the
       * deserialization of widget models.
       */
      static _deserialize_state(state, manager) {
        const serializers = this.serializers;
        let deserialized;
        if (serializers) {
          deserialized = {};
          for (const k in state) {
            if (serializers[k] && serializers[k].deserialize) {
              deserialized[k] = serializers[k].deserialize(state[k], manager);
            } else {
              deserialized[k] = state[k];
            }
          }
        } else {
          deserialized = state;
        }
        return resolvePromisesDict(deserialized);
      }
    };
    DOMWidgetModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _dom_classes: [],
          tabbable: null,
          tooltip: null
          // We do not declare defaults for the layout and style attributes.
          // Those defaults are constructed on the kernel side and synced here
          // as needed, and our code here copes with those attributes being
          // undefined. See
          // https://github.com/jupyter-widgets/ipywidgets/issues/1620 and
          // https://github.com/jupyter-widgets/ipywidgets/pull/1621
        });
      }
    };
    DOMWidgetModel.serializers = Object.assign(Object.assign({}, WidgetModel.serializers), { layout: { deserialize: unpack_models }, style: { deserialize: unpack_models } });
    WidgetView = class extends NativeView {
      /**
       * Public constructor.
       */
      constructor(options) {
        super(options);
      }
      /**
       * Initializer, called at the end of the constructor.
       */
      initialize(parameters) {
        this.listenTo(this.model, "change", (model, options) => {
          const changed = Object.keys(this.model.changedAttributes() || {});
          if (changed[0] === "_view_count" && changed.length === 1) {
            return;
          }
          this.update(options);
        });
        this.options = parameters.options;
        this.once("remove", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") - 1);
            this.model.save_changes();
          }
        });
        this.once("displayed", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") + 1);
            this.model.save_changes();
          }
        });
        this.displayed = new Promise((resolve, reject4) => {
          this.once("displayed", resolve);
          this.model.on("msg:custom", this.handle_message.bind(this));
        });
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.el.focus();
        } else if (content.do === "blur") {
          this.el.blur();
        }
      }
      /**
       * Triggered on model change.
       *
       * Update view to be consistent with this.model
       */
      update(options) {
        return;
      }
      /**
       * Render a view
       *
       * @returns the view or a promise to the view.
       */
      render() {
        return;
      }
      create_child_view(child_model, options = {}) {
        options = Object.assign({ parent: this }, options);
        return this.model.widget_manager.create_view(child_model, options).catch(reject("Could not create child view", true));
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks() {
        return this.model.callbacks(this);
      }
      /**
       * Send a custom msg associated with this view.
       */
      send(content, buffers) {
        this.model.send(content, this.callbacks(), buffers);
      }
      touch() {
        this.model.save_changes(this.callbacks());
      }
      remove() {
        super.remove();
        this.trigger("remove");
        return this;
      }
    };
    JupyterLuminoWidget = class extends Widget {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
    };
    JupyterPhosphorWidget = JupyterLuminoWidget;
    JupyterLuminoPanelWidget = class extends Panel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        var _a;
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.remove();
        this._view = null;
      }
    };
    DOMWidgetView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:_dom_classes", (model, new_classes) => {
          const old_classes = model.previous("_dom_classes");
          this.update_classes(old_classes, new_classes);
        });
        this.layoutPromise = Promise.resolve();
        this.listenTo(this.model, "change:layout", (model, value) => {
          this.setLayout(value, model.previous("layout"));
        });
        this.stylePromise = Promise.resolve();
        this.listenTo(this.model, "change:style", (model, value) => {
          this.setStyle(value, model.previous("style"));
        });
        this.displayed.then(() => {
          this.update_classes([], this.model.get("_dom_classes"));
          this.setLayout(this.model.get("layout"));
          this.setStyle(this.model.get("style"));
        });
        this._comm_live_update();
        this.listenTo(this.model, "comm_live_update", () => {
          this._comm_live_update();
        });
        this.listenTo(this.model, "change:tooltip", this.updateTooltip);
        this.updateTooltip();
      }
      setLayout(layout, oldLayout) {
        if (layout) {
          this.layoutPromise = this.layoutPromise.then((oldLayoutView) => {
            if (oldLayoutView) {
              oldLayoutView.unlayout();
              this.stopListening(oldLayoutView.model);
              oldLayoutView.remove();
            }
            return this.create_child_view(layout).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.listenTo(view.model, "change", () => {
                  MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                });
                MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                this.trigger("layout-changed");
                return view;
              });
            }).catch(reject("Could not add LayoutView to DOMWidgetView", true));
          });
        }
      }
      setStyle(style, oldStyle) {
        if (style) {
          this.stylePromise = this.stylePromise.then((oldStyleView) => {
            if (oldStyleView) {
              oldStyleView.unstyle();
              this.stopListening(oldStyleView.model);
              oldStyleView.remove();
            }
            return this.create_child_view(style).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.trigger("style-changed");
                return view;
              });
            }).catch(reject("Could not add styleView to DOMWidgetView", true));
          });
        }
      }
      updateTooltip() {
        const title = this.model.get("tooltip");
        if (!title) {
          this.el.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.el.setAttribute("title", title);
        }
      }
      /**
       * Update the DOM classes applied to an element, default to this.el.
       */
      update_classes(old_classes, new_classes, el) {
        if (el === void 0) {
          el = this.el;
        }
        difference(old_classes, new_classes).map(function(c6) {
          if (el.classList) {
            el.classList.remove(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").replace(c6, ""));
          }
        });
        difference(new_classes, old_classes).map(function(c6) {
          if (el.classList) {
            el.classList.add(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").concat(" ", c6));
          }
        });
      }
      /**
       * Update the DOM classes applied to the widget based on a single
       * trait's value.
       *
       * Given a trait value classes map, this function automatically
       * handles applying the appropriate classes to the widget element
       * and removing classes that are no longer valid.
       *
       * Parameters
       * ----------
       * class_map: dictionary
       *  Dictionary of trait values to class lists.
       *  Example:
       *      {
       *          success: ['alert', 'alert-success'],
       *          info: ['alert', 'alert-info'],
       *          warning: ['alert', 'alert-warning'],
       *          danger: ['alert', 'alert-danger']
       *      };
       * trait_name: string
       *  Name of the trait to check the value of.
       * el: optional DOM element handle, defaults to this.el
       *  Element that the classes are applied to.
       */
      update_mapped_classes(class_map, trait_name, el) {
        let key = this.model.previous(trait_name);
        const old_classes = class_map[key] ? class_map[key] : [];
        key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes(old_classes, new_classes, el || this.el);
      }
      set_mapped_classes(class_map, trait_name, el) {
        const key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes([], new_classes, el || this.el);
      }
      _setElement(el) {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        this.$el = el instanceof import_jquery.default ? el : (0, import_jquery.default)(el);
        this.el = this.$el[0];
        this.luminoWidget = new JupyterLuminoWidget({
          node: el,
          view: this
        });
      }
      remove() {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        return super.remove();
      }
      processLuminoMessage(msg) {
        switch (msg.type) {
          case "after-attach":
            this.trigger("displayed");
            break;
          case "show":
            this.trigger("shown");
            break;
        }
      }
      _comm_live_update() {
        if (this.model.comm_live) {
          this.luminoWidget.removeClass("jupyter-widgets-disconnected");
        } else {
          this.luminoWidget.addClass("jupyter-widgets-disconnected");
        }
      }
      updateTabindex() {
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.el.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.el.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.el.removeAttribute("tabIndex");
        }
      }
      /**
       * @deprecated Use {@link luminoWidget} instead (Since 8.0).
       */
      get pWidget() {
        return this.luminoWidget;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/manager.js
var init_manager = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/manager.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_layout.js
var css_properties, LayoutModel, LayoutView;
var init_widget_layout = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_layout.js"() {
    init_utils();
    init_widget3();
    css_properties = {
      align_content: null,
      align_items: null,
      align_self: null,
      border_top: null,
      border_right: null,
      border_bottom: null,
      border_left: null,
      bottom: null,
      display: null,
      flex: null,
      flex_flow: null,
      height: null,
      justify_content: null,
      justify_items: null,
      left: null,
      margin: null,
      max_height: null,
      max_width: null,
      min_height: null,
      min_width: null,
      overflow: null,
      order: null,
      padding: null,
      right: null,
      top: null,
      visibility: null,
      width: null,
      // image-specific
      object_fit: null,
      object_position: null,
      // container
      grid_auto_columns: null,
      grid_auto_flow: null,
      grid_auto_rows: null,
      grid_gap: null,
      grid_template_rows: null,
      grid_template_columns: null,
      grid_template_areas: null,
      // items
      grid_row: null,
      grid_column: null,
      grid_area: null
    };
    LayoutModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _model_name: "LayoutModel",
          _view_name: "LayoutView"
        }, css_properties);
      }
    };
    LayoutView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        for (const key of Object.keys(css_properties)) {
          this.registerTrait(key);
        }
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
        this.handleChange(trait, this.model.get(trait));
      }
      /**
       * Get the the name of the css property from the trait name
       * @param  model attribute name
       * @return css property name
       */
      css_name(trait) {
        return trait.replace(/_/g, "-");
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          if (value === null) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            parent.el.style.setProperty(this.css_name(trait), value);
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unlayout() {
        const parent = this.options.parent;
        this._traitNames.forEach((trait) => {
          if (parent) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_style.js
var StyleModel, StyleView;
var init_widget_style = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_style.js"() {
    init_utils();
    init_widget3();
    StyleModel = class extends WidgetModel {
      defaults() {
        const Derived = this.constructor;
        return assign(super.defaults(), {
          _model_name: "StyleModel",
          _view_name: "StyleView"
        }, Object.keys(Derived.styleProperties).reduce((obj, key) => {
          obj[key] = Derived.styleProperties[key].default;
          return obj;
        }, {}));
      }
    };
    StyleModel.styleProperties = {};
    StyleView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        const ModelType = this.model.constructor;
        for (const key of Object.keys(ModelType.styleProperties)) {
          this.registerTrait(key);
        }
        this.style();
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          const ModelType = this.model.constructor;
          const styleProperties = ModelType.styleProperties;
          const attribute = styleProperties[trait].attribute;
          const selector = styleProperties[trait].selector;
          const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
          if (value === null) {
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.removeProperty(attribute);
            }
          } else {
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.setProperty(attribute, value);
            }
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Apply styles for all registered traits
       */
      style() {
        for (const trait of this._traitNames) {
          this.handleChange(trait, this.model.get(trait));
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unstyle() {
        const parent = this.options.parent;
        const ModelType = this.model.constructor;
        const styleProperties = ModelType.styleProperties;
        this._traitNames.forEach((trait) => {
          if (parent) {
            const attribute = styleProperties[trait].attribute;
            const selector = styleProperties[trait].selector;
            const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
            for (let i5 = 0; i5 !== elements.length; ++i5) {
              elements[i5].style.removeProperty(attribute);
            }
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/services-shim.js
var shims;
var init_services_shim = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/services-shim.js"() {
    (function(shims2) {
      let services;
      (function(services2) {
        class CommManager {
          constructor(jsServicesKernel) {
            this.targets = /* @__PURE__ */ Object.create(null);
            this.comms = /* @__PURE__ */ Object.create(null);
            this.init_kernel(jsServicesKernel);
          }
          /**
           * Hookup kernel events.
           * @param  {Kernel.IKernel} jsServicesKernel - @jupyterlab/services Kernel.IKernel instance
           */
          init_kernel(jsServicesKernel) {
            this.kernel = jsServicesKernel;
            this.jsServicesKernel = jsServicesKernel;
          }
          /**
           * Creates a new connected comm
           */
          async new_comm(target_name, data, callbacks, metadata, comm_id, buffers) {
            const c6 = this.jsServicesKernel.createComm(target_name, comm_id);
            const comm = new Comm(c6);
            this.register_comm(comm);
            comm.open(data, callbacks, metadata, buffers);
            return comm;
          }
          /**
           * Register a comm target
           * @param  {string} target_name
           * @param  {(Comm, object) => void} f - callback that is called when the
           *                         comm is made.  Signature of f(comm, msg).
           */
          register_target(target_name, f6) {
            const handle = this.jsServicesKernel.registerCommTarget(target_name, (jsServicesComm, msg) => {
              const comm = new Comm(jsServicesComm);
              this.register_comm(comm);
              try {
                return f6(comm, msg);
              } catch (e4) {
                comm.close();
                console.error(e4);
                console.error(new Error("Exception opening new comm"));
              }
            });
            this.targets[target_name] = handle;
          }
          /**
           * Unregisters a comm target
           * @param  {string} target_name
           */
          unregister_target(target_name, f6) {
            const handle = this.targets[target_name];
            handle.dispose();
            delete this.targets[target_name];
          }
          /**
           * Register a comm in the mapping
           */
          register_comm(comm) {
            this.comms[comm.comm_id] = Promise.resolve(comm);
            comm.kernel = this.kernel;
            return comm.comm_id;
          }
        }
        services2.CommManager = CommManager;
        class Comm {
          constructor(jsServicesComm) {
            this.jsServicesComm = jsServicesComm;
          }
          /**
           * Comm id
           * @return {string}
           */
          get comm_id() {
            return this.jsServicesComm.commId;
          }
          /**
           * Target name
           * @return {string}
           */
          get target_name() {
            return this.jsServicesComm.targetName;
          }
          /**
           * Opens a sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          open(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.open(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Sends a message to the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @param  buffers
           * @return message id
           */
          send(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.send(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Closes the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          close(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.close(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Register a message handler
           * @param  callback, which is given a message
           */
          on_msg(callback) {
            this.jsServicesComm.onMsg = callback.bind(this);
          }
          /**
           * Register a handler for when the comm is closed by the backend
           * @param  callback, which is given a message
           */
          on_close(callback) {
            this.jsServicesComm.onClose = callback.bind(this);
          }
          /**
           * Hooks callback object up with @jupyterlab/services IKernelFuture
           * @param  @jupyterlab/services IKernelFuture instance
           * @param  callbacks
           */
          _hookupCallbacks(future, callbacks) {
            if (callbacks) {
              future.onReply = function(msg) {
                if (callbacks.shell && callbacks.shell.reply) {
                  callbacks.shell.reply(msg);
                }
              };
              future.onStdin = function(msg) {
                if (callbacks.input) {
                  callbacks.input(msg);
                }
              };
              future.onIOPub = function(msg) {
                if (callbacks.iopub) {
                  if (callbacks.iopub.status && msg.header.msg_type === "status") {
                    callbacks.iopub.status(msg);
                  } else if (callbacks.iopub.clear_output && msg.header.msg_type === "clear_output") {
                    callbacks.iopub.clear_output(msg);
                  } else if (callbacks.iopub.output) {
                    switch (msg.header.msg_type) {
                      case "display_data":
                      case "execute_result":
                      case "stream":
                      case "error":
                        callbacks.iopub.output(msg);
                        break;
                      default:
                        break;
                    }
                  }
                }
              };
            }
          }
        }
        services2.Comm = Comm;
      })(services = shims2.services || (shims2.services = {}));
    })(shims || (shims = {}));
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/viewlist.js
var ViewList;
var init_viewlist = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/viewlist.js"() {
    ViewList = class {
      constructor(create_view, remove_view, context) {
        this.initialize(create_view, remove_view, context);
      }
      initialize(create_view, remove_view, context) {
        this._handler_context = context || this;
        this._models = [];
        this.views = [];
        this._create_view = create_view;
        this._remove_view = remove_view || function(view) {
          view.remove();
        };
      }
      /**
       * the create_view, remove_view, and context arguments override the defaults
       * specified when the list is created.
       * after this function, the .views attribute is a list of promises for views
       * if you want to perform some action on the list of views, do something like
       * `Promise.all(myviewlist.views).then(function(views) {...});`
       */
      update(new_models, create_view, remove_view, context) {
        const remove2 = remove_view || this._remove_view;
        const create2 = create_view || this._create_view;
        context = context || this._handler_context;
        let i5 = 0;
        for (; i5 < new_models.length; i5++) {
          if (i5 >= this._models.length || new_models[i5] !== this._models[i5]) {
            break;
          }
        }
        const first_removed = i5;
        const removed = this.views.splice(first_removed, this.views.length - first_removed);
        for (let j2 = 0; j2 < removed.length; j2++) {
          removed[j2].then(function(view) {
            remove2.call(context, view);
          });
        }
        for (; i5 < new_models.length; i5++) {
          this.views.push(Promise.resolve(create2.call(context, new_models[i5], i5)));
        }
        this._models = new_models.slice();
        return Promise.all(this.views);
      }
      /**
       * removes every view in the list; convenience function for `.update([])`
       * that should be faster
       * returns a promise that resolves after this removal is done
       */
      remove() {
        return Promise.all(this.views).then((views) => {
          views.forEach((value) => this._remove_view.call(this._handler_context, value));
          this.views = [];
          this._models = [];
        });
      }
      /**
       * Dispose this viewlist.
       *
       * A synchronous function which just deletes references to child views. This
       * function does not call .remove() on child views because that is
       * asynchronous. Use this in cases where child views will be removed in
       * another way.
       */
      dispose() {
        this.views = null;
        this._models = null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/registry.js
var import_coreutils26, IJupyterWidgetRegistry;
var init_registry3 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/registry.js"() {
    import_coreutils26 = __toESM(require_dist());
    IJupyterWidgetRegistry = new import_coreutils26.Token("jupyter.extensions.jupyterWidgetRegistry");
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/errorwidget.js
function createErrorWidgetModel(error, msg) {
  class ErrorWidget extends DOMWidgetModel {
    constructor(attributes, options) {
      attributes = Object.assign(Object.assign({}, attributes), { _view_name: "ErrorWidgetView", _view_module: "@jupyter-widgets/base", _model_module_version: JUPYTER_WIDGETS_VERSION, _view_module_version: JUPYTER_WIDGETS_VERSION, msg, error });
      super(attributes, options);
      this.comm_live = true;
    }
  }
  return ErrorWidget;
}
function createErrorWidgetView(error, msg) {
  return class InnerErrorWidgetView extends ErrorWidgetView {
    generateErrorMessage() {
      return {
        msg,
        stack: String(error instanceof Error ? error.stack : error)
      };
    }
  };
}
var ErrorWidgetView;
var init_errorwidget = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/errorwidget.js"() {
    init_widget3();
    init_version();
    init_utils();
    ErrorWidgetView = class extends DOMWidgetView {
      generateErrorMessage() {
        return {
          msg: this.model.get("msg"),
          stack: String(this.model.get("error").stack)
        };
      }
      render() {
        const { msg, stack } = this.generateErrorMessage();
        this.el.classList.add("jupyter-widgets");
        const content = document.createElement("div");
        content.classList.add("jupyter-widgets-error-widget", "icon-error");
        content.innerHTML = BROKEN_FILE_SVG_ICON;
        const text = document.createElement("pre");
        text.style.textAlign = "center";
        text.innerText = "Click to show javascript error.";
        content.append(text);
        this.el.appendChild(content);
        let width;
        let height;
        this.el.onclick = () => {
          if (content.classList.contains("icon-error")) {
            height = height || content.clientHeight;
            width = width || content.clientWidth;
            content.classList.remove("icon-error");
            content.innerHTML = `
        <pre>[Open Browser Console for more detailed log - Double click to close this message]
${msg}
${stack}</pre>
        `;
            content.style.height = `${height}px`;
            content.style.width = `${width}px`;
            content.classList.add("text-error");
          }
        };
        this.el.ondblclick = () => {
          if (content.classList.contains("text-error")) {
            content.classList.remove("text-error");
            content.innerHTML = BROKEN_FILE_SVG_ICON;
            content.append(text);
            content.classList.add("icon-error");
          }
        };
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  BROKEN_FILE_SVG_ICON: () => BROKEN_FILE_SVG_ICON,
  DOMWidgetModel: () => DOMWidgetModel,
  DOMWidgetView: () => DOMWidgetView,
  ErrorWidgetView: () => ErrorWidgetView,
  IJupyterWidgetRegistry: () => IJupyterWidgetRegistry,
  JUPYTER_WIDGETS_VERSION: () => JUPYTER_WIDGETS_VERSION,
  JupyterLuminoPanelWidget: () => JupyterLuminoPanelWidget,
  JupyterLuminoWidget: () => JupyterLuminoWidget,
  JupyterPhosphorWidget: () => JupyterPhosphorWidget,
  LayoutModel: () => LayoutModel,
  LayoutView: () => LayoutView,
  PROTOCOL_VERSION: () => PROTOCOL_VERSION,
  StyleModel: () => StyleModel,
  StyleView: () => StyleView,
  ViewList: () => ViewList,
  WidgetModel: () => WidgetModel,
  WidgetView: () => WidgetView,
  assign: () => assign,
  createErrorWidgetModel: () => createErrorWidgetModel,
  createErrorWidgetView: () => createErrorWidgetView,
  difference: () => difference,
  isEqual: () => isEqual,
  isObject: () => isObject,
  isSerializable: () => isSerializable,
  pack_models: () => pack_models,
  put_buffers: () => put_buffers,
  reject: () => reject,
  remove_buffers: () => remove_buffers,
  resolvePromisesDict: () => resolvePromisesDict,
  shims: () => shims,
  unpack_models: () => unpack_models,
  uuid: () => uuid
});
var init_lib10 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/index.js"() {
    init_widget3();
    init_manager();
    init_widget_layout();
    init_widget_style();
    init_services_shim();
    init_viewlist();
    init_version();
    init_utils();
    init_registry3();
    init_errorwidget();
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray2;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i5 = 0, len = code3.length; i5 < len; ++i5) {
      lookup[i5] = code3[i5];
      revLookup[code3.charCodeAt(i5)] = i5;
    }
    var i5;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/utils.js
function hexToBuffer(hex) {
  const x4 = new Uint8Array(hex.length / 2);
  for (let i5 = 0; i5 < hex.length; i5 += 2) {
    x4[i5 / 2] = parseInt(hex.slice(i5, i5 + 2), 16);
  }
  return x4.buffer;
}
function bufferToBase64(buffer) {
  return (0, import_base64_js.fromByteArray)(new Uint8Array(buffer));
}
function base64ToBuffer(base64) {
  return (0, import_base64_js.toByteArray)(base64).buffer;
}
var import_base64_js;
var init_utils2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/utils.js"() {
    import_base64_js = __toESM(require_base64_js());
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/latex.js
function removeMath2(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = /`/.test(text);
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline3);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT2);
  for (let i5 = 1, m4 = blocks.length; i5 < m4; i5 += 2) {
    const block = blocks[i5];
    if (block.charAt(0) === "@") {
      blocks[i5] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i5;
        } else {
          blocks = processMath2(start, i5, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i5 = last2;
          blocks = processMath2(start, i5, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline3 || block === "$$") {
        start = i5;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i5;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i5;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath2(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath2(text, math) {
  const process2 = (match, n4) => {
    let group2 = math[n4];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath2(i5, j2, preProcess, math, blocks) {
  let block = blocks.slice(i5, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i5) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i5] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline3, MATHSPLIT2;
var init_latex2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/latex.js"() {
    inline3 = "$";
    MATHSPLIT2 = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint2 = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// ../../node_modules/htmlparser2/node_modules/entities/lib/decode.js
var require_decode3 = __commonJS({
  "../../node_modules/htmlparser2/node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint2());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint2();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code3) {
      return code3 >= CharCodes.ZERO && code3 <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_F || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_Z || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_Z || isNumber(code3);
    }
    function isEntityInAttributeInvalidEnd(code3) {
      return code3 === CharCodes.EQUALS || isAsciiAlphaNumeric(code3);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str2, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str2.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str2, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str2, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str2, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str2, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str2, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str2, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str2, offset2) {
          if (offset2 >= str2.length) {
            return -1;
          }
          if ((str2.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str2, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str2, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str2, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str2.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str2, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str2.length; offset2++, this.excess++) {
            var char = str2.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result2, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result2 + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str2) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str2);
      });
      return function decodeWithTrie(str2, decodeMode) {
        var lastIndex = 0;
        var offset2 = 0;
        while ((offset2 = str2.indexOf("&", offset2)) >= 0) {
          ret += str2.slice(lastIndex, offset2);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str2,
            // Skip the "&"
            offset2 + 1
          );
          if (len < 0) {
            lastIndex = offset2 + decoder.end();
            break;
          }
          lastIndex = offset2 + len;
          offset2 = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result2 = ret + str2.slice(lastIndex);
        ret = "";
        return result2;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str2, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str2, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str2) {
      return htmlDecoder(str2, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str2) {
      return htmlDecoder(str2, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str2) {
      return xmlDecoder(str2, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// ../../node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer2 = __commonJS({
  "../../node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuoteType = void 0;
    var decode_js_1 = require_decode3();
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes2[CharCodes2["Number"] = 35] = "Number";
      CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
      CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
      CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
      CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
      CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
      CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
      CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
      CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
      CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
      CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
      CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
      CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
      CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
      CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
      CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    var State2;
    (function(State3) {
      State3[State3["Text"] = 1] = "Text";
      State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
      State3[State3["InTagName"] = 3] = "InTagName";
      State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
      State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State3[State3["InAttributeName"] = 9] = "InAttributeName";
      State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
      State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State3[State3["InDeclaration"] = 16] = "InDeclaration";
      State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      State3[State3["BeforeComment"] = 18] = "BeforeComment";
      State3[State3["CDATASequence"] = 19] = "CDATASequence";
      State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
      State3[State3["InCommentLike"] = 21] = "InCommentLike";
      State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
      State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
      State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
      State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
      State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
      State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
      State3[State3["InHexEntity"] = 29] = "InHexEntity";
    })(State2 || (State2 = {}));
    function isWhitespace2(c6) {
      return c6 === CharCodes.Space || c6 === CharCodes.NewLine || c6 === CharCodes.Tab || c6 === CharCodes.FormFeed || c6 === CharCodes.CarriageReturn;
    }
    function isEndOfTagSection(c6) {
      return c6 === CharCodes.Slash || c6 === CharCodes.Gt || isWhitespace2(c6);
    }
    function isNumber(c6) {
      return c6 >= CharCodes.Zero && c6 <= CharCodes.Nine;
    }
    function isASCIIAlpha(c6) {
      return c6 >= CharCodes.LowerA && c6 <= CharCodes.LowerZ || c6 >= CharCodes.UpperA && c6 <= CharCodes.UpperZ;
    }
    function isHexDigit(c6) {
      return c6 >= CharCodes.UpperA && c6 <= CharCodes.UpperF || c6 >= CharCodes.LowerA && c6 <= CharCodes.LowerF;
    }
    var QuoteType;
    (function(QuoteType2) {
      QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
      QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
      QuoteType2[QuoteType2["Single"] = 2] = "Single";
      QuoteType2[QuoteType2["Double"] = 3] = "Double";
    })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
    var Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    };
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(_a, cbs) {
          var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.isSpecial = false;
          this.running = true;
          this.offset = 0;
          this.currentSequence = void 0;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.entityResult = 0;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
        }
        Tokenizer2.prototype.reset = function() {
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.currentSequence = void 0;
          this.running = true;
          this.offset = 0;
        };
        Tokenizer2.prototype.write = function(chunk2) {
          this.offset += this.buffer.length;
          this.buffer = chunk2;
          this.parse();
        };
        Tokenizer2.prototype.end = function() {
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
            this.parse();
          }
        };
        Tokenizer2.prototype.getIndex = function() {
          return this.index;
        };
        Tokenizer2.prototype.getSectionStart = function() {
          return this.sectionStart;
        };
        Tokenizer2.prototype.stateText = function(c6) {
          if (c6 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State2.BeforeTagName;
            this.sectionStart = this.index;
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateSpecialStartSequence = function(c6) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch2 = isEnd ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            isEndOfTagSection(c6)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (c6 | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!isMatch2) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this.state = State2.InTagName;
          this.stateInTagName(c6);
        };
        Tokenizer2.prototype.stateInSpecialTag = function(c6) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c6 === CharCodes.Gt || isWhitespace2(c6)) {
              var endOfText = this.index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this.index;
                this.index = endOfText;
                this.cbs.ontext(this.sectionStart, endOfText);
                this.index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c6);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c6 | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
              if (this.decodeEntities && c6 === CharCodes.Amp) {
                this.state = State2.BeforeEntity;
              }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(c6 === CharCodes.Lt);
          }
        };
        Tokenizer2.prototype.stateCDATASequence = function(c6) {
          if (c6 === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
              this.state = State2.InCommentLike;
              this.currentSequence = Sequences.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = State2.InDeclaration;
            this.stateInDeclaration(c6);
          }
        };
        Tokenizer2.prototype.fastForwardTo = function(c6) {
          while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c6) {
              return true;
            }
          }
          this.index = this.buffer.length + this.offset - 1;
          return false;
        };
        Tokenizer2.prototype.stateInCommentLike = function(c6) {
          if (c6 === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index, 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index, 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = State2.Text;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c6 !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c6) {
          return this.xmlMode ? !isEndOfTagSection(c6) : isASCIIAlpha(c6);
        };
        Tokenizer2.prototype.startSpecial = function(sequence, offset2) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset2;
          this.state = State2.SpecialStartSequence;
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c6) {
          if (c6 === CharCodes.ExclamationMark) {
            this.state = State2.BeforeDeclaration;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.Questionmark) {
            this.state = State2.InProcessingInstruction;
            this.sectionStart = this.index + 1;
          } else if (this.isTagStartChar(c6)) {
            var lower = c6 | 32;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
              this.startSpecial(Sequences.TitleEnd, 3);
            } else {
              this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
            }
          } else if (c6 === CharCodes.Slash) {
            this.state = State2.BeforeClosingTagName;
          } else {
            this.state = State2.Text;
            this.stateText(c6);
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c6) {
          if (isEndOfTagSection(c6)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c6) {
          if (isWhitespace2(c6)) {
          } else if (c6 === CharCodes.Gt) {
            this.state = State2.Text;
          } else {
            this.state = this.isTagStartChar(c6) ? State2.InClosingTagName : State2.InSpecialComment;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c6) {
          if (c6 === CharCodes.Gt || isWhitespace2(c6)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterClosingTagName;
            this.stateAfterClosingTagName(c6);
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c6) {
          if (c6 === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
              this.state = State2.InSpecialTag;
              this.sequenceIndex = 0;
            } else {
              this.state = State2.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.Slash) {
            this.state = State2.InSelfClosingTag;
          } else if (!isWhitespace2(c6)) {
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c6) {
          if (c6 === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace2(c6)) {
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c6) {
          if (c6 === CharCodes.Eq || isEndOfTagSection(c6)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterAttributeName;
            this.stateAfterAttributeName(c6);
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c6) {
          if (c6 === CharCodes.Eq) {
            this.state = State2.BeforeAttributeValue;
          } else if (c6 === CharCodes.Slash || c6 === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          } else if (!isWhitespace2(c6)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c6) {
          if (c6 === CharCodes.DoubleQuote) {
            this.state = State2.InAttributeValueDq;
            this.sectionStart = this.index + 1;
          } else if (c6 === CharCodes.SingleQuote) {
            this.state = State2.InAttributeValueSq;
            this.sectionStart = this.index + 1;
          } else if (!isWhitespace2(c6)) {
            this.sectionStart = this.index;
            this.state = State2.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c6);
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c6, quote) {
          if (c6 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State2.BeforeAttributeName;
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c6) {
          this.handleInAttributeValue(c6, CharCodes.DoubleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c6) {
          this.handleInAttributeValue(c6, CharCodes.SingleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c6) {
          if (isWhitespace2(c6) || c6 === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c6);
          } else if (this.decodeEntities && c6 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c6) {
          if (c6 === CharCodes.OpeningSquareBracket) {
            this.state = State2.CDATASequence;
            this.sequenceIndex = 0;
          } else {
            this.state = c6 === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInDeclaration = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c6) {
          if (c6 === CharCodes.Dash) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c6) {
          if (c6 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c6) {
          var lower = c6 | 32;
          if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
          } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
          } else {
            this.state = State2.InTagName;
            this.stateInTagName(c6);
          }
        };
        Tokenizer2.prototype.stateBeforeEntity = function(c6) {
          this.entityExcess = 1;
          this.entityResult = 0;
          if (c6 === CharCodes.Number) {
            this.state = State2.BeforeNumericEntity;
          } else if (c6 === CharCodes.Amp) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State2.InNamedEntity;
            this.stateInNamedEntity(c6);
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c6) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c6);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            var valueLength = (masked >> 14) - 1;
            if (!this.allowLegacyEntity() && c6 !== CharCodes.Semi) {
              this.trieIndex += valueLength;
            } else {
              var entityStart = this.index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.entityResult = this.trieIndex;
              this.trieIndex += valueLength;
              this.entityExcess = 0;
              this.sectionStart = this.index + 1;
              if (valueLength === 0) {
                this.emitNamedEntity();
              }
            }
          }
        };
        Tokenizer2.prototype.emitNamedEntity = function() {
          this.state = this.baseState;
          if (this.entityResult === 0) {
            return;
          }
          var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (valueLength) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        };
        Tokenizer2.prototype.stateBeforeNumericEntity = function(c6) {
          if ((c6 | 32) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State2.InHexEntity;
          } else {
            this.state = State2.InNumericEntity;
            this.stateInNumericEntity(c6);
          }
        };
        Tokenizer2.prototype.emitNumericEntity = function(strict) {
          var entityStart = this.index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
          if (numberStart !== this.index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
          }
          this.state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c6) {
          if (c6 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c6)) {
            this.entityResult = this.entityResult * 10 + (c6 - CharCodes.Zero);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c6) {
          if (c6 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c6)) {
            this.entityResult = this.entityResult * 16 + (c6 - CharCodes.Zero);
            this.entityExcess++;
          } else if (isHexDigit(c6)) {
            this.entityResult = this.entityResult * 16 + ((c6 | 32) - CharCodes.LowerA + 10);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this.index) {
            if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        };
        Tokenizer2.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        };
        Tokenizer2.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c6 = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case State2.Text: {
                this.stateText(c6);
                break;
              }
              case State2.SpecialStartSequence: {
                this.stateSpecialStartSequence(c6);
                break;
              }
              case State2.InSpecialTag: {
                this.stateInSpecialTag(c6);
                break;
              }
              case State2.CDATASequence: {
                this.stateCDATASequence(c6);
                break;
              }
              case State2.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(c6);
                break;
              }
              case State2.InAttributeName: {
                this.stateInAttributeName(c6);
                break;
              }
              case State2.InCommentLike: {
                this.stateInCommentLike(c6);
                break;
              }
              case State2.InSpecialComment: {
                this.stateInSpecialComment(c6);
                break;
              }
              case State2.BeforeAttributeName: {
                this.stateBeforeAttributeName(c6);
                break;
              }
              case State2.InTagName: {
                this.stateInTagName(c6);
                break;
              }
              case State2.InClosingTagName: {
                this.stateInClosingTagName(c6);
                break;
              }
              case State2.BeforeTagName: {
                this.stateBeforeTagName(c6);
                break;
              }
              case State2.AfterAttributeName: {
                this.stateAfterAttributeName(c6);
                break;
              }
              case State2.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(c6);
                break;
              }
              case State2.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(c6);
                break;
              }
              case State2.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(c6);
                break;
              }
              case State2.AfterClosingTagName: {
                this.stateAfterClosingTagName(c6);
                break;
              }
              case State2.BeforeSpecialS: {
                this.stateBeforeSpecialS(c6);
                break;
              }
              case State2.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(c6);
                break;
              }
              case State2.InSelfClosingTag: {
                this.stateInSelfClosingTag(c6);
                break;
              }
              case State2.InDeclaration: {
                this.stateInDeclaration(c6);
                break;
              }
              case State2.BeforeDeclaration: {
                this.stateBeforeDeclaration(c6);
                break;
              }
              case State2.BeforeComment: {
                this.stateBeforeComment(c6);
                break;
              }
              case State2.InProcessingInstruction: {
                this.stateInProcessingInstruction(c6);
                break;
              }
              case State2.InNamedEntity: {
                this.stateInNamedEntity(c6);
                break;
              }
              case State2.BeforeEntity: {
                this.stateBeforeEntity(c6);
                break;
              }
              case State2.InHexEntity: {
                this.stateInHexEntity(c6);
                break;
              }
              case State2.InNumericEntity: {
                this.stateInNumericEntity(c6);
                break;
              }
              default: {
                this.stateBeforeNumericEntity(c6);
              }
            }
            this.index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.state === State2.InNamedEntity) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this.index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var endIndex = this.buffer.length + this.offset;
          if (this.state === State2.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
              this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
          } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
          } else {
            this.cbs.ontext(this.sectionStart, endIndex);
          }
        };
        Tokenizer2.prototype.emitPartial = function(start, endIndex) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
          } else {
            this.cbs.ontext(start, endIndex);
          }
        };
        Tokenizer2.prototype.emitCodePoint = function(cp) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribentity(cp);
          } else {
            this.cbs.ontextentity(cp);
          }
        };
        return Tokenizer2;
      }()
    );
    exports.default = Tokenizer;
  }
});

// ../../node_modules/htmlparser2/lib/Parser.js
var require_Parser2 = __commonJS({
  "../../node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_js_1 = __importStar(require_Tokenizer2());
    var decode_js_1 = require_decode3();
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags]
    ]);
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = (
      /** @class */
      function() {
        function Parser2(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a, _b, _c, _d, _e;
          this.options = options;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.buffers = [];
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.ontext = function(start, endIndex) {
          var _a, _b;
          var data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
        };
        Parser2.prototype.ontextentity = function(cp) {
          var _a, _b;
          var index2 = this.tokenizer.getSectionStart();
          this.endIndex = index2 - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
          this.startIndex = index2;
        };
        Parser2.prototype.isVoidElement = function(name) {
          return !this.options.xmlMode && voidElements.has(name);
        };
        Parser2.prototype.onopentagname = function(start, endIndex) {
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.emitOpenTag(name);
        };
        Parser2.prototype.emitOpenTag = function(name) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var element2 = this.stack.pop();
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element2, true);
            }
          }
          if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.endOpenTag = function(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser2.prototype.onopentagend = function(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onclosetag = function(start, endIndex) {
          var _a, _b, _c, _d, _e, _f;
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count = this.stack.length - pos;
                while (count--) {
                  this.cbs.onclosetag(this.stack.pop(), count !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
              this.emitOpenTag("p");
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name === "br") {
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onselfclosingtag = function(endIndex) {
          this.endIndex = endIndex;
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = endIndex + 1;
          } else {
            this.onopentagend(endIndex);
          }
        };
        Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a, _b;
          var name = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(start, endIndex) {
          this.startIndex = start;
          var name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
        };
        Parser2.prototype.onattribdata = function(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
        };
        Parser2.prototype.onattribentity = function(cp) {
          this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
        };
        Parser2.prototype.onattribend = function(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var index2 = value.search(reNameEnd);
          var name = index2 < 0 ? value : value.substr(0, index2);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser2.prototype.ondeclaration = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncomment = function(start, endIndex, offset2) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset2));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncdata = function(start, endIndex, offset2) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex - offset2);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.getSlice = function(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
          }
          var slice2 = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice2 += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice2;
        };
        Parser2.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
        };
        Parser2.prototype.write = function(chunk2) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(chunk2);
          if (this.tokenizer.running) {
            this.tokenizer.write(chunk2);
            this.writeIndex++;
          }
        };
        Parser2.prototype.end = function(chunk2) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
          }
          if (chunk2)
            this.write(chunk2);
          this.ended = true;
          this.tokenizer.end();
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
          while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
            this.tokenizer.end();
        };
        Parser2.prototype.parseChunk = function(chunk2) {
          this.write(chunk2);
        };
        Parser2.prototype.done = function(chunk2) {
          this.end(chunk2);
        };
        return Parser2;
      }()
    );
    exports.Parser = Parser;
  }
});

// ../../node_modules/domhandler/lib/node.js
var require_node3 = __commonJS({
  "../../node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d6, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
          d7.__proto__ = b5;
        } || function(d7, b5) {
          for (var p3 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p3))
              d7[p3] = b5[p3];
        };
        return extendStatics(d6, b4);
      };
      return function(d6, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d6, b4);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib4();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports.DataNode = DataNode;
    var Text2 = (
      /** @class */
      function(_super) {
        __extends(Text3, _super);
        function Text3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text3.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text3;
      }(DataNode)
    );
    exports.Text = Text2;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren)
    );
    exports.CDATA = CDATA;
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document3.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document3;
      }(NodeWithChildren)
    );
    exports.Document = Document2;
    var Element2 = (
      /** @class */
      function(_super) {
        __extends(Element3, _super);
        function Element3(name, attribs, children, type2) {
          if (children === void 0) {
            children = [];
          }
          if (type2 === void 0) {
            type2 = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type2;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren)
    );
    exports.Element = Element2;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result2;
      if (isText(node)) {
        result2 = new Text2(node.data);
      } else if (isComment(node)) {
        result2 = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element2(node.name, __assign2({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign2({}, node["x-attribsPrefix"]);
        }
        result2 = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result2 = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document2(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result2 = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result2 = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result2.startIndex = node.startIndex;
      result2.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result2.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result2;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i5 = 1; i5 < children.length; i5++) {
        children[i5].prev = children[i5 - 1];
        children[i5 - 1].next = children[i5];
      }
      return children;
    }
  }
});

// ../../node_modules/domhandler/lib/index.js
var require_lib10 = __commonJS({
  "../../node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m4, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib4();
    var node_js_1 = require_node3();
    __exportStar(require_node3(), exports);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type2 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element2 = new node_js_1.Element(name, attribs, void 0, type2);
          this.addNode(element2);
          this.tagStack.push(element2);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c6) {
        return c6.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint3 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode.js
var require_decode4 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html2());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml2());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint3());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint3();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code3) {
      return code3 >= CharCodes.ZERO && code3 <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_F || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code3) {
      return code3 >= CharCodes.UPPER_A && code3 <= CharCodes.UPPER_Z || code3 >= CharCodes.LOWER_A && code3 <= CharCodes.LOWER_Z || isNumber(code3);
    }
    function isEntityInAttributeInvalidEnd(code3) {
      return code3 === CharCodes.EQUALS || isAsciiAlphaNumeric(code3);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str2, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str2.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str2, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str2, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str2, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str2, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str2, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str2, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str2, offset2) {
          if (offset2 >= str2.length) {
            return -1;
          }
          if ((str2.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str2, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str2, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str2, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str2.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str2, offset2) {
          var startIdx = offset2;
          while (offset2 < str2.length) {
            var char = str2.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str2, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str2, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str2.length; offset2++, this.excess++) {
            var char = str2.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result2, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result2 + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str2) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str2);
      });
      return function decodeWithTrie(str2, decodeMode) {
        var lastIndex = 0;
        var offset2 = 0;
        while ((offset2 = str2.indexOf("&", offset2)) >= 0) {
          ret += str2.slice(lastIndex, offset2);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str2,
            // Skip the "&"
            offset2 + 1
          );
          if (len < 0) {
            lastIndex = offset2 + decoder.end();
            break;
          }
          lastIndex = offset2 + len;
          offset2 = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result2 = ret + str2.slice(lastIndex);
        ret = "";
        return result2;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str2, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str2, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str2) {
      return htmlDecoder(str2, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str2) {
      return htmlDecoder(str2, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str2) {
      return xmlDecoder(str2, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i5 = 1; i5 < arr.length; i5++) {
        arr[i5][0] += arr[i5 - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str2, index2) {
      return str2.codePointAt(index2);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c6, index2) {
        return (c6.charCodeAt(index2) & 64512) === 55296 ? (c6.charCodeAt(index2) - 55296) * 1024 + c6.charCodeAt(index2 + 1) - 56320 + 65536 : c6.charCodeAt(index2);
      }
    );
    function encodeXML(str2) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str2)) !== null) {
        var i5 = match.index;
        var char = str2.charCodeAt(i5);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str2.substring(lastIdx, i5) + next;
          lastIdx = i5 + 1;
        } else {
          ret += "".concat(str2.substring(lastIdx, i5), "&#x").concat((0, exports.getCodePoint)(str2, i5).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str2.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map4) {
      return function escape2(data) {
        var match;
        var lastIdx = 0;
        var result2 = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result2 += data.substring(lastIdx, match.index);
          }
          result2 += map4.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result2 + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/encode.js
var require_encode2 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str2) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str2)) !== null) {
        var i5 = match.index;
        ret += str2.substring(lastIdx, i5);
        var char = str2.charCodeAt(i5);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i5 + 1 < str2.length) {
            var nextChar = str2.charCodeAt(i5 + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i5 + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str2, i5);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str2.substr(lastIdx);
    }
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/index.js
var require_lib11 = __commonJS({
  "../../node_modules/dom-serializer/node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode4();
    var encode_js_1 = require_encode2();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode2();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode4();
    Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// ../../node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames2 = __commonJS({
  "../../node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// ../../node_modules/dom-serializer/lib/index.js
var require_lib12 = __commonJS({
  "../../node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t10) {
        for (var s7, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s7 = arguments[i5];
          for (var p3 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p3))
              t10[p3] = s7[p3];
        }
        return t10;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType = __importStar(require_lib4());
    var entities_1 = require_lib11();
    var foreignNames_js_1 = require_foreignNames2();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i5 = 0; i5 < nodes.length; i5++) {
        output += renderNode(nodes[i5], options);
      }
      return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText2(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign2(__assign2({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign2(__assign2({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText2(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// ../../node_modules/domutils/lib/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib10();
    var dom_serializer_1 = __importDefault(require_lib12());
    var domelementtype_1 = require_lib4();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// ../../node_modules/domutils/lib/traversal.js
var require_traversal2 = __commonJS({
  "../../node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib10();
    function getChildren2(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren2;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren2(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// ../../node_modules/domutils/lib/manipulation.js
var require_manipulation2 = __commonJS({
  "../../node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// ../../node_modules/domutils/lib/querying.js
var require_querying2 = __commonJS({
  "../../node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib10();
    function filter2(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find3(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports.filter = filter2;
    function find3(test, nodes, recurse, limit) {
      var result2 = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result2;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result2.push(elem);
          if (--limit <= 0)
            return result2;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.find = find3;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i5 = 0; i5 < nodes.length && !elem; i5++) {
        var node = nodes[i5];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne(test, node.children, true);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var result2 = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result2;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result2.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.findAll = findAll;
  }
});

// ../../node_modules/domutils/lib/legacy.js
var require_legacy3 = __commonJS({
  "../../node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib10();
    var querying_js_1 = require_querying2();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type2) {
        if (typeof type2 === "function") {
          return function(elem) {
            return type2(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type2;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a4, b4) {
      return function(elem) {
        return a4(elem) || b4(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type2, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type2), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// ../../node_modules/domutils/lib/helpers.js
var require_helpers2 = __commonJS({
  "../../node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib10();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i5, arr) {
        return !arr.includes(node, i5 + 1);
      });
      nodes.sort(function(a4, b4) {
        var relative = compareDocumentPosition(a4, b4);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// ../../node_modules/domutils/lib/feeds.js
var require_feeds2 = __commonJS({
  "../../node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_js_1 = require_stringify3();
    var legacy_js_1 = require_legacy3();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children) || fetch2("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where2) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where2).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where2, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where2, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where2, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// ../../node_modules/domutils/lib/index.js
var require_lib13 = __commonJS({
  "../../node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m4, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify3(), exports);
    __exportStar(require_traversal2(), exports);
    __exportStar(require_manipulation2(), exports);
    __exportStar(require_querying2(), exports);
    __exportStar(require_legacy3(), exports);
    __exportStar(require_helpers2(), exports);
    __exportStar(require_feeds2(), exports);
    var domhandler_1 = require_lib10();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// ../../node_modules/htmlparser2/lib/index.js
var require_lib14 = __commonJS({
  "../../node_modules/htmlparser2/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m4, k);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k];
        } };
      }
      Object.defineProperty(o10, k2, desc);
    } : function(o10, m4, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o10[k2] = m4[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v2) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v2 });
    } : function(o10, v2) {
      o10["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
    var Parser_js_1 = require_Parser2();
    var Parser_js_2 = require_Parser2();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_js_2.Parser;
    } });
    var domhandler_1 = require_lib10();
    var domhandler_2 = require_lib10();
    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_js_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    function createDomStream(callback, options, elementCallback) {
      var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
      return new Parser_js_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;
    var Tokenizer_js_1 = require_Tokenizer2();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_js_1).default;
    } });
    exports.ElementType = __importStar(require_lib4());
    var domutils_1 = require_lib13();
    var domutils_2 = require_lib13();
    Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
      return domutils_2.getFeed;
    } });
    var parseFeedDefaultOptions = { xmlMode: true };
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = parseFeedDefaultOptions;
      }
      return (0, domutils_1.getFeed)(parseDOM(feed, options));
    }
    exports.parseFeed = parseFeed;
    exports.DomUtils = __importStar(require_lib13());
  }
});

// ../../node_modules/sanitize-html/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "../../node_modules/sanitize-html/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/sanitize-html/index.js
var require_sanitize_html2 = __commonJS({
  "../../node_modules/sanitize-html/index.js"(exports, module) {
    var htmlparser = require_lib14();
    var escapeStringRegexp = require_escape_string_regexp2();
    var { isPlainObject } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each3(obj, cb2) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          cb2(obj[key], key);
        });
      }
    }
    function has3(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function filter2(a4, cb2) {
      const n4 = [];
      each3(a4, function(v2) {
        if (cb2(v2)) {
          n4.push(v2);
        }
      });
      return n4;
    }
    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has3(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html, options, _recursing) {
      if (html == null) {
        return "";
      }
      if (typeof html === "number") {
        html = html.toString();
      }
      let result2 = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result2.length;
        this.text = "";
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);
      const tagAllowed = function(name) {
        return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
      };
      vulnerableTags.forEach(function(tag) {
        if (tagAllowed(tag) && !options.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each3(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each3(options.allowedClasses, function(classes, tag) {
        if (allowedAttributesMap) {
          if (!has3(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = classes;
        if (Array.isArray(classes)) {
          const globRegex = [];
          allowedClassesMap[tag] = [];
          allowedClassesRegexMap[tag] = [];
          classes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else if (obj instanceof RegExp) {
              allowedClassesRegexMap[tag].push(obj);
            } else {
              allowedClassesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each3(options.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === "function") {
          transFun = transform;
        } else if (typeof transform === "string") {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name, attribs) {
          if (options.enforceHtmlBoundary && name === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has3(transformTagsMap, name)) {
            transformedTag = transformTagsMap[name](name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (!tagAllowed(name) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === "discard") {
              if (nonTextTagsArray.indexOf(name) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === "discard") {
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          result2 += "<" + name;
          if (name === "script") {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          if (!allowedAttributesMap || has3(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
            each3(attribs, function(value, a4) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a4)) {
                delete frame.attribs[a4];
                return;
              }
              if (value === "" && (options.nonBooleanAttributes.includes(a4) || options.nonBooleanAttributes.includes("*"))) {
                delete frame.attribs[a4];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has3(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a4) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a4) !== -1 || has3(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a4) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a4)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                for (const o10 of allowedAttributesMap[name]) {
                  if (isPlainObject(o10) && o10.name && o10.name === a4) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o10.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s7 of splitStrArray) {
                        if (o10.values.indexOf(s7) !== -1) {
                          if (newValue === "") {
                            newValue = s7;
                          } else {
                            newValue += " " + s7;
                          }
                        }
                      }
                    } else if (o10.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a4) !== -1) {
                  if (naughtyHref(name, value)) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name === "script" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (name === "iframe" && a4 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has3(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e4) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter2(parsed, function(v2) {
                      return !v2.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a4];
                      return;
                    } else {
                      value = stringifySrcset(filter2(parsed, function(v2) {
                        return !v2.evil;
                      }));
                      frame.attribs[a4] = value;
                    }
                  } catch (e4) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex).filter(function(t10) {
                    return t10;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a4];
                    return;
                  }
                }
                if (a4 === "style") {
                  if (options.parseStyleAttributes) {
                    try {
                      const abstractSyntaxTree = postcssParse(name + " {" + value + "}");
                      const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                      value = stringifyStyleAttributes(filteredAST);
                      if (value.length === 0) {
                        delete frame.attribs[a4];
                        return;
                      }
                    } catch (e4) {
                      if (typeof window !== "undefined") {
                        console.warn('Failed to parse "' + name + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                      }
                      delete frame.attribs[a4];
                      return;
                    }
                  } else if (options.allowedStyles) {
                    throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                  }
                }
                result2 += " " + a4;
                if (value && value.length) {
                  result2 += '="' + escapeHtml(value, true) + '"';
                }
              } else {
                delete frame.attribs[a4];
              }
            });
          }
          if (options.selfClosing.indexOf(name) !== -1) {
            result2 += " />";
          } else {
            result2 += ">";
            if (frame.innerText && !hasText && !options.textFilter) {
              result2 += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
            result2 += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options.textFilter && !addedText) {
              result2 += options.textFilter(escaped, tag);
            } else if (!addedText) {
              result2 += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name, isImplied) {
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name) {
            stack.push(frame);
            return;
          }
          skipText = options.enforceHtmlBoundary ? name === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === "discard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          if (transformMap[depth]) {
            name = transformMap[depth];
            delete transformMap[depth];
          }
          if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
            result2 = result2.substr(0, frame.tagPosition);
            return;
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (
            // Already output />
            options.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied
            isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0
          ) {
            if (skip) {
              result2 = tempResult;
              tempResult = "";
            }
            return;
          }
          result2 += "</" + name + ">";
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html);
      parser.end();
      return result2;
      function initializeState() {
        result2 = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s7, quote) {
        if (typeof s7 !== "string") {
          s7 = s7 + "";
        }
        if (options.parser.decodeEntities) {
          s7 = s7.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s7 = s7.replace(/"/g, "&quot;");
          }
        }
        s7 = s7.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s7 = s7.replace(/"/g, "&quot;");
        }
        return s7;
      }
      function naughtyHref(name, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches) {
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches[1].toLowerCase();
        if (has3(options.allowedSchemesByTag, name)) {
          return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
        }
        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i5 = 0; i5 < 100; i5++) {
          base += `/${i5}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has3(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      // Tags that cannot be boolean
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        // Event handlers
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false,
      parseStyleAttributes: true
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge2) {
      merge2 = merge2 === void 0 ? true : merge2;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge2) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js
function default_inline_sanitize(s7) {
  const allowedTags = [
    "a",
    "abbr",
    "b",
    "code",
    "em",
    "i",
    "img",
    "li",
    "ol",
    "span",
    "strong",
    "ul"
  ];
  const allowedAttributes = {
    "*": ["aria-*", "class", "style", "title"],
    a: ["href"],
    img: ["src"],
    style: ["media", "type"]
  };
  return (0, import_sanitize_html2.default)(s7, {
    allowedTags,
    allowedAttributes
  });
}
function serialize_state(models, options = {}) {
  const state = {};
  models.forEach((model) => {
    const model_id = model.model_id;
    const split = remove_buffers(model.serialize(model.get_state(options.drop_defaults)));
    const buffers = split.buffers.map((buffer, index2) => {
      return {
        data: bufferToBase64(buffer),
        path: split.buffer_paths[index2],
        encoding: "base64"
      };
    });
    state[model_id] = {
      model_name: model.name,
      model_module: model.module,
      model_module_version: model.get("_model_module_version"),
      state: split.state
    };
    if (buffers.length > 0) {
      state[model_id].buffers = buffers;
    }
  });
  return { version_major: 2, version_minor: 0, state };
}
var import_coreutils27, import_sanitize_html2, PROTOCOL_MAJOR_VERSION, CONTROL_COMM_TARGET, CONTROL_COMM_PROTOCOL_VERSION, CONTROL_COMM_TIMEOUT, ManagerBase;
var init_manager_base = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js"() {
    init_lib10();
    import_coreutils27 = __toESM(require_dist());
    init_lib10();
    init_utils2();
    init_latex2();
    import_sanitize_html2 = __toESM(require_sanitize_html2());
    PROTOCOL_MAJOR_VERSION = PROTOCOL_VERSION.split(".", 1)[0];
    CONTROL_COMM_TARGET = "jupyter.widget.control";
    CONTROL_COMM_PROTOCOL_VERSION = "1.0.0";
    CONTROL_COMM_TIMEOUT = 4e3;
    ManagerBase = class {
      constructor() {
        this.comm_target_name = "jupyter.widget";
        this._models = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Modifies view options. Generally overloaded in custom widget manager
       * implementations.
       */
      setViewOptions(options = {}) {
        return options;
      }
      create_view(model, options = {}) {
        const id = uuid();
        const viewPromise = model.state_change = model.state_change.then(async () => {
          const _view_name = model.get("_view_name");
          const _view_module = model.get("_view_module");
          try {
            const ViewType = await this.loadViewClass(_view_name, _view_module, model.get("_view_module_version"));
            const view = new ViewType({
              model,
              options: this.setViewOptions(options)
            });
            view.listenTo(model, "destroy", view.remove);
            await view.render();
            view.once("remove", () => {
              if (model.views) {
                delete model.views[id];
              }
            });
            return view;
          } catch (e4) {
            console.error(`Could not create a view for model id ${model.model_id}`);
            const msg = `Failed to create view for '${_view_name}' from module '${_view_module}' with model '${model.name}' from module '${model.module}'`;
            const ModelCls = createErrorWidgetModel(e4, msg);
            const errorModel = new ModelCls();
            const view = new ErrorWidgetView({
              model: errorModel,
              options: this.setViewOptions(options)
            });
            await view.render();
            return view;
          }
        });
        if (model.views) {
          model.views[id] = viewPromise;
        }
        return viewPromise;
      }
      /**
       * callback handlers specific to a view
       */
      callbacks(view) {
        return {};
      }
      /**
       * Get a promise for a model by model id.
       *
       * #### Notes
       * If the model is not found, the returned Promise object is rejected.
       *
       * If you would like to synchronously test if a model exists, use .has_model().
       */
      async get_model(model_id) {
        const modelPromise = this._models[model_id];
        if (modelPromise === void 0) {
          throw new Error("widget model not found");
        }
        return modelPromise;
      }
      /**
       * Returns true if the given model is registered, otherwise false.
       *
       * #### Notes
       * This is a synchronous way to check if a model is registered.
       */
      has_model(model_id) {
        return this._models[model_id] !== void 0;
      }
      /**
       * Handle when a comm is opened.
       */
      handle_comm_open(comm, msg) {
        const protocolVersion = (msg.metadata || {})["version"] || "";
        if (protocolVersion.split(".", 1)[0] !== PROTOCOL_MAJOR_VERSION) {
          const error = `Wrong widget protocol version: received protocol version '${protocolVersion}', but was expecting major version '${PROTOCOL_MAJOR_VERSION}'`;
          console.error(error);
          return Promise.reject(error);
        }
        const data = msg.content.data;
        const buffer_paths = data.buffer_paths || [];
        const buffers = msg.buffers || [];
        put_buffers(data.state, buffer_paths, buffers);
        return this.new_model({
          model_name: data.state["_model_name"],
          model_module: data.state["_model_module"],
          model_module_version: data.state["_model_module_version"],
          comm
        }, data.state).catch(reject("Could not create a model.", true));
      }
      /**
       * Create a comm and new widget model.
       * @param  options - same options as new_model but comm is not
       *                          required and additional options are available.
       * @param  serialized_state - serialized model attributes.
       */
      new_widget(options, serialized_state = {}) {
        let commPromise;
        if (options.view_name === void 0 || options.view_module === void 0 || options.view_module_version === void 0) {
          return Promise.reject("new_widget(...) must be given view information in the options.");
        }
        if (options.comm) {
          commPromise = Promise.resolve(options.comm);
        } else {
          commPromise = this._create_comm(this.comm_target_name, options.model_id, {
            state: {
              _model_module: options.model_module,
              _model_module_version: options.model_module_version,
              _model_name: options.model_name,
              _view_module: options.view_module,
              _view_module_version: options.view_module_version,
              _view_name: options.view_name
            }
          }, { version: PROTOCOL_VERSION });
        }
        const options_clone = Object.assign({}, options);
        return commPromise.then((comm) => {
          options_clone.comm = comm;
          const widget_model = this.new_model(options_clone, serialized_state);
          return widget_model.then((model) => {
            model.sync("create", model);
            return model;
          });
        }, () => {
          if (!options_clone.model_id) {
            options_clone.model_id = uuid();
          }
          return this.new_model(options_clone, serialized_state);
        });
      }
      register_model(model_id, modelPromise) {
        this._models[model_id] = modelPromise;
        modelPromise.then((model) => {
          model.once("comm:close", () => {
            delete this._models[model_id];
          });
        });
      }
      /**
       * Create and return a promise for a new widget model
       *
       * @param options - the options for creating the model.
       * @param serialized_state - attribute values for the model.
       *
       * @example
       * widget_manager.new_model({
       *      model_name: 'IntSlider',
       *      model_module: '@jupyter-widgets/controls',
       *      model_module_version: '1.0.0',
       *      model_id: 'u-u-i-d'
       * }).then((model) => { console.log('Create success!', model); },
       *  (err) => {console.error(err)});
       *
       */
      async new_model(options, serialized_state = {}) {
        var _a, _b;
        const model_id = (_a = options.model_id) !== null && _a !== void 0 ? _a : (_b = options.comm) === null || _b === void 0 ? void 0 : _b.comm_id;
        if (!model_id) {
          throw new Error("Neither comm nor model_id provided in options object. At least one must exist.");
        }
        options.model_id = model_id;
        const modelPromise = this._make_model(options, serialized_state);
        this.register_model(model_id, modelPromise);
        return await modelPromise;
      }
      /**
       * Fetch all widgets states from the kernel using the control comm channel
       * If this fails (control comm handler not implemented kernel side),
       * it will fall back to `_loadFromKernelModels`.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernel() {
        let data;
        let buffers;
        try {
          const initComm = await this._create_comm(CONTROL_COMM_TARGET, uuid(), {}, { version: CONTROL_COMM_PROTOCOL_VERSION });
          await new Promise((resolve, reject4) => {
            initComm.on_msg((msg) => {
              data = msg["content"]["data"];
              if (data.method !== "update_states") {
                console.warn(`
              Unknown ${data.method} message on the Control channel
            `);
                return;
              }
              buffers = (msg.buffers || []).map((b4) => {
                if (b4 instanceof DataView) {
                  return b4;
                } else {
                  return new DataView(b4 instanceof ArrayBuffer ? b4 : b4.buffer);
                }
              });
              resolve(null);
            });
            initComm.on_close(() => reject4("Control comm was closed too early"));
            initComm.send({ method: "request_states" }, {});
            setTimeout(() => reject4("Control comm did not respond in time"), CONTROL_COMM_TIMEOUT);
          });
          initComm.close();
        } catch (error) {
          console.warn('Failed to fetch ipywidgets through the "jupyter.widget.control" comm channel, fallback to fetching individual model state. Reason:', error);
          return this._loadFromKernelModels();
        }
        const states = data.states;
        const bufferPaths = {};
        const bufferGroups = {};
        for (let i5 = 0; i5 < data.buffer_paths.length; i5++) {
          const [widget_id, ...path] = data.buffer_paths[i5];
          const b4 = buffers[i5];
          if (!bufferPaths[widget_id]) {
            bufferPaths[widget_id] = [];
            bufferGroups[widget_id] = [];
          }
          bufferPaths[widget_id].push(path);
          bufferGroups[widget_id].push(b4);
        }
        const widget_comms = await Promise.all(Object.keys(states).map(async (widget_id) => {
          const comm = this.has_model(widget_id) ? void 0 : await this._create_comm("jupyter.widget", widget_id);
          return { widget_id, comm };
        }));
        await Promise.all(widget_comms.map(async ({ widget_id, comm }) => {
          const state = states[widget_id];
          if (widget_id in bufferPaths) {
            put_buffers(state, bufferPaths[widget_id], bufferGroups[widget_id]);
          }
          try {
            if (comm) {
              await this.new_model({
                model_name: state.model_name,
                model_module: state.model_module,
                model_module_version: state.model_module_version,
                model_id: widget_id,
                comm
              }, state.state);
            } else {
              const model = await this.get_model(widget_id);
              const deserializedState = await model.constructor._deserialize_state(state.state, this);
              model.set_state(deserializedState);
            }
          } catch (error) {
            console.error(error);
          }
        }));
      }
      /**
       * Old implementation of fetching widget models one by one using
       * the request_state message on each comm.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernelModels() {
        const comm_ids = await this._get_comm_info();
        const widgets_info = await Promise.all(Object.keys(comm_ids).map(async (comm_id) => {
          if (this.has_model(comm_id)) {
            return;
          }
          const comm = await this._create_comm(this.comm_target_name, comm_id);
          let msg_id = "";
          const info = new import_coreutils27.PromiseDelegate();
          comm.on_msg((msg) => {
            if (msg.parent_header.msg_id === msg_id && msg.header.msg_type === "comm_msg" && msg.content.data.method === "update") {
              const data = msg.content.data;
              const buffer_paths = data.buffer_paths || [];
              const buffers = msg.buffers || [];
              put_buffers(data.state, buffer_paths, buffers);
              info.resolve({ comm, msg });
            }
          });
          msg_id = comm.send({
            method: "request_state"
          }, this.callbacks(void 0));
          return info.promise;
        }));
        await Promise.all(widgets_info.map(async (widget_info) => {
          if (!widget_info) {
            return;
          }
          const content = widget_info.msg.content;
          await this.new_model({
            model_name: content.data.state._model_name,
            model_module: content.data.state._model_module,
            model_module_version: content.data.state._model_module_version,
            comm: widget_info.comm
          }, content.data.state);
        }));
      }
      async _make_model(options, serialized_state = {}) {
        const model_id = options.model_id;
        const model_promise = this.loadModelClass(options.model_name, options.model_module, options.model_module_version);
        let ModelType;
        const makeErrorModel = (error, msg) => {
          const Cls = createErrorWidgetModel(error, msg);
          const widget_model2 = new Cls();
          return widget_model2;
        };
        try {
          ModelType = await model_promise;
        } catch (error) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          return makeErrorModel(error, msg);
        }
        if (!ModelType) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          const error = new Error(`Cannot find model module ${options.model_module}@${options.model_module_version}, ${options.model_name}`);
          return makeErrorModel(error, msg);
        }
        let widget_model;
        try {
          const attributes = await ModelType._deserialize_state(serialized_state, this);
          const modelOptions = {
            widget_manager: this,
            model_id,
            comm: options.comm
          };
          widget_model = new ModelType(attributes, modelOptions);
        } catch (error) {
          console.error(error);
          const msg = `Model class '${options.model_name}' from module '${options.model_module}' is loaded but can not be instantiated`;
          widget_model = makeErrorModel(error, msg);
        }
        widget_model.name = options.model_name;
        widget_model.module = options.model_module;
        return widget_model;
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      clear_state() {
        return resolvePromisesDict(this._models).then((models) => {
          Object.keys(models).forEach((id) => models[id].close());
          this._models = /* @__PURE__ */ Object.create(null);
        });
      }
      /**
       * Asynchronously get the state of the widget manager.
       *
       * This includes all of the widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns Promise for a state dictionary
       */
      get_state(options = {}) {
        const modelPromises = Object.keys(this._models).map((id) => this._models[id]);
        return Promise.all(modelPromises).then((models) => {
          return serialize_state(models, options);
        });
      }
      /**
       * Set the widget manager state.
       *
       * @param state - a Javascript object conforming to the application/vnd.jupyter.widget-state+json spec.
       *
       * Reconstructs all of the widget models in the state, merges that with the
       * current manager state, and then attempts to redisplay the widgets in the
       * state.
       */
      set_state(state) {
        if (!(state.version_major && state.version_major <= 2)) {
          throw "Unsupported widget state format";
        }
        const models = state.state;
        const all_models = this._get_comm_info().then((live_comms) => {
          return Promise.all(Object.keys(models).map((model_id) => {
            const decode = {
              base64: base64ToBuffer,
              hex: hexToBuffer
            };
            const model = models[model_id];
            const modelState = model.state;
            if (model.buffers) {
              const bufferPaths = model.buffers.map((b4) => b4.path);
              const buffers = model.buffers.map((b4) => new DataView(decode[b4.encoding](b4.data)));
              put_buffers(model.state, bufferPaths, buffers);
            }
            if (this.has_model(model_id)) {
              return this.get_model(model_id).then((model2) => {
                return model2.constructor._deserialize_state(modelState || {}, this).then((attributes) => {
                  model2.set_state(attributes);
                  return model2;
                });
              });
            }
            const modelCreate = {
              model_id,
              model_name: model.model_name,
              model_module: model.model_module,
              model_module_version: model.model_module_version
            };
            if (Object.prototype.hasOwnProperty.call(live_comms, "model_id")) {
              return this._create_comm(this.comm_target_name, model_id).then((comm) => {
                modelCreate.comm = comm;
                return this.new_model(modelCreate);
              });
            } else {
              return this.new_model(modelCreate, modelState);
            }
          }));
        });
        return all_models;
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        Object.keys(this._models).forEach((i5) => {
          this._models[i5].then((model) => {
            model.comm_live = false;
          });
        });
      }
      /**
       * Resolve a URL relative to the current notebook location.
       *
       * The default implementation just returns the original url.
       */
      resolveUrl(url) {
        return Promise.resolve(url);
      }
      inline_sanitize(source) {
        const parts = removeMath2(source);
        const sanitized = default_inline_sanitize(parts["text"]);
        return replaceMath2(sanitized, parts["math"]);
      }
      async loadModelClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load model class '${className}' from module '${moduleName}'`;
          return createErrorWidgetModel(error, msg);
        }
      }
      async loadViewClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load view class '${className}' from module '${moduleName}'`;
          return createErrorWidgetView(error, msg);
        }
      }
      /**
       * Filter serialized widget state to remove any ID's already present in manager.
       *
       * @param {*} state Serialized state to filter
       *
       * @returns {*} A copy of the state, with its 'state' attribute filtered
       */
      filterExistingModelState(serialized_state) {
        let models = serialized_state.state;
        models = Object.keys(models).filter((model_id) => !this.has_model(model_id)).reduce((res, model_id) => {
          res[model_id] = models[model_id];
          return res;
        }, {});
        return Object.assign(Object.assign({}, serialized_state), { state: models });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/index.js
var init_lib11 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/index.js"() {
    init_manager_base();
    init_utils2();
  }
});

// ../../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../../node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t10 = exports.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max3] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max3}}`).split(`${token}+`).join(`${token}{1,${max3}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R2++;
      debug(name, index2, value);
      t10[name] = index2;
      src[index2] = value;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t10.NUMERICIDENTIFIER]})\\.(${src[t10.NUMERICIDENTIFIER]})\\.(${src[t10.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t10.NUMERICIDENTIFIERLOOSE]})\\.(${src[t10.NUMERICIDENTIFIERLOOSE]})\\.(${src[t10.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t10.NUMERICIDENTIFIER]}|${src[t10.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t10.NUMERICIDENTIFIERLOOSE]}|${src[t10.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t10.PRERELEASEIDENTIFIER]}(?:\\.${src[t10.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t10.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t10.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t10.BUILDIDENTIFIER]}(?:\\.${src[t10.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t10.MAINVERSION]}${src[t10.PRERELEASE]}?${src[t10.BUILD]}?`);
    createToken("FULL", `^${src[t10.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t10.MAINVERSIONLOOSE]}${src[t10.PRERELEASELOOSE]}?${src[t10.BUILD]}?`);
    createToken("LOOSE", `^${src[t10.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t10.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t10.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t10.XRANGEIDENTIFIER]})(?:\\.(${src[t10.XRANGEIDENTIFIER]})(?:\\.(${src[t10.XRANGEIDENTIFIER]})(?:${src[t10.PRERELEASE]})?${src[t10.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t10.XRANGEIDENTIFIERLOOSE]})(?:${src[t10.PRERELEASELOOSE]})?${src[t10.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t10.GTLT]}\\s*${src[t10.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t10.GTLT]}\\s*${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t10.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t10.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t10.LONETILDE]}${src[t10.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t10.LONETILDE]}${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t10.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t10.LONECARET]}${src[t10.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t10.LONECARET]}${src[t10.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t10.GTLT]}\\s*(${src[t10.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t10.GTLT]}\\s*(${src[t10.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t10.GTLT]}\\s*(${src[t10.LOOSEPLAIN]}|${src[t10.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t10.XRANGEPLAIN]})\\s+-\\s+(${src[t10.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t10.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t10.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b4) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b4);
      if (anum && bnum) {
        a4 = +a4;
        b4 = +b4;
      }
      return a4 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b4 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b4) => compareIdentifiers(b4, a4);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t: t10 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m4 = version2.trim().match(options.loose ? re[t10.LOOSE] : re[t10.FULL]);
        if (!m4) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m4[1];
        this.minor = +m4[2];
        this.patch = +m4[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m4[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m4[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m4[5] ? m4[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i5 = 0;
        do {
          const a4 = this.prerelease[i5];
          const b4 = other.prerelease[i5];
          debug("prerelease compare", i5, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i5);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i5 = 0;
        do {
          const a4 = this.build[i5];
          const b4 = other.build[i5];
          debug("prerelease compare", i5, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i5);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i5 = this.prerelease.length;
              while (--i5 >= 0) {
                if (typeof this.prerelease[i5] === "number") {
                  this.prerelease[i5]++;
                  i5 = -2;
                }
              }
              if (i5 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../../node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse4 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse4;
  }
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/semver/functions/valid.js"(exports, module) {
    var parse4 = require_parse3();
    var valid2 = (version2, options) => {
      const v2 = parse4(version2, options);
      return v2 ? v2.version : null;
    };
    module.exports = valid2;
  }
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/semver/functions/clean.js"(exports, module) {
    var parse4 = require_parse3();
    var clean = (version2, options) => {
      const s7 = parse4(version2.trim().replace(/^[=v]+/, ""), options);
      return s7 ? s7.version : null;
    };
    module.exports = clean;
  }
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/semver/functions/diff.js"(exports, module) {
    var parse4 = require_parse3();
    var diff = (version1, version2) => {
      const v1 = parse4(version1, null, true);
      const v2 = parse4(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a4, loose) => new SemVer(a4, loose).major;
    module.exports = major;
  }
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module.exports = minor;
  }
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a4, loose) => new SemVer(a4, loose).patch;
    module.exports = patch;
  }
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse4 = require_parse3();
    var prerelease = (version2, options) => {
      const parsed = parse4(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare2 = (a4, b4, loose) => new SemVer(a4, loose).compare(new SemVer(b4, loose));
    module.exports = compare2;
  }
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare2 = require_compare();
    var rcompare = (a4, b4, loose) => compare2(b4, a4, loose);
    module.exports = rcompare;
  }
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare2 = require_compare();
    var compareLoose = (a4, b4) => compare2(a4, b4, true);
    module.exports = compareLoose;
  }
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a4, b4, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b4, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a4, b4) => compareBuild(a4, b4, loose));
    module.exports = sort;
  }
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b4) => compareBuild(b4, a4, loose));
    module.exports = rsort;
  }
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/semver/functions/gt.js"(exports, module) {
    var compare2 = require_compare();
    var gt = (a4, b4, loose) => compare2(a4, b4, loose) > 0;
    module.exports = gt;
  }
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/semver/functions/lt.js"(exports, module) {
    var compare2 = require_compare();
    var lt = (a4, b4, loose) => compare2(a4, b4, loose) < 0;
    module.exports = lt;
  }
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/semver/functions/eq.js"(exports, module) {
    var compare2 = require_compare();
    var eq2 = (a4, b4, loose) => compare2(a4, b4, loose) === 0;
    module.exports = eq2;
  }
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/semver/functions/neq.js"(exports, module) {
    var compare2 = require_compare();
    var neq = (a4, b4, loose) => compare2(a4, b4, loose) !== 0;
    module.exports = neq;
  }
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/semver/functions/gte.js"(exports, module) {
    var compare2 = require_compare();
    var gte = (a4, b4, loose) => compare2(a4, b4, loose) >= 0;
    module.exports = gte;
  }
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/semver/functions/lte.js"(exports, module) {
    var compare2 = require_compare();
    var lte = (a4, b4, loose) => compare2(a4, b4, loose) <= 0;
    module.exports = lte;
  }
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/semver/functions/cmp.js"(exports, module) {
    var eq2 = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b4, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 === b4;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 !== b4;
        case "":
        case "=":
        case "==":
          return eq2(a4, b4, loose);
        case "!=":
          return neq(a4, b4, loose);
        case ">":
          return gt(a4, b4, loose);
        case ">=":
          return gte(a4, b4, loose);
        case "<":
          return lt(a4, b4, loose);
        case "<=":
          return lte(a4, b4, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse4 = require_parse3();
    var { safeRe: re, t: t10 } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t10.COERCE]);
      } else {
        let next;
        while ((next = re[t10.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t10.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t10.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse4(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce;
  }
});

// ../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
          self2.push(arguments[i5]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
        push2(this, arguments[i5]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i5 = 0, l7 = arguments.length; i5 < l7; i5++) {
        unshift(this, arguments[i5]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i5 = 0; walker !== null; i5++) {
        fn.call(thisp, walker.value, i5, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i5 = this.length - 1; walker !== null; i5--) {
        fn.call(thisp, walker.value, i5, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n4) {
      for (var i5 = 0, walker = this.head; walker !== null && i5 < n4; i5++) {
        walker = walker.next;
      }
      if (i5 === n4 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n4) {
      for (var i5 = 0, walker = this.tail; walker !== null && i5 < n4; i5++) {
        walker = walker.prev;
      }
      if (i5 === n4 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial2) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial2;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i5 = 0; walker !== null; i5++) {
        acc = fn(acc, walker.value, i5);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial2) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial2;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i5 = this.length - 1; walker !== null; i5--) {
        acc = fn(acc, walker.value, i5);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i5 = 0, walker = this.head; walker !== null; i5++) {
        arr[i5] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i5 = 0, walker = this.tail; walker !== null; i5++) {
        arr[i5] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i5 = 0, walker = this.head; walker !== null && i5 < from; i5++) {
        walker = walker.next;
      }
      for (; walker !== null && i5 < to; i5++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i5 = this.length, walker = this.tail; walker !== null && i5 > to; i5--) {
        walker = walker.prev;
      }
      for (; walker !== null && i5 > from; i5--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i5 = 0, walker = this.head; walker !== null && i5 < start; i5++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i5 = 0; walker && i5 < deleteCount; i5++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i5 = 0; i5 < nodes.length; i5++) {
        walker = insert(this, walker, nodes[i5]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p3 = walker.prev;
        walker.prev = walker.next;
        walker.next = p3;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push2(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max3 = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim2(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim2(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim2(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h4) => h4);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim2(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim2(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l7 = arr.length - 1; l7 >= 0; l7--) {
          const hit = arr[l7];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim2 = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/semver/classes/range.js"(exports, module) {
    var Range = class {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r4) => this.parseRange(r4.trim())).filter((c6) => c6.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c6) => !isNullSet(c6[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c6 of this.set) {
              if (c6.length === 1 && isAny(c6[0])) {
                this.set = [c6];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t10.HYPHENRANGELOOSE] : re[t10.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re[t10.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re[t10.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re[t10.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t10.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result2 = [...rangeMap.values()];
        cache2.set(memoKey, result2);
        return result2;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i5 = 0; i5 < this.set.length; i5++) {
          if (testSet(this.set[i5], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache2 = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t10,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c6) => c6.value === "<0.0.0-0";
    var isAny = (c6) => c6.value === "";
    var isSatisfiable = (comparators, options) => {
      let result2 = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result2 && remainingComparators.length) {
        result2 = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result2;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceTilde(c6, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r4 = options.loose ? re[t10.TILDELOOSE] : re[t10.TILDE];
      return comp.replace(r4, (_5, M4, m4, p3, pr) => {
        debug("tilde", comp, _5, M4, m4, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m4)) {
          ret = `>=${M4}.0.0 <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          ret = `>=${M4}.${m4}.0 <${M4}.${+m4 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${+m4 + 1}.0-0`;
        } else {
          ret = `>=${M4}.${m4}.${p3} <${M4}.${+m4 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceCaret(c6, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r4 = options.loose ? re[t10.CARETLOOSE] : re[t10.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r4, (_5, M4, m4, p3, pr) => {
        debug("caret", comp, _5, M4, m4, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m4)) {
          ret = `>=${M4}.0.0${z2} <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          if (M4 === "0") {
            ret = `>=${M4}.${m4}.0${z2} <${M4}.${+m4 + 1}.0-0`;
          } else {
            ret = `>=${M4}.${m4}.0${z2} <${+M4 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M4 === "0") {
            if (m4 === "0") {
              ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${m4}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m4}.${p3}-${pr} <${M4}.${+m4 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m4}.${p3}-${pr} <${+M4 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M4 === "0") {
            if (m4 === "0") {
              ret = `>=${M4}.${m4}.${p3}${z2} <${M4}.${m4}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m4}.${p3}${z2} <${M4}.${+m4 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m4}.${p3} <${+M4 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c6) => replaceXRange(c6, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r4 = options.loose ? re[t10.XRANGELOOSE] : re[t10.XRANGE];
      return comp.replace(r4, (ret, gtlt, M4, m4, p3, pr) => {
        debug("xRange", comp, ret, gtlt, M4, m4, p3, pr);
        const xM = isX(M4);
        const xm = xM || isX(m4);
        const xp = xm || isX(p3);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m4 = 0;
          }
          p3 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M4 = +M4 + 1;
              m4 = 0;
              p3 = 0;
            } else {
              m4 = +m4 + 1;
              p3 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M4 = +M4 + 1;
            } else {
              m4 = +m4 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M4}.${m4}.${p3}${pr}`;
        } else if (xm) {
          ret = `>=${M4}.0.0${pr} <${+M4 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M4}.${m4}.0${pr} <${M4}.${+m4 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t10.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t10.GTE0PRE : t10.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set3, version2, options) => {
      for (let i5 = 0; i5 < set3.length; i5++) {
        if (!set3[i5].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i5 = 0; i5 < set3.length; i5++) {
          debug(set3[i5].semver);
          if (set3[i5].semver === Comparator.ANY) {
            continue;
          }
          if (set3[i5].semver.prerelease.length > 0) {
            const allowed = set3[i5].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r4 = this.options.loose ? re[t10.COMPARATORLOOSE] : re[t10.COMPARATOR];
        const m4 = comp.match(r4);
        if (!m4) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m4[1] !== void 0 ? m4[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m4[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m4[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t10 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version2, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    module.exports = satisfies;
  }
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c6) => c6.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying2 = (versions, range2, options) => {
      let max3 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max3 || maxSV.compare(v2) === -1) {
            max3 = v2;
            maxSV = new SemVer(max3, options);
          }
        }
      });
      return max3;
    };
    module.exports = maxSatisfying2;
  }
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min3 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min3 || minSV.compare(v2) === 1) {
            min3 = v2;
            minSV = new SemVer(min3, options);
          }
        }
      });
      return min3;
    };
    module.exports = minSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i5 = 0; i5 < range2.set.length; ++i5) {
        const comparators = range2.set[i5];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range2, hilo, options) => {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range2, options)) {
        return false;
      }
      for (let i5 = 0; i5 < range2.set.length; ++i5) {
        const comparators = range2.set[i5];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version2, range2, options) => outside(version2, range2, ">", options);
    module.exports = gtr;
  }
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version2, range2, options) => outside(version2, range2, "<", options);
    module.exports = ltr;
  }
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range2, options) => {
      const set3 = [];
      let first2 = null;
      let prev = null;
      const v2 = versions.sort((a4, b4) => compare2(a4, b4, options));
      for (const version2 of v2) {
        const included = satisfies(version2, range2, options);
        if (included) {
          prev = version2;
          if (!first2) {
            first2 = version2;
          }
        } else {
          if (prev) {
            set3.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set3.push([first2, null]);
      }
      const ranges = [];
      for (const [min3, max3] of set3) {
        if (min3 === max3) {
          ranges.push(min3);
        } else if (!max3 && min3 === v2[0]) {
          ranges.push("*");
        } else if (!max3) {
          ranges.push(`>=${min3}`);
        } else if (min3 === v2[0]) {
          ranges.push(`<=${max3}`);
        } else {
          ranges.push(`${min3} - ${max3}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c6 of sub) {
        if (c6.operator === ">" || c6.operator === ">=") {
          gt = higherGT(gt, c6, options);
        } else if (c6.operator === "<" || c6.operator === "<=") {
          lt = lowerLT(lt, c6, options);
        } else {
          eqSet.add(c6.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt && !satisfies(eq2, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq2, String(lt), options)) {
          return null;
        }
        for (const c6 of dom) {
          if (!satisfies(eq2, String(c6), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c6 of dom) {
        hasDomGT = hasDomGT || c6.operator === ">" || c6.operator === ">=";
        hasDomLT = hasDomLT || c6.operator === "<" || c6.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomGTPre.major && c6.semver.minor === needDomGTPre.minor && c6.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c6.operator === ">" || c6.operator === ">=") {
            higher = higherGT(gt, c6, options);
            if (higher === c6 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c6), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomLTPre.major && c6.semver.minor === needDomLTPre.minor && c6.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c6.operator === "<" || c6.operator === "<=") {
            lower = lowerLT(lt, c6, options);
            if (lower === c6 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c6), options)) {
            return false;
          }
        }
        if (!c6.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare2(a4.semver, b4.semver, options);
      return comp > 0 ? a4 : comp < 0 ? b4 : b4.operator === ">" && a4.operator === ">=" ? b4 : a4;
    };
    var lowerLT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare2(a4.semver, b4.semver, options);
      return comp < 0 ? a4 : comp > 0 ? b4 : b4.operator === "<" && a4.operator === "<=" ? b4 : a4;
    };
    module.exports = subset;
  }
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse4 = require_parse3();
    var valid2 = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying2 = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse4,
      valid: valid2,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq: eq2,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying: maxSatisfying2,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js
var import_semver, SemVerCache;
var init_semvercache = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js"() {
    import_semver = __toESM(require_semver2());
    SemVerCache = class {
      constructor() {
        this._cache = /* @__PURE__ */ Object.create(null);
      }
      set(key, version2, object2) {
        if (!(key in this._cache)) {
          this._cache[key] = /* @__PURE__ */ Object.create(null);
        }
        if (!(version2 in this._cache[key])) {
          this._cache[key][version2] = object2;
        } else {
          throw `Version ${version2} of key ${key} already registered.`;
        }
      }
      get(key, semver) {
        if (key in this._cache) {
          const versions = this._cache[key];
          const best = (0, import_semver.maxSatisfying)(Object.keys(versions), semver);
          if (best !== null) {
            return versions[best];
          }
        }
      }
      getAllVersions(key) {
        if (key in this._cache) {
          return this._cache[key];
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js
var import_semver2, WIDGET_STATE_MIMETYPE, LabWidgetManager, KernelWidgetManager, WidgetManager;
var init_manager2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js"() {
    init_lib10();
    init_lib11();
    init_index_es6();
    import_semver2 = __toESM(require_semver2());
    init_semvercache();
    WIDGET_STATE_MIMETYPE = "application/vnd.jupyter.widget-state+json";
    LabWidgetManager = class extends ManagerBase {
      constructor(rendermime) {
        super();
        this._handleCommOpen = async (comm, msg) => {
          const oldComm = new shims.services.Comm(comm);
          await this.handle_comm_open(oldComm, msg);
        };
        this._restored = new Signal(this);
        this._restoredStatus = false;
        this._kernelRestoreInProgress = false;
        this._isDisposed = false;
        this._registry = new SemVerCache();
        this._modelsSync = /* @__PURE__ */ new Map();
        this._onUnhandledIOPubMessage = new Signal(this);
        this._rendermime = rendermime;
      }
      /**
       * Default callback handler to emit unhandled kernel messages.
       */
      callbacks(view) {
        return {
          iopub: {
            output: (msg) => {
              this._onUnhandledIOPubMessage.emit(msg);
            }
          }
        };
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue, newValue }) {
        if (oldValue) {
          oldValue.removeCommTarget(this.comm_target_name, this._handleCommOpen);
        }
        if (newValue) {
          newValue.registerCommTarget(this.comm_target_name, this._handleCommOpen);
        }
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        super.disconnect();
        this._restoredStatus = false;
      }
      async _loadFromKernel() {
        var _a;
        if (!this.kernel) {
          throw new Error("Kernel not set");
        }
        if (((_a = this.kernel) === null || _a === void 0 ? void 0 : _a.handleComms) === false) {
          return;
        }
        return super._loadFromKernel();
      }
      /**
       * Create a comm.
       */
      async _create_comm(target_name, model_id, data, metadata, buffers) {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const comm = kernel.createComm(target_name, model_id);
        if (data || metadata) {
          comm.open(data, metadata, buffers);
        }
        return new shims.services.Comm(comm);
      }
      /**
       * Get the currently-registered comms.
       */
      async _get_comm_info() {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const reply = await kernel.requestCommInfo({
          target_name: this.comm_target_name
        });
        if (reply.content.status === "ok") {
          return reply.content.comms;
        } else {
          return {};
        }
      }
      /**
       * Get whether the manager is disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        if (this._commRegistration) {
          this._commRegistration.dispose();
        }
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        return url;
      }
      /**
       * Load a class and return a promise to the loaded object.
       */
      async loadClass(className, moduleName, moduleVersion) {
        if ((moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls") && (0, import_semver2.valid)(moduleVersion)) {
          moduleVersion = `^${moduleVersion}`;
        }
        const allVersions = this._registry.getAllVersions(moduleName);
        if (!allVersions) {
          throw new Error(`No version of module ${moduleName} is registered`);
        }
        const mod = this._registry.get(moduleName, moduleVersion);
        if (!mod) {
          const registeredVersionList = Object.keys(allVersions);
          throw new Error(`Module ${moduleName}, version ${moduleVersion} is not registered, however,         ${registeredVersionList.join(",")} ${registeredVersionList.length > 1 ? "are" : "is"}`);
        }
        let module;
        if (typeof mod === "function") {
          module = await mod();
        } else {
          module = await mod;
        }
        const cls = module[className];
        if (!cls) {
          throw new Error(`Class ${className} not found in module ${moduleName}`);
        }
        return cls;
      }
      get rendermime() {
        return this._rendermime;
      }
      /**
       * A signal emitted when state is restored to the widget manager.
       *
       * #### Notes
       * This indicates that previously-unavailable widget models might be available now.
       */
      get restored() {
        return this._restored;
      }
      /**
       * Whether the state has been restored yet or not.
       */
      get restoredStatus() {
        return this._restoredStatus;
      }
      /**
       * A signal emitted for unhandled iopub kernel messages.
       *
       */
      get onUnhandledIOPubMessage() {
        return this._onUnhandledIOPubMessage;
      }
      register(data) {
        this._registry.set(data.name, data.version, data.exports);
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        modelPromise.then((model) => {
          this._modelsSync.set(model_id, model);
          model.once("comm:close", () => {
            this._modelsSync.delete(model_id);
          });
        });
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this._modelsSync = /* @__PURE__ */ new Map();
      }
      /**
       * Synchronously get the state of the live widgets in the widget manager.
       *
       * This includes all of the live widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns A state dictionary
       */
      get_state_sync(options = {}) {
        const models = [];
        for (const model of this._modelsSync.values()) {
          if (model.comm_live) {
            models.push(model);
          }
        }
        return serialize_state(models, options);
      }
    };
    KernelWidgetManager = class extends LabWidgetManager {
      constructor(kernel, rendermime) {
        super(rendermime);
        this._kernel = kernel;
        kernel.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        kernel.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        this._handleKernelChanged({
          name: "kernel",
          oldValue: null,
          newValue: kernel
        });
        this.restoreWidgets();
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets();
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets() {
        try {
          this._kernelRestoreInProgress = true;
          await this._loadFromKernel();
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
        this._kernelRestoreInProgress = false;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._kernel = null;
        super.dispose();
      }
      get kernel() {
        return this._kernel;
      }
    };
    WidgetManager = class extends LabWidgetManager {
      constructor(context, rendermime, settings) {
        var _a, _b;
        super(rendermime);
        this._context = context;
        context.sessionContext.kernelChanged.connect((sender, args) => {
          this._handleKernelChanged(args);
        });
        context.sessionContext.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        context.sessionContext.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        if ((_a = context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) {
          this._handleKernelChanged({
            name: "kernel",
            oldValue: null,
            newValue: (_b = context.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel
          });
        }
        this.restoreWidgets(this._context.model);
        this._settings = settings;
        context.saveState.connect((sender, saveState) => {
          if (saveState === "started" && settings.saveState) {
            this._saveState();
          }
        });
      }
      /**
       * Save the widget state to the context model.
       */
      _saveState() {
        const state = this.get_state_sync({ drop_defaults: true });
        if (this._context.model.setMetadata) {
          this._context.model.setMetadata("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        } else {
          this._context.model.metadata.set("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        }
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets(this._context.model, {
              loadKernel: true,
              loadNotebook: false
            });
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets(notebook, { loadKernel, loadNotebook } = { loadKernel: true, loadNotebook: true }) {
        try {
          if (loadKernel) {
            try {
              this._kernelRestoreInProgress = true;
              await this._loadFromKernel();
            } finally {
              this._kernelRestoreInProgress = false;
            }
          }
          if (loadNotebook) {
            await this._loadFromNotebook(notebook);
          }
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
      }
      /**
       * Load widget state from notebook metadata
       */
      async _loadFromNotebook(notebook) {
        const widget_md = notebook.getMetadata ? notebook.getMetadata("widgets") : (
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore JupyterLab 3 support
          notebook.metadata.get("widgets")
        );
        if (widget_md && widget_md[WIDGET_STATE_MIMETYPE]) {
          let state = widget_md[WIDGET_STATE_MIMETYPE];
          state = this.filterExistingModelState(state);
          await this.set_state(state);
        }
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._context = null;
        super.dispose();
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        const partial2 = await this.context.urlResolver.resolveUrl(url);
        return this.context.urlResolver.getDownloadUrl(partial2);
      }
      get context() {
        return this._context;
      }
      get kernel() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this._context.sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel) !== null && _c !== void 0 ? _c : null;
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        this.setDirty();
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this.setDirty();
      }
      /**
       * Set the dirty state of the notebook model if applicable.
       *
       * TODO: perhaps should also set dirty when any model changes any data
       */
      setDirty() {
        if (this._settings.saveState) {
          this._context.model.dirty = true;
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/output.js
var OUTPUT_WIDGET_VERSION, OutputModel2, OutputView;
var init_output = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/output.js"() {
    init_lib10();
    OUTPUT_WIDGET_VERSION = "1.0.0";
    OutputModel2 = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "OutputModel", _view_name: "OutputView", _model_module: "@jupyter-widgets/output", _view_module: "@jupyter-widgets/output", _model_module_version: OUTPUT_WIDGET_VERSION, _view_module_version: OUTPUT_WIDGET_VERSION });
      }
    };
    OutputView = class extends DOMWidgetView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/index.js
var init_lib12 = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/index.js"() {
    init_output();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js
var output_exports = {};
__export(output_exports, {
  OUTPUT_WIDGET_VERSION: () => OUTPUT_WIDGET_VERSION2,
  OutputModel: () => OutputModel3,
  OutputView: () => OutputView2
});
var import_jquery2, OUTPUT_WIDGET_VERSION2, OutputModel3, OutputView2;
var init_output2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js"() {
    init_lib12();
    init_lib10();
    init_manager2();
    init_lib9();
    import_jquery2 = __toESM(require_jquery());
    OUTPUT_WIDGET_VERSION2 = OUTPUT_WIDGET_VERSION;
    OutputModel3 = class extends OutputModel2 {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { msg_id: "", outputs: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this._outputs = new OutputAreaModel({ trusted: true });
        this._msgHook = (msg) => {
          this.add(msg);
          return false;
        };
        if (this.widget_manager instanceof WidgetManager) {
          this.widget_manager.context.sessionContext.kernelChanged.connect((sender, args) => {
            this._handleKernelChanged(args);
          });
        }
        this.listenTo(this, "change:msg_id", this.reset_msg_id);
        this.listenTo(this, "change:outputs", this.setOutputs);
        this.setOutputs();
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue }) {
        const msgId = this.get("msg_id");
        if (msgId && oldValue) {
          oldValue.removeMessageHook(msgId, this._msgHook);
          this.set("msg_id", null);
        }
      }
      /**
       * Reset the message id.
       */
      reset_msg_id() {
        const kernel = this.widget_manager.kernel;
        const msgId = this.get("msg_id");
        const oldMsgId = this.previous("msg_id");
        if (oldMsgId && kernel) {
          kernel.removeMessageHook(oldMsgId, this._msgHook);
        }
        if (msgId && kernel) {
          kernel.registerMessageHook(msgId, this._msgHook);
        }
      }
      add(msg) {
        const msgType = msg.header.msg_type;
        switch (msgType) {
          case "execute_result":
          case "display_data":
          case "stream":
          case "error": {
            const model = msg.content;
            model.output_type = msgType;
            this._outputs.add(model);
            break;
          }
          case "clear_output":
            this.clear_output(msg.content.wait);
            break;
          default:
            break;
        }
        this.set("outputs", this._outputs.toJSON(), { newMessage: true });
        this.save_changes();
      }
      clear_output(wait = false) {
        this._outputs.clear(wait);
      }
      get outputs() {
        return this._outputs;
      }
      setOutputs(model, value, options) {
        if (!(options && options.newMessage)) {
          this.clear_output();
          this._outputs.fromJSON(JSON.parse(JSON.stringify(this.get("outputs"))));
        }
      }
    };
    OutputView2 = class extends OutputView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery2.default)(this.luminoWidget.node);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this._outputView = new OutputArea({
          rendermime: this.model.widget_manager.rendermime,
          contentFactory: OutputArea.defaultContentFactory,
          model: this.model.outputs
        });
        this.luminoWidget.insertWidget(0, this._outputView);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-output");
        this.update();
      }
      remove() {
        this._outputView.dispose();
        return super.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/version.js
var JUPYTER_CONTROLS_VERSION;
var init_version2 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/version.js"() {
    JUPYTER_CONTROLS_VERSION = "2.0.0";
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js
var init_lib13 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js"() {
    init_output2();
    init_manager2();
    init_renderer();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/utils.js
function typeset(element2, text) {
  if (text !== void 0) {
    element2.textContent = text;
  }
  if (window.MathJax !== void 0) {
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, element2]);
  }
}
function escape_html(text) {
  const esc = document.createElement("div");
  esc.textContent = text;
  return esc.innerHTML;
}
function reject3(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
var init_utils3 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/utils.js"() {
    init_lib10();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_description.js
var DescriptionStyleModel, DescriptionModel, DescriptionView, LabeledDOMWidgetModel, LabeledDOMWidgetView;
var init_widget_description = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_description.js"() {
    init_lib10();
    init_utils3();
    init_version2();
    DescriptionStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    DescriptionStyleModel.styleProperties = {
      description_width: {
        selector: ".widget-label",
        attribute: "width",
        default: null
      }
    };
    DescriptionModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionModel", _view_name: "DescriptionView", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION, description: "", description_allow_html: false });
      }
    };
    DescriptionView = class extends DOMWidgetView {
      render() {
        this.label = document.createElement("label");
        this.el.appendChild(this.label);
        this.label.className = "widget-label";
        this.label.style.display = "none";
        this.listenTo(this.model, "change:description", this.updateDescription);
        this.listenTo(this.model, "change:description_allow_html", this.updateDescription);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.updateDescription();
        this.updateTabindex();
        this.updateTooltip();
      }
      typeset(element2, text) {
        this.displayed.then(() => typeset(element2, text));
      }
      updateDescription() {
        const description = this.model.get("description");
        if (description.length === 0) {
          this.label.style.display = "none";
        } else {
          if (this.model.get("description_allow_html")) {
            this.label.innerHTML = this.model.widget_manager.inline_sanitize(description);
          } else {
            this.label.textContent = description;
          }
          this.typeset(this.label);
          this.label.style.display = "";
        }
      }
      updateTooltip() {
        if (!this.label)
          return;
        this.label.title = this.model.get("tooltip");
      }
    };
    LabeledDOMWidgetModel = class extends DescriptionModel {
    };
    LabeledDOMWidgetView = class extends DescriptionView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_core.js
var CoreWidgetModel, CoreDOMWidgetModel, CoreDescriptionModel;
var init_widget_core = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_core.js"() {
    init_lib10();
    init_widget_description();
    init_version2();
    CoreWidgetModel = class extends WidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDOMWidgetModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDOMWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDescriptionModel = class extends DescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDescriptionModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_link.js
var DirectionalLinkModel, LinkModel;
var init_widget_link = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_link.js"() {
    init_lib10();
    init_widget_core();
    DirectionalLinkModel = class extends CoreWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { target: void 0, source: void 0, _model_name: "DirectionalLinkModel" });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change", this.updateBindings, this);
        this.updateBindings();
      }
      updateValue(sourceModel, sourceAttr, targetModel, targetAttr) {
        if (this._updating) {
          return;
        }
        this._updating = true;
        try {
          if (targetModel) {
            targetModel.set(targetAttr, sourceModel.get(sourceAttr));
            targetModel.save_changes();
          }
        } finally {
          this._updating = false;
        }
      }
      updateBindings() {
        this.cleanup();
        [this.sourceModel, this.sourceAttr] = this.get("source") || [null, null];
        [this.targetModel, this.targetAttr] = this.get("target") || [null, null];
        if (this.sourceModel) {
          this.listenTo(this.sourceModel, "change:" + this.sourceAttr, () => {
            this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          });
          this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          this.listenToOnce(this.sourceModel, "destroy", this.cleanup);
        }
        if (this.targetModel) {
          this.listenToOnce(this.targetModel, "destroy", this.cleanup);
        }
      }
      cleanup() {
        if (this.sourceModel) {
          this.stopListening(this.sourceModel, "change:" + this.sourceAttr, void 0);
          this.stopListening(this.sourceModel, "destroy", void 0);
        }
        if (this.targetModel) {
          this.stopListening(this.targetModel, "destroy", void 0);
        }
      }
    };
    DirectionalLinkModel.serializers = Object.assign(Object.assign({}, CoreWidgetModel.serializers), { target: { deserialize: unpack_models }, source: { deserialize: unpack_models } });
    LinkModel = class extends DirectionalLinkModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LinkModel" });
      }
      updateBindings() {
        super.updateBindings();
        if (this.targetModel) {
          this.listenTo(this.targetModel, "change:" + this.targetAttr, () => {
            this.updateValue(this.targetModel, this.targetAttr, this.sourceModel, this.sourceAttr);
          });
        }
      }
      cleanup() {
        super.cleanup();
        if (this.targetModel) {
          this.stopListening(this.targetModel, "change:" + this.targetAttr, void 0);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js
var CheckboxStyleModel, ToggleButtonStyleModel, BoolModel, CheckboxModel, CheckboxView, ToggleButtonModel, ToggleButtonView, ValidModel, ValidView;
var init_widget_bool = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js"() {
    init_lib10();
    init_widget_core();
    init_widget_description();
    CheckboxStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CheckboxStyleModel" });
      }
    };
    CheckboxStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    } });
    ToggleButtonStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonStyleModel" });
      }
    };
    ToggleButtonStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    BoolModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: false, disabled: false, _model_name: "BoolModel" });
      }
    };
    CheckboxModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { indent: true, style: null, _view_name: "CheckboxView", _model_name: "CheckboxModel" });
      }
    };
    CheckboxView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-checkbox");
        this.label.innerHTML = "&#8203;";
        this.checkboxLabel = document.createElement("label");
        this.checkboxLabel.classList.add("widget-label-basic");
        this.el.appendChild(this.checkboxLabel);
        this.checkbox = document.createElement("input");
        this.checkbox.setAttribute("type", "checkbox");
        this.checkboxLabel.appendChild(this.checkbox);
        this.descriptionSpan = document.createElement("span");
        this.checkboxLabel.appendChild(this.descriptionSpan);
        this.listenTo(this.model, "change:indent", this.updateIndent);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.update();
        this.updateDescription();
        this.updateIndent();
        this.updateTabindex();
        this.updateTooltip();
      }
      /**
       * Overridden from super class
       *
       * Update the description span (rather than the label) since
       * we want the description to the right of the checkbox.
       */
      updateDescription() {
        if (this.checkboxLabel == null) {
          return;
        }
        const description = this.model.get("description");
        if (this.model.get("description_allow_html")) {
          this.descriptionSpan.innerHTML = this.model.widget_manager.inline_sanitize(description);
        } else {
          this.descriptionSpan.textContent = description;
        }
        this.typeset(this.descriptionSpan);
        this.descriptionSpan.title = description;
        this.checkbox.title = description;
      }
      /**
       * Update the visibility of the label in the super class
       * to provide the optional indent.
       */
      updateIndent() {
        const indent = this.model.get("indent");
        this.label.style.display = indent ? "" : "none";
      }
      updateTabindex() {
        if (!this.checkbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.checkbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.checkbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.checkbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.checkbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.checkbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.checkbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          'click input[type="checkbox"]': "_handle_click"
        };
      }
      /**
       * Handles when the checkbox is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click() {
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        this.checkbox.checked = this.model.get("value");
        if (options === void 0 || options.updated_view != this) {
          this.checkbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.checkbox.focus();
        } else if (content.do == "blur") {
          this.checkbox.blur();
        }
      }
    };
    ToggleButtonModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "ToggleButtonView", _model_name: "ToggleButtonModel", tooltip: "", icon: "", button_style: "", style: null });
      }
    };
    ToggleButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-toggle-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      update_button_style() {
        this.update_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (this.model.get("value")) {
          this.el.classList.add("mod-active");
        } else {
          this.el.classList.remove("mod-active");
        }
        if (options === void 0 || options.updated_view !== this) {
          this.el.disabled = this.model.get("disabled");
          this.el.setAttribute("tabbable", this.model.get("tabbable"));
          this.el.setAttribute("title", this.model.get("tooltip"));
          const description = this.model.get("description");
          const icon = this.model.get("icon");
          if (description.trim().length === 0 && icon.trim().length === 0) {
            this.el.innerHTML = "&nbsp;";
          } else {
            this.el.textContent = "";
            if (icon.trim().length) {
              const i5 = document.createElement("i");
              this.el.appendChild(i5);
              i5.classList.add("fa");
              i5.classList.add("fa-" + icon);
            }
            this.el.appendChild(document.createTextNode(description));
          }
        }
        this.updateTabindex();
        return super.update();
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          click: "_handle_click"
        };
      }
      /**
       * Handles and validates user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        event.preventDefault();
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ToggleButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
    ValidModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { readout: "Invalid", _view_name: "ValidView", _model_name: "ValidModel" });
      }
    };
    ValidView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-valid");
        this.el.classList.add("widget-inline-hbox");
        this.icon = document.createElement("i");
        this.icon.classList.add("fa", "fa-fw");
        this.el.appendChild(this.icon);
        this.readout = document.createElement("span");
        this.readout.classList.add("widget-valid-readout");
        this.readout.classList.add("widget-readout");
        this.el.appendChild(this.readout);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.classList.remove("mod-valid");
        this.el.classList.remove("mod-invalid");
        this.icon.classList.remove("fa-check");
        this.icon.classList.remove("fa-times");
        this.readout.textContent = this.model.get("readout");
        if (this.model.get("value")) {
          this.el.classList.add("mod-valid");
          this.icon.classList.add("fa-check");
        } else {
          this.el.classList.add("mod-invalid");
          this.icon.classList.add("fa-times");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_button.js
var ButtonStyleModel, ButtonModel, ButtonView;
var init_widget_button = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_button.js"() {
    init_lib10();
    init_widget_core();
    init_version2();
    ButtonStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ButtonStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    ButtonStyleModel.styleProperties = {
      button_color: {
        selector: "",
        attribute: "background-color",
        default: null
      },
      font_family: {
        selector: "",
        attribute: "font-family",
        default: ""
      },
      font_size: {
        selector: "",
        attribute: "font-size",
        default: ""
      },
      font_style: {
        selector: "",
        attribute: "font-style",
        default: ""
      },
      font_variant: {
        selector: "",
        attribute: "font-variant",
        default: ""
      },
      font_weight: {
        selector: "",
        attribute: "font-weight",
        default: ""
      },
      text_color: {
        selector: "",
        attribute: "color",
        default: ""
      },
      text_decoration: {
        selector: "",
        attribute: "text-decoration",
        default: ""
      }
    };
    ButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { description: "", tooltip: "", disabled: false, icon: "", button_style: "", _view_name: "ButtonView", _model_name: "ButtonModel", style: null });
      }
    };
    ButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.disabled = this.model.get("disabled");
        this.updateTabindex();
        const tooltip = this.model.get("tooltip");
        const description = this.model.get("description");
        const icon = this.model.get("icon");
        this.el.setAttribute("title", tooltip !== null && tooltip !== void 0 ? tooltip : description);
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i5 = document.createElement("i");
            i5.classList.add("fa");
            i5.classList.add(...icon.split(/[\s]+/).filter(Boolean).map((v2) => `fa-${v2}`));
            if (description.length === 0) {
              i5.classList.add("center");
            }
            this.el.appendChild(i5);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(ButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ButtonView.class_map, "button_style");
      }
      /**
       * Dictionary of events and handlers
       */
      events() {
        return { click: "_handle_click" };
      }
      /**
       * Handles when the button is clicked.
       */
      _handle_click(event) {
        event.preventDefault();
        this.send({ event: "click" });
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_box.js
var import_jquery3, BoxModel, HBoxModel, VBoxModel, BoxView, HBoxView, VBoxView, GridBoxView, GridBoxModel;
var init_widget_box = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_box.js"() {
    init_lib10();
    init_widget_core();
    init_index_es64();
    init_index_es65();
    init_index_es63();
    import_jquery3 = __toESM(require_jquery());
    BoxModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "BoxView", _model_name: "BoxModel", children: [], box_style: "" });
      }
    };
    BoxModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { children: { deserialize: unpack_models } });
    HBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HBoxView", _model_name: "HBoxModel" });
      }
    };
    VBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "VBoxView", _model_name: "VBoxModel" });
      }
    };
    BoxView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery3.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_model, null, this);
        this.listenTo(this.model, "change:children", this.update_children);
        this.listenTo(this.model, "change:box_style", this.update_box_style);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-container");
        this.luminoWidget.addClass("widget-box");
      }
      render() {
        super.render();
        this.update_children();
        this.set_box_style();
      }
      update_children() {
        var _a;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children")).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
      update_box_style() {
        this.update_mapped_classes(BoxView.class_map, "box_style");
      }
      set_box_style() {
        this.set_mapped_classes(BoxView.class_map, "box_style");
      }
      add_child_model(model) {
        const dummy = new Widget();
        this.luminoWidget.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.luminoWidget.widgets, dummy);
          this.luminoWidget.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    BoxView.class_map = {
      success: ["alert", "alert-success"],
      info: ["alert", "alert-info"],
      warning: ["alert", "alert-warning"],
      danger: ["alert", "alert-danger"]
    };
    HBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-hbox");
      }
    };
    VBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-vbox");
      }
    };
    GridBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-gridbox");
        this.luminoWidget.removeClass("widget-box");
      }
    };
    GridBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "GridBoxView", _model_name: "GridBoxModel" });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_image.js
var ImageModel, ImageView;
var init_widget_image = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_image.js"() {
    init_lib10();
    init_widget_core();
    ImageModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ImageModel", _view_name: "ImageView", format: "png", width: "", height: "", value: new DataView(new ArrayBuffer(0)) });
      }
    };
    ImageModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    ImageView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `image/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "img";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_video.js
var VideoModel, VideoView;
var init_widget_video = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_video.js"() {
    init_lib10();
    init_widget_core();
    VideoModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "VideoModel", _view_name: "VideoView", format: "mp4", width: "", height: "", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    VideoModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    VideoView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `video/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "video";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js
var AudioModel, AudioView;
var init_widget_audio = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js"() {
    init_lib10();
    init_widget_core();
    AudioModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AudioModel", _view_name: "AudioView", format: "mp3", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    AudioModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    AudioView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `audio/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "audio";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_color.js
function color2hex(color2) {
  return named_colors[color2.toLowerCase()] || rgb3_to_rgb6(color2);
}
function rgb3_to_rgb6(rgb) {
  if (rgb.length === 7) {
    return rgb;
  } else {
    return "#" + rgb.charAt(1) + rgb.charAt(1) + rgb.charAt(2) + rgb.charAt(2) + rgb.charAt(3) + rgb.charAt(3);
  }
}
var named_colors, ColorPickerModel, ColorPickerView;
var init_widget_color = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_color.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    named_colors = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgreen: "#90ee90",
      lightgray: "#d3d3d3",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    ColorPickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "black", concise: false, _model_name: "ColorPickerModel", _view_name: "ColorPickerView" });
      }
    };
    ColorPickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-colorpicker");
        this._color_container = document.createElement("div");
        this._color_container.className = "widget-inline-hbox widget-colorpicker-input";
        this.el.appendChild(this._color_container);
        this._textbox = document.createElement("input");
        this._textbox.setAttribute("type", "text");
        this._textbox.id = this.label.htmlFor = uuid();
        this._color_container.appendChild(this._textbox);
        this._textbox.value = this.model.get("value");
        this._colorpicker = document.createElement("input");
        this._colorpicker.setAttribute("type", "color");
        this._color_container.appendChild(this._colorpicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change:concise", this._update_concise);
        this._update_concise();
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view != this) {
          const disabled = this.model.get("disabled");
          this._textbox.disabled = disabled;
          this._colorpicker.disabled = disabled;
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._text_change;
        return {
          'change [type="color"]': "_picker_change",
          'change [type="text"]': "_text_change"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._colorpicker.value = color2hex(value);
        this._textbox.value = value;
      }
      _update_concise() {
        const concise = this.model.get("concise");
        if (concise) {
          this.el.classList.add("concise");
          this._textbox.style.display = "none";
        } else {
          this.el.classList.remove("concise");
          this._textbox.style.display = "";
        }
      }
      _picker_change() {
        this.model.set("value", this._colorpicker.value);
        this.touch();
      }
      _text_change() {
        const value = this._validate_color(this._textbox.value, this.model.get("value"));
        this.model.set("value", value);
        this.touch();
      }
      _validate_color(color2, fallback) {
        return color2.match(/#[a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?$/) || named_colors[color2.toLowerCase()] ? color2 : fallback;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_date.js
function serialize_date(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate()
    };
  }
}
function deserialize_date(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
}
var DatePickerModel, DatePickerView;
var init_widget_date = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_date.js"() {
    init_widget_description();
    init_widget_core();
    init_utils3();
    DatePickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: null, _model_name: "DatePickerModel", _view_name: "DatePickerView" });
      }
    };
    DatePickerModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: {
      serialize: serialize_date,
      deserialize: deserialize_date
    } });
    DatePickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datepicker");
        this._datepicker = document.createElement("input");
        this._datepicker.setAttribute("type", "date");
        this._datepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._datepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this._datepicker.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._datepicker.valueAsDate = value;
      }
      _picker_change() {
        if (!this._datepicker.validity.badInput) {
          this.model.set("value", this._datepicker.valueAsDate);
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._datepicker.validity.badInput) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_time.js
function serialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const res = PARSER.exec(value);
    if (res === null) {
      return null;
    }
    return {
      hours: Math.min(23, parseInt(res[1], 10)),
      minutes: Math.min(59, parseInt(res[2], 10)),
      seconds: res[4] ? Math.min(59, parseInt(res[4], 10)) : 0,
      milliseconds: res[6] ? parseInt(res[6], 10) : 0
    };
  }
}
function deserialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const parts = [
      `${value.hours.toString().padStart(2, "0")}:${value.minutes.toString().padStart(2, "0")}`
    ];
    if (value.seconds > 0 || value.milliseconds > 0) {
      parts.push(`:${value.seconds.toString().padStart(2, "0")}`);
      if (value.milliseconds > 0) {
        parts.push(`.${value.milliseconds.toString().padStart(3, "0")}`);
      }
    }
    return parts.join("");
  }
}
var PARSER, time_serializers, TimeModel, TimeView;
var init_widget_time = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_time.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    PARSER = /(\d\d):(\d\d)(:(\d\d)(.(\d{1,3})\d*)?)?/;
    time_serializers = {
      serialize: serialize_time,
      deserialize: deserialize_time
    };
    TimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: TimeModel.model_name, _view_name: TimeModel.view_name, value: null, disabled: false, min: null, max: null, step: 60 });
      }
    };
    TimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: time_serializers, min: time_serializers, max: time_serializers });
    TimeModel.model_name = "TimeModel";
    TimeModel.view_name = "TimeView";
    TimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-timepicker");
        this._timepicker = document.createElement("input");
        this._timepicker.setAttribute("type", "time");
        this._timepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._timepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.disabled = this.model.get("disabled");
          this._timepicker.min = this.model.get("min");
          this._timepicker.max = this.model.get("max");
          this._timepicker.step = this.model.get("step");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="time"]': "_picker_change",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.value = this.model.get("value");
        }
      }
      _picker_change() {
        if (!this._timepicker.validity.badInput) {
          this.model.set("value", this._timepicker.value, { updated_view: this });
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._timepicker.validity.badInput) {
          this.model.set("value", null, { updated_view: this });
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js
function serialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate(),
      hours: value.getUTCHours(),
      minutes: value.getUTCMinutes(),
      seconds: value.getUTCSeconds(),
      milliseconds: value.getUTCMilliseconds()
    };
  }
}
function deserialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
function serialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getFullYear(),
      month: value.getMonth(),
      date: value.getDate(),
      hours: value.getHours(),
      minutes: value.getMinutes(),
      seconds: value.getSeconds(),
      milliseconds: value.getMilliseconds()
    };
  }
}
function deserialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(value.year, value.month, value.date);
    date.setHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
var datetime_serializers, DatetimeModel, DatetimeView, Private19, naive_serializers, NaiveDatetimeModel;
var init_widget_datetime = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    init_widget_time();
    datetime_serializers = {
      serialize: serialize_datetime,
      deserialize: deserialize_datetime
    };
    DatetimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DatetimeModel", _view_name: "DatetimeView", value: null, disabled: false, min: null, max: null });
      }
    };
    DatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: datetime_serializers, min: datetime_serializers, max: datetime_serializers });
    DatetimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datetimepicker");
        const test = document.createElement("input");
        test.type = "datetime-local";
        if (test.type === "text") {
          this._datepicker = document.createElement("input");
          this._datepicker.setAttribute("type", "date");
          this._datepicker.id = this.label.htmlFor = uuid();
          this._timepicker = document.createElement("input");
          this._timepicker.setAttribute("type", "time");
          this._timepicker.id = uuid();
          this.el.appendChild(this._datepicker);
          this.el.appendChild(this._timepicker);
        } else {
          this._datetimepicker = test;
          this._datetimepicker.id = this.label.htmlFor = uuid();
          this.el.appendChild(this._datetimepicker);
        }
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          const min3 = this.model.get("min");
          const max3 = this.model.get("max");
          if (this._datetimepicker) {
            this._datetimepicker.disabled = this.model.get("disabled");
            this._datetimepicker.min = Private19.dt_as_dt_string(min3);
            this._datetimepicker.max = Private19.dt_as_dt_string(max3);
          } else {
            this._datepicker.disabled = this.model.get("disabled");
            this._datepicker.min = Private19.dt_as_date_string(min3);
            this._datepicker.max = Private19.dt_as_date_string(max3);
            this._timepicker.disabled = this.model.get("disabled");
          }
        }
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'change [type="time"]': "_picker_change",
          'change [type="datetime-local"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout",
          'focusout [type="datetime-local"]': "_picker_focusout",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._datetimepicker) {
            this._datetimepicker.value = Private19.dt_as_dt_string(value);
          } else {
            this._datepicker.valueAsDate = value;
            this._timepicker.value = Private19.dt_as_time_string(value);
          }
        }
      }
      _picker_change() {
        if (this._datetimepicker) {
          if (!this._datetimepicker.validity.badInput) {
            const v2 = this._datetimepicker.value;
            let date = v2 ? new Date(v2) : null;
            if (date && isNaN(date.valueOf())) {
              date = null;
            }
            this.model.set("value", date, { updated_view: this });
            this.touch();
          }
        } else {
          if (!this._datepicker.validity.badInput && !this._timepicker.validity.badInput) {
            const date = this._datepicker.valueAsDate;
            const time = serialize_time(this._timepicker.value);
            if (date !== null && time !== null) {
              date.setHours(time.hours, time.minutes, time.seconds, time.milliseconds);
            }
            this.model.set("value", time !== null && date, { updated_view: this });
            this.touch();
          }
        }
      }
      _picker_focusout() {
        const pickers = [this._datetimepicker, this._datepicker, this._timepicker];
        if (pickers.some((p3) => p3 && p3.validity.badInput)) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
    (function(Private20) {
      function dt_as_dt_string(value) {
        if (value === null) {
          return "";
        }
        const parts = [];
        parts.push(`${value.getFullYear().toString().padStart(4, "0")}`);
        parts.push(`-${(value.getMonth() + 1).toString().padStart(2, "0")}`);
        parts.push(`-${value.getDate().toString().padStart(2, "0")}`);
        parts.push(`T${value.getHours().toString().padStart(2, "0")}`);
        parts.push(`:${value.getMinutes().toString().padStart(2, "0")}`);
        if (value.getSeconds() > 0 || value.getMilliseconds() > 0) {
          parts.push(`:${value.getSeconds().toString().padStart(2, "0")}`);
          if (value.getMilliseconds() > 0) {
            parts.push(`.${value.getMilliseconds().toString().padStart(3, "0")}`);
          }
        }
        return parts.join("");
      }
      Private20.dt_as_dt_string = dt_as_dt_string;
      function dt_as_date_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[0] : "";
      }
      Private20.dt_as_date_string = dt_as_date_string;
      function dt_as_time_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[1] : "";
      }
      Private20.dt_as_time_string = dt_as_time_string;
    })(Private19 || (Private19 = {}));
    naive_serializers = {
      serialize: serialize_naive,
      deserialize: deserialize_naive
    };
    NaiveDatetimeModel = class extends DatetimeModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "NaiveDatetimeModel" });
      }
    };
    NaiveDatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: naive_serializers, min: naive_serializers, max: naive_serializers });
  }
});

// ../../node_modules/nouislider/dist/nouislider.js
var require_nouislider = __commonJS({
  "../../node_modules/nouislider/dist/nouislider.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.noUiSlider = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.PipsMode = void 0;
      (function(PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports2.PipsMode || (exports2.PipsMode = {}));
      exports2.PipsType = void 0;
      (function(PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports2.PipsType || (exports2.PipsType = {}));
      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }
      function isValidPartialFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function";
      }
      function removeElement(el) {
        el.parentElement.removeChild(el);
      }
      function isSet(value) {
        return value !== null && value !== void 0;
      }
      function preventDefault(e4) {
        e4.preventDefault();
      }
      function unique(array) {
        return array.filter(function(a4) {
          return !this[a4] ? this[a4] = true : false;
        }, {});
      }
      function closest(value, to) {
        return Math.round(value / to) * to;
      }
      function offset2(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }
        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      }
      function isNumeric(a4) {
        return typeof a4 === "number" && !isNaN(a4) && isFinite(a4);
      }
      function addClassFor(element2, className, duration) {
        if (duration > 0) {
          addClass(element2, className);
          setTimeout(function() {
            removeClass(element2, className);
          }, duration);
        }
      }
      function limit(a4) {
        return Math.max(Math.min(a4, 100), 0);
      }
      function asArray(a4) {
        return Array.isArray(a4) ? a4 : [a4];
      }
      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      }
      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      }
      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      }
      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      }
      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== void 0;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x4 = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y3 = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x: x4,
          y: y3
        };
      }
      function getActions() {
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      }
      function getSupportsPassive() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e4) {
        }
        return supportsPassive;
      }
      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      }
      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      }
      function fromPercentage(range2, value, startRange) {
        return value * 100 / (range2[startRange + 1] - range2[startRange]);
      }
      function toPercentage(range2, value) {
        return fromPercentage(range2, range2[0] < 0 ? value + Math.abs(range2[0]) : value - range2[0], 0);
      }
      function isPercentage(range2, value) {
        return value * (range2[1] - range2[0]) / 100 + range2[0];
      }
      function getJ(value, arr) {
        var j2 = 1;
        while (value >= arr[j2]) {
          j2 += 1;
        }
        return j2;
      }
      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }
        var j2 = getJ(value, xVal);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
      }
      function fromStepping(xVal, xPct, value) {
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }
        var j2 = getJ(value, xPct);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      }
      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }
        var j2 = getJ(value, xPct);
        var a4 = xPct[j2 - 1];
        var b4 = xPct[j2];
        if (snap) {
          if (value - a4 > (b4 - a4) / 2) {
            return b4;
          }
          return a4;
        }
        if (!xSteps[j2 - 1]) {
          return value;
        }
        return xPct[j2 - 1] + closest(value - xPct[j2 - 1], xSteps[j2 - 1]);
      }
      var Spectrum = (
        /** @class */
        function() {
          function Spectrum2(entry, snap, singleStep) {
            this.xPct = [];
            this.xVal = [];
            this.xSteps = [];
            this.xNumSteps = [];
            this.xHighestCompleteStep = [];
            this.xSteps = [singleStep || false];
            this.xNumSteps = [false];
            this.snap = snap;
            var index2;
            var ordered = [];
            Object.keys(entry).forEach(function(index3) {
              ordered.push([asArray(entry[index3]), index3]);
            });
            ordered.sort(function(a4, b4) {
              return a4[0][0] - b4[0][0];
            });
            for (index2 = 0; index2 < ordered.length; index2++) {
              this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
            }
            this.xNumSteps = this.xSteps.slice(0);
            for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
              this.handleStepPoint(index2, this.xNumSteps[index2]);
            }
          }
          Spectrum2.prototype.getDistance = function(value) {
            var index2;
            var distances = [];
            for (index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
              var step = this.xNumSteps[index2];
              if (step && value / step % 1 !== 0) {
                throw new Error("noUiSlider: 'limit', 'margin' and 'padding' of " + this.xPct[index2] + "% range must be divisible by step.");
              }
              distances[index2] = fromPercentage(this.xVal, value, index2);
            }
            return distances;
          };
          Spectrum2.prototype.getAbsoluteDistance = function(value, distances, direction) {
            var xPct_index = 0;
            if (value < this.xPct[this.xPct.length - 1]) {
              while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
              }
            } else if (value === this.xPct[this.xPct.length - 1]) {
              xPct_index = this.xPct.length - 2;
            }
            if (!direction && value === this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
            if (distances === null) {
              distances = [];
            }
            var start_factor;
            var rest_factor = 1;
            var rest_rel_distance = distances[xPct_index];
            var range_pct = 0;
            var rel_range_distance = 0;
            var abs_distance_counter = 0;
            var range_counter = 0;
            if (direction) {
              start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            } else {
              start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            while (rest_rel_distance > 0) {
              range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
              if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                rel_range_distance = range_pct * start_factor;
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                start_factor = 1;
              } else {
                rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                rest_factor = 0;
              }
              if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                if (this.xPct.length + range_counter >= 1) {
                  range_counter--;
                }
              } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                if (this.xPct.length - range_counter >= 1) {
                  range_counter++;
                }
              }
              rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
            }
            return value + abs_distance_counter;
          };
          Spectrum2.prototype.toStepping = function(value) {
            value = toStepping(this.xVal, this.xPct, value);
            return value;
          };
          Spectrum2.prototype.fromStepping = function(value) {
            return fromStepping(this.xVal, this.xPct, value);
          };
          Spectrum2.prototype.getStep = function(value) {
            value = getStep(this.xPct, this.xSteps, this.snap, value);
            return value;
          };
          Spectrum2.prototype.getDefaultStep = function(value, isDown, size3) {
            var j2 = getJ(value, this.xPct);
            if (value === 100 || isDown && value === this.xPct[j2 - 1]) {
              j2 = Math.max(j2 - 1, 1);
            }
            return (this.xVal[j2] - this.xVal[j2 - 1]) / size3;
          };
          Spectrum2.prototype.getNearbySteps = function(value) {
            var j2 = getJ(value, this.xPct);
            return {
              stepBefore: {
                startValue: this.xVal[j2 - 2],
                step: this.xNumSteps[j2 - 2],
                highestStep: this.xHighestCompleteStep[j2 - 2]
              },
              thisStep: {
                startValue: this.xVal[j2 - 1],
                step: this.xNumSteps[j2 - 1],
                highestStep: this.xHighestCompleteStep[j2 - 1]
              },
              stepAfter: {
                startValue: this.xVal[j2],
                step: this.xNumSteps[j2],
                highestStep: this.xHighestCompleteStep[j2]
              }
            };
          };
          Spectrum2.prototype.countStepDecimals = function() {
            var stepDecimals = this.xNumSteps.map(countDecimals);
            return Math.max.apply(null, stepDecimals);
          };
          Spectrum2.prototype.hasNoSize = function() {
            return this.xVal[0] === this.xVal[this.xVal.length - 1];
          };
          Spectrum2.prototype.convert = function(value) {
            return this.getStep(this.toStepping(value));
          };
          Spectrum2.prototype.handleEntryPoint = function(index2, value) {
            var percentage;
            if (index2 === "min") {
              percentage = 0;
            } else if (index2 === "max") {
              percentage = 100;
            } else {
              percentage = parseFloat(index2);
            }
            if (!isNumeric(percentage) || !isNumeric(value[0])) {
              throw new Error("noUiSlider: 'range' value isn't numeric.");
            }
            this.xPct.push(percentage);
            this.xVal.push(value[0]);
            var value1 = Number(value[1]);
            if (!percentage) {
              if (!isNaN(value1)) {
                this.xSteps[0] = value1;
              }
            } else {
              this.xSteps.push(isNaN(value1) ? false : value1);
            }
            this.xHighestCompleteStep.push(0);
          };
          Spectrum2.prototype.handleStepPoint = function(i5, n4) {
            if (!n4) {
              return;
            }
            if (this.xVal[i5] === this.xVal[i5 + 1]) {
              this.xSteps[i5] = this.xHighestCompleteStep[i5] = this.xVal[i5];
              return;
            }
            this.xSteps[i5] = fromPercentage([this.xVal[i5], this.xVal[i5 + 1]], n4, 0) / subRangeRatio(this.xPct[i5], this.xPct[i5 + 1]);
            var totalSteps = (this.xVal[i5 + 1] - this.xVal[i5]) / this.xNumSteps[i5];
            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
            var step = this.xVal[i5] + this.xNumSteps[i5] * highestStep;
            this.xHighestCompleteStep[i5] = step;
          };
          return Spectrum2;
        }()
      );
      var defaultFormatter = {
        to: function(value) {
          return value === void 0 ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      };
      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      };
      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        }
        parsed.singleStep = entry;
      }
      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }
        parsed.keyboardPageMultiplier = entry;
      }
      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }
        parsed.keyboardMultiplier = entry;
      }
      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }
        parsed.keyboardDefaultStep = entry;
      }
      function testRange(parsed, entry) {
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        }
        if (entry.min === void 0 || entry.max === void 0) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }
        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }
      function testStart(parsed, entry) {
        entry = asArray(entry);
        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        }
        parsed.handles = entry.length;
        parsed.start = entry;
      }
      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
        parsed.snap = entry;
      }
      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
        parsed.animate = entry;
      }
      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }
        parsed.animationDuration = entry;
      }
      function testConnect(parsed, entry) {
        var connect = [false];
        var i5;
        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        }
        if (entry === true || entry === false) {
          for (i5 = 1; i5 < parsed.handles; i5++) {
            connect.push(entry);
          }
          connect.push(false);
        } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }
        parsed.connect = connect;
      }
      function testOrientation(parsed, entry) {
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;
          case "vertical":
            parsed.ort = 1;
            break;
          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }
      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        }
        if (entry === 0) {
          return;
        }
        parsed.margin = parsed.spectrum.getDistance(entry);
      }
      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }
        parsed.limit = parsed.spectrum.getDistance(entry);
        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }
      function testPadding(parsed, entry) {
        var index2;
        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (entry === 0) {
          return;
        }
        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        }
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
        for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
          if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }
        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }
      function testDirection(parsed, entry) {
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;
          case "rtl":
            parsed.dir = 1;
            break;
          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }
      function testBehaviour(parsed, entry) {
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }
        var tap2 = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          }
          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }
        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }
        parsed.events = {
          tap: tap2 || snap,
          drag,
          dragAll,
          fixed,
          snap,
          hover,
          unconstrained
        };
      }
      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }
        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];
          for (var i5 = 0; i5 < parsed.handles; i5++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);
          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }
          entry.forEach(function(formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }
      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }
        parsed.handleAttributes = entry;
      }
      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }
        parsed.ariaFormat = entry;
      }
      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }
        parsed.format = entry;
      }
      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }
        parsed.keyboardSupport = entry;
      }
      function testDocumentElement(parsed, entry) {
        parsed.documentElement = entry;
      }
      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }
        parsed.cssPrefix = entry;
      }
      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }
        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function(key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      }
      function testOptions(options) {
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        };
        var tests = {
          step: { r: false, t: testStep },
          keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
          keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
          keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
          start: { r: true, t: testStart },
          connect: { r: true, t: testConnect },
          direction: { r: true, t: testDirection },
          snap: { r: false, t: testSnap },
          animate: { r: false, t: testAnimate },
          animationDuration: { r: false, t: testAnimationDuration },
          range: { r: true, t: testRange },
          orientation: { r: false, t: testOrientation },
          margin: { r: false, t: testMargin },
          limit: { r: false, t: testLimit },
          padding: { r: false, t: testPadding },
          behaviour: { r: true, t: testBehaviour },
          ariaFormat: { r: false, t: testAriaFormat },
          format: { r: false, t: testFormat },
          tooltips: { r: false, t: testTooltips },
          keyboardSupport: { r: true, t: testKeyboardSupport },
          documentElement: { r: false, t: testDocumentElement },
          cssPrefix: { r: true, t: testCssPrefix },
          cssClasses: { r: true, t: testCssClasses },
          handleAttributes: { r: false, t: testHandleAttributes }
        };
        var defaults = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        };
        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        }
        Object.keys(tests).forEach(function(name) {
          if (!isSet(options[name]) && defaults[name] === void 0) {
            if (tests[name].r) {
              throw new Error("noUiSlider: '" + name + "' is required.");
            }
            return;
          }
          tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        });
        parsed.pips = options.pips;
        var d6 = document.createElement("div");
        var msPrefix = d6.style.msTransform !== void 0;
        var noPrefix = d6.style.transform !== void 0;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
        var styles = [
          ["left", "top"],
          ["right", "bottom"]
        ];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      }
      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");
          if (className) {
            addClass(div, className);
          }
          addTarget.appendChild(div);
          return div;
        }
        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));
          if (options.keyboardSupport) {
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function(event) {
              return eventKeydown(event, handleNumber);
            });
          }
          if (options.handleAttributes !== void 0) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function(attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }
          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }
          return origin;
        }
        function addConnect(base, add) {
          if (!add) {
            return false;
          }
          return addNodeTo(base, options.cssClasses.connect);
        }
        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0]));
          for (var i5 = 0; i5 < options.handles; i5++) {
            scope_Handles.push(addOrigin(base, i5));
            scope_HandleNumbers[i5] = i5;
            scope_Connects.push(addConnect(connectBase, connectOptions[i5 + 1]));
          }
        }
        function addSlider(addTarget) {
          addClass(addTarget, options.cssClasses.target);
          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }
          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }
          var textDirection = getComputedStyle(addTarget).direction;
          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }
          return addNodeTo(addTarget, options.cssClasses.base);
        }
        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }
          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }
        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        }
        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }
        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function(tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        }
        function tooltips() {
          removeTooltips();
          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values2, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }
            if (scope_Tooltips[handleNumber] === false) {
              return;
            }
            var formattedValue = values2[handleNumber];
            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }
            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }
        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values2, handleNumber, unencoded, tap2, positions) {
            scope_HandleNumbers.forEach(function(index2) {
              var handle = scope_Handles[index2];
              var min3 = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
              var max3 = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
              var now = positions[index2];
              var text = String(options.ariaFormat.to(unencoded[index2]));
              min3 = scope_Spectrum.fromStepping(min3).toFixed(1);
              max3 = scope_Spectrum.fromStepping(max3).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min3);
              handle.children[0].setAttribute("aria-valuemax", max3);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text);
            });
          });
        }
        function getGroup(pips2) {
          if (pips2.mode === exports2.PipsMode.Range || pips2.mode === exports2.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }
          if (pips2.mode === exports2.PipsMode.Count) {
            if (pips2.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            }
            var interval = pips2.values - 1;
            var spread = 100 / interval;
            var values2 = [];
            while (interval--) {
              values2[interval] = interval * spread;
            }
            values2.push(100);
            return mapToRange(values2, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Positions) {
            return mapToRange(pips2.values, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Values) {
            if (pips2.stepped) {
              return pips2.values.map(function(value) {
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            }
            return pips2.values;
          }
          return [];
        }
        function mapToRange(values2, stepped) {
          return values2.map(function(value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }
        function generateSpread(pips2) {
          function safeIncrement(value, increment) {
            return Number((value + increment).toFixed(7));
          }
          var group2 = getGroup(pips2);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0;
          group2 = unique(group2.slice().sort(function(a4, b4) {
            return a4 - b4;
          }));
          if (group2[0] !== firstInRange) {
            group2.unshift(firstInRange);
            ignoreFirst = true;
          }
          if (group2[group2.length - 1] !== lastInRange) {
            group2.push(lastInRange);
            ignoreLast = true;
          }
          group2.forEach(function(current, index2) {
            var step;
            var i5;
            var q2;
            var low = current;
            var high = group2[index2 + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type2;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips2.mode === exports2.PipsMode.Steps;
            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index2];
            }
            if (!step) {
              step = high - low;
            }
            if (high === void 0) {
              high = low;
            }
            step = Math.max(step, 1e-7);
            for (i5 = low; i5 <= high; i5 = safeIncrement(i5, step)) {
              newPct = scope_Spectrum.toStepping(i5);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips2.density || 1);
              realSteps = Math.round(steps);
              stepSize = pctDifference / realSteps;
              for (q2 = 1; q2 <= realSteps; q2 += 1) {
                pctPos = prevPct + q2 * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              }
              type2 = group2.indexOf(i5) > -1 ? exports2.PipsType.LargeValue : isSteps ? exports2.PipsType.SmallValue : exports2.PipsType.NoValue;
              if (!index2 && ignoreFirst && i5 !== high) {
                type2 = 0;
              }
              if (!(i5 === high && ignoreLast)) {
                indexes[newPct.toFixed(5)] = [i5, type2];
              }
              prevPct = newPct;
            }
          });
          return indexes;
        }
        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;
          var element2 = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports2.PipsType.None] = "", _a[exports2.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports2.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports2.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports2.PipsType.None] = "", _b[exports2.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports2.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports2.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element2, options.cssClasses.pips);
          addClass(element2, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
          function getClasses4(type2, source) {
            var a4 = source === options.cssClasses.value;
            var orientationClasses = a4 ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a4 ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type2];
          }
          function addSpread(offset3, value, type2) {
            type2 = filterFunc ? filterFunc(value, type2) : type2;
            if (type2 === exports2.PipsType.None) {
              return;
            }
            var node = addNodeTo(element2, false);
            node.className = getClasses4(type2, options.cssClasses.marker);
            node.style[options.style] = offset3 + "%";
            if (type2 > exports2.PipsType.NoValue) {
              node = addNodeTo(element2, false);
              node.className = getClasses4(type2, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset3 + "%";
              node.innerHTML = String(formatter.to(value));
            }
          }
          Object.keys(spread).forEach(function(offset3) {
            addSpread(offset3, spread[offset3][0], spread[offset3][1]);
          });
          return element2;
        }
        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }
        function pips(pips2) {
          removePips();
          var spread = generateSpread(pips2);
          var filter2 = pips2.filter;
          var format2 = pips2.format || {
            to: function(value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter2, format2));
          return scope_Pips;
        }
        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }
        function attachEvent2(events2, element2, callback, data) {
          var method = function(event) {
            var e4 = fixEvent(event, data.pageOffset, data.target || element2);
            if (!e4) {
              return false;
            }
            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            }
            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            }
            if (events2 === actions.start && e4.buttons !== void 0 && e4.buttons > 1) {
              return false;
            }
            if (data.hover && e4.buttons) {
              return false;
            }
            if (!supportsPassive) {
              e4.preventDefault();
            }
            e4.calcPoint = e4.points[options.ort];
            callback(e4, data);
            return;
          };
          var methods = [];
          events2.split(" ").forEach(function(eventName) {
            element2.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
            methods.push([eventName, method]);
          });
          return methods;
        }
        function fixEvent(e4, pageOffset, eventTarget) {
          var touch = e4.type.indexOf("touch") === 0;
          var mouse = e4.type.indexOf("mouse") === 0;
          var pointer = e4.type.indexOf("pointer") === 0;
          var x4 = 0;
          var y3 = 0;
          if (e4.type.indexOf("MSPointer") === 0) {
            pointer = true;
          }
          if (e4.type === "mousedown" && !e4.buttons && !e4.touches) {
            return false;
          }
          if (touch) {
            var isTouchOnTarget = function(checkTouch) {
              var target2 = checkTouch.target;
              return target2 === eventTarget || eventTarget.contains(target2) || e4.composed && e4.composedPath().shift() === eventTarget;
            };
            if (e4.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e4.touches, isTouchOnTarget);
              if (targetTouches.length > 1) {
                return false;
              }
              x4 = targetTouches[0].pageX;
              y3 = targetTouches[0].pageY;
            } else {
              var targetTouch = Array.prototype.find.call(e4.changedTouches, isTouchOnTarget);
              if (!targetTouch) {
                return false;
              }
              x4 = targetTouch.pageX;
              y3 = targetTouch.pageY;
            }
          }
          pageOffset = pageOffset || getPageOffset(scope_Document);
          if (mouse || pointer) {
            x4 = e4.clientX + pageOffset.x;
            y3 = e4.clientY + pageOffset.y;
          }
          e4.pageOffset = pageOffset;
          e4.points = [x4, y3];
          e4.cursor = mouse || pointer;
          return e4;
        }
        function calcPointToPercentage(calcPoint) {
          var location2 = calcPoint - offset2(scope_Base, options.ort);
          var proposal = location2 * 100 / baseSize();
          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        }
        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function(handle, index2) {
            if (isHandleDisabled(index2)) {
              return;
            }
            var handlePosition = scope_Locations[index2];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index2;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        }
        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        }
        function eventMove(event, data) {
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          }
          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        }
        function eventEnd(event, data) {
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          }
          data.listeners.forEach(function(c6) {
            scope_DocumentElement.removeEventListener(c6[0], c6[1]);
          });
          if (scope_ActiveHandlesCount === 0) {
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex();
            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        }
        function eventStart(event, data) {
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }
          var handle;
          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1;
            addClass(handle, options.cssClasses.active);
          }
          event.stopPropagation();
          var listeners = [];
          var moveEvent = attachEvent2(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle,
            connect: data.connect,
            listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent2(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent2("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
          if (event.cursor) {
            scope_Body.style.cursor = getComputedStyle(event.target).cursor;
            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            }
            scope_Body.addEventListener("selectstart", preventDefault, false);
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("start", handleNumber);
          });
        }
        function eventTap(event) {
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal);
          if (handleNumber === false) {
            return;
          }
          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);
          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, { handleNumbers: [handleNumber] });
          }
        }
        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function(targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(scope_Self, value);
              });
            }
          });
        }
        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }
          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];
          if (options.dir && !options.ort) {
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            verticalKeys.reverse();
            largeStepKeys.reverse();
          }
          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];
          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }
          event.preventDefault();
          var to;
          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction];
            if (step === null) {
              return false;
            }
            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }
            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            }
            step = Math.max(step, 1e-7);
            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            to = options.spectrum.xVal[0];
          }
          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        }
        function bindSliderEvents(behaviour) {
          if (!behaviour.fixed) {
            scope_Handles.forEach(function(handle, index2) {
              attachEvent2(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index2]
              });
            });
          }
          if (behaviour.tap) {
            attachEvent2(actions.start, scope_Base, eventTap, {});
          }
          if (behaviour.hover) {
            attachEvent2(actions.move, scope_Base, eventHover, {
              hover: true
            });
          }
          if (behaviour.drag) {
            scope_Connects.forEach(function(connect, index2) {
              if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
                return;
              }
              var handleBefore = scope_Handles[index2 - 1];
              var handleAfter = scope_Handles[index2];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index2 - 1, index2];
              addClass(connect, options.cssClasses.draggable);
              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }
              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }
              eventHolders.forEach(function(eventHolder) {
                attachEvent2(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect
                });
              });
            });
          }
        }
        function bindEvent(namespacedEvent, callback) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback);
          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function(a4, index2) {
              fireEvent("update", index2);
            });
          }
        }
        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }
        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function(bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);
            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind];
              }
            }
          });
        }
        function fireEvent(eventName, handleNumber, tap2) {
          Object.keys(scope_Events).forEach(function(targetEvent) {
            var eventType = targetEvent.split(".")[0];
            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(
                  // Use the slider public API as the scope ('this')
                  scope_Self,
                  // Return values as array, so arg_1[arg_2] is always valid.
                  scope_Values.map(options.format.to),
                  // Handle index, 0 or 1
                  handleNumber,
                  // Un-formatted slider values
                  scope_Values.slice(),
                  // Event is fired by tap, true or false
                  tap2 || false,
                  // Left offset of the handle, in relation to the slider
                  scope_Locations.slice(),
                  // add the slider public API to an accessible parameter when this is unavailable
                  scope_Self
                );
              });
            }
          });
        }
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
          var distance;
          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          }
          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          }
          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }
            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }
          to = scope_Spectrum.getStep(to);
          to = limit(to);
          if (to === reference[handleNumber] && !getValue) {
            return false;
          }
          return to;
        }
        function inRuleOrder(v2, a4) {
          var o10 = options.ort;
          return (o10 ? a4 : v2) + ", " + (o10 ? v2 : a4);
        }
        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice();
          var firstHandle = handleNumbers[0];
          var b4 = [!upward, upward];
          var f6 = [upward, !upward];
          handleNumbers = handleNumbers.slice();
          if (upward) {
            handleNumbers.reverse();
          }
          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function(handleNumber, o10) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b4[o10], f6[o10], false);
              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } else {
            b4 = f6 = [true];
          }
          var state = false;
          handleNumbers.forEach(function(handleNumber, o10) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b4[o10], f6[o10]) || state;
          });
          if (state) {
            handleNumbers.forEach(function(handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            });
            if (connect != void 0) {
              fireEvent("drag", firstHandle);
            }
          }
        }
        function transformDirection(a4, b4) {
          return options.dir ? 100 - a4 - b4 : a4;
        }
        function updateHandlePosition(handleNumber, to) {
          scope_Locations[handleNumber] = to;
          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        }
        function setZindex() {
          scope_HandleNumbers.forEach(function(handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        }
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
          }
          if (to === false) {
            return false;
          }
          updateHandlePosition(handleNumber, to);
          return true;
        }
        function updateConnect(index2) {
          if (!scope_Connects[index2]) {
            return;
          }
          var l7 = 0;
          var h4 = 100;
          if (index2 !== 0) {
            l7 = scope_Locations[index2 - 1];
          }
          if (index2 !== scope_Connects.length - 1) {
            h4 = scope_Locations[index2];
          }
          var connectWidth = h4 - l7;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l7, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index2].style[options.transformRule] = translateRule + " " + scaleRule;
        }
        function resolveToValue(to, handleNumber) {
          if (to === null || to === false || to === void 0) {
            return scope_Locations[handleNumber];
          }
          if (typeof to === "number") {
            to = String(to);
          }
          to = options.format.from(to);
          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          }
          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }
          return to;
        }
        function valueSet(input, fireSetEvent, exactInput) {
          var values2 = asArray(input);
          var isInit = scope_Locations[0] === void 0;
          fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          scope_HandleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, resolveToValue(values2[handleNumber], handleNumber), true, false, exactInput);
          });
          var i5 = scope_HandleNumbers.length === 1 ? 0 : 1;
          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;
            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function(handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          }
          for (; i5 < scope_HandleNumbers.length; ++i5) {
            scope_HandleNumbers.forEach(function(handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }
          setZindex();
          scope_HandleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
            if (values2[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        }
        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        }
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          handleNumber = Number(handleNumber);
          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          }
          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);
          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        }
        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }
          if (unencoded) {
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }
          var values2 = scope_Values.map(options.format.to);
          if (values2.length === 1) {
            return values2[0];
          }
          return values2;
        }
        function destroy() {
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function(key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });
          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }
          delete scope_Target.noUiSlider;
        }
        function getNextStepsForHandle(handleNumber) {
          var location2 = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location2);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null;
          if (options.snap) {
            return [
              value - nearbySteps.stepBefore.startValue || null,
              nearbySteps.stepAfter.startValue - value || null
            ];
          }
          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          }
          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          }
          if (location2 === 100) {
            increment = null;
          } else if (location2 === 0) {
            decrement = null;
          }
          var stepDecimals = scope_Spectrum.countStepDecimals();
          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }
          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }
          return [decrement, increment];
        }
        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        }
        function updateOptions(optionsToUpdate, fireSetEvent) {
          var v2 = valueGet();
          var updateAble = [
            "margin",
            "limit",
            "padding",
            "range",
            "animate",
            "snap",
            "step",
            "format",
            "pips",
            "tooltips"
          ];
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              originalOptions[name] = optionsToUpdate[name];
            }
          });
          var newOptions = testOptions(originalOptions);
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              options[name] = newOptions[name];
            }
          });
          scope_Spectrum = newOptions.spectrum;
          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding;
          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          }
          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          }
          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v2, fireSetEvent);
        }
        function setupSlider() {
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base);
          bindSliderEvents(options.events);
          valueSet(options.start);
          if (options.pips) {
            pips(options.pips);
          }
          if (options.tooltips) {
            tooltips();
          }
          aria();
        }
        setupSlider();
        var scope_Self = {
          destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          // Exposed for unit testing, don't use this in your application.
          __moveHandles: function(upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions,
          target: scope_Target,
          removePips,
          removeTooltips,
          getPositions: function() {
            return scope_Locations.slice();
          },
          getTooltips: function() {
            return scope_Tooltips;
          },
          getOrigins: function() {
            return scope_Handles;
          },
          pips
          // Issue #594
        };
        return scope_Self;
      }
      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        }
        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        }
        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }
      var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses,
        create: initialize
      };
      exports2.create = initialize;
      exports2.cssClasses = cssClasses;
      exports2["default"] = nouislider;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_int.js
var import_nouislider, IntModel, BoundedIntModel, SliderStyleModel, IntSliderModel, IntRangeSliderModel, BaseIntSliderView, IntRangeSliderView, IntSliderView, IntTextModel, BoundedIntTextModel, IntTextView, ProgressStyleModel, IntProgressModel, ProgressView, PlayModel, PlayView;
var init_widget_int = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_int.js"() {
    init_widget_core();
    init_widget_description();
    init_lib10();
    init_utils3();
    init_src();
    import_nouislider = __toESM(require_nouislider());
    IntModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntModel", value: 0 });
      }
    };
    BoundedIntModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntModel", max: 100, min: 0 });
      }
    };
    SliderStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SliderStyleModel" });
      }
    };
    SliderStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { handle_color: {
      selector: ".noUi-handle",
      attribute: "background-color",
      default: null
    } });
    IntSliderModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntSliderModel", _view_name: "IntSliderView", step: 1, orientation: "horizontal", readout: true, readout_format: "d", continuous_update: true, style: null, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    IntRangeSliderModel = class extends IntSliderModel {
    };
    BaseIntSliderView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-slider");
        this.el.classList.add("widget-hslider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.contentEditable = "true";
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:max", this.updateSliderOptions, this);
        this.model.on("change:min", this.updateSliderOptions, this);
        this.model.on("change:step", this.updateSliderOptions, this);
        this.model.on("change:value", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.model.get("disabled")) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          const orientation = this.model.get("orientation");
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.add("widget-vslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.add("widget-hslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
            this.displayed.then(() => {
              if (this.readout_overflow()) {
                this.readout.classList.add("overflow");
              } else {
                this.readout.classList.remove("overflow");
              }
            });
          } else {
            this.readout.style.display = "none";
          }
        }
        return super.update();
      }
      /**
       * Returns true if the readout box content overflows.
       */
      readout_overflow() {
        return this.readout.scrollWidth > this.readout.clientWidth;
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          "blur [contentEditable=true]": "handleTextChange",
          "keydown [contentEditable=true]": "handleKeyDown"
        };
      }
      handleKeyDown(e4) {
        if (e4.keyCode === 13) {
          e4.preventDefault();
          this.handleTextChange();
        }
      }
      /**
       * Create a new noUiSlider object
       */
      createSlider() {
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider.default.create(this.$slider, {
          start: this.model.get("value"),
          connect: true,
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step"),
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => this._validate_slide_value(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Recreate/Regenerate a slider object
       * noUiSlider does not support in-place mutation of the orientation
       * state. We therefore need to destroy the current instance
       * and create a new one with the new properties. This is
       * handled in a separate function and has a dedicated event
       * handler.
       */
      regenSlider(e4) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return Math.round(x4);
      }
    };
    IntRangeSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._range_regex = /^\s*([+-]?\d+)\s*[-:]\s*([+-]?\d+)/;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return value.map(function(v2) {
          return format2(v2);
        }).join(" \u2013 ");
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        if (text === null) {
          return null;
        }
        const match = this._range_regex.exec(text);
        if (match) {
          return [this._parse_value(match[1]), this._parse_value(match[2])];
        } else {
          return null;
        }
      }
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (value === null || isNaN(value[0]) || isNaN(value[1]) || value[0] > value[1]) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = [
            Math.max(Math.min(value[0], vmax), vmin),
            Math.max(Math.min(value[1], vmax), vmin)
          ];
          if (value[0] !== this.model.get("value")[0] || value[1] !== this.model.get("value")[1]) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value[0] !== value[0] || prev_value[1] !== value[1]) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntSliderView = class extends BaseIntSliderView {
      update(options) {
        super.update(options);
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        let value = this.model.get("value");
        if (value > max3) {
          value = max3;
        } else if (value < min3) {
          value = min3;
        }
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      stringToValue(text) {
        return this._parse_value(text);
      }
      handleTextChange() {
        var _a;
        let value = this.stringToValue((_a = this.readout.textContent) !== null && _a !== void 0 ? _a : "");
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, vmax), vmin);
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = this._validate_slide_value(values2[handle]);
        const model_value = this.model.get("value");
        if (parseFloat(model_value) !== actual_value) {
          this.model.set("value", actual_value, { updated_view: this });
          this.touch();
        }
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value !== value) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntTextModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedIntTextModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false, step: 1 });
      }
    };
    IntTextView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
        this._default_step = "1";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.type = "number";
        this.textbox.required = true;
        this.textbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.textbox);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._parse_value(this.textbox.value) !== value) {
            this.textbox.value = value.toString();
          }
          if (this.model.get("min") !== void 0) {
            this.textbox.min = this.model.get("min");
          }
          if (this.model.get("max") !== void 0) {
            this.textbox.max = this.model.get("max");
          }
          if (this.model.get("step") !== void 0 && this.model.get("step") !== null) {
            this.textbox.step = this.model.get("step");
          } else {
            this.textbox.step = this._default_step;
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "keyup input": "handleKeyUp",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles key press
       */
      handleKeypress(e4) {
        if (/[e,. ]/.test(String.fromCharCode(e4.keyCode))) {
          e4.preventDefault();
        }
      }
      /**
       * Handle key up
       */
      handleKeyUp(e4) {
        if (e4.altKey || e4.ctrlKey) {
          return;
        }
        const target = e4.target;
        let value = target.value;
        value = value.replace(/[e,.\s]/g, "");
        if (value.length >= 1) {
          const subvalue = value.substr(1);
          value = value[0] + subvalue.replace(/[+-]/g, "");
        }
        if (target.value !== value) {
          e4.preventDefault();
          target.value = value;
        }
      }
      /**
       * Call the submit handler if continuous update is true and we are not
       * obviously incomplete.
       */
      handleChanging(e4) {
        const target = e4.target;
        const trimmed = target.value.trim();
        if (trimmed === "" || ["-", "-.", ".", "+.", "+"].indexOf(trimmed) >= 0) {
          return;
        }
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Applies validated input.
       */
      handleChanged(e4) {
        const target = e4.target;
        let numericalValue = this._parse_value(target.value);
        if (isNaN(numericalValue)) {
          target.value = this.model.get("value");
        } else {
          let boundedValue = numericalValue;
          if (this.model.get("max") !== void 0) {
            boundedValue = Math.min(this.model.get("max"), boundedValue);
          }
          if (this.model.get("min") !== void 0) {
            boundedValue = Math.max(this.model.get("min"), boundedValue);
          }
          if (boundedValue !== numericalValue) {
            target.value = boundedValue;
            numericalValue = boundedValue;
          }
          if (numericalValue !== this.model.get("value")) {
            this.model.set("value", numericalValue, { updated_view: this });
            this.touch();
          }
        }
      }
    };
    ProgressStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ProgressStyleModel" });
      }
    };
    ProgressStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { bar_color: {
      selector: ".progress-bar",
      attribute: "background-color",
      default: null
    } });
    IntProgressModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
    ProgressView = class extends DescriptionView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:bar_style", this.update_bar_style);
        this.luminoWidget.addClass("jupyter-widgets");
      }
      render() {
        super.render();
        const orientation = this.model.get("orientation");
        const className = orientation === "horizontal" ? "widget-hprogress" : "widget-vprogress";
        this.el.classList.add(className);
        this.progress = document.createElement("div");
        this.progress.classList.add("progress");
        this.progress.style.position = "relative";
        this.el.appendChild(this.progress);
        this.bar = document.createElement("div");
        this.bar.classList.add("progress-bar");
        this.bar.style.position = "absolute";
        this.bar.style.bottom = "0px";
        this.bar.style.left = "0px";
        this.progress.appendChild(this.bar);
        this.update();
        this.set_bar_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        const value = this.model.get("value");
        const max3 = this.model.get("max");
        const min3 = this.model.get("min");
        const orientation = this.model.get("orientation");
        const percent = 100 * (value - min3) / (max3 - min3);
        if (orientation === "horizontal") {
          this.el.classList.remove("widget-inline-vbox");
          this.el.classList.remove("widget-vprogress");
          this.el.classList.add("widget-inline-hbox");
          this.el.classList.add("widget-hprogress");
          this.bar.style.width = percent + "%";
          this.bar.style.height = "100%";
        } else {
          this.el.classList.remove("widget-inline-hbox");
          this.el.classList.remove("widget-hprogress");
          this.el.classList.add("widget-inline-vbox");
          this.el.classList.add("widget-vprogress");
          this.bar.style.width = "100%";
          this.bar.style.height = percent + "%";
        }
        return super.update();
      }
      update_bar_style() {
        this.update_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
      set_bar_style() {
        this.set_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
    };
    ProgressView.class_map = {
      success: ["progress-bar-success"],
      info: ["progress-bar-info"],
      warning: ["progress-bar-warning"],
      danger: ["progress-bar-danger"]
    };
    PlayModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "PlayModel", _view_name: "PlayView", repeat: false, playing: false, show_repeat: true, interval: 100, step: 1, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
      }
      loop() {
        if (!this.get("playing")) {
          return;
        }
        const next_value = this.get("value") + this.get("step");
        if (next_value <= this.get("max")) {
          this.set("value", next_value);
          this.schedule_next();
        } else {
          if (this.get("repeat")) {
            this.set("value", this.get("min"));
            this.schedule_next();
          } else {
            this.pause();
          }
        }
        this.save_changes();
      }
      schedule_next() {
        this._timerId = window.setTimeout(this.loop.bind(this), this.get("interval"));
      }
      stop() {
        this.pause();
        this.set("value", this.get("min"));
        this.save_changes();
      }
      pause() {
        window.clearTimeout(this._timerId);
        this._timerId = void 0;
        this.set("playing", false);
        this.save_changes();
      }
      animate() {
        if (this._timerId !== void 0) {
          return;
        }
        if (this.get("value") === this.get("max")) {
          this.set("value", this.get("min"));
          this.schedule_next();
          this.save_changes();
        } else {
          this.loop();
        }
        this.save_changes();
      }
      play() {
        this.set("playing", !this.get("playing"));
        this.save_changes();
      }
      repeat() {
        this.set("repeat", !this.get("repeat"));
        this.save_changes();
      }
    };
    PlayView = class extends DOMWidgetView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-play");
        this.playPauseButton = document.createElement("button");
        this.stopButton = document.createElement("button");
        this.repeatButton = document.createElement("button");
        this.playPauseButton.className = "jupyter-button";
        this.stopButton.className = "jupyter-button";
        this.repeatButton.className = "jupyter-button";
        this.el.appendChild(this.playPauseButton);
        this.el.appendChild(this.stopButton);
        this.el.appendChild(this.repeatButton);
        const playIcon = document.createElement("i");
        playIcon.className = "fa fa-play";
        this.playPauseButton.appendChild(playIcon);
        const stopIcon2 = document.createElement("i");
        stopIcon2.className = "fa fa-stop";
        this.stopButton.appendChild(stopIcon2);
        const repeatIcon = document.createElement("i");
        repeatIcon.className = "fa fa-retweet";
        this.repeatButton.appendChild(repeatIcon);
        this.playPauseButton.onclick = this.model.play.bind(this.model);
        this.stopButton.onclick = this.model.stop.bind(this.model);
        this.repeatButton.onclick = this.model.repeat.bind(this.model);
        this.listenTo(this.model, "change:playing", this.onPlayingChanged);
        this.listenTo(this.model, "change:repeat", this.updateRepeat);
        this.listenTo(this.model, "change:show_repeat", this.updateRepeat);
        this.updatePlaying();
        this.updateRepeat();
        this.update();
      }
      update() {
        const disabled = this.model.get("disabled");
        this.playPauseButton.disabled = disabled;
        this.stopButton.disabled = disabled;
        this.repeatButton.disabled = disabled;
        this.updatePlaying();
      }
      onPlayingChanged() {
        this.updatePlaying();
        const previous = this.model.previous("playing");
        const current = this.model.get("playing");
        if (!previous && current) {
          this.model.animate();
        } else {
          this.model.pause();
        }
      }
      updatePlaying() {
        const playing = this.model.get("playing");
        const icon = this.playPauseButton.getElementsByTagName("i")[0];
        if (playing) {
          icon.className = "fa fa-pause";
        } else {
          icon.className = "fa fa-play";
        }
      }
      updateRepeat() {
        const repeat2 = this.model.get("repeat");
        this.repeatButton.style.display = this.model.get("show_repeat") ? this.playPauseButton.style.display : "none";
        if (repeat2) {
          this.repeatButton.classList.add("mod-active");
        } else {
          this.repeatButton.classList.remove("mod-active");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_float.js
var import_nouislider2, FloatModel, BoundedFloatModel, FloatSliderModel, FloatLogSliderModel, FloatRangeSliderModel, FloatSliderView, FloatLogSliderView, FloatRangeSliderView, FloatTextModel, BoundedFloatTextModel, FloatTextView, FloatProgressModel;
var init_widget_float = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_float.js"() {
    init_widget_core();
    init_widget_int();
    init_src();
    import_nouislider2 = __toESM(require_nouislider());
    FloatModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatModel", value: 0 });
      }
    };
    BoundedFloatModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatModel", max: 100, min: 0 });
      }
    };
    FloatSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatSliderModel", _view_name: "FloatSliderView", step: 1, orientation: "horizontal", _range: false, readout: true, readout_format: ".2f", slider_color: null, continuous_update: true, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatLogSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatLogSliderModel", _view_name: "FloatLogSliderView", step: 0.1, orientation: "horizontal", _range: false, readout: true, readout_format: ".3g", slider_color: null, continuous_update: true, disabled: false, base: 10, value: 1, min: 0, max: 4 });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatRangeSliderModel = class extends FloatSliderModel {
    };
    FloatSliderView = class extends IntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatLogSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
      }
      /**
       * Convert from value to exponent
       *
       * @param value the widget value
       * @returns the log-value between the min/max exponents
       */
      logCalc(value) {
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        const base = this.model.get("base");
        let log_value = Math.log(value) / Math.log(base);
        if (log_value > max3) {
          log_value = max3;
        } else if (log_value < min3) {
          log_value = min3;
        }
        return log_value;
      }
      createSlider() {
        var _a;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider2.default.create(this.$slider, {
          start: this.logCalc(this.model.get("value")),
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: (_a = this.model.get("step")) !== null && _a !== void 0 ? _a : void 0,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => value
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        return text === null ? NaN : this._parse_value(text);
      }
      /**
       * this handles the entry of text into the contentEditable label first, the
       * value is checked if it contains a parseable value then it is clamped
       * within the min-max range of the slider finally, the model is updated if
       * the value is to be changed
       *
       * if any of these conditions are not met, the text is reset
       */
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        const base = this.model.get("base");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, Math.pow(base, vmax)), Math.pow(base, vmin));
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        if (this._updating_slider) {
          return;
        }
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, value, options) {
        if (options.updated_view === this) {
          return;
        }
        const log_value = this.logCalc(this.model.get("value"));
        this.$slider.noUiSlider.set(log_value);
      }
      updateSliderOptions(e4) {
        this.$slider.noUiSlider.updateOptions({
          start: this.logCalc(this.model.get("value")),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatRangeSliderView = class extends IntRangeSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._range_regex = /^\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][-:]?\d+)?)\s*[-:]\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][+-]?\d+)?)/;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x4) {
        return x4;
      }
    };
    FloatTextModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedFloatTextModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false, step: 0.1 });
      }
    };
    FloatTextView = class extends IntTextView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._default_step = "any";
      }
      /**
       * Handle key press
       */
      handleKeypress(e4) {
        e4.stopPropagation();
      }
      /**
       * Handle key up
       */
      handleKeyUp(e4) {
      }
    };
    FloatProgressModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js
var import_jquery4, ControllerButtonModel, ControllerButtonView, ControllerAxisModel, ControllerAxisView, ControllerModel, ControllerView;
var init_widget_controller = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js"() {
    init_widget_core();
    init_lib10();
    init_index_es63();
    init_index_es64();
    init_utils3();
    import_jquery4 = __toESM(require_jquery());
    ControllerButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerButtonModel", _view_name: "ControllerButtonView", value: 0, pressed: false });
      }
    };
    ControllerButtonView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-button");
        this.el.style.width = "fit-content";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "16px";
        this.support.style.height = "16px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.el.appendChild(this.support);
        this.bar = document.createElement("div");
        this.bar.style.position = "absolute";
        this.bar.style.width = "100%";
        this.bar.style.bottom = "0px";
        this.bar.style.background = "gray";
        this.support.appendChild(this.bar);
        this.update();
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.el.appendChild(this.label);
      }
      update() {
        this.bar.style.height = 100 * this.model.get("value") + "%";
      }
    };
    ControllerAxisModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerAxisModel", _view_name: "ControllerAxisView", value: 0 });
      }
    };
    ControllerAxisView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-axis");
        this.el.style.width = "16px";
        this.el.style.padding = "4px";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "4px";
        this.support.style.height = "64px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.bullet = document.createElement("div");
        this.bullet.style.position = "absolute";
        this.bullet.style.margin = "-3px";
        this.bullet.style.boxSizing = "unset";
        this.bullet.style.width = "10px";
        this.bullet.style.height = "10px";
        this.bullet.style.background = "gray";
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.support.appendChild(this.bullet);
        this.el.appendChild(this.support);
        this.el.appendChild(this.label);
        this.update();
      }
      update() {
        this.bullet.style.top = 50 * (this.model.get("value") + 1) + "%";
      }
    };
    ControllerModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerModel", _view_name: "ControllerView", index: 0, name: "", mapping: "", connected: false, timestamp: 0, buttons: [], axes: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        if (navigator.getGamepads === void 0) {
          this.readout = "This browser does not support gamepads.";
          console.error(this.readout);
        } else {
          this.readout = "Connect gamepad and press any button.";
          if (this.get("connected")) {
            this.update_loop();
          } else {
            this.wait_loop();
          }
        }
      }
      /**
       * Waits for a gamepad to be connected at the provided index.
       * Once one is connected, it will start the update loop, which
       * populates the update of axes and button values.
       */
      wait_loop() {
        const index2 = this.get("index");
        const pad = navigator.getGamepads()[index2];
        if (pad) {
          this.setup(pad).then((controls) => {
            this.set(controls);
            this.save_changes();
            window.requestAnimationFrame(this.update_loop.bind(this));
          });
        } else {
          window.requestAnimationFrame(this.wait_loop.bind(this));
        }
      }
      /**
       * Given a native gamepad object, returns a promise for a dictionary of
       * controls, of the form
       * {
       *     buttons: list of Button models,
       *     axes: list of Axis models,
       * }
       */
      setup(pad) {
        this.set({
          name: pad.id,
          mapping: pad.mapping,
          connected: pad.connected,
          timestamp: pad.timestamp
        });
        return resolvePromisesDict({
          buttons: Promise.all(pad.buttons.map((btn, index2) => {
            return this._create_button_model(index2);
          })),
          axes: Promise.all(pad.axes.map((axis, index2) => {
            return this._create_axis_model(index2);
          }))
        });
      }
      /**
       * Update axes and buttons values, until the gamepad is disconnected.
       * When the gamepad is disconnected, this.reset_gamepad is called.
       */
      update_loop() {
        const index2 = this.get("index");
        const id = this.get("name");
        const pad = navigator.getGamepads()[index2];
        if (pad && index2 === pad.index && id === pad.id) {
          this.set({
            timestamp: pad.timestamp,
            connected: pad.connected
          });
          this.save_changes();
          this.get("buttons").forEach(function(model, index3) {
            model.set({
              value: pad.buttons[index3].value,
              pressed: pad.buttons[index3].pressed
            });
            model.save_changes();
          });
          this.get("axes").forEach(function(model, index3) {
            model.set("value", pad.axes[index3]);
            model.save_changes();
          });
          window.requestAnimationFrame(this.update_loop.bind(this));
        } else {
          this.reset_gamepad();
        }
      }
      /**
       * Resets the gamepad attributes, and start the wait_loop.
       */
      reset_gamepad() {
        this.get("buttons").forEach(function(button) {
          button.close();
        });
        this.get("axes").forEach(function(axis) {
          axis.close();
        });
        this.set({
          name: "",
          mapping: "",
          connected: false,
          timestamp: 0,
          buttons: [],
          axes: []
        });
        this.save_changes();
        window.requestAnimationFrame(this.wait_loop.bind(this));
      }
      /**
       * Creates a gamepad button widget.
       */
      _create_button_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerButtonModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerButtonView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
      /**
       * Creates a gamepad axis widget.
       */
      _create_axis_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerAxisModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerAxisView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
    };
    ControllerModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { buttons: { deserialize: unpack_models }, axes: { deserialize: unpack_models } });
    ControllerView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery4.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.button_views = new ViewList(this.add_button, null, this);
        this.listenTo(this.model, "change:buttons", (model, value) => {
          this.button_views.update(value);
        });
        this.axis_views = new ViewList(this.add_axis, null, this);
        this.listenTo(this.model, "change:axes", (model, value) => {
          this.axis_views.update(value);
        });
        this.listenTo(this.model, "change:name", this.update_label);
      }
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller");
        this.label = document.createElement("div");
        this.el.appendChild(this.label);
        this.axis_box = new Panel();
        this.axis_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.axis_box);
        this.button_box = new Panel();
        this.button_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.button_box);
        this.button_views.update(this.model.get("buttons"));
        this.axis_views.update(this.model.get("axes"));
        this.update_label();
      }
      update_label() {
        this.label.textContent = this.model.get("name") || this.model.readout;
      }
      add_button(model) {
        const dummy = new Widget();
        this.button_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.button_box.widgets, dummy);
          this.button_box.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child button view to controller", true));
      }
      add_axis(model) {
        const dummy = new Widget();
        this.axis_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i5 = ArrayExt.firstIndexOf(this.axis_box.widgets, dummy);
          this.axis_box.insertWidget(i5, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child axis view to controller", true));
      }
      remove() {
        super.remove();
        this.button_views.remove();
        this.axis_views.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js
var import_nouislider3, SelectionModel, SelectionView, DropdownModel, DropdownView, SelectModel, SelectView, RadioButtonsModel, RadioButtonsView, ToggleButtonsStyleModel, ToggleButtonsModel, ToggleButtonsView, SelectionSliderModel, SelectionSliderView, MultipleSelectionModel, SelectMultipleModel, SelectMultipleView, SelectionRangeSliderModel, SelectionRangeSliderView;
var init_widget_selection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    import_nouislider3 = __toESM(require_nouislider());
    init_utils3();
    SelectionModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionModel", index: "", _options_labels: [], disabled: false });
      }
    };
    SelectionView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        super.update();
        if (this.listbox) {
          this.listbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
      }
      updateTabindex() {
        if (!this.listbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.listbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.listbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.listbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.listbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.listbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.listbox.setAttribute("title", title);
        }
      }
    };
    DropdownModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DropdownModel", _view_name: "DropdownView", button_style: "" });
      }
    };
    DropdownView = class extends SelectionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-dropdown");
        this.listbox = document.createElement("select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChanged = this.model.hasChanged("_options_labels");
          if (optsChanged) {
            this._updateOptions();
          }
        }
        const index2 = this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
        return super.update();
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i5 = 0; i5 < items.length; i5++) {
          const item = items[i5];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex === -1 ? null : this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.listbox.focus();
        } else if (content.do === "blur") {
          this.listbox.blur();
        }
      }
    };
    SelectModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectModel", _view_name: "SelectView", rows: 5 });
      }
    };
    SelectView = class extends SelectionView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox = document.createElement("select");
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
        this.updateSelection();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChange = this.model.hasChanged("_options_labels");
          const idxChange = this.model.hasChanged("index");
          if (optsChange || idxChange) {
            const idx = this.model.get("index");
            if (optsChange) {
              this._updateOptions();
            }
            this.updateSelection(idx);
          }
        }
        super.update();
        let rows = this.model.get("rows");
        if (rows === null) {
          rows = "";
        }
        this.listbox.setAttribute("size", rows);
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i5 = 0; i5 < items.length; i5++) {
          const item = items[i5];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.listbox.focus();
        } else if (content.do == "blur") {
          this.listbox.blur();
        }
      }
    };
    RadioButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "RadioButtonsModel", _view_name: "RadioButtonsView", tooltips: [], icons: [], button_style: "" });
      }
    };
    RadioButtonsView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-radio");
        this.container = document.createElement("div");
        this.el.appendChild(this.container);
        this.container.classList.add("widget-radio-box");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        const items = this.model.get("_options_labels");
        const radios = Array.from(this.container.querySelectorAll('input[type="radio"]')).map((x4) => x4.value);
        let stale = items.length !== radios.length;
        if (!stale) {
          for (let i5 = 0, len = items.length; i5 < len; ++i5) {
            if (radios[i5] !== items[i5]) {
              stale = true;
              break;
            }
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.container.textContent = "";
          items.forEach((item, index2) => {
            const label = document.createElement("label");
            label.textContent = item;
            this.container.appendChild(label);
            const radio = document.createElement("input");
            radio.setAttribute("type", "radio");
            radio.value = index2.toString();
            radio.setAttribute("data-value", encodeURIComponent(item));
            label.appendChild(radio);
          });
        }
        items.forEach((item, index2) => {
          const item_query = 'input[data-value="' + encodeURIComponent(item) + '"]';
          const radio = this.container.querySelectorAll(item_query);
          if (radio.length > 0) {
            const radio_el = radio[0];
            radio_el.checked = this.model.get("index") === index2;
            radio_el.disabled = this.model.get("disabled");
          }
        });
        setTimeout(this.adjustPadding, 0, this);
        return super.update(options);
      }
      /**
       * Adjust Padding to Multiple of Line Height
       *
       * Adjust margins so that the overall height
       * is a multiple of a single line height.
       *
       * This widget needs it because radio options
       * are spaced tighter than individual widgets
       * yet we would like the full widget line up properly
       * when displayed side-by-side with other widgets.
       */
      adjustPadding(e4) {
        const elStyles = window.getComputedStyle(e4.el);
        const margins = parseInt(elStyles.marginTop, 10) + parseInt(elStyles.marginBottom, 10);
        const lineHeight = e4.label.offsetHeight + margins;
        const cStyles = window.getComputedStyle(e4.container);
        const containerMargin = parseInt(cStyles.marginBottom, 10);
        const diff = (e4.el.offsetHeight + margins - containerMargin) % lineHeight;
        const extraMargin = diff === 0 ? 0 : lineHeight - diff;
        e4.container.style.marginBottom = extraMargin + "px";
      }
      events() {
        return {
          'click input[type="radio"]': "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          const firstItem = this.container.firstElementChild;
          firstItem.focus();
        } else if (content.do == "blur") {
          for (let i5 = 0; i5 < this.container.children.length; i5++) {
            const item = this.container.children[i5];
            item.blur();
          }
        }
      }
    };
    ToggleButtonsStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsStyleModel" });
      }
    };
    ToggleButtonsStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { button_width: {
      selector: ".widget-toggle-button",
      attribute: "width",
      default: null
    }, font_weight: {
      selector: ".widget-toggle-button",
      attribute: "font-weight",
      default: ""
    } });
    ToggleButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsModel", _view_name: "ToggleButtonsView" });
      }
    };
    ToggleButtonsView = class extends DescriptionView {
      initialize(options) {
        this._css_state = {};
        super.initialize(options);
        this.listenTo(this.model, "change:button_style", this.update_button_style);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-toggle-buttons");
        this.buttongroup = document.createElement("div");
        this.el.appendChild(this.buttongroup);
        this.update();
        this.set_button_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        const items = this.model.get("_options_labels");
        const icons = this.model.get("icons") || [];
        const previous_icons = this.model.previous("icons") || [];
        const previous_bstyle = ToggleButtonsView.classMap[this.model.previous("button_style")] || "";
        const tooltips = this.model.get("tooltips") || [];
        const disabled = this.model.get("disabled");
        const buttons = this.buttongroup.querySelectorAll("button");
        const values2 = Array.from(buttons).map((x4) => x4.value);
        let stale = false;
        for (let i5 = 0, len = items.length; i5 < len; ++i5) {
          if (values2[i5] !== items[i5] || icons[i5] !== previous_icons[i5]) {
            stale = true;
            break;
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.buttongroup.textContent = "";
          items.forEach((item, index2) => {
            let item_html;
            const empty = item.trim().length === 0 && (!icons[index2] || icons[index2].trim().length === 0);
            if (empty) {
              item_html = "&nbsp;";
            } else {
              item_html = escape_html(item);
            }
            const icon = document.createElement("i");
            const button = document.createElement("button");
            if (icons[index2]) {
              icon.className = "fa fa-" + icons[index2];
            }
            button.setAttribute("type", "button");
            button.className = "widget-toggle-button jupyter-button";
            if (previous_bstyle) {
              button.classList.add(previous_bstyle);
            }
            button.innerHTML = item_html;
            button.setAttribute("data-value", encodeURIComponent(item));
            button.setAttribute("value", index2.toString());
            button.appendChild(icon);
            button.disabled = disabled;
            if (tooltips[index2]) {
              button.setAttribute("title", tooltips[index2]);
            }
            this.update_style_traits(button);
            this.buttongroup.appendChild(button);
          });
        }
        items.forEach((item, index2) => {
          const item_query = '[data-value="' + encodeURIComponent(item) + '"]';
          const button = this.buttongroup.querySelector(item_query);
          if (this.model.get("index") === index2) {
            button.classList.add("mod-active");
          } else {
            button.classList.remove("mod-active");
          }
        });
        this.stylePromise.then(function(style) {
          if (style) {
            style.style();
          }
        });
        return super.update(options);
      }
      update_style_traits(button) {
        for (const name in this._css_state) {
          if (Object.prototype.hasOwnProperty.call(this._css_state, "name")) {
            if (name === "margin") {
              this.buttongroup.style[name] = this._css_state[name];
            } else if (name !== "width") {
              if (button) {
                button.style[name] = this._css_state[name];
              } else {
                const buttons = this.buttongroup.querySelectorAll("button");
                if (buttons.length) {
                  buttons[0].style[name] = this._css_state[name];
                }
              }
            }
          }
        }
      }
      update_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i5 = 0; i5 < buttons.length; i5++) {
          this.update_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i5]);
        }
      }
      set_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i5 = 0; i5 < buttons.length; i5++) {
          this.set_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i5]);
        }
      }
      events() {
        return {
          "click button": "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
        this.send({ event: "click" });
      }
    };
    (function(ToggleButtonsView2) {
      ToggleButtonsView2.classMap = {
        primary: ["mod-primary"],
        success: ["mod-success"],
        info: ["mod-info"],
        warning: ["mod-warning"],
        danger: ["mod-danger"]
      };
    })(ToggleButtonsView || (ToggleButtonsView = {}));
    SelectionSliderModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionSliderView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-hslider");
        this.el.classList.add("widget-slider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:index", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          this.updateSliderOptions(this.model);
          const orientation = this.model.get("orientation");
          const disabled = this.model.get("disabled");
          if (disabled) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-vslider");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-hslider");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
          } else {
            this.readout.style.display = "none";
          }
          this.updateSelection();
        }
        return super.update(options);
      }
      regenSlider(e4) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      createSlider() {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max3 = labels.length - 1;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider3.default.create(this.$slider, {
          start: this.model.get("index"),
          connect: true,
          behaviour: behavior,
          range: {
            min: min3,
            max: max3
          },
          step: 1,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => Math.round(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      events() {
        return {
          slide: "handleSliderChange",
          slidestop: "handleSliderChanged"
        };
      }
      updateSelection() {
        const index2 = this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const value = this.model.get("_options_labels")[index2];
        this.readout.textContent = value;
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e4) {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max3 = labels.length - 1;
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("index"),
          range: {
            min: min3,
            max: max3
          },
          step: 1
        });
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get();
        const index2 = this.model.get("index");
        if (prev_index !== index2) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
    MultipleSelectionModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "MultipleSelectionModel" });
      }
    };
    SelectMultipleModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectMultipleModel", _view_name: "SelectMultipleView", rows: null });
      }
    };
    SelectMultipleView = class extends SelectView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox.multiple = true;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select-multiple");
      }
      updateSelection() {
        const selected = this.model.get("index") || [];
        const listboxOptions = this.listbox.options;
        this.listbox.selectedIndex = -1;
        selected.forEach((i5) => {
          listboxOptions[i5].selected = true;
        });
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        const index2 = Array.prototype.map.call(this.listbox.selectedOptions || [], function(option) {
          return option.index;
        });
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
    };
    SelectionRangeSliderModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionRangeSliderView = class extends SelectionSliderView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const labels = this.model.get("_options_labels");
        const minValue = labels[index2[0]];
        const maxValue = labels[index2[1]];
        this.readout.textContent = `${minValue}-${maxValue}`;
      }
      /**
       * Called when the slider value is changing.
       */
      handleSliderUpdateEvent(values2, handle) {
        const intValues = values2.map(Math.trunc);
        this.updateReadout(intValues);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const intValues = values2.map(Math.round);
        this.updateReadout(intValues);
        this.model.set("index", intValues.slice(), { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, _5, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get().map(Math.round);
        const index2 = this.model.get("index").map(Math.round);
        if (prev_index[0] !== index2[0] || prev_index[1] !== index2[1]) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js
var EventedPanel, TabPanel;
var init_tabpanel = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js"() {
    init_index_es65();
    init_index_es6();
    init_index_es66();
    init_index_es63();
    EventedPanel = class extends Panel {
      constructor() {
        super(...arguments);
        this._widgetRemoved = new Signal(this);
      }
      /**
       * A signal emitted when a widget is removed from the panel.
       */
      get widgetRemoved() {
        return this._widgetRemoved;
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        this._widgetRemoved.emit(msg.child);
      }
    };
    TabPanel = class extends Widget {
      /**
       * Construct a new tab panel.
       *
       * @param options - The options for initializing the tab panel.
       */
      constructor(options = {}) {
        super();
        this._currentChanged = new Signal(this);
        this.addClass("jupyter-widget-TabPanel");
        this.tabBar = new TabBar(options);
        this.tabBar.addClass("jupyter-widget-TabPanel-tabBar");
        this.tabContents = new EventedPanel();
        this.tabContents.addClass("jupyter-widget-TabPanel-tabContents");
        this.tabBar.tabMoved.connect(this._onTabMoved, this);
        this.tabBar.currentChanged.connect(this._onCurrentChanged, this);
        this.tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        this.tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        this.tabContents.widgetRemoved.connect(this._onWidgetRemoved, this);
        const layout = new PanelLayout();
        layout.addWidget(this.tabBar);
        layout.addWidget(this.tabContents);
        this.layout = layout;
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentIndex() {
        const currentIndex = this.tabBar.currentIndex;
        return currentIndex === -1 ? null : currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the index is out of range, it will be set to `null`.
       */
      set currentIndex(value) {
        this.tabBar.currentIndex = value === null ? -1 : value;
      }
      /**
       * Get the currently selected widget.
       *
       * #### Notes
       * This will be `null` if there is no selected tab.
       */
      get currentWidget() {
        const title = this.tabBar.currentTitle;
        return title ? title.owner : null;
      }
      /**
       * Set the currently selected widget.
       *
       * #### Notes
       * If the widget is not in the panel, it will be set to `null`.
       */
      set currentWidget(value) {
        this.tabBar.currentTitle = value ? value.title : null;
      }
      /**
       * Get the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      get tabsMovable() {
        return this.tabBar.tabsMovable;
      }
      /**
       * Set the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      set tabsMovable(value) {
        this.tabBar.tabsMovable = value;
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.tabContents.widgets;
      }
      /**
       * Add a widget to the end of the tab panel.
       *
       * @param widget - The widget to add to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      addWidget(widget) {
        this.insertWidget(this.widgets.length, widget);
      }
      /**
       * Insert a widget into the tab panel at a specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      insertWidget(index2, widget) {
        if (widget !== this.currentWidget) {
          widget.hide();
        }
        this.tabContents.insertWidget(index2, widget);
        this.tabBar.insertTab(index2, widget.title);
      }
      /**
       * Handle the `currentChanged` signal from the tab bar.
       */
      _onCurrentChanged(sender, args) {
        const { previousIndex, previousTitle, currentIndex, currentTitle } = args;
        const previousWidget = previousTitle ? previousTitle.owner : null;
        const currentWidget = currentTitle ? currentTitle.owner : null;
        if (previousWidget) {
          previousWidget.hide();
        }
        if (currentWidget) {
          currentWidget.show();
        }
        this._currentChanged.emit({
          previousIndex,
          previousWidget,
          currentIndex,
          currentWidget
        });
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
      }
      /**
       * Handle the `tabActivateRequested` signal from the tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from the tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        this.tabContents.insertWidget(args.toIndex, args.title.owner);
      }
      /**
       * Handle the `widgetRemoved` signal from the stacked panel.
       */
      _onWidgetRemoved(sender, widget) {
        this.tabBar.removeTab(widget.title);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js
var Selection;
var init_currentselection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js"() {
    init_index_es64();
    init_index_es6();
    Selection = class {
      constructor(sequence, options = {}) {
        this._array = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged = new Signal(this);
        this._array = sequence;
        this._insertBehavior = options.insertBehavior || "select-item-if-needed";
        this._removeBehavior = options.removeBehavior || "select-item-after";
      }
      /**
       * A signal emitted when the current item is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected item is changed either
       * through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current item
       * changes due to other items being inserted, removed, or moved, but the
       * current item remains the same. It is only emitted when the actual current
       * item is changed.
       */
      get selectionChanged() {
        return this._selectionChanged;
      }
      /**
       * Adjust for setting an item.
       *
       * This should be called *after* the set.
       *
       * @param index - The index set.
       * @param oldValue - The old value at the index.
       */
      adjustSelectionForSet(index2) {
        const pi = this.index;
        const pv = this.value;
        if (index2 !== pi) {
          return;
        }
        this._updateSelectedValue();
        const cv = this.value;
        this._previousValue = null;
        if (pv !== cv) {
          this._selectionChanged.emit({
            previousIndex: pi,
            previousValue: pv,
            currentIndex: pi,
            currentValue: cv
          });
        }
      }
      /**
       * Get the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get value() {
        return this._value;
      }
      /**
       * Set the currently selected item.
       *
       * #### Notes
       * If the item does not exist in the vector, the currentValue will be set to
       * `null`. This selects the first entry equal to the desired item.
       */
      set value(value) {
        if (value === null || this._array === null) {
          this.index = null;
        } else {
          this.index = ArrayExt.firstIndexOf(this._array, value);
        }
      }
      /**
       * Get the index of the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get index() {
        return this._index;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * @param index - The index to select.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `null`, which
       * indicates no item is selected.
       */
      set index(index2) {
        let i5;
        if (index2 !== null && this._array !== null) {
          i5 = Math.floor(index2);
          if (i5 < 0 || i5 >= this._array.length) {
            i5 = null;
          }
        } else {
          i5 = null;
        }
        if (this._index === i5) {
          return;
        }
        const pi = this._index;
        const pv = this._value;
        this._index = i5;
        this._updateSelectedValue();
        this._previousValue = pv;
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: i5,
          currentValue: this._value
        });
      }
      /**
       * Get the selection behavior when inserting a tab.
       */
      get insertBehavior() {
        return this._insertBehavior;
      }
      /**
       * Set the selection behavior when inserting a tab.
       */
      set insertBehavior(value) {
        this._insertBehavior = value;
      }
      /**
       * Get the selection behavior when removing a tab.
       */
      get removeBehavior() {
        return this._removeBehavior;
      }
      /**
       * Set the selection behavior when removing a tab.
       */
      set removeBehavior(value) {
        this._removeBehavior = value;
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * @param i - The new index of the inserted item.
       * @param j - The inserted item.
       *
       * #### Notes
       * This method accounts for the tab bar's insertion behavior when adjusting
       * the current index and emitting the changed signal. This should be called
       * after the insertion.
       */
      adjustSelectionForInsert(i5, item) {
        const cv = this._value;
        const ci = this._index;
        const bh = this._insertBehavior;
        if (bh === "select-item" || bh === "select-item-if-needed" && ci === null) {
          this._index = i5;
          this._value = item;
          this._previousValue = cv;
          this._selectionChanged.emit({
            previousIndex: ci,
            previousValue: cv,
            currentIndex: i5,
            currentValue: item
          });
          return;
        }
        if (ci !== null && ci >= i5) {
          this._index++;
        }
      }
      /**
       * Clear the selection and history.
       */
      clearSelection() {
        const pi = this._index;
        const pv = this._value;
        this._index = null;
        this._value = null;
        this._previousValue = null;
        if (pi === null) {
          return;
        }
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Adjust the current index for an item remove operation.
       *
       * @param i - The former index of the removed item.
       * @param item - The removed item.
       *
       * #### Notes
       * This method accounts for the remove behavior when adjusting the current
       * index and emitting the changed signal. It should be called after the item
       * is removed.
       */
      adjustSelectionForRemove(i5, item) {
        if (this._index === null) {
          return;
        }
        const ci = this._index;
        const bh = this._removeBehavior;
        if (ci !== i5) {
          if (ci > i5) {
            this._index--;
          }
          return;
        }
        if (!this._array || this._array.length === 0) {
          this._index = null;
          this._value = null;
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-after") {
          this._index = Math.min(i5, this._array.length - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-before") {
          this._index = Math.max(0, i5 - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-previous-item") {
          if (this._previousValue) {
            this.value = this._previousValue;
          } else {
            this._index = Math.min(i5, this._array.length - 1);
            this._updateSelectedValue();
          }
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i5,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this.value
          });
          return;
        }
        this._index = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged.emit({
          previousIndex: i5,
          previousValue: item,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Set the current value based on the current index.
       */
      _updateSelectedValue() {
        const i5 = this._index;
        this._value = i5 !== null && this._array ? this._array[i5] : null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js
var COLLAPSE_CLASS, COLLAPSE_HEADER_CLASS, COLLAPSE_CONTENTS_CLASS, COLLAPSE_CLASS_OPEN, Collapse, ACCORDION_CLASS, ACCORDION_CHILD_CLASS, ACCORDION_CHILD_ACTIVE_CLASS, Accordion;
var init_accordion = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js"() {
    init_index_es64();
    init_index_es6();
    init_index_es63();
    init_currentselection();
    COLLAPSE_CLASS = "jupyter-widget-Collapse";
    COLLAPSE_HEADER_CLASS = "jupyter-widget-Collapse-header";
    COLLAPSE_CONTENTS_CLASS = "jupyter-widget-Collapse-contents";
    COLLAPSE_CLASS_OPEN = "jupyter-widget-Collapse-open";
    Collapse = class extends Widget {
      constructor(options) {
        super(options);
        this._collapseChanged = new Signal(this);
        this.addClass(COLLAPSE_CLASS);
        this._header = new Widget();
        this._header.addClass(COLLAPSE_HEADER_CLASS);
        this._header.node.addEventListener("click", this);
        const icon = document.createElement("i");
        icon.classList.add("fa", "fa-fw", "fa-caret-right");
        this._header.node.appendChild(icon);
        this._header.node.appendChild(document.createElement("span"));
        this._content = new Panel();
        this._content.addClass(COLLAPSE_CONTENTS_CLASS);
        const layout = new PanelLayout();
        this.layout = layout;
        layout.addWidget(this._header);
        layout.addWidget(this._content);
        if (options.widget) {
          this.widget = options.widget;
        }
        this.collapsed = false;
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._header = null;
        this._widget = null;
        this._content = null;
      }
      get widget() {
        return this._widget;
      }
      set widget(widget) {
        const oldWidget = this._widget;
        if (oldWidget) {
          oldWidget.disposed.disconnect(this._onChildDisposed, this);
          oldWidget.title.changed.disconnect(this._onTitleChanged, this);
          oldWidget.parent = null;
        }
        this._widget = widget;
        widget.disposed.connect(this._onChildDisposed, this);
        widget.title.changed.connect(this._onTitleChanged, this);
        this._onTitleChanged(widget.title);
        this._content.addWidget(widget);
      }
      get collapsed() {
        return this._collapsed;
      }
      set collapsed(value) {
        if (value === this._collapsed) {
          return;
        }
        if (value) {
          this._collapse();
        } else {
          this._uncollapse();
        }
      }
      toggle() {
        this.collapsed = !this.collapsed;
      }
      get collapseChanged() {
        return this._collapseChanged;
      }
      _collapse() {
        this._collapsed = true;
        if (this._content) {
          this._content.hide();
        }
        this.removeClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-right");
        this._header.node.children[0].classList.remove("fa-caret-down");
        this._collapseChanged.emit(void 0);
      }
      _uncollapse() {
        this._collapsed = false;
        if (this._content) {
          this._content.show();
        }
        this.addClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-down");
        this._header.node.children[0].classList.remove("fa-caret-right");
        this._collapseChanged.emit(void 0);
      }
      /**
       * Handle the DOM events for the Collapse widget.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          default:
            break;
        }
      }
      _evtClick(event) {
        this.toggle();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this._header.node.children[1].textContent = this._widget.title.label;
      }
      _onChildDisposed(sender) {
        this.dispose();
      }
    };
    ACCORDION_CLASS = "jupyter-widget-Accordion";
    ACCORDION_CHILD_CLASS = "jupyter-widget-Accordion-child";
    ACCORDION_CHILD_ACTIVE_CLASS = "jupyter-widget-Accordion-child-active";
    Accordion = class extends Panel {
      constructor(options) {
        super(options);
        this._selection = new Selection(this.widgets);
        this._selection.selectionChanged.connect(this._onSelectionChanged, this);
        this.addClass(ACCORDION_CLASS);
      }
      /**
       * A read-only sequence of the widgets in the panel.
       *
       * #### Notes
       * This is a read-only property.
       */
      /*  get widgets(): ISequence<Widget> {
          return new ArraySequence(toArray(map((this.layout as PanelLayout).widgets, (w: Collapse) => w.widget)));
        }
      */
      get collapseWidgets() {
        return this.layout.widgets;
      }
      get selection() {
        return this._selection;
      }
      indexOf(widget) {
        return ArrayExt.findFirstIndex(this.collapseWidgets, (w4) => w4.widget === widget);
      }
      /**
       * Add a widget to the end of the accordion.
       *
       * @param widget - The widget to add to the accordion.
       *
       * @returns The Collapse widget wrapping the added widget.
       *
       * #### Notes
       * The widget will be wrapped in a CollapsedWidget.
       */
      addWidget(widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.addWidget(collapse);
        this._selection.adjustSelectionForInsert(this.widgets.length - 1, collapse);
        return collapse;
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the accordion.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.insertWidget(index2, collapse);
        this._selection.adjustSelectionForInsert(index2, collapse);
      }
      removeWidget(widget) {
        const index2 = this.indexOf(widget);
        if (index2 >= 0) {
          const collapse = this.collapseWidgets[index2];
          widget.parent = null;
          collapse.dispose();
          this._selection.adjustSelectionForRemove(index2, null);
        }
      }
      _wrapWidget(widget) {
        const collapse = new Collapse({ widget });
        collapse.addClass(ACCORDION_CHILD_CLASS);
        collapse.collapseChanged.connect(this._onCollapseChange, this);
        return collapse;
      }
      _onCollapseChange(sender) {
        if (!sender.collapsed) {
          this._selection.value = sender;
        } else if (this._selection.value === sender && sender.collapsed) {
          this._selection.value = null;
        }
      }
      _onSelectionChanged(sender, change) {
        const pv = change.previousValue;
        const cv = change.currentValue;
        if (pv) {
          pv.collapsed = true;
          pv.removeClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
        if (cv) {
          cv.collapsed = false;
          cv.addClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js
var import_jquery5, SelectionContainerModel, AccordionModel, JupyterLuminoAccordionWidget, AccordionView, TabModel, JupyterLuminoTabPanelWidget, TabView, StackModel, StackView;
var init_widget_selectioncontainer = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js"() {
    init_lib10();
    init_widget_box();
    init_tabpanel();
    init_accordion();
    init_index_es63();
    init_index_es64();
    init_index_es65();
    import_jquery5 = __toESM(require_jquery());
    SelectionContainerModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionContainerModel", selected_index: null, titles: [] });
      }
    };
    AccordionModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AccordionModel", _view_name: "AccordionView" });
      }
    };
    JupyterLuminoAccordionWidget = class extends Accordion {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        var _a;
        super.processMessage(msg);
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    AccordionView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoAccordionWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_view, this.remove_child_view, this);
        this.listenTo(this.model, "change:children", () => this.updateChildren());
        this.listenTo(this.model, "change:selected_index", () => this.update_selected_index());
        this.listenTo(this.model, "change:titles", () => this.update_titles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        var _a;
        super.render();
        const accordion = this.luminoWidget;
        accordion.addClass("jupyter-widgets");
        accordion.addClass("widget-accordion");
        accordion.addClass("widget-container");
        accordion.selection.selectionChanged.connect((sender) => {
          if (!this.updatingChildren) {
            this.model.set("selected_index", accordion.selection.index);
            this.touch();
          }
        });
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_titles();
        this.update_selected_index();
      }
      /**
       * Update children
       */
      updateChildren() {
        var _a;
        this.updatingChildren = true;
        this.luminoWidget.selection.index = null;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_selected_index();
        this.updatingChildren = false;
      }
      /**
       * Set header titles
       */
      update_titles() {
        const collapsed = this.luminoWidget.collapseWidgets;
        const titles = this.model.get("titles");
        for (let i5 = 0; i5 < collapsed.length; i5++) {
          if (titles[i5] !== void 0) {
            collapsed[i5].widget.title.label = titles[i5];
          }
        }
      }
      /**
       * Make the rendering and selected index consistent.
       */
      update_selected_index() {
        this.luminoWidget.selection.index = this.model.get("selected_index");
      }
      /**
       * Called when a child is removed from children list.
       */
      remove_child_view(view) {
        this.luminoWidget.removeWidget(view.luminoWidget);
        view.remove();
      }
      /**
       * Called when a child is added to children list.
       */
      add_child_view(model, index2) {
        const accordion = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = this.model.get("titles")[index2] || "";
        accordion.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          const collapse = accordion.collapseWidgets[accordion.indexOf(placeholder2)];
          collapse.widget = widget;
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    TabModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TabModel", _view_name: "TabView" });
      }
    };
    JupyterLuminoTabPanelWidget = class extends TabPanel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
        MessageLoop.installMessageHook(this.tabContents, (handler, msg) => {
          this._view.processLuminoMessage(msg);
          return true;
        });
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    TabView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.updatingTabs = false;
      }
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoTabPanelWidget({
          view: this
        });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.childrenViews = new ViewList(this.addChildView, (view) => {
          view.remove();
        }, this);
        this.listenTo(this.model, "change:children", () => this.updateTabs());
        this.listenTo(this.model, "change:titles", () => this.updateTitles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        const tabs = this.luminoWidget;
        tabs.addClass("jupyter-widgets");
        tabs.addClass("widget-container");
        tabs.addClass("jupyter-widget-tab");
        tabs.addClass("widget-tab");
        tabs.tabsMovable = true;
        tabs.tabBar.insertBehavior = "none";
        tabs.tabBar.currentChanged.connect(this._onTabChanged, this);
        tabs.tabBar.tabMoved.connect(this._onTabMoved, this);
        tabs.tabBar.addClass("widget-tab-bar");
        tabs.tabContents.addClass("widget-tab-contents");
        tabs.tabBar.tabsMovable = false;
        this.updateTabs();
        this.update();
      }
      /**
       * Render tab views based on the current model's children.
       */
      updateTabs() {
        var _a;
        this.updatingTabs = true;
        this.luminoWidget.currentIndex = null;
        (_a = this.childrenViews) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.luminoWidget.currentIndex = this.model.get("selected_index");
        this.updatingTabs = false;
      }
      /**
       * Called when a child is added to children list.
       */
      addChildView(model, index2) {
        const label = this.model.get("titles")[index2] || "";
        const tabs = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = label;
        tabs.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          widget.title.closable = false;
          const i5 = ArrayExt.firstIndexOf(tabs.widgets, placeholder2);
          tabs.insertWidget(i5 + 1, widget);
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.updateSelectedIndex();
        return super.update();
      }
      /**
       * Updates the tab page titles.
       */
      updateTitles() {
        const titles = this.model.get("titles") || [];
        each(this.luminoWidget.widgets, (widget, i5) => {
          widget.title.label = titles[i5] || "";
        });
      }
      /**
       * Updates the selected index.
       */
      updateSelectedIndex() {
        this.luminoWidget.currentIndex = this.model.get("selected_index");
      }
      remove() {
        this.childrenViews = null;
        super.remove();
      }
      _onTabChanged(sender, args) {
        if (!this.updatingTabs) {
          const i5 = args.currentIndex;
          this.model.set("selected_index", i5 === -1 ? null : i5);
          this.touch();
        }
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        const children = this.model.get("children").slice();
        ArrayExt.move(children, args.fromIndex, args.toIndex);
        this.model.set("children", children);
        this.touch();
      }
    };
    StackModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StackModel", _view_name: "StackView" });
      }
    };
    StackView = class extends BoxView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:selected_index", this.update_children);
      }
      update_children() {
        var _a;
        let child;
        if (this.model.get("selected_index") === null) {
          child = [];
        } else {
          child = [this.model.get("children")[this.model.get("selected_index")]];
        }
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(child).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js
function trim(value) {
  return value.replace(/^\s+|\s+$/g, "");
}
function clamp2(value, min3, max3) {
  return Math.min(Math.max(value, min3), max3);
}
function removeChildren(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var Selection2, TagsInputBaseModel, TagsInputBaseView, TagsInputModel, TagsInputView, ColorsInputModel, ColorsInputView, NumbersInputModel, NumbersInputView, FloatsInputModel, FloatsInputView, IntsInputModel, IntsInputView;
var init_widget_tagsinput = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js"() {
    init_src2();
    init_src();
    init_widget_core();
    init_lib10();
    Selection2 = class {
      constructor(start, dx, max3) {
        this.start = start;
        this.dx = dx;
        this.max = max3;
      }
      /**
       * Check if a given index is currently selected.
       */
      isSelected(index2) {
        let min3;
        let max3;
        if (this.dx >= 0) {
          min3 = this.start;
          max3 = this.start + this.dx;
        } else {
          min3 = this.start + this.dx;
          max3 = this.start;
        }
        return min3 <= index2 && index2 < max3;
      }
      /**
       * Update selection
       */
      updateSelection(dx) {
        this.dx += dx;
        if (this.start + this.dx > this.max) {
          this.dx = this.max - this.start;
        }
        if (this.start + this.dx < 0) {
          this.dx = -this.start;
        }
      }
    };
    TagsInputBaseModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], placeholder: "\u200B", allowed_tags: null, allow_duplicates: true });
      }
    };
    TagsInputBaseView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-widget-tagsinput");
        this.taginputWrapper = document.createElement("div");
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.datalistID = uuid();
        this.taginput = document.createElement("input");
        this.taginput.classList.add("jupyter-widget-tag");
        this.taginput.classList.add("jupyter-widget-taginput");
        this.taginput.setAttribute("list", this.datalistID);
        this.taginput.setAttribute("type", "text");
        this.autocompleteList = document.createElement("datalist");
        this.autocompleteList.id = this.datalistID;
        this.updateAutocomplete();
        this.model.on("change:allowed_tags", this.updateAutocomplete.bind(this));
        this.updatePlaceholder();
        this.model.on("change:placeholder", this.updatePlaceholder.bind(this));
        this.taginputWrapper.classList.add("widget-text");
        this.taginputWrapper.appendChild(this.taginput);
        this.taginputWrapper.appendChild(this.autocompleteList);
        this.el.onclick = this.focus.bind(this);
        this.el.ondrop = (event) => {
          const index2 = this.hoveredTagIndex == null ? this.tags.length : this.hoveredTagIndex;
          return this.ondrop(event, index2);
        };
        this.el.ondragover = this.ondragover.bind(this);
        this.taginput.onchange = this.handleValueAdded.bind(this);
        this.taginput.oninput = this.resizeInput.bind(this);
        this.taginput.onkeydown = this.handleKeyEvent.bind(this);
        this.taginput.onblur = this.loseFocus.bind(this);
        this.resizeInput();
        this.inputIndex = this.model.get("value").length;
        this.selection = null;
        this.preventLoosingFocus = false;
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.preventLoosingFocus = true;
        removeChildren(this.el);
        this.tags = [];
        const value = this.model.get("value");
        for (const idx in value) {
          const index2 = parseInt(idx);
          const tag = this.createTag(value[index2], index2, this.selection != null && this.selection.isSelected(index2));
          tag.draggable = true;
          tag.ondragstart = ((index3, value2) => {
            return (event) => {
              this.ondragstart(event, index3, value2, this.model.model_id);
            };
          })(index2, value[index2]);
          tag.ondrop = ((index3) => {
            return (event) => {
              this.ondrop(event, index3);
            };
          })(index2);
          tag.ondragover = this.ondragover.bind(this);
          tag.ondragenter = ((index3) => {
            return (event) => {
              this.ondragenter(event, index3);
            };
          })(index2);
          tag.ondragend = this.ondragend.bind(this);
          this.tags.push(tag);
          this.el.appendChild(tag);
        }
        this.el.insertBefore(this.taginputWrapper, this.el.children[this.inputIndex]);
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.preventLoosingFocus = false;
        return super.update();
      }
      /**
       * Update the auto-completion list
       */
      updateAutocomplete() {
        removeChildren(this.autocompleteList);
        const allowedTags = this.model.get("allowed_tags");
        for (const tag of allowedTags) {
          const option = document.createElement("option");
          option.value = tag;
          this.autocompleteList.appendChild(option);
        }
      }
      /**
       * Update the auto-completion list
       */
      updatePlaceholder() {
        this.taginput.placeholder = this.model.get("placeholder");
        this.resizeInput();
      }
      /**
       * Update the tags, called when the selection has changed and we need to update the tags CSS
       */
      updateTags() {
        const value = this.model.get("value");
        for (const idx in this.tags) {
          const index2 = parseInt(idx);
          this.updateTag(this.tags[index2], value[index2], index2, this.selection != null && this.selection.isSelected(index2));
        }
      }
      /**
       * Handle a new value is added from the input element
       */
      handleValueAdded(event) {
        const newTagValue = trim(this.taginput.value);
        const tagIndex = this.inputIndex;
        if (newTagValue == "") {
          return;
        }
        this.inputIndex++;
        const tagAdded = this.addTag(tagIndex, newTagValue);
        if (tagAdded) {
          this.taginput.value = "";
          this.resizeInput();
          this.focus();
        }
      }
      /**
       * Add a new tag with a value of `tagValue` at the `index` position
       * Return true if the tag was correctly added, false otherwise
       */
      addTag(index2, tagValue) {
        const value = this.model.get("value");
        let newTagValue;
        try {
          newTagValue = this.validateValue(tagValue);
        } catch (error) {
          return false;
        }
        const allowedTagValues = this.model.get("allowed_tags");
        if (allowedTagValues.length && !allowedTagValues.includes(newTagValue)) {
          return false;
        }
        if (!this.model.get("allow_duplicates") && value.includes(newTagValue)) {
          return false;
        }
        this.selection = null;
        const newValue = [...value];
        newValue.splice(index2, 0, newTagValue);
        this.model.set("value", newValue);
        this.model.save_changes();
        return true;
      }
      /**
       * Resize the input element
       */
      resizeInput() {
        let content;
        if (this.taginput.value.length != 0) {
          content = this.taginput.value;
        } else {
          content = this.model.get("placeholder");
        }
        const size3 = content.length + 1;
        this.taginput.setAttribute("size", String(size3));
      }
      /**
       * Handle key events on the input element
       */
      handleKeyEvent(event) {
        const valueLength = this.model.get("value").length;
        if (this.taginput.value.length) {
          return;
        }
        const currentElement = this.inputIndex;
        switch (event.key) {
          case "ArrowLeft":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -1);
            }
            if (event.ctrlKey) {
              this.inputIndex = 0;
            } else {
              this.inputIndex--;
            }
            break;
          case "ArrowRight":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, valueLength - currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, 1);
            }
            if (event.ctrlKey) {
              this.inputIndex = valueLength;
            } else {
              this.inputIndex++;
            }
            break;
          case "Backspace":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex - 1);
            }
            break;
          case "Delete":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex);
            }
            break;
          default:
            return;
            break;
        }
        if (!event.shiftKey) {
          this.selection = null;
        }
        this.inputIndex = clamp2(this.inputIndex, 0, valueLength);
        this.update();
        this.focus();
      }
      /**
       * Function that gets called when a tag with a given `value` is being dragged.
       */
      ondragstart(event, index2, tagValue, origin) {
        if (event.dataTransfer == null) {
          return;
        }
        event.dataTransfer.setData("index", String(index2));
        event.dataTransfer.setData("tagValue", String(tagValue));
        event.dataTransfer.setData("origin", origin);
      }
      /**
       * Function that gets called when a tag has been dragged on the tag at the `index` position.
       */
      ondrop(event, index2) {
        if (event.dataTransfer == null) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        const draggedTagValue = event.dataTransfer.getData("tagValue");
        const draggedTagindex = parseInt(event.dataTransfer.getData("index"));
        const sameOrigin = event.dataTransfer.getData("origin") == this.model.model_id;
        if (isNaN(draggedTagindex)) {
          return;
        }
        if (sameOrigin) {
          const value = this.model.get("value");
          const newValue = [...value];
          if (draggedTagindex < index2) {
            index2--;
          }
          newValue.splice(draggedTagindex, 1);
          newValue.splice(index2, 0, draggedTagValue);
          this.model.set("value", newValue);
          this.model.save_changes();
          return;
        }
        this.addTag(index2, draggedTagValue);
      }
      ondragover(event) {
        event.preventDefault();
      }
      ondragenter(event, index2) {
        if (this.hoveredTag != null && this.hoveredTag != this.tags[index2]) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = this.tags[index2];
        this.hoveredTagIndex = index2;
        this.hoveredTag.style.marginLeft = "30px";
      }
      ondragend() {
        if (this.hoveredTag != null) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Select tags from `start` to `start + dx` not included.
       */
      select(start, dx) {
        const valueLength = this.model.get("value").length;
        if (!this.selection) {
          this.selection = new Selection2(start, dx, valueLength);
        } else {
          this.selection.updateSelection(dx);
        }
      }
      /**
       * Remove all the selected tags.
       */
      removeSelectedTags() {
        const value = [...this.model.get("value")];
        const valueLength = value.length;
        for (let idx = valueLength - 1; idx >= 0; idx--) {
          if (this.selection != null && this.selection.isSelected(idx)) {
            value.splice(idx, 1);
            if (idx < this.inputIndex) {
              this.inputIndex--;
            }
          }
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Remove a tag given its index in the list
       */
      removeTag(tagIndex) {
        const value = [...this.model.get("value")];
        value.splice(tagIndex, 1);
        if (tagIndex < this.inputIndex) {
          this.inputIndex--;
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Focus on the input element
       */
      focus() {
        this.taginputWrapper.style.display = "inline-block";
        this.taginput.focus();
      }
      /**
       * Lose focus on the input element
       */
      loseFocus() {
        if (this.preventLoosingFocus) {
          return;
        }
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        }
        this.selection = null;
        this.updateTags();
      }
      preinitialize() {
        this.tagName = "div";
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        return value;
      }
    };
    TagsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], tag_style: "", _view_name: "TagsInputView", _model_name: "TagsInputModel" });
      }
    };
    TagsInputView = class extends TagsInputBaseView {
      /**
       * Create the string tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const style = this.model.get("tag_style");
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add(TagsInputView.class_map[style]);
        if (selected) {
          tag.classList.add("mod-active");
        }
        tag.appendChild(document.createTextNode(this.getTagText(value)));
        const i5 = document.createElement("i");
        i5.classList.add("fa");
        i5.classList.add("fa-times");
        i5.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i5);
        i5.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return value;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        if (selected) {
          tag.classList.add("mod-active");
        } else {
          tag.classList.remove("mod-active");
        }
      }
    };
    TagsInputView.class_map = {
      primary: "mod-primary",
      success: "mod-success",
      info: "mod-info",
      warning: "mod-warning",
      danger: "mod-danger"
    };
    ColorsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], _view_name: "ColorsInputView", _model_name: "ColorsInputModel" });
      }
    };
    ColorsInputView = class extends TagsInputBaseView {
      /**
       * Create the Color tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add("jupyter-widget-colortag");
        if (!selected) {
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
        const i5 = document.createElement("i");
        i5.classList.add("fa");
        i5.classList.add("fa-times");
        i5.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i5);
        i5.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        if (!selected) {
          tag.classList.remove("mod-active");
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        if (color(value) == null) {
          throw value + " is not a valid Color";
        }
        return value;
      }
    };
    NumbersInputModel = class extends TagsInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { min: null, max: null });
      }
    };
    NumbersInputView = class extends TagsInputView {
      render() {
        this.model.on("change:format", () => {
          this.formatter = format(this.model.get("format"));
          this.update();
        });
        this.formatter = format(this.model.get("format"));
        super.render();
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return this.formatter(this.parseNumber(value));
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        const parsed = this.parseNumber(value);
        const min3 = this.model.get("min");
        const max3 = this.model.get("max");
        if (isNaN(parsed) || min3 != null && parsed < min3 || max3 != null && parsed > max3) {
          throw value + " is not a valid number, it should be in the range [" + min3 + ", " + max3 + "]";
        }
        return parsed;
      }
    };
    FloatsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "FloatsInputView", _model_name: "FloatsInputModel", format: ".1f" });
      }
    };
    FloatsInputView = class extends NumbersInputView {
      parseNumber(value) {
        return parseFloat(value);
      }
    };
    IntsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "IntsInputView", _model_name: "IntsInputModel", format: "d" });
      }
    };
    IntsInputView = class extends NumbersInputView {
      parseNumber(value) {
        const int2 = parseInt(value);
        if (int2 != parseFloat(value)) {
          throw value + " should be an integer";
        }
        return int2;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_string.js
var INVALID_VALUE_CLASS, StringStyleModel, HTMLStyleModel, HTMLMathStyleModel, LabelStyleModel, TextStyleModel, StringModel, StringView, HTMLModel, HTMLView, HTMLMathModel, HTMLMathView, LabelModel, LabelView, TextareaModel, TextareaView, TextModel, TextView, PasswordModel, PasswordView, ComboboxModel, ComboboxView;
var init_widget_string = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_string.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    init_version2();
    INVALID_VALUE_CLASS = "jpwidgets-invalidComboValue";
    StringStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StringStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    StringStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    } });
    HTMLStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    HTMLMathStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLMathStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLMathStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    LabelStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LabelStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    LabelStyleModel.styleProperties = Object.assign(Object.assign({}, StringStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    TextStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TextStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    TextStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: ".widget-input",
      attribute: "background",
      default: null
    }, font_size: {
      selector: ".widget-input",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: ".widget-input",
      attribute: "color",
      default: ""
    } });
    StringModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "", disabled: false, placeholder: "\u200B", _model_name: "StringModel" });
      }
    };
    StringView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
    };
    HTMLModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLView", _model_name: "HTMLModel" });
      }
    };
    HTMLView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-html");
        this.content = document.createElement("div");
        this.content.classList.add("widget-html-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    HTMLMathModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLMathView", _model_name: "HTMLMathModel" });
      }
    };
    HTMLMathView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-htmlmath");
        this.content = document.createElement("div");
        this.content.classList.add("widget-htmlmath-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        this.typeset(this.content);
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    LabelModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "LabelView", _model_name: "LabelModel" });
      }
    };
    LabelView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-label");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.typeset(this.el, this.model.get("value"));
        return super.update();
      }
    };
    TextareaModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextareaView", _model_name: "TextareaModel", rows: null, continuous_update: true });
      }
    };
    TextareaView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-textarea");
        this.textbox = document.createElement("textarea");
        this.textbox.setAttribute("rows", "5");
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTooltip();
      }
      update_placeholder(value) {
        const v2 = value || this.model.get("placeholder");
        this.textbox.setAttribute("placeholder", v2.toString());
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this.textbox.value = this.model.get("value");
          let rows = this.model.get("rows");
          if (rows === null) {
            rows = "";
          }
          this.textbox.setAttribute("rows", rows);
          this.textbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
        return super.update();
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "input textarea": "handleChanging",
          "change textarea": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles key press
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeypress(e4) {
        e4.stopPropagation();
      }
      /**
       * Triggered on input change
       */
      handleChanging(e4) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Sync the value with the kernel.
       *
       * @param e Event
       */
      handleChanged(e4) {
        const target = e4.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    TextModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextView", _model_name: "TextModel", continuous_update: true });
      }
    };
    TextView = class extends StringView {
      constructor() {
        super(...arguments);
        this.inputType = "text";
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.setAttribute("type", this.inputType);
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTabindex();
        this.updateTooltip();
      }
      update_placeholder(value) {
        this.textbox.setAttribute("placeholder", value || this.model.get("placeholder"));
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.textbox.value !== this.model.get("value")) {
            this.textbox.value = this.model.get("value");
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeyDown(e4) {
        e4.stopPropagation();
      }
      /**
       * Handles text submission
       */
      handleKeypress(e4) {
        e4.stopPropagation();
        if (e4.keyCode === 13) {
          this.send({ event: "submit" });
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanging(e4) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e4);
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanged(e4) {
        const target = e4.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    PasswordModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "PasswordView", _model_name: "PasswordModel" });
      }
    };
    PasswordView = class extends TextView {
      constructor() {
        super(...arguments);
        this.inputType = "password";
      }
    };
    ComboboxModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ComboboxModel", _view_name: "ComboboxView", options: [], ensure_options: false });
      }
    };
    ComboboxView = class extends TextView {
      constructor() {
        super(...arguments);
        this.isInitialRender = true;
      }
      render() {
        this.datalist = document.createElement("datalist");
        this.datalist.id = uuid();
        super.render();
        this.textbox.setAttribute("list", this.datalist.id);
        this.el.appendChild(this.datalist);
        this.updateTooltip();
      }
      update(options) {
        super.update(options);
        if (!this.datalist) {
          return;
        }
        const valid2 = this.isValid(this.model.get("value"));
        this.highlightValidState(valid2);
        if (options !== void 0 && options.updated_view || !this.model.hasChanged("options") && !this.isInitialRender) {
          return;
        }
        this.isInitialRender = false;
        const opts = this.model.get("options");
        const optionFragment = document.createDocumentFragment();
        for (const v2 of opts) {
          const o10 = document.createElement("option");
          o10.value = v2;
          optionFragment.appendChild(o10);
        }
        this.datalist.replaceChildren(...optionFragment.children);
      }
      isValid(value) {
        if (true === this.model.get("ensure_option")) {
          const options = this.model.get("options");
          if (options.indexOf(value) === -1) {
            return false;
          }
        }
        return true;
      }
      handleChanging(e4) {
        const target = e4.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanging(e4);
        }
      }
      handleChanged(e4) {
        const target = e4.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanged(e4);
        }
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
      highlightValidState(valid2) {
        this.textbox.classList.toggle(INVALID_VALUE_CLASS, !valid2);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js
var FileUploadModel, FileUploadView;
var init_widget_upload = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js"() {
    init_widget_core();
    init_lib10();
    FileUploadModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FileUploadModel", _view_name: "FileUploadView", accept: "", description: "Upload", disabled: false, icon: "upload", button_style: "", multiple: false, value: [], error: "", style: null });
      }
    };
    FileUploadModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), {
      // use a dummy serializer for value to circumvent the default serializer.
      value: { serialize: (x4) => x4 }
    });
    FileUploadView = class extends DOMWidgetView {
      preinitialize() {
        this.tagName = "button";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-upload");
        this.el.classList.add("jupyter-button");
        this.fileInput = document.createElement("input");
        this.fileInput.type = "file";
        this.fileInput.style.display = "none";
        this.el.addEventListener("click", () => {
          this.fileInput.click();
        });
        this.fileInput.addEventListener("click", () => {
          this.fileInput.value = "";
        });
        this.fileInput.addEventListener("change", () => {
          var _a;
          const promisesFile = [];
          Array.from((_a = this.fileInput.files) !== null && _a !== void 0 ? _a : []).forEach((file) => {
            promisesFile.push(new Promise((resolve, reject4) => {
              const fileReader = new FileReader();
              fileReader.onload = () => {
                const content = fileReader.result;
                resolve({
                  content,
                  name: file.name,
                  type: file.type,
                  size: file.size,
                  last_modified: file.lastModified
                });
              };
              fileReader.onerror = () => {
                reject4();
              };
              fileReader.onabort = fileReader.onerror;
              fileReader.readAsArrayBuffer(file);
            }));
          });
          Promise.all(promisesFile).then((files) => {
            this.model.set({
              value: files,
              error: ""
            });
            this.touch();
          }).catch((err) => {
            console.error("error in file upload: %o", err);
            this.model.set({
              error: err
            });
            this.touch();
          });
        });
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.set_button_style();
        this.update();
      }
      update() {
        this.el.disabled = this.model.get("disabled");
        this.el.setAttribute("title", this.model.get("tooltip"));
        const value = this.model.get("value");
        const description = `${this.model.get("description")} (${value.length})`;
        const icon = this.model.get("icon");
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i5 = document.createElement("i");
            i5.classList.add("fa");
            i5.classList.add("fa-" + icon);
            if (description.length === 0) {
              i5.classList.add("center");
            }
            this.el.appendChild(i5);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        this.fileInput.accept = this.model.get("accept");
        this.fileInput.multiple = this.model.get("multiple");
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
      set_button_style() {
        this.set_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
    };
    FileUploadView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/package.json
var require_package = __commonJS({
  "../../node_modules/@jupyter-widgets/controls/package.json"(exports, module) {
    module.exports = {
      name: "@jupyter-widgets/controls",
      version: "5.0.7",
      description: "Jupyter interactive widgets",
      repository: {
        type: "git",
        url: "https://github.com/jupyter-widgets/ipywidgets.git"
      },
      license: "BSD-3-Clause",
      author: "Project Jupyter",
      main: "lib/index.js",
      typings: "lib/index.d.ts",
      files: [
        "lib/**/*.d.ts",
        "lib/**/*.js",
        "css/*.css",
        "dist/"
      ],
      scripts: {
        build: "npm run build:src && npm run build:css",
        "build:css": "lessc css/nouislider.less css/nouislider.css && postcss --use postcss-import --use postcss-cssnext -o css/widgets.built.css css/widgets.css",
        "build:src": "tsc --build",
        "build:test": "tsc --build test && webpack --config test/webpack.conf.js",
        clean: "npm run clean:src",
        "clean:src": "rimraf lib && rimraf tsconfig.tsbuildinfo",
        prepublish: "npm run clean && npm run build",
        test: "npm run test:unit",
        "test:coverage": "npm run build:test && webpack --config test/webpack-cov.conf.js && karma start test/karma-cov.conf.js",
        "test:unit": "npm run test:unit:firefox && npm run test:unit:chrome",
        "test:unit:chrome": "npm run test:unit:default -- --browsers=Chrome",
        "test:unit:default": "npm run build:test && karma start test/karma.conf.js --log-level debug",
        "test:unit:firefox": "npm run test:unit:default -- --browsers=Firefox",
        "test:unit:firefox:headless": "npm run test:unit:default -- --browsers=FirefoxHeadless",
        "test:unit:ie": "npm run test:unit:default -- --browsers=IE"
      },
      dependencies: {
        "@jupyter-widgets/base": "^6.0.6",
        "@lumino/algorithm": "^1.9.1 || ^2.1",
        "@lumino/domutils": "^1.8.1 || ^2.1",
        "@lumino/messaging": "^1.10.1 || ^2.1",
        "@lumino/signaling": "^1.10.1 || ^2.1",
        "@lumino/widgets": "^1.30.0 || ^2.1",
        "d3-color": "^3.0.1",
        "d3-format": "^3.0.1",
        jquery: "^3.1.1",
        nouislider: "15.4.0"
      },
      devDependencies: {
        "@jupyterlab/services": "^6.0.0 || ^7.0.0",
        "@types/d3-color": "^3.0.2",
        "@types/d3-format": "^3.0.1",
        "@types/expect.js": "^0.3.29",
        "@types/jquery": "^3.5.16",
        "@types/mathjax": "^0.0.37",
        "@types/mocha": "^9.0.0",
        "@types/node": "^17.0.2",
        chai: "^4.0.0",
        "css-loader": "^6.5.1",
        "expect.js": "^0.3.1",
        "istanbul-instrumenter-loader": "^3.0.1",
        karma: "^6.3.3",
        "karma-chrome-launcher": "^3.1.0",
        "karma-coverage": "^2.0.3",
        "karma-firefox-launcher": "^2.1.1",
        "karma-ie-launcher": "^1.0.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-webpack": "^5.0.0",
        less: "^4.1.2",
        mocha: "^9.0.0",
        "npm-run-all": "^4.1.5",
        postcss: "^8.3.2",
        "postcss-cli": "^9.1.0",
        "postcss-cssnext": "^3.1.0",
        "postcss-import": "^14.0.2",
        "postcss-loader": "^6.1.0",
        rimraf: "^3.0.2",
        sinon: "^12.0.1",
        "sinon-chai": "^3.3.0",
        "style-loader": "^3.3.1",
        typescript: "~4.9.4",
        webpack: "^5.65.0"
      },
      gitHead: "17f68ed1b50f1c8b6843cb33f6b08161be89d3ea"
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AccordionModel: () => AccordionModel,
  AccordionView: () => AccordionView,
  AudioModel: () => AudioModel,
  AudioView: () => AudioView,
  BaseIntSliderView: () => BaseIntSliderView,
  BoolModel: () => BoolModel,
  BoundedFloatModel: () => BoundedFloatModel,
  BoundedFloatTextModel: () => BoundedFloatTextModel,
  BoundedIntModel: () => BoundedIntModel,
  BoundedIntTextModel: () => BoundedIntTextModel,
  BoxModel: () => BoxModel,
  BoxView: () => BoxView,
  ButtonModel: () => ButtonModel,
  ButtonStyleModel: () => ButtonStyleModel,
  ButtonView: () => ButtonView,
  CheckboxModel: () => CheckboxModel,
  CheckboxStyleModel: () => CheckboxStyleModel,
  CheckboxView: () => CheckboxView,
  ColorPickerModel: () => ColorPickerModel,
  ColorPickerView: () => ColorPickerView,
  ColorsInputModel: () => ColorsInputModel,
  ColorsInputView: () => ColorsInputView,
  ComboboxModel: () => ComboboxModel,
  ComboboxView: () => ComboboxView,
  ControllerAxisModel: () => ControllerAxisModel,
  ControllerAxisView: () => ControllerAxisView,
  ControllerButtonModel: () => ControllerButtonModel,
  ControllerButtonView: () => ControllerButtonView,
  ControllerModel: () => ControllerModel,
  ControllerView: () => ControllerView,
  DatePickerModel: () => DatePickerModel,
  DatePickerView: () => DatePickerView,
  DatetimeModel: () => DatetimeModel,
  DatetimeView: () => DatetimeView,
  DescriptionModel: () => DescriptionModel,
  DescriptionStyleModel: () => DescriptionStyleModel,
  DescriptionView: () => DescriptionView,
  DirectionalLinkModel: () => DirectionalLinkModel,
  DropdownModel: () => DropdownModel,
  DropdownView: () => DropdownView,
  FileUploadModel: () => FileUploadModel,
  FileUploadView: () => FileUploadView,
  FloatLogSliderModel: () => FloatLogSliderModel,
  FloatLogSliderView: () => FloatLogSliderView,
  FloatModel: () => FloatModel,
  FloatProgressModel: () => FloatProgressModel,
  FloatRangeSliderModel: () => FloatRangeSliderModel,
  FloatRangeSliderView: () => FloatRangeSliderView,
  FloatSliderModel: () => FloatSliderModel,
  FloatSliderView: () => FloatSliderView,
  FloatTextModel: () => FloatTextModel,
  FloatTextView: () => FloatTextView,
  FloatsInputModel: () => FloatsInputModel,
  FloatsInputView: () => FloatsInputView,
  GridBoxModel: () => GridBoxModel,
  GridBoxView: () => GridBoxView,
  HBoxModel: () => HBoxModel,
  HBoxView: () => HBoxView,
  HTMLMathModel: () => HTMLMathModel,
  HTMLMathStyleModel: () => HTMLMathStyleModel,
  HTMLMathView: () => HTMLMathView,
  HTMLModel: () => HTMLModel,
  HTMLStyleModel: () => HTMLStyleModel,
  HTMLView: () => HTMLView,
  ImageModel: () => ImageModel,
  ImageView: () => ImageView,
  IntModel: () => IntModel,
  IntProgressModel: () => IntProgressModel,
  IntRangeSliderModel: () => IntRangeSliderModel,
  IntRangeSliderView: () => IntRangeSliderView,
  IntSliderModel: () => IntSliderModel,
  IntSliderView: () => IntSliderView,
  IntTextModel: () => IntTextModel,
  IntTextView: () => IntTextView,
  IntsInputModel: () => IntsInputModel,
  IntsInputView: () => IntsInputView,
  JUPYTER_CONTROLS_VERSION: () => JUPYTER_CONTROLS_VERSION,
  JupyterLuminoAccordionWidget: () => JupyterLuminoAccordionWidget,
  JupyterLuminoTabPanelWidget: () => JupyterLuminoTabPanelWidget,
  LabelModel: () => LabelModel,
  LabelStyleModel: () => LabelStyleModel,
  LabelView: () => LabelView,
  LabeledDOMWidgetModel: () => LabeledDOMWidgetModel,
  LabeledDOMWidgetView: () => LabeledDOMWidgetView,
  LinkModel: () => LinkModel,
  MultipleSelectionModel: () => MultipleSelectionModel,
  NaiveDatetimeModel: () => NaiveDatetimeModel,
  PasswordModel: () => PasswordModel,
  PasswordView: () => PasswordView,
  PlayModel: () => PlayModel,
  PlayView: () => PlayView,
  ProgressStyleModel: () => ProgressStyleModel,
  ProgressView: () => ProgressView,
  RadioButtonsModel: () => RadioButtonsModel,
  RadioButtonsView: () => RadioButtonsView,
  SelectModel: () => SelectModel,
  SelectMultipleModel: () => SelectMultipleModel,
  SelectMultipleView: () => SelectMultipleView,
  SelectView: () => SelectView,
  SelectionContainerModel: () => SelectionContainerModel,
  SelectionModel: () => SelectionModel,
  SelectionRangeSliderModel: () => SelectionRangeSliderModel,
  SelectionRangeSliderView: () => SelectionRangeSliderView,
  SelectionSliderModel: () => SelectionSliderModel,
  SelectionSliderView: () => SelectionSliderView,
  SelectionView: () => SelectionView,
  SliderStyleModel: () => SliderStyleModel,
  StackModel: () => StackModel,
  StackView: () => StackView,
  StringModel: () => StringModel,
  StringView: () => StringView,
  TabModel: () => TabModel,
  TabView: () => TabView,
  TagsInputModel: () => TagsInputModel,
  TagsInputView: () => TagsInputView,
  TextModel: () => TextModel,
  TextStyleModel: () => TextStyleModel,
  TextView: () => TextView,
  TextareaModel: () => TextareaModel,
  TextareaView: () => TextareaView,
  TimeModel: () => TimeModel,
  TimeView: () => TimeView,
  ToggleButtonModel: () => ToggleButtonModel,
  ToggleButtonStyleModel: () => ToggleButtonStyleModel,
  ToggleButtonView: () => ToggleButtonView,
  ToggleButtonsModel: () => ToggleButtonsModel,
  ToggleButtonsStyleModel: () => ToggleButtonsStyleModel,
  ToggleButtonsView: () => ToggleButtonsView,
  VBoxModel: () => VBoxModel,
  VBoxView: () => VBoxView,
  ValidModel: () => ValidModel,
  ValidView: () => ValidView,
  VideoModel: () => VideoModel,
  VideoView: () => VideoView,
  datetime_serializers: () => datetime_serializers,
  deserialize_date: () => deserialize_date,
  deserialize_datetime: () => deserialize_datetime,
  deserialize_naive: () => deserialize_naive,
  deserialize_time: () => deserialize_time,
  escape_html: () => escape_html,
  naive_serializers: () => naive_serializers,
  reject: () => reject3,
  resolvePromisesDict: () => resolvePromisesDict,
  serialize_date: () => serialize_date,
  serialize_datetime: () => serialize_datetime,
  serialize_naive: () => serialize_naive,
  serialize_time: () => serialize_time,
  time_serializers: () => time_serializers,
  typeset: () => typeset,
  uuid: () => uuid,
  version: () => version
});
var version;
var init_lib14 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/index.js"() {
    init_utils3();
    init_version2();
    init_widget_link();
    init_widget_bool();
    init_widget_button();
    init_widget_box();
    init_widget_image();
    init_widget_video();
    init_widget_audio();
    init_widget_color();
    init_widget_date();
    init_widget_datetime();
    init_widget_time();
    init_widget_int();
    init_widget_float();
    init_widget_controller();
    init_widget_selection();
    init_widget_selectioncontainer();
    init_widget_tagsinput();
    init_widget_string();
    init_widget_description();
    init_widget_upload();
    version = require_package().version;
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js
var init_url_alphabet = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js"() {
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/index.browser.js
var random2, customRandom, customAlphabet;
var init_index_browser = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random2 = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size3 = defaultSize) => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let j2 = step;
          while (j2--) {
            id += alphabet[bytes[j2] & mask] || "";
            if (id.length === size3)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size3 = 21) => customRandom(alphabet, size3, random2);
  }
});

// ../../node_modules/thebe-core/dist/esm/utils.js
function shortId() {
  return nanoid();
}
function ensureString2(maybeString) {
  if (Array.isArray(maybeString))
    return maybeString.join("\n");
  return maybeString;
}
function isMimeBundle({ output_type }) {
  return output_type === "display_data" || output_type === "execute_result";
}
function placeholder(plainText) {
  return `
<div class="thebe-ipywidgets-placeholder">
  <div class="thebe-ipywidgets-placeholder-image"></div>
  <div class="thebe-ipywidgets-placeholder-message"><code>ipywidgets</code> - a Jupyter kernel connection is required to fully display this output.</div>
  ${plainText && `<pre>${plainText}</pre>`}
</div>
`;
}
function stripWidgets(outputs, hideWidgets = true, placeholderFn = placeholder) {
  return outputs.map((output) => {
    if (!isMimeBundle(output))
      return output;
    const _a = output.data, _b = WIDGET_MIMETYPE, widgets = _a[_b], others = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    if (!widgets)
      return output;
    let data = output.data;
    if (hideWidgets)
      data = Object.assign({}, others);
    if (placeholderFn && !("text/html" in data))
      data["text/html"] = placeholderFn(ensureString2(data["text/plain"]));
    const stripped = Object.assign(Object.assign({}, output), { data });
    return stripped;
  });
}
var nanoid;
var init_utils4 = __esm({
  "../../node_modules/thebe-core/dist/esm/utils.js"() {
    init_tslib_es6();
    init_index_browser();
    init_manager3();
    nanoid = customAlphabet("1234567890abcdef", 8);
  }
});

// ../../node_modules/thebe-core/dist/esm/requireJsLoader.js
function fetchAndLoadInFrame(baseUrl) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof document === "undefined")
      throw new Error("Cannot load requirejs outside of the browser");
    const res = yield fetch(REQUIREJS_URL);
    if (!res.ok) {
      throw new Error(`Could not fetch requirejs ${res.status} ${res.statusText}`);
    }
    const requireJsSource = yield res.text();
    return new Promise((resolve, reject4) => {
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.onload = () => {
        const contentWindow = iframe.contentWindow;
        if (!contentWindow)
          return reject4("Cannot load in isolated: no contentWindow, origin error?");
        contentWindow.window.eval(requireJsSource);
        const requirejs = {
          require: contentWindow.window.require,
          define: contentWindow.window.define
        };
        if (!requirejs.require || !requirejs.define)
          return reject4("Require.js loading did not result in `require` and `define` objects attachment to window");
        requirejs.require.config({ baseUrl });
        resolve(requirejs);
        iframe.onload = null;
      };
      document.body.appendChild(iframe);
    });
  });
}
var REQUIREJS_CDN_URL, REQUIREJS_URL, RequireJsLoader;
var init_requireJsLoader = __esm({
  "../../node_modules/thebe-core/dist/esm/requireJsLoader.js"() {
    init_tslib_es6();
    REQUIREJS_CDN_URL = "https://cdn.jsdelivr.net/npm/";
    REQUIREJS_URL = "https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js";
    RequireJsLoader = class {
      constructor(baseUrl) {
        this.baseUrl = baseUrl !== null && baseUrl !== void 0 ? baseUrl : REQUIREJS_CDN_URL;
        this.requested = false;
        this.resolveFn = () => ({});
        this.ready = new Promise((resolve) => this.resolveFn = resolve);
      }
      load(postLoadFn) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.requested) {
            this.requested = true;
            this.requirejs = yield fetchAndLoadInFrame(this.baseUrl);
            yield postLoadFn === null || postLoadFn === void 0 ? void 0 : postLoadFn(this.requirejs.require, this.requirejs.define);
            this.resolveFn(this.requirejs);
          }
          return this.ready;
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/loader.js
function requirePromise(requirejs, moduleName) {
  return new Promise((resolve, reject4) => requirejs.require([`${moduleName}`], resolve, reject4));
}
function moduleNameToCDNUrl(moduleName, moduleVersion) {
  let packageName = moduleName;
  let fileName = "index";
  let index2 = moduleName.indexOf("/");
  if (index2 !== -1 && moduleName[0] === "@") {
    index2 = moduleName.indexOf("/", index2 + 1);
  }
  if (index2 !== -1) {
    fileName = moduleName.substr(index2 + 1);
    packageName = moduleName.substr(0, index2);
  }
  return `${cdn}${packageName}@${moduleVersion}/dist/${fileName}`;
}
function requireFromCDN(requirejs, moduleName, moduleVersion) {
  return __awaiter(this, void 0, void 0, function* () {
    const url = moduleNameToCDNUrl(moduleName, moduleVersion);
    const conf = { paths: {} };
    conf.paths[moduleName] = url;
    requirejs.require.config(conf);
    try {
      const module = yield requirePromise(requirejs, moduleName);
      return module;
    } catch (err) {
      console.error(`thebe:loader requirejs error on cdn require`, err);
      throw err;
    }
  });
}
function requireLoader(requirejs, moduleName, moduleVersion, useCDNOnly = false) {
  return __awaiter(this, void 0, void 0, function* () {
    console.debug(`thebe:loader loading ${moduleName}@${moduleVersion}`);
    if (useCDNOnly) {
      return requireFromCDN(requirejs, moduleName, moduleVersion);
    } else {
      if (requirejs.require.defined(moduleName)) {
        return requirePromise(requirejs, moduleName);
      }
      console.debug(`thebe:loader falling back to ${cdn} for ${moduleName}@${moduleVersion}`);
      return requireFromCDN(requirejs, moduleName, moduleVersion);
    }
  });
}
var cdn;
var init_loader = __esm({
  "../../node_modules/thebe-core/dist/esm/loader.js"() {
    init_tslib_es6();
    cdn = "https://cdn.jsdelivr.net/npm/";
  }
});

// ../../node_modules/thebe-core/dist/esm/manager.js
var WIDGET_MIMETYPE, ThebeManager;
var init_manager3 = __esm({
  "../../node_modules/thebe-core/dist/esm/manager.js"() {
    init_tslib_es6();
    init_index_es63();
    init_index_es65();
    init_lib13();
    init_lib10();
    init_lib14();
    init_utils4();
    init_requireJsLoader();
    init_loader();
    WIDGET_MIMETYPE = "application/vnd.jupyter.widget-view+json";
    ThebeManager = class extends KernelWidgetManager {
      constructor(kernel, rendermime) {
        super(kernel, rendermime);
        this.id = shortId();
        this.addWidgetFactories();
        this._registerWidgets();
        this._loader = new RequireJsLoader();
      }
      addWidgetFactories() {
        this.rendermime.addFactory({
          safe: false,
          mimeTypes: [WIDGET_MIMETYPE],
          createRenderer: (options) => new WidgetRenderer(options, this)
        }, 1);
      }
      removeWidgetFactories() {
        this.rendermime.removeMimeType(WIDGET_MIMETYPE);
      }
      /**
       * TODO implement a reasonable method for thebe-core that can load serialized widget state
       * see: https://github.dev/voila-dashboards/voila/blob/7090eb3e30c0c4aa25c2b7d5d2d45e8de1333b3b/packages/voila/src/manager.ts#L52
       *
       */
      build_widgets() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("ThebeManager:build_widgets not implmented");
        });
      }
      display_view(msg, view, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (options.el) {
            Widget.attach(view.luminoWidget, options.el);
          }
          if (view.el) {
            view.el.setAttribute("data-thebe-jupyter-widget", "");
            view.el.addEventListener("jupyterWidgetResize", () => {
              MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
            });
          }
          return view.luminoWidget;
        });
      }
      loadClass(className, moduleName, moduleVersion) {
        const _super = Object.create(null, {
          loadClass: { get: () => super.loadClass }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._loader.requested) {
            console.debug(`thebe:manager:loadClass initial requirejs load ${this.id}`);
            this._loader.load((require2, define2) => {
              define2("@jupyter-widgets/base", lib_exports2);
              define2("@jupyter-widgets/controls", lib_exports4);
              define2("@jupyter-widgets/output", output_exports);
            });
          }
          console.debug(`thebe:manager:loadClass ${moduleName}@${moduleVersion}`);
          const rjs = yield this._loader.ready;
          if (moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls" || moduleName === "@jupyter-widgets/output") {
            return _super.loadClass.call(this, className, moduleName, moduleVersion);
          } else {
            let mod;
            try {
              mod = yield requireLoader(rjs, moduleName, moduleVersion);
            } catch (err) {
              console.error(`thebe:manager:loadClass loader error`, err);
              throw err;
            }
            if (mod[className]) {
              return mod[className];
            } else {
              console.error(`thebe:manager:loadClass ${className} not found in module ${moduleName}@${moduleVersion}`);
              throw new Error(`Class ${className} not found in module ${moduleName}@${moduleVersion}`);
            }
          }
        });
      }
      _registerWidgets() {
        this.register({
          name: "@jupyter-widgets/base",
          version: JUPYTER_WIDGETS_VERSION,
          exports: lib_exports2
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/controls",
          version: JUPYTER_CONTROLS_VERSION,
          exports: lib_exports4
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/output",
          version: output_exports.OUTPUT_WIDGET_VERSION,
          exports: output_exports
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/emitter.js
var EventEmitter;
var init_emitter = __esm({
  "../../node_modules/thebe-core/dist/esm/emitter.js"() {
    init_events();
    EventEmitter = class {
      constructor(id, config, subject, object2) {
        this._id = id;
        this._config = config;
        this._subject = subject;
        this._object = object2;
      }
      triggerStatus({ status, message }) {
        console.debug(`${status} ${message}`);
        this._config.events.trigger(ThebeEventType.status, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
      triggerError({ status, message }) {
        console.debug(`Error [${this._subject}][${this._id}] ${message}`);
        this._config.events.trigger(ThebeEventType.error, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/session.js
var ThebeSession, session_default;
var init_session = __esm({
  "../../node_modules/thebe-core/dist/esm/session.js"() {
    init_tslib_es6();
    init_events();
    init_manager3();
    init_emitter();
    ThebeSession = class {
      constructor(server, connection, rendermime) {
        var _a;
        this.server = server;
        this.connection = connection;
        this.events = new EventEmitter(this.connection.id, server.config, EventSubject.session, this);
        if (this.connection.kernel == null)
          throw Error("ThebeSession - kernel is null");
        this.manager = new ThebeManager(this.connection.kernel, rendermime);
        this.connection.statusChanged.connect((_5, s7) => {
          let status;
          switch (s7) {
            case "starting":
            case "restarting":
            case "autorestarting":
              status = SessionStatusEvent.starting;
              break;
            case "idle":
            case "busy":
              status = SessionStatusEvent.ready;
              break;
            case "terminating":
            case "dead":
            default:
              status = SessionStatusEvent.shutdown;
              break;
          }
          this.events.triggerStatus({
            status,
            message: `kernel ${this.connection.name} status changed to ${status}[${s7}]`
          });
          if (s7 === "dead") {
            this.events.triggerError({
              status: ErrorStatusEvent.session,
              message: `kernel ${this.connection.name} is dead`
            });
            this.dispose();
          }
        });
        this.connection.disposed.connect(() => {
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `kernel ${this.connection.name} disposed`
          });
        });
        this.events.triggerStatus({
          status: SessionStatusEvent.ready,
          message: `ThebeSession created, kernel '${(_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.name}' available`
        });
      }
      get id() {
        return this.connection.id;
      }
      get kernel() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel;
      }
      get path() {
        return this.connection.path;
      }
      get name() {
        return this.connection.name;
      }
      restart() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug(`requesting restart for kernel ${this.id}`);
          const p3 = (_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.restart();
          this.events.triggerStatus({
            status: SessionStatusEvent.starting,
            message: `Kernel restart requested`
          });
          yield p3;
          this.events.triggerStatus({
            status: SessionStatusEvent.ready,
            message: `session restarted, kernel '${(_b = this.connection.kernel) === null || _b === void 0 ? void 0 : _b.name}' available`
          });
        });
      }
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.connection.isDisposed)
            return;
          yield this.connection.shutdown();
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `session ${this.name}`
          });
          this.dispose();
        });
      }
      dispose() {
        if (!this.connection.isDisposed)
          this.connection.dispose();
      }
    };
    session_default = ThebeSession;
  }
});

// ../../node_modules/thebe-core/dist/esm/server.js
function responseToJson(res) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!res.ok)
      throw Error(`${res.status} - ${res.statusText}`);
    const json2 = yield res.json();
    return json2;
  });
}
function errorAsString(errorLike) {
  if (typeof errorLike === "string")
    return errorLike;
  if (errorLike.message)
    return errorLike.message;
  if (errorLike.status && errorLike.statusText)
    return `${errorLike.status} - ${errorLike.statusText}`;
  return JSON.stringify(errorLike);
}
var import_services4, ThebeServer, server_default;
var init_server = __esm({
  "../../node_modules/thebe-core/dist/esm/server.js"() {
    init_tslib_es6();
    init_url();
    init_sessions();
    import_services4 = __toESM(require_lib());
    init_session();
    init_utils4();
    init_events();
    init_emitter();
    ThebeServer = class {
      constructor(config) {
        this.id = shortId();
        this.config = config;
        this.events = new EventEmitter(this.id, config, EventSubject.server, this);
        this.ready = new Promise((resolve, reject4) => {
          this.resolveReadyFn = resolve;
          this.rejectReadyFn = reject4;
        });
        this._isDisposed = false;
      }
      get isBinder() {
        return !!this.binderUrls;
      }
      get isReady() {
        var _a, _b;
        return (_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.isReady) !== null && _b !== void 0 ? _b : false;
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get settings() {
        var _a;
        return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings;
      }
      shutdownSession(id) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdown(id);
        });
      }
      shutdownAllSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdownAll();
        });
      }
      check() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const resp = yield ThebeServer.status((_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings) !== null && _b !== void 0 ? _b : this.config.serverSettings);
          return resp.ok;
        });
      }
      dispose() {
        var _a, _b, _c, _d;
        if (this._isDisposed)
          return;
        if (!((_a = this.serviceManager) === null || _a === void 0 ? void 0 : _a.isDisposed))
          (_b = this.serviceManager) === null || _b === void 0 ? void 0 : _b.dispose();
        if (!((_c = this.sessionManager) === null || _c === void 0 ? void 0 : _c.isDisposed))
          (_d = this.sessionManager) === null || _d === void 0 ? void 0 : _d.dispose();
        this._isDisposed = true;
      }
      startNewSession(rendermime, kernelOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          let path = (_a = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.path) !== null && _a !== void 0 ? _a : this.config.kernels.path;
          let name = "thebe.ipynb";
          const match = path.match(/\/*([a-zA-Z0-9-]+.ipynb)$/);
          if (match) {
            name = match[1];
          }
          const kernelName = (_b = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.kernelName) !== null && _b !== void 0 ? _b : this.config.kernels.kernelName;
          console.debug("thebe:api:startNewSession server", this);
          console.debug("thebe:api:startNewSession", { name, path, kernelName });
          if (this.serviceManager) {
            path = path.slice(1).replace(/\//g, "-");
          }
          const connection = yield (_c = this.sessionManager) === null || _c === void 0 ? void 0 : _c.startNew({
            name,
            path,
            type: "notebook",
            kernel: {
              name: kernelName
            }
          });
          return new session_default(this, connection, rendermime);
        });
      }
      listRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          const iter = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.running();
          const models = [];
          let result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          while (result2 && !result2.done) {
            models.push(result2.value);
            result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          }
          return models;
        });
      }
      refreshRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          yield (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.refreshRunning();
          return this.listRunningSessions();
        });
      }
      connectToExistingSession(model, rendermime) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          const connection = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.connectTo({ model });
          return new session_default(this, connection, rendermime);
        });
      }
      clearSavedBinderSessions() {
        return __awaiter(this, void 0, void 0, function* () {
          const urls = this.makeBinderUrls();
          window.localStorage.removeItem(urls.storageKey);
        });
      }
      /**
       * Connect to a Jupyter server directly
       *
       */
      connectToJupyterServer() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug("thebe:api:connectToJupyterServer:serverSettings:", this.config.serverSettings);
          const serverSettings = import_services4.ServerConnection.makeSettings(this.config.serverSettings);
          try {
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Checking server url`
            });
            yield ThebeServer.status(serverSettings);
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Server reachable`
            });
          } catch (err) {
            const message = `Server not reachable (${serverSettings.baseUrl}) - ${err}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
            return;
          }
          const kernelManager = new import_services4.KernelManager({ serverSettings });
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Created KernelManager`
          });
          this.sessionManager = new import_services4.SessionManager({
            kernelManager,
            serverSettings
          });
          this.sessionManager.connectionFailure.connect((_5, err) => {
            this.events.triggerError({
              status: ErrorStatusEvent.server,
              message: `connection failure: ${err}`
            });
          });
          this.sessionManager.runningChanged.connect((_5, models) => {
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `${models.length} running sessions changed: ${models.map((m4) => m4.name).join(",")}`
            });
          });
          this.events.triggerStatus({
            status: ServerStatusEvent.ready,
            message: `Created SessionManager`
          });
          return this.sessionManager.ready.then(() => {
            var _a2;
            this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection ready`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      /**
       * Connect to Jupyterlite Server
       */
      connectToJupyterLiteServer(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to JupyterLite`
          });
          if (!window.thebeLite)
            throw new Error(`thebe-lite is not available at window.thebeLite - load this onto your page before loading thebe or thebe-core.`);
          this.serviceManager = yield window.thebeLite.startJupyterLiteServer(config);
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Started JupyterLite server`
          });
          console.debug("thebe:api:connectToJupyterLiteServer:serverSettings:", this.serviceManager.serverSettings);
          this.sessionManager = this.serviceManager.sessions;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Received SessionMananger from JupyterLite`
          });
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.ready.then(() => {
            var _a2;
            this.userServerUrl = "/";
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection established`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      makeBinderUrls() {
        var _a;
        return makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
      }
      checkForSavedBinderSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const { storageKey } = makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
            return getExistingServer(this.config.savedSessions, storageKey);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to check for saved session.`
            });
            return null;
          }
        });
      }
      /**
       * Connect to a Binder instance in order to
       * access a Jupyter server that can provide kernels
       *
       * @param ctx
       * @param opts
       * @returns
       */
      connectToServerViaBinder(customProviders) {
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to binderhub at ${this.config.binder.binderUrl}`
          });
          this.repoProviders = [...WELL_KNOWN_REPO_PROVIDERS, ...customProviders !== null && customProviders !== void 0 ? customProviders : []];
          try {
            this.binderUrls = makeBinderUrls(this.config, this.repoProviders);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to connect to binderhub at ${this.config.binder.binderUrl}`
            });
            return;
          }
          const urls = this.binderUrls;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Binder build url is ${urls.build}`
          });
          if (this.config.savedSessions.enabled) {
            console.debug("thebe:server:connectToServerViaBinder Checking for saved session...");
            const existingSettings = yield this.checkForSavedBinderSession();
            if (existingSettings) {
              const serverSettings = import_services4.ServerConnection.makeSettings(existingSettings);
              const kernelManager = new import_services4.KernelManager({ serverSettings });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              this.sessionManager = new import_services4.SessionManager({
                kernelManager,
                serverSettings
              });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              return this.sessionManager.ready.then(() => {
                var _a;
                this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
                this.events.triggerStatus({
                  status: ServerStatusEvent.ready,
                  message: `Re-connected to binder server`
                });
                (_a = this.resolveReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, this);
              }, (err) => {
                var _a;
                return (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, errorAsString(err));
              });
            }
          }
          const state = {
            status: ServerStatusEvent.launching
          };
          const es = new EventSource(urls.build);
          this.events.triggerStatus({
            status: state.status,
            message: `Opened connection to binder: ${urls.build}`
          });
          es.onerror = (evt) => {
            var _a;
            console.error(`Lost connection to binder: ${urls.build}`, evt);
            es === null || es === void 0 ? void 0 : es.close();
            state.status = ErrorStatusEvent.error;
            const data = evt === null || evt === void 0 ? void 0 : evt.data;
            const phase = data ? data.phase : "unknown";
            const message = `Lost connection to binder: ${urls.build}
phase: ${phase} - ${data ? data.message : "no message"}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
          };
          es.onmessage = (evt) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const msg = JSON.parse(evt.data);
            const phase = (_b = (_a = msg.phase) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
            switch (phase) {
              case "failed":
                es === null || es === void 0 ? void 0 : es.close();
                state.status = ErrorStatusEvent.error;
                this.events.triggerError({
                  status: ErrorStatusEvent.error,
                  message: `Binder: failed to build - ${urls.build} - ${msg.message}`
                });
                (_c = this.rejectReadyFn) === null || _c === void 0 ? void 0 : _c.call(this, msg.message);
                break;
              case "ready":
                {
                  es === null || es === void 0 ? void 0 : es.close();
                  const settings = {
                    baseUrl: msg.url,
                    wsUrl: "ws" + msg.url.slice(4),
                    token: msg.token,
                    appendToken: true
                  };
                  const serverSettings = import_services4.ServerConnection.makeSettings(settings);
                  const kernelManager = new import_services4.KernelManager({ serverSettings });
                  this.sessionManager = new import_services4.SessionManager({
                    kernelManager,
                    serverSettings
                  });
                  if (this.config.savedSessions.enabled) {
                    saveServerInfo(urls.storageKey, this.id, serverSettings);
                    console.debug(`thebe:server:connectToServerViaBinder Saved session for ${this.id} at ${urls.build}`);
                  }
                  yield this.sessionManager.ready;
                  this.userServerUrl = `${msg.url}?token=${msg.token}`;
                  state.status = ServerStatusEvent.ready;
                  this.events.triggerStatus({
                    status: state.status,
                    message: `Binder server is ready: ${msg.message}`
                  });
                  (_d = this.resolveReadyFn) === null || _d === void 0 ? void 0 : _d.call(this, this);
                }
                break;
              default:
                this.events.triggerStatus({
                  status: state.status,
                  message: `Binder is: ${phase} - ${msg.message}`
                });
            }
          });
        });
      }
      //
      // ServerRestAPI Implementation
      //
      getFetchUrl(relativeUrl) {
        var _a, _b;
        if (!this.sessionManager)
          throw new Error("Must connect to a server before requesting KernelSpecs");
        if (!((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings))
          throw new Error("No server settings available in session manager");
        const settings = (_b = this.sessionManager) === null || _b === void 0 ? void 0 : _b.serverSettings;
        const baseUrl = new URL(settings.baseUrl);
        const url = new URL(`${baseUrl.pathname}${relativeUrl}`.replace("//", "/"), baseUrl.origin);
        url.searchParams.append("token", settings.token);
        return url;
      }
      static status(serverSettings) {
        return import_services4.ServerConnection.makeRequest(`${serverSettings.baseUrl}api/status`, {}, import_services4.ServerConnection.makeSettings(serverSettings));
      }
      getKernelSpecs() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.sessionManager)
            throw new Error("Must connect to a server before requesting KernelSpecs");
          return import_services4.KernelSpecAPI.getSpecs(import_services4.ServerConnection.makeSettings((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings));
        });
      }
      getContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          if (opts.type)
            url.searchParams.append("type", opts.type);
          if (opts.format)
            url.searchParams.append("format", opts.format);
          url.searchParams.append("content", opts.returnContent ? "1" : "0");
          return responseToJson(yield fetch(url));
        });
      }
      duplicateFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          const { copy_from, ext, type: type2 } = opts;
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ copy_from, ext, type: type2 })
          }));
        });
      }
      createDirectory(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "directory" })
          }));
        });
      }
      renameContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path, newPath } = opts;
          const url = this.getFetchUrl(`/api/contents/${path}`);
          return responseToJson(yield fetch(url, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ path: newPath })
          }));
        });
      }
      uploadFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path, content, format: format2, type: type2 } = opts;
          const url = this.getFetchUrl(`/api/contents/${path}`);
          console.debug("thebe:api:server:uploadFile", url);
          return responseToJson(yield fetch(url, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path,
              content,
              format: format2 !== null && format2 !== void 0 ? format2 : "json",
              type: type2 !== null && type2 !== void 0 ? type2 : "notebook"
            })
          }));
        });
      }
    };
    server_default = ThebeServer;
  }
});

// ../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_coreutils = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.JSONExt = void 0;
      (function(JSONExt13) {
        JSONExt13.emptyObject = Object.freeze({});
        JSONExt13.emptyArray = Object.freeze([]);
        function isPrimitive(value) {
          return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
        }
        JSONExt13.isPrimitive = isPrimitive;
        function isArray(value) {
          return Array.isArray(value);
        }
        JSONExt13.isArray = isArray;
        function isObject5(value) {
          return !isPrimitive(value) && !isArray(value);
        }
        JSONExt13.isObject = isObject5;
        function deepEqual2(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (isPrimitive(first2) || isPrimitive(second)) {
            return false;
          }
          var a1 = isArray(first2);
          var a22 = isArray(second);
          if (a1 !== a22) {
            return false;
          }
          if (a1 && a22) {
            return deepArrayEqual(first2, second);
          }
          return deepObjectEqual(first2, second);
        }
        JSONExt13.deepEqual = deepEqual2;
        function deepCopy(value) {
          if (isPrimitive(value)) {
            return value;
          }
          if (isArray(value)) {
            return deepArrayCopy(value);
          }
          return deepObjectCopy(value);
        }
        JSONExt13.deepCopy = deepCopy;
        function deepArrayEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (first2.length !== second.length) {
            return false;
          }
          for (var i5 = 0, n4 = first2.length; i5 < n4; ++i5) {
            if (!deepEqual2(first2[i5], second[i5])) {
              return false;
            }
          }
          return true;
        }
        function deepObjectEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          for (var key in first2) {
            if (first2[key] !== void 0 && !(key in second)) {
              return false;
            }
          }
          for (var key in second) {
            if (second[key] !== void 0 && !(key in first2)) {
              return false;
            }
          }
          for (var key in first2) {
            var firstValue = first2[key];
            var secondValue = second[key];
            if (firstValue === void 0 && secondValue === void 0) {
              continue;
            }
            if (firstValue === void 0 || secondValue === void 0) {
              return false;
            }
            if (!deepEqual2(firstValue, secondValue)) {
              return false;
            }
          }
          return true;
        }
        function deepArrayCopy(value) {
          var result2 = new Array(value.length);
          for (var i5 = 0, n4 = value.length; i5 < n4; ++i5) {
            result2[i5] = deepCopy(value[i5]);
          }
          return result2;
        }
        function deepObjectCopy(value) {
          var result2 = {};
          for (var key in value) {
            var subvalue = value[key];
            if (subvalue === void 0) {
              continue;
            }
            result2[key] = deepCopy(subvalue);
          }
          return result2;
        }
      })(exports2.JSONExt || (exports2.JSONExt = {}));
      var MimeData2 = (
        /** @class */
        function() {
          function MimeData3() {
            this._types = [];
            this._values = [];
          }
          MimeData3.prototype.types = function() {
            return this._types.slice();
          };
          MimeData3.prototype.hasData = function(mime) {
            return this._types.indexOf(mime) !== -1;
          };
          MimeData3.prototype.getData = function(mime) {
            var i5 = this._types.indexOf(mime);
            return i5 !== -1 ? this._values[i5] : void 0;
          };
          MimeData3.prototype.setData = function(mime, data) {
            this.clearData(mime);
            this._types.push(mime);
            this._values.push(data);
          };
          MimeData3.prototype.clearData = function(mime) {
            var i5 = this._types.indexOf(mime);
            if (i5 !== -1) {
              this._types.splice(i5, 1);
              this._values.splice(i5, 1);
            }
          };
          MimeData3.prototype.clear = function() {
            this._types.length = 0;
            this._values.length = 0;
          };
          return MimeData3;
        }()
      );
      var PromiseDelegate8 = (
        /** @class */
        function() {
          function PromiseDelegate9() {
            var _this = this;
            this.promise = new Promise(function(resolve, reject4) {
              _this._resolve = resolve;
              _this._reject = reject4;
            });
          }
          PromiseDelegate9.prototype.resolve = function(value) {
            var resolve = this._resolve;
            resolve(value);
          };
          PromiseDelegate9.prototype.reject = function(reason) {
            var reject4 = this._reject;
            reject4(reason);
          };
          return PromiseDelegate9;
        }()
      );
      var Token4 = (
        /** @class */
        function() {
          function Token5(name) {
            this.name = name;
            this._tokenStructuralPropertyT = null;
          }
          return Token5;
        }()
      );
      function fallbackRandomValues(buffer) {
        var value = 0;
        for (var i5 = 0, n4 = buffer.length; i5 < n4; ++i5) {
          if (i5 % 4 === 0) {
            value = Math.random() * 4294967295 >>> 0;
          }
          buffer[i5] = value & 255;
          value >>>= 8;
        }
      }
      exports2.Random = void 0;
      (function(Random) {
        Random.getRandomValues = function() {
          var crypto2 = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
          if (crypto2 && typeof crypto2.getRandomValues === "function") {
            return function getRandomValues(buffer) {
              return crypto2.getRandomValues(buffer);
            };
          }
          return fallbackRandomValues;
        }();
      })(exports2.Random || (exports2.Random = {}));
      function uuid4Factory(getRandomValues) {
        var bytes = new Uint8Array(16);
        var lut = new Array(256);
        for (var i5 = 0; i5 < 16; ++i5) {
          lut[i5] = "0" + i5.toString(16);
        }
        for (var i5 = 16; i5 < 256; ++i5) {
          lut[i5] = i5.toString(16);
        }
        return function uuid4() {
          getRandomValues(bytes);
          bytes[6] = 64 | bytes[6] & 15;
          bytes[8] = 128 | bytes[8] & 63;
          return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
        };
      }
      exports2.UUID = void 0;
      (function(UUID6) {
        UUID6.uuid4 = uuid4Factory(exports2.Random.getRandomValues);
      })(exports2.UUID || (exports2.UUID = {}));
      exports2.MimeData = MimeData2;
      exports2.PromiseDelegate = PromiseDelegate8;
      exports2.Token = Token4;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyterlab/mathjax2/lib/index.js
var import_coreutils28, MathJaxTypesetter;
var init_lib15 = __esm({
  "../../node_modules/@jupyterlab/mathjax2/lib/index.js"() {
    import_coreutils28 = __toESM(require_dist2());
    MathJaxTypesetter = class {
      /**
       * Create a new MathJax typesetter.
       */
      constructor(options) {
        this._initPromise = new import_coreutils28.PromiseDelegate();
        this._initialized = false;
        this._url = options.url;
        this._config = options.config;
      }
      /**
       * Typeset the math in a node.
       *
       * #### Notes
       * MathJax schedules the typesetting asynchronously,
       * but there are not currently any callbacks or Promises
       * firing when it is done.
       */
      typeset(node) {
        if (!this._initialized) {
          this._init();
        }
        void this._initPromise.promise.then(() => {
          MathJax.Hub.Queue(["Typeset", MathJax.Hub, node]);
          try {
            MathJax.Hub.Queue(["Require", MathJax.Ajax, "[MathJax]/extensions/TeX/AMSmath.js"], () => {
              MathJax.InputJax.TeX.resetEquationNumbers();
            });
          } catch (e4) {
            console.error("Error queueing resetEquationNumbers:", e4);
          }
        });
      }
      /**
       * Initialize MathJax.
       */
      _init() {
        const head = document.getElementsByTagName("head")[0];
        const script = document.createElement("script");
        script.type = "text/javascript";
        script.src = `${this._url}?config=${this._config}&amp;delayStartupUntil=configured`;
        script.charset = "utf-8";
        head.appendChild(script);
        script.addEventListener("load", () => {
          this._onLoad();
        });
        this._initialized = true;
      }
      /**
       * Handle MathJax loading.
       */
      _onLoad() {
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [
              ["$", "$"],
              ["\\(", "\\)"]
            ],
            displayMath: [
              ["$$", "$$"],
              ["\\[", "\\]"]
            ],
            processEscapes: true,
            processEnvironments: true
          },
          // Center justify equations in code and markdown cells. Elsewhere
          // we use CSS to left justify single line equations in code cells.
          displayAlign: "center",
          CommonHTML: {
            linebreaks: { automatic: true }
          },
          "HTML-CSS": {
            availableFonts: [],
            imageFont: null,
            preferredFont: null,
            webFont: "STIX-Web",
            styles: { ".MathJax_Display": { margin: 0 } },
            linebreaks: { automatic: true }
          },
          skipStartupTypeset: true,
          messageStyle: "none"
        });
        MathJax.Hub.Register.StartupHook("End Config", () => {
          var _a, _b, _c, _d, _e, _f;
          (_c = (_b = (_a = MathJax.Hub) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.MathEvents) === null || _c === void 0 ? true : delete _c.styles[".MathJax_Hover_Arrow:hover span"];
          (_f = (_e = (_d = MathJax.Hub) === null || _d === void 0 ? void 0 : _d.config) === null || _e === void 0 ? void 0 : _e.MathMenu) === null || _f === void 0 ? true : delete _f.styles[".MathJax_MenuClose:hover span"];
        });
        MathJax.Hub.Configured();
        this._initPromise.resolve(void 0);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/javascript-extension/lib/index.js
function evalInContext(code, element, document, window) {
  return eval(code);
}
var TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE, ExperimentalRenderedJavascript, rendererFactory, extension, lib_default;
var init_lib16 = __esm({
  "../../node_modules/@jupyterlab/javascript-extension/lib/index.js"() {
    init_lib8();
    TEXT_JAVASCRIPT_MIMETYPE = "text/javascript";
    APPLICATION_JAVASCRIPT_MIMETYPE = "application/javascript";
    ExperimentalRenderedJavascript = class extends RenderedJavaScript {
      render(model) {
        const trans = this.translator.load("jupyterlab");
        const renderJavascript = () => {
          try {
            const data = model.data[this.mimeType];
            if (data) {
              evalInContext(data, this.node, document, window);
            }
            return Promise.resolve();
          } catch (error) {
            return Promise.reject(error);
          }
        };
        if (!model.trusted) {
          const pre = document.createElement("pre");
          pre.textContent = trans.__("Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
          const button = document.createElement("button");
          button.textContent = trans.__("Run");
          this.node.appendChild(pre);
          this.node.appendChild(button);
          button.onclick = (event) => {
            this.node.textContent = "";
            void renderJavascript();
          };
          return Promise.resolve();
        }
        return renderJavascript();
      }
    };
    rendererFactory = {
      safe: false,
      mimeTypes: [TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE],
      createRenderer: (options) => new ExperimentalRenderedJavascript(options)
    };
    extension = {
      id: "@jupyterlab/javascript-extension:factory",
      description: "Adds renderer for JavaScript content.",
      rendererFactory,
      rank: 0,
      dataType: "string"
    };
    lib_default = extension;
  }
});

// ../../node_modules/@jupyterlab/json-extension/lib/index.js
var React66, import_client, CSS_CLASS, MIME_TYPE, RenderedJSON, rendererFactory2;
var init_lib17 = __esm({
  "../../node_modules/@jupyterlab/json-extension/lib/index.js"() {
    init_lib5();
    init_lib();
    init_index_es63();
    React66 = __toESM(require_react());
    import_client = __toESM(require_client());
    CSS_CLASS = "jp-RenderedJSON";
    MIME_TYPE = "application/json";
    RenderedJSON = class extends Widget {
      /**
       * Create a new widget for rendering JSON.
       */
      constructor(options) {
        super();
        this._rootDOM = null;
        this.addClass(CSS_CLASS);
        this.addClass("CodeMirror");
        this._mimeType = options.mimeType;
        this.translator = options.translator || nullTranslator;
      }
      [Printing.symbol]() {
        return () => Printing.printWidget(this);
      }
      /**
       * Render JSON into this widget's node.
       */
      async renderModel(model) {
        const { Component } = await import("/myst_assets_folder/_shared/component-WSYCTQ3T.js");
        const data = model.data[this._mimeType] || {};
        const metadata = model.metadata[this._mimeType] || {};
        if (this._rootDOM === null) {
          this._rootDOM = (0, import_client.createRoot)(this.node);
        }
        return new Promise((resolve, reject4) => {
          this._rootDOM.render(React66.createElement(Component, { data, metadata, translator: this.translator, forwardedRef: () => resolve() }));
        });
      }
      /**
       * Called before the widget is detached from the DOM.
       */
      onBeforeDetach(msg) {
        if (this._rootDOM) {
          this._rootDOM.unmount();
          this._rootDOM = null;
        }
      }
    };
    rendererFactory2 = {
      safe: true,
      mimeTypes: [MIME_TYPE],
      createRenderer: (options) => new RenderedJSON(options)
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/config.js
var Config;
var init_config = __esm({
  "../../node_modules/thebe-core/dist/esm/config.js"() {
    init_options();
    init_events();
    Config = class {
      constructor(opts = {}, extraConfig) {
        var _a, _b, _c, _d, _e, _f, _g;
        this._events = (_a = extraConfig === null || extraConfig === void 0 ? void 0 : extraConfig.events) !== null && _a !== void 0 ? _a : new ThebeEvents();
        this._options = {
          mathjaxUrl: (_b = opts.mathjaxUrl) !== null && _b !== void 0 ? _b : "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js",
          mathjaxConfig: (_c = opts.mathjaxConfig) !== null && _c !== void 0 ? _c : "TeX-AMS_CHTML-full,Safe"
        };
        this._binderOptions = makeBinderOptions((_d = opts.binderOptions) !== null && _d !== void 0 ? _d : {});
        this._savedSessions = makeSavedSessionOptions((_e = opts.savedSessionOptions) !== null && _e !== void 0 ? _e : {});
        this._kernelOptions = makeKernelOptions((_f = opts.kernelOptions) !== null && _f !== void 0 ? _f : {});
        this._serverSettings = makeServerSettings((_g = opts.serverSettings) !== null && _g !== void 0 ? _g : {});
        console.debug("thebe:config:constructor", this);
      }
      get events() {
        return this._events;
      }
      get base() {
        return this._options;
      }
      get mathjax() {
        return {
          mathjaxUrl: this._options.mathjaxUrl,
          mathjaxConfig: this._options.mathjaxConfig
        };
      }
      get binder() {
        return this._binderOptions;
      }
      get savedSessions() {
        return this._savedSessions;
      }
      get kernels() {
        return this._kernelOptions;
      }
      get serverSettings() {
        return this._serverSettings;
      }
      set serverSettings(newSettings) {
        this._serverSettings = newSettings;
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/options.js
function makeBinderOptions(opts) {
  return Object.assign({ repo: "executablebooks/thebe-binder-base", ref: "HEAD", binderUrl: "https://mybinder.org", repoProvider: "github" }, opts);
}
function makeSavedSessionOptions(opts) {
  return Object.assign({ enabled: true, maxAge: 86400, storagePrefix: "thebe-binder" }, opts);
}
function makeKernelOptions(opts) {
  var _a, _b;
  return {
    path: (_a = opts.path) !== null && _a !== void 0 ? _a : "/",
    kernelName: (_b = opts.kernelName) !== null && _b !== void 0 ? _b : "python"
  };
}
function makeServerSettings(settings) {
  var _a, _b;
  const baseUrl = (_a = settings.baseUrl) !== null && _a !== void 0 ? _a : "http://localhost:8888";
  const wsUrl = (_b = settings.wsUrl) !== null && _b !== void 0 ? _b : baseUrl.replace(/^http/, "ws");
  return Object.assign(Object.assign({ token: shortId(), appendToken: true }, settings), {
    wsUrl,
    baseUrl
  });
}
function makeMathjaxOptions(opts) {
  return Object.assign({ mathjaxUrl: "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js", mathjaxConfig: "TeX-AMS_CHTML-full,Safe" }, opts);
}
function makeConfiguration(options, events2) {
  return new Config(options, { events: events2 });
}
function ensureCoreOptions(options, events2) {
  const config = new Config(options, { events: events2 });
  return Object.assign(Object.assign({}, config.base), { binderOptions: config.binder, savedSessionOptions: config.savedSessions, kernelOptions: config.kernels, serverSettings: config.serverSettings });
}
var init_options = __esm({
  "../../node_modules/thebe-core/dist/esm/options.js"() {
    init_config();
    init_utils4();
  }
});

// ../../node_modules/thebe-core/dist/esm/rendermime.js
function getRenderers(mathjax) {
  if (RENDERERS == null) {
    RENDERERS = EXTENDED_FACTORIES.filter((f6) => {
      if (f6.mimeTypes.indexOf("text/latex") >= 0) {
        if (mathjax.mathjaxUrl) {
          return true;
        } else {
          console.debug("thebe:getRenderers MathJax unavailable");
          return false;
        }
      } else {
        return true;
      }
    });
  }
  let latexTypesetter;
  if (mathjax.mathjaxUrl && mathjax.mathjaxConfig) {
    latexTypesetter = new MathJaxTypesetter({
      url: mathjax.mathjaxUrl,
      config: mathjax.mathjaxConfig
    });
  }
  return {
    initialFactories: [...RENDERERS],
    latexTypesetter
  };
}
function makeRenderMimeRegistry(mathjax) {
  const rendermime = new RenderMimeRegistry(getRenderers(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions()));
  rendermime.addFactory(rendererFactory2, 10);
  return rendermime;
}
var EXTENDED_FACTORIES, RENDERERS;
var init_rendermime = __esm({
  "../../node_modules/thebe-core/dist/esm/rendermime.js"() {
    init_lib8();
    init_lib15();
    init_lib16();
    init_lib17();
    init_options();
    EXTENDED_FACTORIES = [
      htmlRendererFactory,
      markdownRendererFactory,
      latexRendererFactory,
      svgRendererFactory,
      imageRendererFactory,
      rendererFactory,
      textRendererFactory
    ];
    RENDERERS = null;
  }
});

// ../../node_modules/thebe-core/dist/esm/passive.js
var PassiveCellRenderer, passive_default;
var init_passive = __esm({
  "../../node_modules/thebe-core/dist/esm/passive.js"() {
    init_rendermime();
    init_lib9();
    init_options();
    init_index_es63();
    init_index_es65();
    PassiveCellRenderer = class {
      constructor(id, rendermime, mathjax) {
        this.id = id;
        this.rendermime = rendermime !== null && rendermime !== void 0 ? rendermime : makeRenderMimeRegistry(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions());
        this.model = new OutputAreaModel({ trusted: true });
        this.area = new OutputArea({
          model: this.model,
          rendermime: this.rendermime
        });
      }
      /**
       * Serialize the model state to JSON
       */
      get outputs() {
        return this.model.toJSON();
      }
      get isAttachedToDOM() {
        return this.area.isAttached;
      }
      attachToDOM(el, strict = false) {
        if (!this.area || !el) {
          console.error(`thebe:renderer:attachToDOM - could not attach to DOM - area: ${this.area}, el: ${el}`);
          return;
        }
        if (this.area.isAttached) {
          console.debug(`thebe:renderer:attachToDOM - already attached`);
          if (strict)
            return;
        } else {
          console.debug(`thebe:renderer:attachToDOM ${this.id} - appending existing contents`);
          if (el.innerHTML) {
            this.area.model.add({
              output_type: "display_data",
              data: {
                "text/html": el.innerHTML
              }
            });
          }
        }
        el.textContent = "";
        const div = document.createElement("div");
        div.style.position = "relative";
        div.className = "thebe-output";
        el.append(div);
        MessageLoop.sendMessage(this.area, Widget.Msg.BeforeAttach);
        div.appendChild(this.area.node);
        MessageLoop.sendMessage(this.area, Widget.Msg.AfterAttach);
      }
      setOutputText(text) {
        if (!this.area)
          return;
        this.area.model.clear(true);
        this.area.model.add({
          output_type: "stream",
          name: "stdout",
          text
        });
      }
      /**
       * Clears the output area model
       *
       * @returns
       */
      clear() {
        if (!this.area)
          return;
        this.area.model.clear();
      }
      /**
       * Will trigger the output to render an error with text taken from the optional argument
       *
       * @param error
       * @returns
       */
      clearOnError(error) {
        if (!this.area)
          return;
        this.area.model.clear();
        this.area.model.add({
          output_type: "stream",
          name: "stderr",
          text: `Failed to execute. ${error !== null && error !== void 0 ? error : ""} Please refresh the page.`
        });
      }
      /**
       * Render output data directly from json
       *
       * @param outputs - serialised jupyter outputs
       * @returns
       */
      render(outputs) {
        this.model.fromJSON(outputs);
      }
    };
    passive_default = PassiveCellRenderer;
  }
});

// ../../node_modules/thebe-core/dist/esm/cell.js
var ThebeCodeCell, cell_default;
var init_cell = __esm({
  "../../node_modules/thebe-core/dist/esm/cell.js"() {
    init_tslib_es6();
    init_passive();
    init_events();
    init_emitter();
    init_utils4();
    ThebeCodeCell = class extends passive_default {
      constructor(id, notebookId, source, config, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "code";
        this.events = new EventEmitter(id, config, EventSubject.cell, this);
        this.notebookId = notebookId;
        this.source = source;
        this.metadata = metadata;
        this.busy = false;
        this.executionCount = null;
        this.initialOutputs = [];
        console.debug("thebe:cell constructor", this);
      }
      static fromICodeCell(icc, notebookId, config, rendermime) {
        var _a;
        const cell = new ThebeCodeCell((_a = icc.id) !== null && _a !== void 0 ? _a : shortId(), notebookId, ensureString2(icc.source), config, icc.metadata, rendermime);
        Object.assign(cell.metadata, icc.metadata);
        return cell;
      }
      get isBusy() {
        return this.busy;
      }
      get isAttached() {
        return this.session !== void 0;
      }
      get tags() {
        var _a;
        return (_a = this.metadata.tags) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Attaches to the session and adds the widgets factory to the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::attachSession
       *
       * @param session
       */
      attachSession(session) {
        this.session = session;
        this.events.triggerStatus({
          status: CellStatusEvent.attached,
          message: "Attached to session"
        });
      }
      /**
       * Detaches from the session and removes the widgets factory from the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::detachSession
       *
       */
      detachSession() {
        this.session = void 0;
        this.events.triggerStatus({
          status: CellStatusEvent.detached,
          message: "Detached from session"
        });
      }
      setAsBusy() {
        console.debug(`thebe:renderer:message:busy ${this.id}`);
        this.busy = true;
        this.events.triggerStatus({
          status: CellStatusEvent.executing,
          message: "Executing..."
        });
      }
      setAsIdle() {
        console.debug(`thebe:renderer:message:completed ${this.id}`);
        this.busy = false;
        this.events.triggerStatus({
          status: CellStatusEvent.idle,
          message: "Completed"
        });
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      initOutputs(initialOutputs) {
        this.initialOutputs = initialOutputs;
        this.render(initialOutputs);
        this.executionCount = null;
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      reset() {
        this.render(this.initialOutputs);
        this.executionCount = null;
      }
      /**
       * TODO
       *  - pass execute_count or timestamp or something back to redux on success/failure?
       *
       * @param source?
       * @returns
       */
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.session || !this.session.kernel) {
            console.warn("Attempting to execute on a cell without an attached kernel");
            return null;
          }
          const code3 = source !== null && source !== void 0 ? source : this.source;
          try {
            console.debug(`thebe:renderer:execute ${this.id}`);
            if (!this.isBusy)
              this.setAsBusy();
            this.area.future = this.session.kernel.requestExecute({ code: code3 });
            const reply = yield this.area.future.done;
            this.executionCount = reply.content.execution_count;
            let executeErrors;
            for (let i5 = 0; i5 < this.model.length; i5++) {
              const out = this.model.get(i5);
              console.debug("thebecell:execute:output", { out: out.toJSON() });
              if (out.type === "error") {
                const json2 = out.toJSON();
                if (json2.ename === "stderr") {
                  this.events.triggerError({
                    status: ErrorStatusEvent.warning,
                    message: errorToMessage(json2)
                  });
                } else {
                  if (!executeErrors)
                    executeErrors = [json2];
                  else
                    executeErrors === null || executeErrors === void 0 ? void 0 : executeErrors.push(json2);
                  this.events.triggerError({
                    status: ErrorStatusEvent.executeError,
                    message: errorToMessage(json2)
                  });
                }
              }
            }
            this.setAsIdle();
            return {
              id: this.id,
              height: this.area.node.offsetHeight,
              width: this.area.node.offsetWidth,
              error: executeErrors
            };
          } catch (err) {
            console.error("thebe:renderer:execute Error:", err);
            this.clearOnError(err);
            this.events.triggerError(err.message);
            return null;
          }
        });
      }
    };
    cell_default = ThebeCodeCell;
  }
});

// ../../node_modules/thebe-core/dist/esm/markdown.js
var ThebeMarkdownCell;
var init_markdown = __esm({
  "../../node_modules/thebe-core/dist/esm/markdown.js"() {
    init_tslib_es6();
    init_passive();
    init_utils4();
    ThebeMarkdownCell = class extends passive_default {
      constructor(id, notebookId, source, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "markdown";
        this.id = id;
        this.notebookId = notebookId;
        this.source = source;
        this.busy = false;
        this.metadata = metadata;
      }
      static fromICell(ic, notebookId, rendermime) {
        const cell = new ThebeMarkdownCell(typeof ic.id === "string" ? ic.id : shortId(), notebookId, ensureString2(ic.source), ic.metadata, rendermime);
        return cell;
      }
      get isAttachedToDOM() {
        return false;
      }
      get isBusy() {
        return false;
      }
      get isAttached() {
        return false;
      }
      get executionCount() {
        return null;
      }
      setAsBusy() {
      }
      setAsIdle() {
      }
      initOutputs(initialOutputs) {
      }
      reset() {
      }
      attachToDOM(el) {
      }
      attachSession(session) {
      }
      detachSession() {
      }
      setOutputText(text) {
      }
      clear() {
      }
      clearOnError(error) {
      }
      messageBusy() {
      }
      messageCompleted() {
      }
      messageError(message) {
      }
      render(outputs) {
      }
      get tags() {
        return [];
      }
      get outputs() {
        return [];
      }
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          return { id: this.id, height: 0, width: 0 };
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/notebook.js
var ThebeNotebook, notebook_default;
var init_notebook = __esm({
  "../../node_modules/thebe-core/dist/esm/notebook.js"() {
    init_tslib_es6();
    init_cell();
    init_utils4();
    init_events();
    init_emitter();
    init_markdown();
    ThebeNotebook = class {
      constructor(id, config, rendermime) {
        this.id = id;
        this.events = new EventEmitter(id, config, EventSubject.notebook, this);
        this.cells = [];
        this.metadata = {};
        this.rendermime = rendermime;
        console.debug("thebe:notebook constructor", this);
      }
      static fromCodeBlocks(blocks, config, rendermime) {
        const id = shortId();
        const notebook = new ThebeNotebook(id, config, rendermime);
        notebook.cells = blocks.map((c6) => {
          const metadata = {};
          const cell = new cell_default(c6.id, id, c6.source, config, metadata, notebook.rendermime);
          console.debug(`thebe:notebook:fromCodeBlocks Initializing cell ${c6.id}`);
          return cell;
        });
        return notebook;
      }
      static fromIpynb(ipynb, config, rendermime) {
        const notebook = new ThebeNotebook(shortId(), config, rendermime);
        Object.assign(notebook.metadata, ipynb.metadata);
        notebook.cells = ipynb.cells.map((c6) => {
          if (c6.cell_type === "code")
            return cell_default.fromICodeCell(c6, notebook.id, config, notebook.rendermime);
          return ThebeMarkdownCell.fromICell(c6, notebook.id, notebook.rendermime);
        });
        return notebook;
      }
      get parameters() {
        const p3 = this.findCells("parameters");
        if (!p3 || (p3 === null || p3 === void 0 ? void 0 : p3.length) === 0)
          return void 0;
        if (p3.length > 1)
          console.warn(`Mulitple parameter cells found in notebook ${this.id}`);
        return p3;
      }
      get widgets() {
        var _a;
        return (_a = this.findCells("widget")) !== null && _a !== void 0 ? _a : [];
      }
      get last() {
        if (this.cells.length === 0)
          throw new Error("empty notebook");
        return this.cells[this.cells.length - 1];
      }
      get markdown() {
        return this.cells.filter((c6) => c6.kind === "markdown");
      }
      get code() {
        return this.cells.filter((c6) => c6.kind === "code");
      }
      /**
       * reset the notebook to its initial state by resetting each cell
       *
       * @param hideWidgets boolean
       */
      reset() {
        this.cells.forEach((cell) => cell.reset());
      }
      numCells() {
        var _a, _b;
        return (_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      findCells(tag) {
        const found = this.cells.filter((c6) => c6.tags.includes(tag));
        return found.length > 0 ? found : void 0;
      }
      getCell(idx) {
        if (!this.cells)
          throw Error("Dag not initialized");
        if (idx >= this.cells.length)
          throw Error(`Notebook.cells index out of range: ${idx}:${this.cells.length}`);
        return this.cells[idx];
      }
      getCellById(id) {
        var _a;
        const cell = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.find((c6) => c6.id === id);
        return cell;
      }
      lastCell() {
        if (!this.cells)
          throw Error("Notebook not initialized");
        return this.cells[this.cells.length - 1];
      }
      updateParameters(newSource, interpolate = false) {
        if (interpolate)
          throw new Error("Not implemented yet");
        if (this.parameters)
          this.parameters[0].source = newSource;
      }
      waitForKernel(kernel) {
        return __awaiter(this, void 0, void 0, function* () {
          return kernel.then((k) => {
            this.attachSession(k);
            return k;
          });
        });
      }
      attachSession(session) {
        var _a;
        if (!session.kernel)
          throw Error("ThebeNotebook - cannot connect to session, no kernel");
        this.session = session;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.forEach((cell) => cell.session = session);
        this.events.triggerStatus({
          status: NotebookStatusEvent.attached,
          message: "Attached to session"
        });
      }
      detachSession() {
        var _a;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.map((cell) => cell.session = void 0);
        this.session = void 0;
        this.events.triggerStatus({
          status: NotebookStatusEvent.detached,
          message: "Detached from session"
        });
      }
      clear() {
        this.cells.forEach((cell) => cell.clear());
      }
      executeUpTo(cellId, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeUpTo ${cellId}`
          });
          const idx = this.cells.findIndex((c6) => c6.id === cellId);
          if (idx === -1)
            return [];
          const cellsToExecute = this.cells.slice(0, idx + 1);
          cellsToExecute.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(cellsToExecute.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2;
        });
      }
      executeOnly(cellId, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return null;
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeOnly ${cellId}`
          });
          const result2 = yield this.executeCells([cellId], false, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2[0];
        });
      }
      executeCells(cellIds, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeCells ${cellIds.length} cells`
          });
          const cells = this.cells.filter((c6) => {
            const found = cellIds.find((id) => id === c6.id);
            if (!found) {
              console.warn(`Cell ${c6.id} not found in notebook`);
            }
            return Boolean(found);
          });
          let result2 = [];
          if (stopOnError) {
            let skipRemaining = false;
            for (const cell of cells) {
              if (skipRemaining)
                continue;
              const cellReturn = yield cell.execute(preprocessor ? preprocessor(cell.source) : cell.source);
              if (cellReturn == null || cellReturn.error)
                skipRemaining = true;
              result2.push(cellReturn);
            }
          } else {
            result2 = yield Promise.all(cells.map((cell) => cell.execute(preprocessor ? preprocessor(cell.source) : cell.source)));
          }
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeCells executed ${cellIds.length} cells`
          });
          return result2;
        });
      }
      executeAll(stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeAll`
          });
          this.cells.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(this.cells.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeAll`
          });
          return result2;
        });
      }
    };
    notebook_default = ThebeNotebook;
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/api.js
function connectToBinder(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect binder \u{1F4E1}`, config.binder);
  server.connectToServerViaBinder();
  return server;
}
function connectToJupyter(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect direct \u{1F50C}`, config.serverSettings);
  server.connectToJupyterServer();
  return server;
}
function connectToJupyterLite(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect JupyterLite \u{1F918}`);
  server.connectToJupyterLiteServer();
  return server;
}
function makeEvents() {
  return new ThebeEvents();
}
function makeServer(config) {
  return new server_default(config);
}
function setupNotebookFromBlocks(blocks, config, rendermime) {
  return notebook_default.fromCodeBlocks(blocks, config, rendermime);
}
function setupNotebookFromIpynb(ipynb, config, rendermime) {
  return notebook_default.fromIpynb(ipynb, config, rendermime);
}
function setupThebeCore() {
  var _a;
  console.debug(`thebe:api:setupThebeCore`, { coreModule: esm_exports });
  window.thebeCore = Object.assign((_a = window.thebeCore) !== null && _a !== void 0 ? _a : {}, {
    module: esm_exports,
    api: {
      makeConfiguration,
      makeEvents,
      makeServer,
      makeRenderMimeRegistry,
      connectToBinder,
      connectToJupyter,
      connectToJupyterLite,
      setupNotebookFromBlocks,
      setupNotebookFromIpynb
    }
  });
}
var init_api = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/api.js"() {
    init_server();
    init_notebook();
    init_events();
    init_options();
    init_rendermime();
    init_esm();
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js
var init_entrypoint = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js"() {
    init_api();
    if (typeof window !== "undefined")
      setupThebeCore();
  }
});

// ../../node_modules/thebe-core/dist/esm/types.js
var init_types = __esm({
  "../../node_modules/thebe-core/dist/esm/types.js"() {
  }
});

// ../../node_modules/thebe-core/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CellStatusEvent: () => CellStatusEvent,
  Config: () => Config,
  ErrorStatusEvent: () => ErrorStatusEvent,
  EventSubject: () => EventSubject,
  KernelStatusEvent: () => KernelStatusEvent,
  NotebookStatusEvent: () => NotebookStatusEvent,
  PassiveCellRenderer: () => passive_default,
  ServerStatusEvent: () => ServerStatusEvent,
  SessionStatusEvent: () => SessionStatusEvent,
  ThebeCodeCell: () => cell_default,
  ThebeEventType: () => ThebeEventType,
  ThebeEvents: () => ThebeEvents,
  ThebeManager: () => ThebeManager,
  ThebeMarkdownCell: () => ThebeMarkdownCell,
  ThebeNotebook: () => notebook_default,
  ThebeServer: () => server_default,
  ThebeSession: () => session_default,
  WIDGET_MIMETYPE: () => WIDGET_MIMETYPE,
  clearAllSavedSessions: () => clearAllSavedSessions,
  clearSavedSession: () => clearSavedSession,
  connectToBinder: () => connectToBinder,
  connectToJupyter: () => connectToJupyter,
  connectToJupyterLite: () => connectToJupyterLite,
  ensureCoreOptions: () => ensureCoreOptions,
  ensureString: () => ensureString2,
  errorToMessage: () => errorToMessage,
  getRenderers: () => getRenderers,
  isMimeBundle: () => isMimeBundle,
  makeBinderOptions: () => makeBinderOptions,
  makeConfiguration: () => makeConfiguration,
  makeEvents: () => makeEvents,
  makeKernelOptions: () => makeKernelOptions,
  makeMathjaxOptions: () => makeMathjaxOptions,
  makeRenderMimeRegistry: () => makeRenderMimeRegistry,
  makeSavedSessionOptions: () => makeSavedSessionOptions,
  makeServer: () => makeServer,
  makeServerSettings: () => makeServerSettings,
  placeholder: () => placeholder,
  setupNotebookFromBlocks: () => setupNotebookFromBlocks,
  setupNotebookFromIpynb: () => setupNotebookFromIpynb,
  setupThebeCore: () => setupThebeCore,
  shortId: () => shortId,
  stripWidgets: () => stripWidgets
});
var init_esm = __esm({
  "../../node_modules/thebe-core/dist/esm/index.js"() {
    init_server();
    init_session();
    init_notebook();
    init_cell();
    init_markdown();
    init_passive();
    init_options();
    init_events();
    init_api();
    init_entrypoint();
    init_utils4();
    init_manager3();
    init_rendermime();
    init_types();
    init_config();
    init_sessions();
  }
});

// ../../node_modules/thebe-react/dist/ThebeLoaderProvider.js
var require_ThebeLoaderProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeLoaderProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeLoader = exports.ThebeBundleLoaderProvider = exports.ThebeLoaderProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeLoaderContext = react_1.default.createContext(void 0);
    function ThebeLoaderProvider({ start, children }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core2, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!startLoad || core2)
          return;
        setLoading(true);
        console.debug("importing thebe-core...");
        Promise.resolve().then(() => tslib_1.__importStar((init_esm(), __toCommonJS(esm_exports)))).then((thebeCore) => {
          console.debug("thebe-core loaded");
          setCore(thebeCore);
          setLoading(false);
        }).catch(({ message }) => {
          console.debug(`thebe-core load failed ${message}`);
          setError(message);
          setLoading(false);
        });
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core: core2, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports.ThebeLoaderProvider = ThebeLoaderProvider;
    function ThebeBundleLoaderProvider2({ start, loadThebeLite, publicPath, children, options = {} }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core2, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        var _a;
        if (!startLoad || core2)
          return;
        setLoading(true);
        console.debug("importing thebe-core...");
        if (typeof document !== "undefined" && typeof window !== "undefined") {
          try {
            if (!window.thebeCore) {
              const script = document.createElement("script");
              script.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-core.min.js`);
              script.setAttribute("async", "true");
              script.setAttribute("type", "text/javascript");
              document.head.appendChild(script);
            }
            if (loadThebeLite) {
              const liteScript = document.createElement("script");
              liteScript.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-lite.min.js`);
              liteScript.setAttribute("async", "true");
              liteScript.setAttribute("type", "text/javascript");
              document.head.appendChild(liteScript);
            }
            let attempts = 0;
            const timer = setInterval(() => {
              var _a2, _b;
              if (window.thebeCore && (window.thebeLite || !loadThebeLite)) {
                setLoading(false);
                setCore((_a2 = window.thebeCore) === null || _a2 === void 0 ? void 0 : _a2.module);
                console.debug("thebe-core loaded");
                if (window.thebeLite)
                  console.debug("thebe-lite loaded");
                clearInterval(timer);
              }
              if (attempts > ((_b = options === null || options === void 0 ? void 0 : options.attempts) !== null && _b !== void 0 ? _b : 50)) {
                setError("thebe-core load failed");
                setLoading(false);
                clearInterval(timer);
                console.warn("thebe load timed out");
                if (!window.thebeCore)
                  console.debug("thebe-core failed to load");
                if (!window.thebeLite)
                  console.debug("thebe-lite failed to load");
              }
              attempts += 1;
            }, (_a = options === null || options === void 0 ? void 0 : options.delay) !== null && _a !== void 0 ? _a : 300);
          } catch (err) {
            setError(err);
            setLoading(false);
          }
        }
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core: core2, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports.ThebeBundleLoaderProvider = ThebeBundleLoaderProvider2;
    function useThebeLoader4() {
      const context = react_1.default.useContext(ThebeLoaderContext);
      return context !== null && context !== void 0 ? context : { loading: false, load: () => ({}) };
    }
    exports.useThebeLoader = useThebeLoader4;
  }
});

// ../../node_modules/thebe-react/dist/ThebeServerProvider.js
var require_ThebeServerProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeServerProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeServer = exports.useDisposeThebeServer = exports.useThebeConfig = exports.ThebeServerProvider = exports.ThebeServerContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports.ThebeServerContext = react_1.default.createContext(void 0);
    function ThebeServerProvider2({ connect = true, config, options, useBinder, useJupyterLite, customConnectFn, customRepoProviders, events: events2, children }) {
      var _a;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const [doConnect, setDoConnect] = (0, react_1.useState)(connect);
      const [connecting, setConnecting] = (0, react_1.useState)(false);
      const [server, setServer] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const thebeConfig = (0, react_1.useMemo)(() => config !== null && config !== void 0 ? config : core2 === null || core2 === void 0 ? void 0 : core2.makeConfiguration(options !== null && options !== void 0 ? options : {}, events2), [core2, options]);
      (0, react_1.useEffect)(() => {
        if (!core2 || !thebeConfig || server)
          return;
        const svr = new core2.ThebeServer(thebeConfig);
        const handler = (evt, data) => {
          const subjects = [
            core2.EventSubject.server,
            core2.EventSubject.session,
            core2.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject)) {
            setError(`${data.status} - ${data.message}`);
          }
        };
        thebeConfig.events.on(core2.ThebeEventType.error, handler);
        setServer(svr);
      }, [core2, thebeConfig, server]);
      const connectToServer = () => {
        if (!server)
          return;
        setConnecting(true);
        if (customConnectFn)
          customConnectFn(server);
        else if (useBinder)
          server.connectToServerViaBinder(customRepoProviders);
        else if (useJupyterLite)
          server.connectToJupyterLiteServer({
            litePluginSettings: {
              "@jupyterlite/pyodide-kernel-extension:kernel": {
                pipliteUrls: ["https://unpkg.com/@jupyterlite/pyodide-kernel@0.3.2/pypi/all.json"],
                pipliteWheelUrl: "https://unpkg.com/@jupyterlite/pyodide-kernel@0.3.2/pypi/piplite-0.3.2-py3-none-any.whl"
              }
            }
          });
        else
          server.connectToJupyterServer();
        server.ready.then(() => {
          setConnecting(false);
          setReady(true);
        }, () => {
          setConnecting(false);
          setReady(false);
        });
        return server.ready;
      };
      (0, react_1.useEffect)(() => {
        if (!core2 || !thebeConfig)
          return;
        if (!server || !doConnect)
          return;
        if (server.isReady && server.userServerUrl)
          return;
        connectToServer();
      }, [server, doConnect]);
      return (0, jsx_runtime_1.jsx)(exports.ThebeServerContext.Provider, Object.assign({ value: {
        config: thebeConfig,
        events: events2 !== null && events2 !== void 0 ? events2 : thebeConfig === null || thebeConfig === void 0 ? void 0 : thebeConfig.events,
        server,
        connecting,
        ready: ((_a = server === null || server === void 0 ? void 0 : server.isReady) !== null && _a !== void 0 ? _a : false) && ready,
        connect: connectToServer,
        disconnect: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (core2 && thebeConfig && server) {
            server.dispose();
            setServer(new core2.ThebeServer(thebeConfig));
          }
          setReady(false);
          setDoConnect(false);
          setConnecting(false);
          setError(void 0);
        }),
        error
      } }, { children }));
    }
    exports.ThebeServerProvider = ThebeServerProvider2;
    function useThebeConfig3() {
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      return { config: serverContext.config };
    }
    exports.useThebeConfig = useThebeConfig3;
    function useDisposeThebeServer() {
      const [disposed, setDisposed] = (0, react_1.useState)(false);
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      const { server, ready } = serverContext;
      (0, react_1.useEffect)(() => {
        if (!server || !ready)
          return;
        Promise.resolve().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield server.shutdownAllSessions();
          server.dispose();
          setDisposed(true);
        }));
      }, [ready, server]);
      return disposed;
    }
    exports.useDisposeThebeServer = useDisposeThebeServer;
    function useThebeServer5() {
      const thebe = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { core: core2 } = thebe !== null && thebe !== void 0 ? thebe : {};
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      const { config, events: events2, server, connecting, ready, connect, disconnect, error } = serverContext !== null && serverContext !== void 0 ? serverContext : {
        ready: false,
        connecting: false
      };
      const [eventCallbacks, setEventCallbacks] = (0, react_1.useState)([]);
      const subscribe = (0, react_1.useCallback)((fn) => {
        if (!core2 || !config || !server)
          return;
        const callbackFn = (evt, data) => {
          const subjects = [
            core2.EventSubject.server,
            core2.EventSubject.session,
            core2.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject))
            fn(data);
        };
        config === null || config === void 0 ? void 0 : config.events.on(core2.ThebeEventType.status, callbackFn);
        setEventCallbacks([...eventCallbacks, callbackFn]);
      }, [config, server]);
      const unsubAll = (0, react_1.useCallback)(() => {
        if (!core2)
          return;
        eventCallbacks.forEach((cb2) => {
          config === null || config === void 0 ? void 0 : config.events.off(core2.ThebeEventType.status, cb2);
        });
        setEventCallbacks([]);
      }, [config, server]);
      return serverContext ? {
        config,
        events: events2,
        server,
        connecting,
        ready,
        error,
        connect,
        disconnect,
        subscribe,
        unsubAll
      } : { connecting: false, ready: false };
    }
    exports.useThebeServer = useThebeServer5;
  }
});

// ../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js
var require_ThebeRenderMimeRegistryProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useRenderMimeRegistry = exports.ThebeRenderMimeRegistryProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var RenderMimeRegistryContext = react_1.default.createContext(void 0);
    function ThebeRenderMimeRegistryProvider({ children }) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = react_1.default.useMemo(() => core2 === null || core2 === void 0 ? void 0 : core2.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax), [core2, config]);
      return (0, jsx_runtime_1.jsx)(RenderMimeRegistryContext.Provider, Object.assign({ value: { rendermime } }, { children }));
    }
    exports.ThebeRenderMimeRegistryProvider = ThebeRenderMimeRegistryProvider;
    function useRenderMimeRegistry() {
      const context = react_1.default.useContext(RenderMimeRegistryContext);
      return context === null || context === void 0 ? void 0 : context.rendermime;
    }
    exports.useRenderMimeRegistry = useRenderMimeRegistry;
  }
});

// ../../node_modules/thebe-react/dist/ThebeSessionProvider.js
var require_ThebeSessionProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeSessionProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeSession = exports.ThebeSessionProvider = exports.ThebeSessionContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports.ThebeSessionContext = react_1.default.createContext(void 0);
    function ThebeSessionProvider({ start = true, path, shutdownOnUnmount = false, children }) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config, server, ready: serverReady } = (0, ThebeServerProvider_1.useThebeServer)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [doStart, setDoStart] = (0, react_1.useState)(start);
      const [starting, setStarting] = (0, react_1.useState)(false);
      const [session, setSession] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const [unsubscribe, setUnsubscribe] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!server || !serverReady || !doStart || starting || ready)
          return;
        startSession();
      }, [ready, doStart, starting, server, serverReady]);
      (0, react_1.useEffect)(() => {
        if (!core2 || !config || !session)
          return;
        const handler = (evt, data) => {
          const subjects = [core2.EventSubject.session, core2.EventSubject.kernel];
          if (data.subject && subjects.includes(data.subject) && data.status === "shutdown" && data.id === session.id) {
            setError(`session ${session.path} - ${data.status} - ${data.message}`);
          }
        };
        setUnsubscribe(config.events.on(core2.ThebeEventType.status, handler));
      }, [core2, config, session]);
      const startSession = () => {
        if (!rendermime)
          throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
        setStarting(true);
        server === null || server === void 0 ? void 0 : server.startNewSession(rendermime, { path }).then((sesh) => {
          setStarting(false);
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              setError(`Could not start a session - available kernels: ${Object.keys(specs.kernelspecs)}`);
            });
            return;
          }
          setSession(sesh);
          setReady(true);
        }, (err) => {
          setError(typeof err === "object" ? err.message : JSON.stringify(err));
          setReady(false);
          setDoStart(false);
          setStarting(false);
        });
      };
      (0, react_1.useEffect)(() => {
        return () => {
          if (shutdownOnUnmount) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            session === null || session === void 0 ? void 0 : session.shutdown().then(() => {
              setReady(false);
              setStarting(false);
              setError(void 0);
            });
          }
        };
      }, [session]);
      return (0, jsx_runtime_1.jsx)(exports.ThebeSessionContext.Provider, Object.assign({ value: {
        path,
        starting,
        ready,
        session,
        // eslint-disable-next-line @typescript-eslint/no-shadow
        start: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!!session && ready) {
            yield session.restart();
          } else {
            startSession();
          }
        }),
        shutdown: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (session) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            yield session.shutdown();
            setSession(void 0);
            setReady(false);
            setStarting(false);
            setError(void 0);
          }
        }),
        error
      } }, { children }));
    }
    exports.ThebeSessionProvider = ThebeSessionProvider;
    function useThebeSession() {
      const sessionContext = (0, react_1.useContext)(exports.ThebeSessionContext);
      return sessionContext !== null && sessionContext !== void 0 ? sessionContext : { starting: false, ready: false };
    }
    exports.useThebeSession = useThebeSession;
  }
});

// ../../node_modules/thebe-react/dist/hooks/notebook.js
var require_notebook = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useNotebookfromSourceLegacy = exports.useNotebookFromSource = exports.useNotebook = exports.useNotebookBase = exports.findErrors = void 0;
    var react_1 = require_react();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeSessionProvider_1 = require_ThebeSessionProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    function findErrors2(execReturns) {
      return execReturns.reduce((acc, retval, index2) => {
        if (retval === null || retval === void 0 ? void 0 : retval.error) {
          if (acc == null)
            return [Object.assign(Object.assign({}, retval), { index: index2 })];
          else
            return [...acc, Object.assign(Object.assign({}, retval), { index: index2 })];
        }
        return acc;
      }, null);
    }
    exports.findErrors = findErrors2;
    function useNotebookBase() {
      const { session, ready: sessionReady } = (0, ThebeSessionProvider_1.useThebeSession)();
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [refs, setRefs] = (0, react_1.useState)([]);
      const [sessionAttached, setSessionAttached] = (0, react_1.useState)(false);
      const [executing, setExecuting] = (0, react_1.useState)(false);
      const [executed, setExecuted] = (0, react_1.useState)(false);
      const [errors, setErrors] = (0, react_1.useState)(null);
      (0, react_1.useEffect)(() => {
        if (!notebook || !session || !sessionReady)
          return;
        console.debug(`thebe-react: attaching notebook to session`, { notebook, session });
        notebook.attachSession(session);
        setSessionAttached(true);
      }, [notebook, session, sessionReady]);
      const executeAll = (options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeAll called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        return notebook.executeAll((_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const executeSome = (predicate, options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeSome called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        const filteredCells = notebook.cells.filter(predicate).map((c6) => c6.id);
        return notebook.executeCells(filteredCells, (_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const clear = () => {
        if (!notebook)
          throw new Error("clear called before notebook available");
        notebook.clear();
        setExecuted(false);
      };
      return {
        ready: !!notebook && sessionAttached,
        attached: sessionAttached,
        executing,
        executed,
        errors,
        notebook,
        setNotebook,
        refs,
        setRefs,
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebookBase = useNotebookBase;
    function useNotebook(name, fetchNotebook, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        if (!core2 || !config)
          return;
        setLoading(true);
        fetchNotebook(name).then((ipynb) => {
          return core2 === null || core2 === void 0 ? void 0 : core2.ThebeNotebook.fromIpynb(ipynb, config, rendermime);
        }).then((nb) => {
          var _a2, _b2;
          const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
          setRefs(Array(cells.length).fill(null).map((_5, idx) => (node) => {
            console.debug(`new ref[${idx}] - attaching to dom...`, node);
            if (node != null)
              cells[idx].attachToDOM(node);
          }));
          setNotebook(nb);
          setLoading(false);
        });
      }, [core2, config]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebook = useNotebook;
    function useNotebookFromSource(sourceCode, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        var _a2, _b2;
        if (!core2 || !config || loading || notebook)
          return;
        setLoading(true);
        const nb = core2.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core2 === null || core2 === void 0 ? void 0 : core2.shortId(), source })), config, rendermime);
        const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
        setRefs(Array(cells.length).fill(null).map((_5, idx) => (node) => {
          console.debug(`new ref[${idx}] - attaching to dom...`, node);
          if (node != null)
            cells[idx].attachToDOM(node);
        }));
        setNotebook(nb);
        setLoading(false);
      }, [core2, notebook, loading]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebookFromSource = useNotebookFromSource;
    function useNotebookfromSourceLegacy(sourceCode) {
      const { core: core2 } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const [busy, setBusy] = (0, react_1.useState)(false);
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [_5, setReRender] = (0, react_1.useState)({});
      const [cellRefs] = (0, react_1.useState)(Array(sourceCode.length).fill(void 0).map(() => (0, react_1.createRef)()));
      (0, react_1.useEffect)(() => {
        if (!core2 || !config || notebook)
          return;
        setNotebook(core2.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core2 === null || core2 === void 0 ? void 0 : core2.shortId(), source })), config, rendermime));
      }, [core2, notebook]);
      const execute = () => {
        if (!notebook)
          throw new Error("execute called before notebook available");
        setBusy(true);
        notebook.executeAll().then(() => {
          setBusy(false);
        });
      };
      const attach = (session) => {
        if (session.kernel == null)
          return;
        if (!notebook) {
          console.warn("attach called before notebook available");
          return;
        }
        notebook === null || notebook === void 0 ? void 0 : notebook.detachSession();
        notebook === null || notebook === void 0 ? void 0 : notebook.attachSession(session);
        notebook === null || notebook === void 0 ? void 0 : notebook.cells.forEach((cell, idx) => {
          var _a;
          if (cellRefs[idx].current)
            cell.attachToDOM((_a = cellRefs[idx].current) !== null && _a !== void 0 ? _a : void 0);
        });
      };
      return {
        notebook,
        busy,
        execute,
        attach,
        cellRefs,
        rerender: () => setReRender({})
      };
    }
    exports.useNotebookfromSourceLegacy = useNotebookfromSourceLegacy;
  }
});

// ../../node_modules/thebe-react/dist/hooks/interpolate.js
var require_interpolate = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/interpolate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interpolatorFactoryFn = exports.PYTHON_PARAM = void 0;
    exports.PYTHON_PARAM = /^(.*)=([^;]*);*\s*#\|*\s*@param\s*(.*)$/;
    function interpolatorFactoryFn(parameterMap) {
      return (source) => {
        const params = new Set(Object.keys(parameterMap));
        const lines = source.split("\n");
        const interpolated = lines.map((line) => {
          if (exports.PYTHON_PARAM.test(line)) {
            const match = line.match(exports.PYTHON_PARAM);
            if (match != null) {
              const [_5, variable, value, schemaString] = match;
              let schema2 = {};
              try {
                if (schemaString !== "")
                  schema2 = JSON.parse(schemaString);
              } catch (err) {
                console.error("Could not parse schema from", line, err);
              }
              if (params.has(variable.trim())) {
                return `${variable}= ${parameterMap[variable.trim()]} #| @param${schema2 ? ` ${JSON.stringify(Object.assign(Object.assign({}, schema2), { last: value }))}` : ""}`;
              }
            }
          }
          return line;
        });
        return interpolated.join("\n");
      };
    }
    exports.interpolatorFactoryFn = interpolatorFactoryFn;
  }
});

// ../../node_modules/thebe-react/dist/hooks/index.js
var require_hooks = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_notebook(), exports);
    tslib_1.__exportStar(require_interpolate(), exports);
  }
});

// ../../node_modules/thebe-react/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/thebe-react/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_OutputAreaByRef(), exports);
    tslib_1.__exportStar(require_ThebeLoaderProvider(), exports);
    tslib_1.__exportStar(require_ThebeServerProvider(), exports);
    tslib_1.__exportStar(require_ThebeSessionProvider(), exports);
    tslib_1.__exportStar(require_ThebeRenderMimeRegistryProvider(), exports);
    tslib_1.__exportStar(require_hooks(), exports);
  }
});

// ../../node_modules/anser/lib/index.js
var require_lib15 = __commonJS({
  "../../node_modules/anser/lib/index.js"(exports, module) {
    "use strict";
    var _createClass2 = function() {
      function defineProperties(target, props) {
        for (var i5 = 0; i5 < props.length; i5++) {
          var descriptor = props[i5];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var Anser2 = function() {
      _createClass2(Anser3, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser3().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser3().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser3().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser3().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser3().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser3() {
        _classCallCheck2(this, Anser3);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass2(Anser3, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i5 = 0; i5 < 2; ++i5) {
            for (var j2 = 0; j2 < 8; ++j2) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i5][j2].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format2 = function format3(r5, g5, b5) {
            return levels[r5] + ", " + levels[g5] + ", " + levels[b5];
          };
          var r4 = void 0, g4 = void 0, b4 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b = 0; _b < 6; ++_b) {
                this.PALETTE_COLORS.push(format2(_r, _g, _b));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format2(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str2) {
            return str2 == "&" ? "&amp;" : str2 == '"' ? "&quot;" : str2 == "<" ? "&lt;" : str2 == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(/(https?:\/\/[^\s]+)/gm, function(str2) {
            return '<a href="' + str2 + '">' + str2 + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self2 = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk2) {
            return _this.processChunk(chunk2, options, markup);
          });
          if (options && options.json) {
            var first2 = self2.processChunkJson("");
            first2.content = first_chunk;
            first2.clearLine = options.clearLine;
            color_chunks.unshift(first2);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c6) {
                return !c6.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key = options.key = use_classes ? "class" : "color";
          var result2 = {
            content: text,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty2() {
              return !result2.content;
            }
          };
          var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches)
            return result2;
          var orig_txt = result2.content = matches[4];
          var nums = matches[2].split(";");
          if (matches[1] !== "" || matches[3] !== "m") {
            return result2;
          }
          if (!markup) {
            return result2;
          }
          var self2 = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self2.fg = self2.bg = null;
              self2.decorations = [];
            } else if (num === 1) {
              self2.decorations.push("bold");
            } else if (num === 2) {
              self2.decorations.push("dim");
            } else if (num === 3) {
              self2.decorations.push("italic");
            } else if (num === 4) {
              self2.decorations.push("underline");
            } else if (num === 5) {
              self2.decorations.push("blink");
            } else if (num === 7) {
              self2.decorations.push("reverse");
            } else if (num === 8) {
              self2.decorations.push("hidden");
            } else if (num === 9) {
              self2.decorations.push("strikethrough");
            } else if (num === 21) {
              self2.removeDecoration("bold");
            } else if (num === 22) {
              self2.removeDecoration("bold");
              self2.removeDecoration("dim");
            } else if (num === 23) {
              self2.removeDecoration("italic");
            } else if (num === 24) {
              self2.removeDecoration("underline");
            } else if (num === 25) {
              self2.removeDecoration("blink");
            } else if (num === 27) {
              self2.removeDecoration("reverse");
            } else if (num === 28) {
              self2.removeDecoration("hidden");
            } else if (num === 29) {
              self2.removeDecoration("strikethrough");
            } else if (num === 39) {
              self2.fg = null;
            } else if (num === 49) {
              self2.bg = null;
            } else if (num >= 30 && num < 38) {
              self2.fg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 90 && num < 98) {
              self2.fg = ANSI_COLORS[1][num % 10][key];
            } else if (num >= 40 && num < 48) {
              self2.bg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 100 && num < 108) {
              self2.bg = ANSI_COLORS[1][num % 10][key];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self2.setupPalette();
                      }
                      if (is_foreground) {
                        self2.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self2.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self2.fg = klass;
                      } else {
                        self2.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r4 = parseInt(nums.shift());
                  var g4 = parseInt(nums.shift());
                  var b4 = parseInt(nums.shift());
                  if (r4 >= 0 && r4 <= 255 && g4 >= 0 && g4 <= 255 && b4 >= 0 && b4 <= 255) {
                    var color2 = r4 + ", " + g4 + ", " + b4;
                    if (!use_classes) {
                      if (is_foreground) {
                        self2.fg = color2;
                      } else {
                        self2.bg = color2;
                      }
                    } else {
                      if (is_foreground) {
                        self2.fg = "ansi-truecolor";
                        self2.fg_truecolor = color2;
                      } else {
                        self2.bg = "ansi-truecolor";
                        self2.bg_truecolor = color2;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self2.fg === null && self2.bg === null && self2.decorations.length === 0) {
            return result2;
          } else {
            var styles = [];
            var classes = [];
            var data = {};
            result2.fg = self2.fg;
            result2.bg = self2.bg;
            result2.fg_truecolor = self2.fg_truecolor;
            result2.bg_truecolor = self2.bg_truecolor;
            result2.decorations = self2.decorations;
            result2.decoration = self2.decorations.slice(-1).pop() || null;
            result2.was_processed = true;
            return result2;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data = {};
          var render_data = function render_data2(data2) {
            var fragments = [];
            var key = void 0;
            for (key in data2) {
              if (data2.hasOwnProperty(key)) {
                fragments.push("data-" + key + '="' + _this2.escapeForHtml(data2[key]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index2 = this.decorations.indexOf(decoration);
          if (index2 >= 0) {
            this.decorations.splice(index2, 1);
          }
        }
      }]);
      return Anser3;
    }();
    module.exports = Anser2;
  }
});

// ../../node_modules/escape-carriage/index.js
var require_escape_carriage = __commonJS({
  "../../node_modules/escape-carriage/index.js"(exports, module) {
    function escapeCarriageReturn2(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      txt = txt.replace(/\r+\n/gm, "\n");
      while (/\r./.test(txt)) {
        txt = txt.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function(_5, base, insert) {
          return insert + base.slice(insert.length);
        });
      }
      return txt;
    }
    function findLongestString(arr) {
      var longest = 0;
      for (var i5 = 0; i5 < arr.length; i5++) {
        if (arr[longest].length <= arr[i5].length) {
          longest = i5;
        }
      }
      return longest;
    }
    function escapeSingleLineSafe(txt) {
      if (!/\r/.test(txt))
        return txt;
      var arr = txt.split("\r");
      var res = [];
      while (arr.length > 0) {
        var longest = findLongestString(arr);
        res.push(arr[longest]);
        arr = arr.slice(longest + 1);
      }
      return res.join("\r");
    }
    function escapeCarriageReturnSafe(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      if (!/\n/.test(txt))
        return escapeSingleLineSafe(txt);
      txt = txt.replace(/\r+\n/gm, "\n");
      var idx = txt.lastIndexOf("\n");
      return escapeCarriageReturn2(txt.slice(0, idx)) + "\n" + escapeSingleLineSafe(txt.slice(idx + 1));
    }
    module.exports = escapeCarriageReturn2;
    module.exports.escapeCarriageReturn = escapeCarriageReturn2;
    module.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;
  }
});

// empty-module:~/utils/loaders.server
var require_loaders = __commonJS({
  "empty-module:~/utils/loaders.server"(exports, module) {
    module.exports = {};
  }
});

// ../../packages/providers/dist/hooks.js
var import_react = __toESM(require_react(), 1);
function useMediaQuery(query) {
  const ssr = typeof document === "undefined";
  const getMatches = (match) => {
    if (ssr)
      return false;
    return window.matchMedia(match).matches;
  };
  const [matches, setMatches] = (0, import_react.useState)(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  (0, import_react.useEffect)(() => {
    if (ssr)
      return;
    const matchMedia = window.matchMedia(query);
    handleChange();
    matchMedia.addEventListener("change", handleChange);
    return () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]);
  return matches;
}

// ../../packages/providers/dist/theme.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// ../../node_modules/nbtx/dist/esm/minify/utils.js
function walkOutputs(outputs, func) {
  outputs.forEach((output) => {
    if ("data" in output && output.data) {
      Object.entries(output.data).forEach(([, bundle]) => {
        func(bundle);
      });
    } else {
      func(output);
    }
  });
}
function ensureString(maybeString, joinWith = "") {
  if (!maybeString)
    return "";
  if (typeof maybeString === "string")
    return maybeString;
  if (maybeString.join)
    return maybeString.join(joinWith);
  return maybeString;
}

// ../../node_modules/nbtx/dist/esm/minify/convert.js
var __rest2 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function convertToIOutputs(minified, outputCache) {
  return minified.map((m4) => {
    switch (m4.output_type) {
      case "stream": {
        const { hash } = m4, rest2 = __rest2(m4, ["hash"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { text: outputCache[hash][0] });
        }
        return rest2;
      }
      case "error": {
        const { hash, traceback } = m4, rest2 = __rest2(m4, ["hash", "traceback"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { traceback: [outputCache[hash][0]] });
        }
        return Object.assign(Object.assign({}, rest2), { traceback: [traceback] });
      }
      default: {
        return Object.assign(Object.assign({}, m4), { data: Object.entries(m4.data).reduce((acc, [mimetype, payload]) => {
          let { content } = payload;
          const { hash } = payload;
          if (hash && outputCache[hash]) {
            [content] = outputCache[hash];
          }
          if (content && mimetype !== "application/javascript" && mimetype.startsWith("application/")) {
            try {
              content = JSON.parse(content);
            } catch (e4) {
              console.debug(`${mimetype} is not json parsable, leaving as is`);
            }
          }
          if (content && mimetype.startsWith("image/") && !mimetype.startsWith("image/svg") && content.startsWith("data:") && content.includes(";base64,")) {
            const [data] = content.split(";base64,").reverse();
            content = data;
          }
          if (!content)
            return acc;
          return Object.assign(Object.assign({}, acc), { [mimetype]: content });
        }, {}) });
      }
    }
  });
}

// ../../node_modules/nbtx/dist/esm/types.js
var KnownCellOutputMimeTypes;
(function(KnownCellOutputMimeTypes2) {
  KnownCellOutputMimeTypes2["TextPlain"] = "text/plain";
  KnownCellOutputMimeTypes2["TextHtml"] = "text/html";
  KnownCellOutputMimeTypes2["TextLatex"] = "text/latex";
  KnownCellOutputMimeTypes2["ImagePng"] = "image/png";
  KnownCellOutputMimeTypes2["ImageBmp"] = "image/bmp";
  KnownCellOutputMimeTypes2["ImageJpeg"] = "image/jpeg";
  KnownCellOutputMimeTypes2["ImageSvg"] = "image/svg+xml";
  KnownCellOutputMimeTypes2["ImageGif"] = "image/gif";
  KnownCellOutputMimeTypes2["AppJson"] = "application/json";
  KnownCellOutputMimeTypes2["AppGeoJson"] = "application/geo+json";
  KnownCellOutputMimeTypes2["AppPlotly"] = "application/vnd.plotly.v1+json";
  KnownCellOutputMimeTypes2["AppVega"] = "application/vnd.vega.v5+json";
  KnownCellOutputMimeTypes2["AppVegaLite"] = "application/vnd.vegalite.v3+json";
  KnownCellOutputMimeTypes2["AppVirtualDom"] = "application/vdom.v1+json";
  KnownCellOutputMimeTypes2["AppJavascript"] = "application/javascript";
  KnownCellOutputMimeTypes2["AppWidgetView"] = "application/vnd.jupyter.widget-view+json";
  KnownCellOutputMimeTypes2["AppWidgetState"] = "application/vnd.jupyter.widget-state+json";
  KnownCellOutputMimeTypes2["AppBokehLoad"] = "application/vnd.bokehjs_load.v0+json";
  KnownCellOutputMimeTypes2["AppBokehExec"] = "application/vnd.bokehjs_exec.v0+json";
})(KnownCellOutputMimeTypes || (KnownCellOutputMimeTypes = {}));
var CELL_TYPES;
(function(CELL_TYPES2) {
  CELL_TYPES2["raw"] = "raw";
  CELL_TYPES2["markdown"] = "markdown";
  CELL_TYPES2["code"] = "code";
})(CELL_TYPES || (CELL_TYPES = {}));

// ../../packages/common/dist/utils.js
function getProject(config, projectSlug) {
  var _a, _b;
  if (!config)
    return void 0;
  if (!config.projects || config.projects.length === 0)
    return void 0;
  if (!projectSlug)
    return config.projects[0];
  const project = (_b = (_a = config.projects) === null || _a === void 0 ? void 0 : _a.find((p3) => p3.slug === projectSlug)) !== null && _b !== void 0 ? _b : config.projects[0];
  return project;
}
function getProjectHeadings(config, projectSlug, opts = { addGroups: false }) {
  const project = getProject(config, projectSlug);
  if (!project)
    return void 0;
  const headings = [
    {
      title: project.title,
      short_title: project.short_title,
      slug: project.index,
      path: project.slug ? `/${project.slug}` : "/",
      level: "index"
    },
    ...project.pages.map((p3) => {
      if (!("slug" in p3))
        return p3;
      return { ...p3, path: projectSlug ? `/${project.slug}/${p3.slug}` : `/${p3.slug}` };
    })
  ];
  if (opts.addGroups) {
    let lastTitle = project.short_title || project.title;
    return headings.map((heading) => {
      if (!heading.slug || heading.level === "index") {
        lastTitle = heading.short_title || heading.title;
      }
      return { ...heading, group: lastTitle };
    });
  }
  return headings;
}

// ../../packages/common/dist/types.js
var Theme;
(function(Theme2) {
  Theme2["light"] = "light";
  Theme2["dark"] = "dark";
})(Theme || (Theme = {}));
var ErrorStatus;
(function(ErrorStatus2) {
  ErrorStatus2["noSite"] = "Site was not found";
  ErrorStatus2["noArticle"] = "Article was not found";
})(ErrorStatus || (ErrorStatus = {}));

// ../../packages/providers/dist/theme.js
var __rest3 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function HtmlLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className }, props, { children }));
}
function HtmlNavLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className: staticClass }, props, { children }));
}
function isTheme(value) {
  return typeof value === "string" && Object.values(Theme).includes(value);
}
var ThemeContext = import_react2.default.createContext(void 0);
ThemeContext.displayName = "ThemeContext";
var prefersLightMQ = "(prefers-color-scheme: light)";
function ThemeProvider({ children, theme: startingTheme = Theme.light, renderers: renderers2, Link: Link2, top, NavLink: NavLink2 }) {
  const [theme, setTheme] = import_react2.default.useState(() => {
    if (startingTheme) {
      if (isTheme(startingTheme))
        return startingTheme;
      else
        return null;
    }
    if (typeof document === "undefined")
      return null;
    return window.matchMedia(prefersLightMQ).matches ? Theme.light : Theme.dark;
  });
  const nextTheme = import_react2.default.useCallback((next) => {
    if (!next || next === theme || !isTheme(next))
      return;
    if (typeof document !== "undefined") {
      document.getElementsByTagName("html")[0].className = next;
    }
    const xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "/api/theme");
    xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
    xmlhttp.send(JSON.stringify({ theme: next }));
    setTheme(next);
  }, [theme]);
  return (0, import_jsx_runtime.jsx)(ThemeContext.Provider, { value: { theme, setTheme: nextTheme, renderers: renderers2, Link: Link2, NavLink: NavLink2, top }, children });
}
function useTheme() {
  const context = import_react2.default.useContext(ThemeContext);
  if (context === void 0) {
    const error = "useTheme should be used within a ThemeProvider";
    const throwError2 = () => {
      throw new Error(error);
    };
    console.error(error);
    return {
      theme: Theme.light,
      isLight: true,
      isDark: false,
      setTheme: throwError2,
      nextTheme: throwError2
    };
  }
  const { theme, setTheme } = context;
  const isDark = theme === Theme.dark;
  const isLight = theme === Theme.light;
  const nextTheme = import_react2.default.useCallback(() => {
    const next = theme === Theme.light ? Theme.dark : Theme.light;
    setTheme(next);
  }, [theme]);
  return { theme, isLight, isDark, setTheme, nextTheme };
}
function useNodeRenderers() {
  const context = import_react2.default.useContext(ThemeContext);
  const { renderers: renderers2 } = context !== null && context !== void 0 ? context : {};
  return renderers2 !== null && renderers2 !== void 0 ? renderers2 : {};
}
function useLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { Link: Link2 } = context !== null && context !== void 0 ? context : {};
  return Link2 !== null && Link2 !== void 0 ? Link2 : HtmlLink;
}
function useNavLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { NavLink: NavLink2 } = context !== null && context !== void 0 ? context : {};
  return NavLink2 !== null && NavLink2 !== void 0 ? NavLink2 : HtmlNavLink;
}
function useThemeTop() {
  const context = import_react2.default.useContext(ThemeContext);
  const { top } = context !== null && context !== void 0 ? context : {};
  return top || 0;
}

// ../../packages/providers/dist/grid.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var Context = import_react3.default.createContext(void 0);
Context.displayName = "GridSystemContext";
function GridSystemProvider({ children, gridSystem }) {
  return (0, import_jsx_runtime2.jsx)(Context.Provider, { value: { gridSystem }, children });
}
function useGridSystemProvider() {
  const context = import_react3.default.useContext(Context);
  const { gridSystem } = context !== null && context !== void 0 ? context : {};
  return gridSystem || "article-grid";
}

// ../../packages/providers/dist/references.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var ReferencesContext = import_react4.default.createContext({});
function ReferencesProvider({ references, frontmatter, children }) {
  return (0, import_jsx_runtime3.jsx)(ReferencesContext.Provider, { value: { references, frontmatter }, children });
}
function useReferences() {
  const data = (0, import_react4.useContext)(ReferencesContext);
  return data === null || data === void 0 ? void 0 : data.references;
}

// ../../packages/providers/dist/baseurl.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var BaseUrlContext = import_react5.default.createContext({});
function BaseUrlProvider({ baseurl, children }) {
  return (0, import_jsx_runtime4.jsx)(BaseUrlContext.Provider, { value: { baseurl }, children });
}
function useBaseurl() {
  const data = (0, import_react5.useContext)(BaseUrlContext);
  return data === null || data === void 0 ? void 0 : data.baseurl;
}
function withBaseurl(url, baseurl) {
  if (baseurl)
    return baseurl + url;
  return url;
}

// ../../packages/providers/dist/ui.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var UiContext = (0, import_react6.createContext)(void 0);
function UiStateProvider({ children }) {
  const wide = useMediaQuery("(min-width: 1280px)");
  const [state, setState] = (0, import_react6.useState)({ isNavOpen: false });
  (0, import_react6.useEffect)(() => {
    if (wide)
      setState(Object.assign(Object.assign({}, state), { isNavOpen: false }));
  }, [wide]);
  return (0, import_jsx_runtime5.jsx)(UiContext.Provider, { value: [state, setState], children });
}
function useNavOpen() {
  var _a, _b;
  const [state, setState] = (_a = (0, import_react6.useContext)(UiContext)) !== null && _a !== void 0 ? _a : [];
  const setOpen = (open) => {
    if (open === (state === null || state === void 0 ? void 0 : state.isNavOpen))
      return;
    setState === null || setState === void 0 ? void 0 : setState(Object.assign(Object.assign({}, state), { isNavOpen: open }));
  };
  return [(_b = state === null || state === void 0 ? void 0 : state.isNavOpen) !== null && _b !== void 0 ? _b : false, setOpen];
}

// ../../packages/providers/dist/site.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var SiteContext = import_react7.default.createContext(void 0);
function SiteProvider({ config, children }) {
  return (0, import_jsx_runtime6.jsx)(SiteContext.Provider, { value: config, children });
}
function useSiteManifest() {
  const config = (0, import_react7.useContext)(SiteContext);
  return config;
}

// ../../packages/providers/dist/tabs.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var TabContext = (0, import_react8.createContext)(void 0);
function TabStateProvider({ children }) {
  const [state, setState] = (0, import_react8.useState)("");
  return (0, import_jsx_runtime7.jsx)(TabContext.Provider, { value: [state, setState], children });
}
function useTabSet() {
  return (0, import_react8.useContext)(TabContext);
}

// ../../packages/providers/dist/xref.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var XRefContext = (0, import_react9.createContext)(void 0);
function useXRefState() {
  var _a;
  const state = (_a = (0, import_react9.useContext)(XRefContext)) !== null && _a !== void 0 ? _a : { inCrossRef: false, remote: false };
  return state;
}
function XRefProvider({ remote, url, dataUrl, remoteBaseUrl, children }) {
  const parent = useXRefState();
  const value = {
    inCrossRef: true,
    remote: remote !== null && remote !== void 0 ? remote : parent.remote,
    url: url !== null && url !== void 0 ? url : parent.url,
    dataUrl: dataUrl !== null && dataUrl !== void 0 ? dataUrl : parent.dataUrl,
    remoteBaseUrl: remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : parent.remoteBaseUrl
  };
  if (value.remote && !value.url) {
    value.remote = false;
  }
  return (0, import_jsx_runtime8.jsx)(XRefContext.Provider, { value, children });
}

// ../../packages/providers/dist/project.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var ProjectContext = import_react10.default.createContext(void 0);
function ProjectProvider({ project, children }) {
  var _a;
  const config = useSiteManifest();
  return (0, import_jsx_runtime9.jsx)(ProjectContext.Provider, { value: project !== null && project !== void 0 ? project : (_a = config === null || config === void 0 ? void 0 : config.projects) === null || _a === void 0 ? void 0 : _a[0], children });
}
function useProjectManifest() {
  const config = (0, import_react10.useContext)(ProjectContext);
  return config;
}

// ../../packages/myst-to-react/dist/basic.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);

// ../../packages/myst-to-react/dist/hashLink.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_classnames = __toESM(require_classnames(), 1);
function openDetails(el) {
  if (!el)
    return;
  if (el.nodeName === "DETAILS") {
    el.open = true;
  }
  openDetails(el.parentElement);
}
function scrollToElement(el, { htmlId = el === null || el === void 0 ? void 0 : el.id, scrollBehavior = "smooth", historyState = "replace", focusTarget = true } = {}) {
  if (!el)
    return;
  openDetails(el);
  el.scrollIntoView({ behavior: scrollBehavior });
  if (historyState === "push") {
    history.pushState(void 0, "", `#${htmlId}`);
  } else if (historyState === "replace") {
    history.replaceState(void 0, "", `#${htmlId}`);
  }
  if (focusTarget) {
    if (el.tabIndex === -1)
      el.tabIndex = -1;
    el.focus({ preventScroll: true });
  }
}
function HashLink({ id, kind, title = `Link to this ${kind}`, children = "\xB6", canSelectText = false, hover, className = "font-normal", hideInPopup, scrollBehavior, historyState, focusTarget }) {
  const { inCrossRef } = useXRefState();
  if (inCrossRef || !id) {
    return hideInPopup ? null : (0, import_jsx_runtime10.jsx)("span", { className: (0, import_classnames.default)("select-none", className), children });
  }
  const scroll = (evt) => {
    evt.preventDefault();
    const el = document.getElementById(id);
    scrollToElement(el, { scrollBehavior, historyState, focusTarget });
  };
  return (0, import_jsx_runtime10.jsx)("a", { className: (0, import_classnames.default)("no-underline text-inherit hover:text-inherit", className, {
    "select-none": !canSelectText,
    "transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70": hover,
    "hover:underline": !hover
  }), onClick: scroll, href: `#${id}`, title, "aria-label": title, children });
}

// ../../packages/myst-to-react/dist/basic.js
var import_classnames4 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowDownTrayIcon.js
var React7 = __toESM(require_react(), 1);
function ArrowDownTrayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React7.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React7.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React7.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"
  }));
}
var ForwardRef = React7.forwardRef(ArrowDownTrayIcon);
var ArrowDownTrayIcon_default = ForwardRef;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowLeftIcon.js
var React8 = __toESM(require_react(), 1);
function ArrowLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React8.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React8.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React8.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18"
  }));
}
var ForwardRef2 = React8.forwardRef(ArrowLeftIcon);
var ArrowLeftIcon_default = ForwardRef2;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightCircleIcon.js
var React9 = __toESM(require_react(), 1);
function ArrowRightCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React9.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React9.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React9.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12.75 15l3-3m0 0l-3-3m3 3h-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef3 = React9.forwardRef(ArrowRightCircleIcon);
var ArrowRightCircleIcon_default = ForwardRef3;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightIcon.js
var React10 = __toESM(require_react(), 1);
function ArrowRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React10.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React10.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React10.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"
  }));
}
var ForwardRef4 = React10.forwardRef(ArrowRightIcon);
var ArrowRightIcon_default = ForwardRef4;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowTopRightOnSquareIcon.js
var React11 = __toESM(require_react(), 1);
function ArrowTopRightOnSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React11.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React11.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React11.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"
  }));
}
var ForwardRef5 = React11.forwardRef(ArrowTopRightOnSquareIcon);
var ArrowTopRightOnSquareIcon_default = ForwardRef5;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowUturnLeftIcon.js
var React12 = __toESM(require_react(), 1);
function ArrowUturnLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React12.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React12.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React12.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3"
  }));
}
var ForwardRef6 = React12.forwardRef(ArrowUturnLeftIcon);
var ArrowUturnLeftIcon_default = ForwardRef6;

// ../../node_modules/@heroicons/react/24/outline/esm/BoltIcon.js
var React13 = __toESM(require_react(), 1);
function BoltIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React13.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React13.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React13.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z"
  }));
}
var ForwardRef7 = React13.forwardRef(BoltIcon);
var BoltIcon_default = ForwardRef7;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckCircleIcon.js
var React14 = __toESM(require_react(), 1);
function CheckCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React14.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React14.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React14.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef8 = React14.forwardRef(CheckCircleIcon);
var CheckCircleIcon_default = ForwardRef8;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckIcon.js
var React15 = __toESM(require_react(), 1);
function CheckIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React15.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React15.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React15.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M4.5 12.75l6 6 9-13.5"
  }));
}
var ForwardRef9 = React15.forwardRef(CheckIcon);
var CheckIcon_default = ForwardRef9;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentArrowDownIcon.js
var React16 = __toESM(require_react(), 1);
function DocumentArrowDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React16.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React16.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React16.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m.75 12l3 3m0 0l3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"
  }));
}
var ForwardRef10 = React16.forwardRef(DocumentArrowDownIcon);
var DocumentArrowDownIcon_default = ForwardRef10;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentDuplicateIcon.js
var React17 = __toESM(require_react(), 1);
function DocumentDuplicateIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React17.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React17.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React17.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75"
  }));
}
var ForwardRef11 = React17.forwardRef(DocumentDuplicateIcon);
var DocumentDuplicateIcon_default = ForwardRef11;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentIcon.js
var React18 = __toESM(require_react(), 1);
function DocumentIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React18.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React18.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React18.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"
  }));
}
var ForwardRef12 = React18.forwardRef(DocumentIcon);
var DocumentIcon_default = ForwardRef12;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationCircleIcon.js
var React19 = __toESM(require_react(), 1);
function ExclamationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React19.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React19.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React19.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z"
  }));
}
var ForwardRef13 = React19.forwardRef(ExclamationCircleIcon);
var ExclamationCircleIcon_default = ForwardRef13;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationTriangleIcon.js
var React20 = __toESM(require_react(), 1);
function ExclamationTriangleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React20.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React20.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React20.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
  }));
}
var ForwardRef14 = React20.forwardRef(ExclamationTriangleIcon);
var ExclamationTriangleIcon_default = ForwardRef14;

// ../../node_modules/@heroicons/react/24/outline/esm/InformationCircleIcon.js
var React21 = __toESM(require_react(), 1);
function InformationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React21.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React21.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React21.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z"
  }));
}
var ForwardRef15 = React21.forwardRef(InformationCircleIcon);
var InformationCircleIcon_default = ForwardRef15;

// ../../node_modules/@heroicons/react/24/outline/esm/LightBulbIcon.js
var React22 = __toESM(require_react(), 1);
function LightBulbIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React22.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React22.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React22.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 7.478a12.06 12.06 0 01-4.5 0m3.75 2.383a14.406 14.406 0 01-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 10-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"
  }));
}
var ForwardRef16 = React22.forwardRef(LightBulbIcon);
var LightBulbIcon_default = ForwardRef16;

// ../../node_modules/@heroicons/react/24/outline/esm/LinkIcon.js
var React23 = __toESM(require_react(), 1);
function LinkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React23.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React23.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React23.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"
  }));
}
var ForwardRef17 = React23.forwardRef(LinkIcon);
var LinkIcon_default = ForwardRef17;

// ../../node_modules/@heroicons/react/24/outline/esm/MegaphoneIcon.js
var React24 = __toESM(require_react(), 1);
function MegaphoneIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React24.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React24.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React24.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.34 15.84c-.688-.06-1.386-.09-2.09-.09H7.5a4.5 4.5 0 110-9h.75c.704 0 1.402-.03 2.09-.09m0 9.18c.253.962.584 1.892.985 2.783.247.55.06 1.21-.463 1.511l-.657.38c-.551.318-1.26.117-1.527-.461a20.845 20.845 0 01-1.44-4.282m3.102.069a18.03 18.03 0 01-.59-4.59c0-1.586.205-3.124.59-4.59m0 9.18a23.848 23.848 0 018.835 2.535M10.34 6.66a23.847 23.847 0 008.835-2.535m0 0A23.74 23.74 0 0018.795 3m.38 1.125a23.91 23.91 0 011.014 5.395m-1.014 8.855c-.118.38-.245.754-.38 1.125m.38-1.125a23.91 23.91 0 001.014-5.395m0-3.46c.495.413.811 1.035.811 1.73 0 .695-.316 1.317-.811 1.73m0-3.46a24.347 24.347 0 010 3.46"
  }));
}
var ForwardRef18 = React24.forwardRef(MegaphoneIcon);
var MegaphoneIcon_default = ForwardRef18;

// ../../node_modules/@heroicons/react/24/outline/esm/MinusCircleIcon.js
var React25 = __toESM(require_react(), 1);
function MinusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React25.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React25.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React25.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef19 = React25.forwardRef(MinusCircleIcon);
var MinusCircleIcon_default = ForwardRef19;

// ../../node_modules/@heroicons/react/24/outline/esm/PencilSquareIcon.js
var React26 = __toESM(require_react(), 1);
function PencilSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React26.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React26.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React26.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10"
  }));
}
var ForwardRef20 = React26.forwardRef(PencilSquareIcon);
var PencilSquareIcon_default = ForwardRef20;

// ../../node_modules/@heroicons/react/24/outline/esm/PlayCircleIcon.js
var React27 = __toESM(require_react(), 1);
function PlayCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React27.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React27.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React27.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  }), /* @__PURE__ */ React27.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z"
  }));
}
var ForwardRef21 = React27.forwardRef(PlayCircleIcon);
var PlayCircleIcon_default = ForwardRef21;

// ../../node_modules/@heroicons/react/24/outline/esm/PlusCircleIcon.js
var React28 = __toESM(require_react(), 1);
function PlusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React28.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React28.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React28.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v6m3-3H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
  }));
}
var ForwardRef22 = React28.forwardRef(PlusCircleIcon);
var PlusCircleIcon_default = ForwardRef22;

// ../../node_modules/@heroicons/react/24/outline/esm/PowerIcon.js
var React29 = __toESM(require_react(), 1);
function PowerIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React29.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React29.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React29.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M5.636 5.636a9 9 0 1012.728 0M12 3v9"
  }));
}
var ForwardRef23 = React29.forwardRef(PowerIcon);
var PowerIcon_default = ForwardRef23;

// ../../node_modules/@heroicons/react/24/outline/esm/ScaleIcon.js
var React30 = __toESM(require_react(), 1);
function ScaleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React30.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React30.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React30.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v17.25m0 0c-1.472 0-2.882.265-4.185.75M12 20.25c1.472 0 2.882.265 4.185.75M18.75 4.97A48.416 48.416 0 0012 4.5c-2.291 0-4.545.16-6.75.47m13.5 0c1.01.143 2.01.317 3 .52m-3-.52l2.62 10.726c.122.499-.106 1.028-.589 1.202a5.988 5.988 0 01-2.031.352 5.988 5.988 0 01-2.031-.352c-.483-.174-.711-.703-.59-1.202L18.75 4.971zm-16.5.52c.99-.203 1.99-.377 3-.52m0 0l2.62 10.726c.122.499-.106 1.028-.589 1.202a5.989 5.989 0 01-2.031.352 5.989 5.989 0 01-2.031-.352c-.483-.174-.711-.703-.59-1.202L5.25 4.971z"
  }));
}
var ForwardRef24 = React30.forwardRef(ScaleIcon);
var ScaleIcon_default = ForwardRef24;

// ../../node_modules/@heroicons/react/24/outline/esm/SunIcon.js
var React31 = __toESM(require_react(), 1);
function SunIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React31.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React31.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React31.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"
  }));
}
var ForwardRef25 = React31.forwardRef(SunIcon);
var SunIcon_default = ForwardRef25;

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_react11 = __toESM(require_react(), 1);
var import_classnames2 = __toESM(require_classnames(), 1);
function CopyIcon({ text, className }) {
  const [copied, setCopied] = (0, import_react11.useState)(false);
  const onClick = () => {
    if (copied)
      return;
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 3e3);
    });
  };
  return (0, import_jsx_runtime11.jsx)("button", { title: copied ? "Copied!!" : "Copy to Clipboard", className: (0, import_classnames2.default)("inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2", "transition-color duration-200 ease-in-out", {
    "text-blue-400 hover:text-blue-500": !copied,
    "text-green-500 hover:text-green-500": copied
  }, className), onClick, "aria-pressed": copied ? "true" : "false", "aria-label": "Copy code to clipboard", children: copied ? (0, import_jsx_runtime11.jsx)(CheckIcon_default, { width: 24, height: 24, className: "text-success" }) : (0, import_jsx_runtime11.jsx)(DocumentDuplicateIcon_default, { width: 24, height: 24 }) });
}

// ../../packages/myst-to-react/dist/components/HoverPopover.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
init_extends();
var import_react27 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// ../../node_modules/@radix-ui/react-context/dist/index.mjs
var import_react12 = __toESM(require_react(), 1);
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ (0, import_react12.createContext)(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = (0, import_react12.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react12.createElement)(Context2.Provider, {
        value
      }, children);
    }
    function useContext11(consumerName, scope) {
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = (0, import_react12.useContext)(Context2);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext11
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ (0, import_react12.createContext)(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return (0, import_react12.useMemo)(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return (0, import_react12.useMemo)(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var import_react14 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var import_react13 = __toESM(require_react(), 1);
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = (0, import_react13.useRef)(callback);
  (0, import_react13.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react13.useMemo)(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = (0, import_react14.useCallback)((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = (0, import_react14.useState)(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = (0, import_react14.useRef)(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  (0, import_react14.useEffect)(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_react15 = __toESM(require_react(), 1);
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return (0, import_react15.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
init_extends();
var import_react22 = __toESM(require_react(), 1);

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x4,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i5 = 0; i5 < validMiddleware.length; i5++) {
    const {
      name,
      fn
    } = validMiddleware[i5];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x4,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x4 = nextX != null ? nextX : x4;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x4,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i5 = -1;
      continue;
    }
  }
  return {
    x: x4,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x4,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x4,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x4,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element: element2,
      padding = 0
    } = evaluate(options, state) || {};
    if (element2 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x4,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element2);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d6) => d6.overflows[0] <= 0).sort((a4, b4) => a4.overflows[1] - b4.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d6) => [d6.placement, d6.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b4) => a4[1] - b4[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x4,
        y: y3
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x4 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x4,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x5,
              y: y4
            } = _ref;
            return {
              x: x5,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x4,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x4,
        y: y3,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y3
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $8
  } = getCssDimensions(domElement);
  let x4 = ($8 ? round(rect.width) : rect.width) / width;
  let y3 = ($8 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y3 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x4 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x4 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache2) {
  const cachedResult = cache2.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element2, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  return getCssDimensions(element2);
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const window2 = getWindow(element2);
  if (!isHTMLElement(element2)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e4) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React32 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var arrow2 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element: element2,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element2 && isRef(element2)) {
        if (element2.current != null) {
          return arrow({
            element: element2.current,
            padding
          }).fn(state);
        }
        return {};
      } else if (element2) {
        return arrow({
          element: element2,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react16.useLayoutEffect : import_react16.useEffect;
function deepEqual(a4, b4) {
  if (a4 === b4) {
    return true;
  }
  if (typeof a4 !== typeof b4) {
    return false;
  }
  if (typeof a4 === "function" && a4.toString() === b4.toString()) {
    return true;
  }
  let length, i5, keys2;
  if (a4 && b4 && typeof a4 == "object") {
    if (Array.isArray(a4)) {
      length = a4.length;
      if (length != b4.length)
        return false;
      for (i5 = length; i5-- !== 0; ) {
        if (!deepEqual(a4[i5], b4[i5])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a4);
    length = keys2.length;
    if (length !== Object.keys(b4).length) {
      return false;
    }
    for (i5 = length; i5-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b4, keys2[i5])) {
        return false;
      }
    }
    for (i5 = length; i5-- !== 0; ) {
      const key = keys2[i5];
      if (key === "_owner" && a4.$$typeof) {
        continue;
      }
      if (!deepEqual(a4[key], b4[key])) {
        return false;
      }
    }
    return true;
  }
  return a4 !== a4 && b4 !== b4;
}
function getDPR(element2) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React32.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React32.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React32.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React32.useState(null);
  const [_floating, _setFloating] = React32.useState(null);
  const setReference = React32.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = React32.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React32.useRef(null);
  const floatingRef = React32.useRef(null);
  const dataRef = React32.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React32.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React32.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React32.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React32.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React32.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x4 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x4 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x4,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React32.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
init_extends();
var import_react19 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
init_extends();
var import_react18 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
init_extends();
var import_react17 = __toESM(require_react(), 1);
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react17.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react17.Children.count(newElement) > 1)
          return import_react17.Children.only(null);
        return /* @__PURE__ */ (0, import_react17.isValidElement)(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ (0, import_react17.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ (0, import_react17.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react17.cloneElement)(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ (0, import_react17.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ (0, import_react17.isValidElement)(children))
    return /* @__PURE__ */ (0, import_react17.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return import_react17.Children.count(children) > 1 ? import_react17.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ (0, import_react17.createElement)(import_react17.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ (0, import_react17.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ (0, import_react18.forwardRef)((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    (0, import_react18.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ (0, import_react18.createElement)(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    (0, import_react_dom.flushSync)(
      () => target.dispatchEvent(event)
    );
}

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react19.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_react19.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ (0, import_react19.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var import_react20 = __toESM(require_react(), 1);
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react20.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-use-size/dist/index.mjs
var import_react21 = __toESM(require_react(), 1);
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element2) {
  const [size3, setSize] = (0, import_react21.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element2) {
      setSize({
        width: element2.offsetWidth,
        height: element2.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element2.offsetWidth;
          height = element2.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element2, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element2);
    } else
      setSize(void 0);
  }, [
    element2
  ]);
  return size3;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react22.useState)(null);
  return /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react22.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react22.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, avoidCollisions = true, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, updatePositionStrategy = "optimized", onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react22.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow3, setArrow] = (0, import_react22.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow3);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip({
        ...detectOverflowOptions
      }),
      size({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow3 && arrow2({
        element: arrow3,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && hide({
        strategy: "referenceHidden",
        ...detectOverflowOptions
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react22.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  return /* @__PURE__ */ (0, import_react22.createElement)("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ (0, import_react22.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPositioned ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react22.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_react22.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react22.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x4 = "";
    let y3 = "";
    if (placedSide === "bottom") {
      x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x4 = `${-arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x4 = `${rects.floating.width + arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x4,
        y: y3
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// ../../node_modules/@radix-ui/react-portal/dist/index.mjs
init_extends();
var import_react23 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});

// ../../node_modules/@radix-ui/react-presence/dist/index.mjs
var import_react24 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return (0, import_react24.useReducer)((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : import_react24.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react24.cloneElement)(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = (0, import_react24.useState)();
  const stylesRef = (0, import_react24.useRef)({});
  const prevPresentRef = (0, import_react24.useRef)(present);
  const prevAnimationNameRef = (0, import_react24.useRef)("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  (0, import_react24.useEffect)(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          (0, import_react_dom4.flushSync)(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: (0, import_react24.useCallback)((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
init_extends();
var import_react26 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var import_react25 = __toESM(require_react(), 1);
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  (0, import_react25.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var $5cb92bef7577960e$var$originalBodyPointerEvents;
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react26.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = (0, import_react26.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = (0, import_react26.useState)(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = (0, import_react26.useState)({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  (0, import_react26.useEffect)(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  (0, import_react26.useEffect)(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  (0, import_react26.useEffect)(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = (0, import_react26.useRef)(false);
  const handleClickRef = (0, import_react26.useRef)(() => {
  });
  (0, import_react26.useEffect)(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      } else
        ownerDocument.removeEventListener("click", handleClickRef.current);
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = (0, import_react26.useRef)(false);
  (0, import_react26.useEffect)(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
var $cef8881cdc69808e$var$originalBodyUserSelect;
var $cef8881cdc69808e$var$HOVERCARD_NAME = "HoverCard";
var [$cef8881cdc69808e$var$createHoverCardContext, $cef8881cdc69808e$export$47b6998a836b7260] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cef8881cdc69808e$var$HOVERCARD_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cef8881cdc69808e$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cef8881cdc69808e$var$HoverCardProvider, $cef8881cdc69808e$var$useHoverCardContext] = $cef8881cdc69808e$var$createHoverCardContext($cef8881cdc69808e$var$HOVERCARD_NAME);
var $cef8881cdc69808e$export$57a077cc9fbe653e = (props) => {
  const { __scopeHoverCard, children, open: openProp, defaultOpen, onOpenChange, openDelay = 700, closeDelay = 300 } = props;
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  const openTimerRef = (0, import_react27.useRef)(0);
  const closeTimerRef = (0, import_react27.useRef)(0);
  const hasSelectionRef = (0, import_react27.useRef)(false);
  const isPointerDownOnContentRef = (0, import_react27.useRef)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const handleOpen = (0, import_react27.useCallback)(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(
      () => setOpen(true),
      openDelay
    );
  }, [
    openDelay,
    setOpen
  ]);
  const handleClose = (0, import_react27.useCallback)(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current)
      closeTimerRef.current = window.setTimeout(
        () => setOpen(false),
        closeDelay
      );
  }, [
    closeDelay,
    setOpen
  ]);
  const handleDismiss = (0, import_react27.useCallback)(
    () => setOpen(false),
    [
      setOpen
    ]
  );
  (0, import_react27.useEffect)(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ (0, import_react27.createElement)($cef8881cdc69808e$var$HoverCardProvider, {
    scope: __scopeHoverCard,
    open,
    onOpenChange: setOpen,
    onOpen: handleOpen,
    onClose: handleClose,
    onDismiss: handleDismiss,
    hasSelectionRef,
    isPointerDownOnContentRef
  }, /* @__PURE__ */ (0, import_react27.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, children));
};
var $cef8881cdc69808e$var$TRIGGER_NAME = "HoverCardTrigger";
var $cef8881cdc69808e$export$ef9f7fd8e4ba882f = /* @__PURE__ */ (0, import_react27.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, ...triggerProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$TRIGGER_NAME, __scopeHoverCard);
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react27.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), /* @__PURE__ */ (0, import_react27.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.a, _extends({
    "data-state": context.open ? "open" : "closed"
  }, triggerProps, {
    ref: forwardedRef,
    onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerEnter, $cef8881cdc69808e$var$excludeTouch(context.onOpen)),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $cef8881cdc69808e$var$excludeTouch(context.onClose)),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, context.onOpen),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
    onTouchStart: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onTouchStart,
      (event) => event.preventDefault()
    )
  })));
});
var $cef8881cdc69808e$var$PORTAL_NAME = "HoverCardPortal";
var [$cef8881cdc69808e$var$PortalProvider, $cef8881cdc69808e$var$usePortalContext] = $cef8881cdc69808e$var$createHoverCardContext($cef8881cdc69808e$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cef8881cdc69808e$export$b384c6e0a789f88b = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$PORTAL_NAME, __scopeHoverCard);
  return /* @__PURE__ */ (0, import_react27.createElement)($cef8881cdc69808e$var$PortalProvider, {
    scope: __scopeHoverCard,
    forceMount
  }, /* @__PURE__ */ (0, import_react27.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react27.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cef8881cdc69808e$var$CONTENT_NAME = "HoverCardContent";
var $cef8881cdc69808e$export$aa4724a5938c586 = /* @__PURE__ */ (0, import_react27.forwardRef)((props, forwardedRef) => {
  const portalContext = $cef8881cdc69808e$var$usePortalContext($cef8881cdc69808e$var$CONTENT_NAME, props.__scopeHoverCard);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$CONTENT_NAME, props.__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react27.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react27.createElement)($cef8881cdc69808e$var$HoverCardContentImpl, _extends({
    "data-state": context.open ? "open" : "closed"
  }, contentProps, {
    onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerEnter, $cef8881cdc69808e$var$excludeTouch(context.onOpen)),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $cef8881cdc69808e$var$excludeTouch(context.onClose)),
    ref: forwardedRef
  })));
});
var $cef8881cdc69808e$var$HoverCardContentImpl = /* @__PURE__ */ (0, import_react27.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cef8881cdc69808e$var$useHoverCardContext($cef8881cdc69808e$var$CONTENT_NAME, __scopeHoverCard);
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  const ref = (0, import_react27.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [containSelection, setContainSelection] = (0, import_react27.useState)(false);
  (0, import_react27.useEffect)(() => {
    if (containSelection) {
      const body = document.body;
      $cef8881cdc69808e$var$originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = $cef8881cdc69808e$var$originalBodyUserSelect;
        body.style.webkitUserSelect = $cef8881cdc69808e$var$originalBodyUserSelect;
      };
    }
  }, [
    containSelection
  ]);
  (0, import_react27.useEffect)(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          var _document$getSelectio;
          const hasSelection = ((_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.toString()) !== "";
          if (hasSelection)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [
    context.isPointerDownOnContentRef,
    context.hasSelectionRef
  ]);
  (0, import_react27.useEffect)(() => {
    if (ref.current) {
      const tabbables = $cef8881cdc69808e$var$getTabbableNodes(ref.current);
      tabbables.forEach(
        (tabbable) => tabbable.setAttribute("tabindex", "-1")
      );
    }
  });
  return /* @__PURE__ */ (0, import_react27.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onFocusOutside, (event) => {
      event.preventDefault();
    }),
    onDismiss: context.onDismiss
  }, /* @__PURE__ */ (0, import_react27.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({}, popperScope, contentProps, {
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onPointerDown, (event) => {
      if (event.currentTarget.contains(event.target))
        setContainSelection(true);
      context.hasSelectionRef.current = false;
      context.isPointerDownOnContentRef.current = true;
    }),
    ref: composedRefs,
    style: {
      ...contentProps.style,
      userSelect: containSelection ? "text" : void 0,
      // Safari requires prefix
      WebkitUserSelect: containSelection ? "text" : void 0,
      "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
      "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
      "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
    }
  })));
});
var $cef8881cdc69808e$export$b9744d3e7456d806 = /* @__PURE__ */ (0, import_react27.forwardRef)((props, forwardedRef) => {
  const { __scopeHoverCard, ...arrowProps } = props;
  const popperScope = $cef8881cdc69808e$var$usePopperScope(__scopeHoverCard);
  return /* @__PURE__ */ (0, import_react27.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cef8881cdc69808e$var$excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function $cef8881cdc69808e$var$getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
var $cef8881cdc69808e$export$be92b6f5f03c0fe9 = $cef8881cdc69808e$export$57a077cc9fbe653e;
var $cef8881cdc69808e$export$41fb9f06171c75f4 = $cef8881cdc69808e$export$ef9f7fd8e4ba882f;
var $cef8881cdc69808e$export$602eac185826482c = $cef8881cdc69808e$export$b384c6e0a789f88b;
var $cef8881cdc69808e$export$7c6e2c02157bb7d2 = $cef8881cdc69808e$export$aa4724a5938c586;
var $cef8881cdc69808e$export$21b07c8f274aebd5 = $cef8881cdc69808e$export$b9744d3e7456d806;

// ../../packages/myst-to-react/dist/components/HoverPopover.js
function HoverPopover({ children, openDelay = 400, card, side, arrowClass = "fill-white" }) {
  const [load2, setLoad] = (0, import_react28.useState)(false);
  return (0, import_jsx_runtime12.jsxs)($cef8881cdc69808e$export$be92b6f5f03c0fe9, { openDelay, children: [(0, import_jsx_runtime12.jsx)($cef8881cdc69808e$export$41fb9f06171c75f4, { asChild: true, onMouseEnter: () => setLoad(true), children }), (0, import_jsx_runtime12.jsx)($cef8881cdc69808e$export$602eac185826482c, { children: (0, import_jsx_runtime12.jsxs)($cef8881cdc69808e$export$7c6e2c02157bb7d2, { className: "exclude-from-outline hover-card-content", sideOffset: 5, side, children: [typeof card === "function" ? load2 && card({ load: load2 }) : card, (0, import_jsx_runtime12.jsx)($cef8881cdc69808e$export$21b07c8f274aebd5, { className: arrowClass })] }) })] });
}
function Tooltip({ title, children }) {
  return (0, import_jsx_runtime12.jsx)(HoverPopover, { side: "top", card: (0, import_jsx_runtime12.jsx)("div", { className: "p-1 text-xs text-white bg-blue-900 dark:bg-white dark:text-black", children: title }), arrowClass: "fill-blue-900 dark:fill-white", children });
}

// ../../packages/myst-to-react/dist/components/LinkCard.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_classnames3 = __toESM(require_classnames(), 1);
function LinkCard({ url, title, internal = false, loading = false, description, thumbnail, className = "w-[300px] sm:max-w-[500px] bg-white rounded shadow-md" }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const to = withBaseurl(url, baseurl);
  return (0, import_jsx_runtime13.jsxs)("div", { className: (0, import_classnames3.default)("hover-card-content rounded overflow-hidden", className, {
    "animate-pulse": loading
  }), children: [!loading && thumbnail && (0, import_jsx_runtime13.jsx)("img", { src: thumbnail, className: "w-full h-[150px] object-cover object-top object-left m-0" }), loading && (0, import_jsx_runtime13.jsx)("div", { className: "animate-pulse bg-slate-100 dark:bg-slate-800 w-full h-[150px]" }), internal && (0, import_jsx_runtime13.jsx)(Link2, { to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", prefetch: "intent", children: title }), !internal && (0, import_jsx_runtime13.jsxs)("a", { href: to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime13.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), title] }), !loading && description && (0, import_jsx_runtime13.jsx)("div", { className: "p-3 prose text-sm max-h-[300px] overflow-hidden", children: description })] });
}

// ../../packages/myst-to-react/dist/MyST.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function DefaultComponent({ node }) {
  if (!node.children)
    return (0, import_jsx_runtime14.jsx)("span", { children: node.value });
  return (0, import_jsx_runtime14.jsx)("div", { children: (0, import_jsx_runtime14.jsx)(MyST, { ast: node.children }) });
}
function MyST({ ast }) {
  var _a, _b;
  const renderers2 = useNodeRenderers();
  if (!ast || ast.length === 0)
    return null;
  if (!Array.isArray(ast)) {
    const Component = (_b = (_a = renderers2[ast.type]) !== null && _a !== void 0 ? _a : renderers2["DefaultComponent"]) !== null && _b !== void 0 ? _b : DefaultComponent;
    return (0, import_jsx_runtime14.jsx)(Component, { node: ast }, ast.key);
  }
  return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: ast === null || ast === void 0 ? void 0 : ast.map((node) => {
    var _a2;
    const Component = (_a2 = renderers2[node.type]) !== null && _a2 !== void 0 ? _a2 : DefaultComponent;
    return (0, import_jsx_runtime14.jsx)(Component, { node }, node.key);
  }) });
}

// ../../packages/myst-to-react/dist/basic.js
var BASIC_RENDERERS = {
  text({ node }) {
    var _a;
    if (!((_a = node.value) === null || _a === void 0 ? void 0 : _a.includes("\u200B"))) {
      return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: node.value });
    }
    const text = node.value.split("\u200B");
    return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: text.map((v2, i5) => (0, import_jsx_runtime15.jsxs)(import_react29.default.Fragment, { children: [v2, i5 < text.length - 1 && (0, import_jsx_runtime15.jsx)("wbr", {})] }, i5)) });
  },
  span({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  div({ node }) {
    return (0, import_jsx_runtime15.jsx)("div", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  delete({ node }) {
    return (0, import_jsx_runtime15.jsx)("del", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  strong({ node }) {
    return (0, import_jsx_runtime15.jsx)("strong", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  emphasis({ node }) {
    return (0, import_jsx_runtime15.jsx)("em", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  underline({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { style: { textDecoration: "underline" }, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  smallcaps({ node }) {
    return (0, import_jsx_runtime15.jsx)("span", { style: { fontVariant: "small-caps" }, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  link({ node }) {
    return (0, import_jsx_runtime15.jsx)("a", { target: "_blank", href: node.url, rel: "noreferrer", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  paragraph({ node }) {
    return (0, import_jsx_runtime15.jsx)("p", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  algorithmLine({ node }) {
    var _a;
    const style = {
      paddingLeft: `${((_a = node.indent) !== null && _a !== void 0 ? _a : 0) + 2}rem`
    };
    return (0, import_jsx_runtime15.jsx)("p", { className: "line", style, "data-line-number": node.enumerator, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  break() {
    return (0, import_jsx_runtime15.jsx)("br", {});
  },
  inlineMath({ node }) {
    return (0, import_jsx_runtime15.jsx)("code", { children: node.value });
  },
  math({ node }) {
    return (0, import_jsx_runtime15.jsx)("code", { children: node.value });
  },
  list({ node }) {
    if (node.ordered) {
      return (0, import_jsx_runtime15.jsx)("ol", { start: node.start || void 0, id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime15.jsx)("ul", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  listItem({ node }) {
    if (node.checked == null) {
      return (0, import_jsx_runtime15.jsx)("li", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime15.jsxs)("li", { className: "task-list-item", children: [(0, import_jsx_runtime15.jsx)("input", { type: "checkbox", className: "task-list-item-checkbox", defaultChecked: node.checked }), (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children })] });
  },
  container({ node }) {
    const figureName = `fig-${node.kind}`;
    return (0, import_jsx_runtime15.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames4.default)({ [figureName]: !!node.kind, subcontainer: node.subcontainer }, node.class), children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  caption({ node }) {
    return (0, import_jsx_runtime15.jsx)("figcaption", { className: "group", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  legend({ node }) {
    return (0, import_jsx_runtime15.jsx)("figcaption", { className: "text-sm", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  blockquote({ node }) {
    return (0, import_jsx_runtime15.jsx)("blockquote", { id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  thematicBreak() {
    return (0, import_jsx_runtime15.jsx)("hr", { className: "py-2 my-5 translate-y-2" });
  },
  captionNumber({ node }) {
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime15.jsx)(HashLink, { id, kind: node.kind, className: "mr-1 font-semibold text-inherit hover:text-inherit hover:font-semibold", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  table({ node }) {
    return (0, import_jsx_runtime15.jsx)("table", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)("tbody", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) });
  },
  tableRow({ node }) {
    return (0, import_jsx_runtime15.jsx)("tr", { className: node.class, style: node.style, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  tableCell({ node }) {
    const ifGreaterThanOne = (num) => num === 1 ? void 0 : num;
    const attrs = {
      rowSpan: ifGreaterThanOne(node.rowspan),
      colSpan: ifGreaterThanOne(node.colspan)
    };
    const align = {
      "text-left": node.align === "left",
      "text-right": node.align === "right",
      "text-center": node.align === "center"
    };
    if (node.header)
      return (0, import_jsx_runtime15.jsx)("th", Object.assign({ className: (0, import_classnames4.default)(node.class, align), style: node.style }, attrs, { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }));
    return (0, import_jsx_runtime15.jsx)("td", Object.assign({ className: (0, import_classnames4.default)(node.class, align), style: node.style }, attrs, { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }));
  },
  subscript({ node }) {
    return (0, import_jsx_runtime15.jsx)("sub", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  superscript({ node }) {
    return (0, import_jsx_runtime15.jsx)("sup", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  abbreviation({ node }) {
    return (0, import_jsx_runtime15.jsx)(Tooltip, { title: node.title, children: (0, import_jsx_runtime15.jsx)("abbr", { "aria-label": node.title, className: "border-b border-dotted cursor-help", children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) });
  },
  mystComment() {
    return null;
  },
  comment() {
    return null;
  },
  definitionList({ node }) {
    return (0, import_jsx_runtime15.jsx)("dl", { className: "my-5", id: node.html_id, children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  definitionTerm({ node }) {
    var _a, _b;
    const allowedStrongTypes = /* @__PURE__ */ new Set(["text", "emphasis"]);
    const makeStrong = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce((allowed, n4) => allowed && allowedStrongTypes.has(n4.type), true)) !== null && _b !== void 0 ? _b : false;
    return (0, import_jsx_runtime15.jsx)("dt", { id: node.html_id, children: makeStrong ? (0, import_jsx_runtime15.jsx)("strong", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) }) : (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  definitionDescription({ node }) {
    return (0, import_jsx_runtime15.jsx)("dd", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  keyboard({ node }) {
    return (0, import_jsx_runtime15.jsx)("kbd", { children: (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children }) });
  },
  include({ node }) {
    return (0, import_jsx_runtime15.jsx)(MyST, { ast: node.children });
  }
};
var basic_default = BASIC_RENDERERS;

// ../../packages/myst-to-react/dist/admonitions.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/solid/esm/Bars3Icon.js
var React34 = __toESM(require_react(), 1);
function Bars3Icon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React34.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React34.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React34.createElement("path", {
    fillRule: "evenodd",
    d: "M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z",
    clipRule: "evenodd"
  }));
}
var ForwardRef26 = React34.forwardRef(Bars3Icon);
var Bars3Icon_default = ForwardRef26;

// ../../node_modules/@heroicons/react/24/solid/esm/BoltIcon.js
var React35 = __toESM(require_react(), 1);
function BoltIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React35.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React35.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React35.createElement("path", {
    fillRule: "evenodd",
    d: "M14.615 1.595a.75.75 0 01.359.852L12.982 9.75h7.268a.75.75 0 01.548 1.262l-10.5 11.25a.75.75 0 01-1.272-.71l1.992-7.302H3.75a.75.75 0 01-.548-1.262l10.5-11.25a.75.75 0 01.913-.143z",
    clipRule: "evenodd"
  }));
}
var ForwardRef27 = React35.forwardRef(BoltIcon2);
var BoltIcon_default2 = ForwardRef27;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronDownIcon.js
var React36 = __toESM(require_react(), 1);
function ChevronDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React36.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React36.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React36.createElement("path", {
    fillRule: "evenodd",
    d: "M12.53 16.28a.75.75 0 01-1.06 0l-7.5-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef28 = React36.forwardRef(ChevronDownIcon);
var ChevronDownIcon_default = ForwardRef28;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronRightIcon.js
var React37 = __toESM(require_react(), 1);
function ChevronRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React37.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React37.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React37.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef29 = React37.forwardRef(ChevronRightIcon);
var ChevronRightIcon_default = ForwardRef29;

// ../../node_modules/@heroicons/react/24/solid/esm/EllipsisVerticalIcon.js
var React38 = __toESM(require_react(), 1);
function EllipsisVerticalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React38.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React38.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React38.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z",
    clipRule: "evenodd"
  }));
}
var ForwardRef30 = React38.forwardRef(EllipsisVerticalIcon);
var EllipsisVerticalIcon_default = ForwardRef30;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationCircleIcon.js
var React39 = __toESM(require_react(), 1);
function ExclamationCircleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React39.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React39.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React39.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef31 = React39.forwardRef(ExclamationCircleIcon2);
var ExclamationCircleIcon_default2 = ForwardRef31;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationTriangleIcon.js
var React40 = __toESM(require_react(), 1);
function ExclamationTriangleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React40.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React40.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React40.createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
  }));
}
var ForwardRef32 = React40.forwardRef(ExclamationTriangleIcon2);
var ExclamationTriangleIcon_default2 = ForwardRef32;

// ../../node_modules/@heroicons/react/24/solid/esm/MoonIcon.js
var React41 = __toESM(require_react(), 1);
function MoonIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React41.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React41.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React41.createElement("path", {
    fillRule: "evenodd",
    d: "M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z",
    clipRule: "evenodd"
  }));
}
var ForwardRef33 = React41.forwardRef(MoonIcon);
var MoonIcon_default = ForwardRef33;

// ../../node_modules/@heroicons/react/24/solid/esm/XCircleIcon.js
var React42 = __toESM(require_react(), 1);
function XCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React42.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React42.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React42.createElement("path", {
    fillRule: "evenodd",
    d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm-1.72 6.97a.75.75 0 10-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 101.06 1.06L12 13.06l1.72 1.72a.75.75 0 101.06-1.06L13.06 12l1.72-1.72a.75.75 0 10-1.06-1.06L12 10.94l-1.72-1.72z",
    clipRule: "evenodd"
  }));
}
var ForwardRef34 = React42.forwardRef(XCircleIcon);
var XCircleIcon_default = ForwardRef34;

// ../../packages/myst-to-react/dist/admonitions.js
var import_classnames5 = __toESM(require_classnames(), 1);
var AdmonitionKind;
(function(AdmonitionKind2) {
  AdmonitionKind2["admonition"] = "admonition";
  AdmonitionKind2["attention"] = "attention";
  AdmonitionKind2["caution"] = "caution";
  AdmonitionKind2["danger"] = "danger";
  AdmonitionKind2["error"] = "error";
  AdmonitionKind2["important"] = "important";
  AdmonitionKind2["hint"] = "hint";
  AdmonitionKind2["note"] = "note";
  AdmonitionKind2["seealso"] = "seealso";
  AdmonitionKind2["tip"] = "tip";
  AdmonitionKind2["warning"] = "warning";
})(AdmonitionKind || (AdmonitionKind = {}));
function getClasses(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getFirstKind({ kind, classes = [] }) {
  if (kind === AdmonitionKind.note || classes.includes("note")) {
    return { kind: AdmonitionKind.note, color: "blue" };
  }
  if (kind === AdmonitionKind.important || classes.includes("important")) {
    return { kind: AdmonitionKind.important, color: "blue" };
  }
  if (kind === AdmonitionKind.hint || classes.includes("hint")) {
    return { kind: AdmonitionKind.hint, color: "green" };
  }
  if (kind === AdmonitionKind.seealso || classes.includes("seealso")) {
    return { kind: AdmonitionKind.seealso, color: "green" };
  }
  if (kind === AdmonitionKind.tip || classes.includes("tip")) {
    return { kind: AdmonitionKind.tip, color: "green" };
  }
  if (kind === AdmonitionKind.attention || classes.includes("attention")) {
    return { kind: AdmonitionKind.attention, color: "yellow" };
  }
  if (kind === AdmonitionKind.warning || classes.includes("warning")) {
    return { kind: AdmonitionKind.warning, color: "yellow" };
  }
  if (kind === AdmonitionKind.caution || classes.includes("caution")) {
    return { kind: AdmonitionKind.caution, color: "yellow" };
  }
  if (kind === AdmonitionKind.danger || classes.includes("danger")) {
    return { kind: AdmonitionKind.danger, color: "red" };
  }
  if (kind === AdmonitionKind.error || classes.includes("error")) {
    return { kind: AdmonitionKind.error, color: "red" };
  }
  return { kind: AdmonitionKind.note, color: "blue" };
}
var iconClass = "inline-block pl-2 mr-2 self-center flex-none";
function AdmonitionIcon({ kind, className }) {
  const cn = (0, import_classnames5.default)(iconClass, className);
  const opts = { width: "2rem", height: "2rem", className: cn };
  if (kind === AdmonitionKind.note)
    return (0, import_jsx_runtime16.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.caution)
    return (0, import_jsx_runtime16.jsx)(ExclamationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.warning)
    return (0, import_jsx_runtime16.jsx)(ExclamationTriangleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.danger)
    return (0, import_jsx_runtime16.jsx)(ExclamationCircleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.error)
    return (0, import_jsx_runtime16.jsx)(XCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.attention)
    return (0, import_jsx_runtime16.jsx)(MegaphoneIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.tip)
    return (0, import_jsx_runtime16.jsx)(PencilSquareIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.hint)
    return (0, import_jsx_runtime16.jsx)(LightBulbIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.important)
    return (0, import_jsx_runtime16.jsx)(BoltIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.seealso)
    return (0, import_jsx_runtime16.jsx)(ArrowRightCircleIcon_default, Object.assign({}, opts));
  return (0, import_jsx_runtime16.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
}
var AdmonitionTitle = ({ node }) => {
  return (0, import_jsx_runtime16.jsx)(MyST, { ast: node.children });
};
var WrapperElement = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime16.jsx)("details", { className, children });
  return (0, import_jsx_runtime16.jsx)("aside", { className, children });
};
var HeaderElement = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime16.jsx)("summary", { className, children });
  return (0, import_jsx_runtime16.jsx)("div", { className, children });
};
function Admonition({ title, kind, color: color2, simple, dropdown, children, hideIcon, className }) {
  return (0, import_jsx_runtime16.jsxs)(WrapperElement, { dropdown, className: (0, import_classnames5.default)("my-5 shadow-md dark:shadow-2xl dark:shadow-neutral-900", "bg-gray-50/10 dark:bg-stone-800", "overflow-hidden", {
    "rounded border-l-4": !simple,
    "border-l-2": simple,
    "border-blue-500": !color2 || color2 === "blue",
    "border-green-600": color2 === "green",
    "border-amber-600": color2 === "yellow",
    "border-red-600": color2 === "red"
  }, className), children: [title && (0, import_jsx_runtime16.jsxs)(HeaderElement, { dropdown, className: (0, import_classnames5.default)("m-0 font-medium py-1 flex min-w-0", {
    "text-lg": !simple,
    "text-md": simple,
    "bg-gray-100 dark:bg-stone-700": simple,
    "text-blue-600 bg-blue-50 dark:bg-slate-900": !simple && (!color2 || color2 === "blue"),
    "text-green-600 bg-green-50 dark:bg-slate-900": !simple && color2 === "green",
    "text-amber-600 bg-amber-50 dark:bg-slate-900": !simple && color2 === "yellow",
    "text-red-600 bg-red-50 dark:bg-slate-900": !simple && color2 === "red",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [!hideIcon && (0, import_jsx_runtime16.jsx)(AdmonitionIcon, { kind: kind !== null && kind !== void 0 ? kind : AdmonitionKind.note, className: (0, import_classnames5.default)({
    // Needed for simple!
    "text-blue-600": !color2 || color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-red-600": color2 === "red"
  }) }), (0, import_jsx_runtime16.jsx)("div", { className: (0, import_classnames5.default)("text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", { "ml-4": hideIcon }), children: title }), dropdown && (0, import_jsx_runtime16.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime16.jsx)(ChevronRightIcon_default, { width: "2rem", height: "2rem", className: (0, import_classnames5.default)(iconClass, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime16.jsx)("div", { className: (0, import_classnames5.default)("px-4", { "py-1": !simple, "details-body": dropdown }), children })] });
}
var AdmonitionRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses(node.class);
  const { kind, color: color2 } = getFirstKind({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const isSimple = classes.includes("simple");
  const hideIcon = node.icon === false;
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime16.jsx)(Admonition, { title: useTitle ? (0, import_jsx_runtime16.jsx)(MyST, { ast: [title] }) : void 0, kind, color: color2, dropdown: isDropdown, simple: isSimple, hideIcon, className: (0, import_classnames5.default)(classes), children: useTitle ? (0, import_jsx_runtime16.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime16.jsx)(MyST, { ast: node.children }) });
};
var ADMONITION_RENDERERS = {
  admonition: AdmonitionRenderer,
  admonitionTitle: AdmonitionTitle
};
var admonitions_default = ADMONITION_RENDERERS;

// ../../packages/myst-to-react/dist/dropdown.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_classnames6 = __toESM(require_classnames(), 1);
var iconClass2 = "inline-block pl-2 mr-2 -translate-y-[1px]";
var SummaryTitle = ({ node }) => {
  return (0, import_jsx_runtime17.jsx)(MyST, { ast: node.children });
};
function Details({ title, children, open }) {
  return (0, import_jsx_runtime17.jsxs)("details", { className: (0, import_classnames6.default)("rounded-md my-5 shadow dark:shadow-2xl dark:shadow-neutral-900 overflow-hidden", "bg-gray-50 dark:bg-stone-800"), open, children: [(0, import_jsx_runtime17.jsx)("summary", { className: (0, import_classnames6.default)("m-0 text-lg font-medium py-1 min-h-[2em] pl-3", "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]", "bg-gray-100 dark:bg-slate-900"), children: (0, import_jsx_runtime17.jsxs)("span", { className: "text-neutral-900 dark:text-white", children: [(0, import_jsx_runtime17.jsx)("span", { className: "block float-right text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime17.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames6.default)(iconClass2, "details-toggle", "transition-transform") }) }), title] }) }), (0, import_jsx_runtime17.jsx)("div", { className: "px-4 py-1 details-body", children })] });
}
var DetailsRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  return (0, import_jsx_runtime17.jsx)(Details, { title: (0, import_jsx_runtime17.jsx)(MyST, { ast: [title] }), open: node.open, children: (0, import_jsx_runtime17.jsx)(MyST, { ast: rest2 }) });
};
var DROPDOWN_RENDERERS = {
  details: DetailsRenderer,
  summary: SummaryTitle
};
var dropdown_default = DROPDOWN_RENDERERS;

// ../../packages/myst-to-react/dist/card.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);
var Header = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("header", { className: "py-1 pl-3 m-0 border-b border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
var Footer = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("footer", { className: "py-1 pl-3 m-0 border-t border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
var CardTitle = ({ node }) => {
  return (0, import_jsx_runtime18.jsx)("div", { className: "pt-3 font-bold group-hover:underline", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: node.children }) });
};
function getParts(children) {
  var _a, _b;
  const parts = {};
  if (!Array.isArray(children))
    return parts;
  const next = [...children];
  if (((_a = next[0]) === null || _a === void 0 ? void 0 : _a.type) === "header") {
    parts.header = next.splice(0, 1);
  }
  if (((_b = next[next.length - 1]) === null || _b === void 0 ? void 0 : _b.type) === "footer") {
    parts.footer = next.splice(-1, 1);
  }
  parts.body = next;
  return parts;
}
function ExternalOrInternalLink({ to, className, isStatic, prefetch = "intent", children }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  if (to.startsWith("http") || isStatic) {
    return (0, import_jsx_runtime18.jsx)("a", { href: to, className, target: "_blank", rel: "noopener noreferrer", children });
  }
  return (0, import_jsx_runtime18.jsx)(Link2, { to: withBaseurl(to, baseurl), className, prefetch, children });
}
var CardRenderer = ({ node }) => {
  const parts = getParts(node.children);
  const url = node.url;
  const isStatic = node.static || false;
  const link2 = !!url;
  const sharedStyle = "my-5 rounded shadow dark:shadow-neutral-800 overflow-hidden border border-gray-100 dark:border-gray-800 flex flex-col";
  if (link2) {
    return (0, import_jsx_runtime18.jsxs)(ExternalOrInternalLink, { to: url, isStatic, className: (0, import_classnames7.default)(sharedStyle, "text-inherit hover:text-inherit", "block font-normal no-underline hover:no-underline cursor-pointer group", "hover:border-blue-500 dark:hover:border-blue-400"), children: [(0, import_jsx_runtime18.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime18.jsx)("div", { className: "flex-grow px-4 py-2", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.footer })] });
  }
  return (0, import_jsx_runtime18.jsxs)("div", { className: sharedStyle, children: [(0, import_jsx_runtime18.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime18.jsx)("div", { className: "flex-grow px-4 py-2", children: (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime18.jsx)(MyST, { ast: parts.footer })] });
};
var CARD_RENDERERS = {
  card: CardRenderer,
  cardTitle: CardTitle,
  header: Header,
  footer: Footer
};
var card_default = CARD_RENDERERS;

// ../../packages/myst-to-react/dist/grid.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_classnames8 = __toESM(require_classnames(), 1);
var gridClassNames = {
  main: [
    "grid-cols-1",
    "grid-cols-2",
    "grid-cols-3",
    "grid-cols-4",
    "grid-cols-5",
    "grid-cols-6",
    "grid-cols-7",
    "grid-cols-8",
    "grid-cols-9",
    "grid-cols-10",
    "grid-cols-11",
    "grid-cols-12"
  ],
  sm: [
    "sm:grid-cols-1",
    "sm:grid-cols-2",
    "sm:grid-cols-3",
    "sm:grid-cols-4",
    "sm:grid-cols-5",
    "sm:grid-cols-6",
    "sm:grid-cols-7",
    "sm:grid-cols-8",
    "sm:grid-cols-9",
    "sm:grid-cols-10",
    "sm:grid-cols-11",
    "sm:grid-cols-12"
  ],
  md: [
    "md:grid-cols-1",
    "md:grid-cols-2",
    "md:grid-cols-3",
    "md:grid-cols-4",
    "md:grid-cols-5",
    "md:grid-cols-6",
    "md:grid-cols-7",
    "md:grid-cols-8",
    "md:grid-cols-9",
    "md:grid-cols-10",
    "md:grid-cols-11",
    "md:grid-cols-12"
  ],
  lg: [
    "lg:grid-cols-1",
    "lg:grid-cols-2",
    "lg:grid-cols-3",
    "lg:grid-cols-4",
    "lg:grid-cols-5",
    "lg:grid-cols-6",
    "lg:grid-cols-7",
    "lg:grid-cols-8",
    "lg:grid-cols-9",
    "lg:grid-cols-10",
    "lg:grid-cols-11",
    "lg:grid-cols-12"
  ],
  xl: [
    "xl:grid-cols-1",
    "xl:grid-cols-2",
    "xl:grid-cols-3",
    "xl:grid-cols-4",
    "xl:grid-cols-5",
    "xl:grid-cols-6",
    "xl:grid-cols-7",
    "xl:grid-cols-8",
    "xl:grid-cols-9",
    "xl:grid-cols-10",
    "xl:grid-cols-11",
    "xl:grid-cols-12"
  ]
};
var DEFAULT_NUM_COLUMNS = 3;
function getColumnClassName(classes, number) {
  var _a;
  const num = Number(number);
  if (!number || Number.isNaN(num)) {
    return getColumnClassName(classes, DEFAULT_NUM_COLUMNS);
  }
  return (_a = classes[num - 1]) !== null && _a !== void 0 ? _a : classes[DEFAULT_NUM_COLUMNS];
}
function gridColumnClasses(columns) {
  if (!columns || columns.length <= 1) {
    return getColumnClassName(gridClassNames.main, columns === null || columns === void 0 ? void 0 : columns[0]);
  }
  if (columns.length !== 4) {
    return getColumnClassName(gridClassNames.main, columns[0]);
  }
  return [
    // getColumnClassName(gridClassNames.main, columns[0]),
    getColumnClassName(gridClassNames.sm, columns[0]),
    getColumnClassName(gridClassNames.md, columns[1]),
    getColumnClassName(gridClassNames.lg, columns[2]),
    getColumnClassName(gridClassNames.xl, columns[3])
  ].join(" ");
}
function Grid({ columns, children }) {
  const gridClasses = gridColumnClasses(columns);
  const gutterClasses = "gap-4";
  return (0, import_jsx_runtime19.jsx)("div", { className: (0, import_classnames8.default)("myst-grid grid my-5", gridClasses, gutterClasses), children });
}
var GridRenderer = ({ node }) => {
  return (0, import_jsx_runtime19.jsx)(Grid, { columns: node.columns, children: (0, import_jsx_runtime19.jsx)(MyST, { ast: node.children }) });
};
var GRID_RENDERERS = {
  grid: GridRenderer
};
var grid_default = GRID_RENDERERS;

// ../../packages/myst-to-react/dist/cite.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_classnames9 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/inlineError.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function InlineError({ value, message }) {
  return (0, import_jsx_runtime20.jsxs)("span", { className: "text-yellow-600", title: message || value, children: [(0, import_jsx_runtime20.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), value] });
}

// ../../packages/myst-to-react/dist/cite.js
function useNumberedReferences() {
  var _a;
  const config = useSiteManifest();
  const numbered_references = !!((_a = config === null || config === void 0 ? void 0 : config.options) === null || _a === void 0 ? void 0 : _a.numbered_references);
  return numbered_references;
}
function CiteChild({ html }) {
  return (0, import_jsx_runtime21.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", dangerouslySetInnerHTML: { __html: html || "" } });
}
var CiteGroup = ({ node }) => {
  var _a, _b;
  const allCite = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.every((child) => child.type === "cite")) !== null && _b !== void 0 ? _b : false;
  return (0, import_jsx_runtime21.jsx)("span", { className: (0, import_classnames9.default)({
    "cite-group": allCite,
    "xref-group": !allCite,
    narrative: node.kind === "narrative",
    parenthetical: node.kind === "parenthetical"
  }), children: (0, import_jsx_runtime21.jsx)(MyST, { ast: node.children }) });
};
var Cite = ({ label, error, children }) => {
  var _a, _b;
  const references = useReferences();
  if (!label) {
    return (0, import_jsx_runtime21.jsx)(InlineError, { value: "cite (no label)", message: "Citation Has No Label" });
  }
  const { html, doi: doiString, url: refUrl } = (_b = (_a = references === null || references === void 0 ? void 0 : references.cite) === null || _a === void 0 ? void 0 : _a.data[label]) !== null && _b !== void 0 ? _b : {};
  if (error) {
    return (0, import_jsx_runtime21.jsx)(InlineError, { value: label, message: "Citation Not Found" });
  }
  const url = doiString ? doi.buildUrl(doiString) : refUrl;
  return (0, import_jsx_runtime21.jsx)(HoverPopover, { openDelay: 300, card: (0, import_jsx_runtime21.jsx)(CiteChild, { html }), children: (0, import_jsx_runtime21.jsxs)("cite", { children: [url && (0, import_jsx_runtime21.jsx)("a", { href: url, target: "_blank", rel: "noreferrer", className: "hover-link", children }), !url && (0, import_jsx_runtime21.jsx)("span", { className: "hover-link", children })] }) });
};
var CiteRenderer = ({ node }) => {
  const numbered = useNumberedReferences();
  return (0, import_jsx_runtime21.jsx)(Cite, { label: node.label, error: node.error, children: numbered && node.kind === "parenthetical" ? node.enumerator : (0, import_jsx_runtime21.jsx)(MyST, { ast: node.children }) });
};
var CITE_RENDERERS = {
  citeGroup: CiteGroup,
  cite: CiteRenderer
};
var cite_default = CITE_RENDERERS;

// ../../packages/myst-to-react/dist/footnotes.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function FootnoteDefinition({ identifier }) {
  var _a, _b;
  const references = useReferences();
  const node = (_b = (_a = references === null || references === void 0 ? void 0 : references.footnotes) === null || _a === void 0 ? void 0 : _a[identifier]) !== null && _b !== void 0 ? _b : select(`footnoteDefinition[identifier=${identifier}]`, references === null || references === void 0 ? void 0 : references.article);
  return (0, import_jsx_runtime22.jsx)(XRefProvider, { children: (0, import_jsx_runtime22.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] px-3 text-sm", children: (0, import_jsx_runtime22.jsx)(MyST, { ast: node.children }) }) });
}
var FootnoteReference = ({ node }) => {
  var _a, _b;
  return (0, import_jsx_runtime22.jsx)(HoverPopover, { openDelay: 0, card: (0, import_jsx_runtime22.jsx)(FootnoteDefinition, { identifier: node.identifier }), children: (0, import_jsx_runtime22.jsx)("span", { id: `fnref-${node.key}`, children: (0, import_jsx_runtime22.jsx)("sup", { className: "hover-link", children: (0, import_jsx_runtime22.jsxs)(HashLink, { id: `fn-${node.identifier}`, title: "Link to Footnote", scrollBehavior: "instant", canSelectText: true, children: ["[", (_b = (_a = node.enumerator) !== null && _a !== void 0 ? _a : node.number) !== null && _b !== void 0 ? _b : node.identifier, "]"] }) }) }) });
};
var FOOTNOTE_RENDERERS = {
  footnoteReference: FootnoteReference,
  // Do not render the definitions, they get pulled in by a handler
  footnoteDefinition: () => null
};
var footnotes_default = FOOTNOTE_RENDERERS;

// ../../packages/myst-to-react/dist/code.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i5;
  for (i5 = 0; i5 < sourceKeys.length; i5++) {
    key = sourceKeys[i5];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i5;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {
      key = sourceSymbolKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// ../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
init_arrayLikeToArray();
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// ../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
init_unsupportedIterableToArray();

// ../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// ../../node_modules/react-syntax-highlighter/dist/esm/highlight.js
init_defineProperty();
var import_react31 = __toESM(require_react());

// ../../node_modules/react-syntax-highlighter/dist/esm/create-element.js
init_extends();
init_defineProperty();
var import_react30 = __toESM(require_react());
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = null != arguments[i5] ? arguments[i5] : {};
    i5 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames40) {
  if (classNames40.length === 0 || classNames40.length === 1)
    return classNames40;
  var key = classNames40.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames40);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames40) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames40.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames40) {
  return classNames40.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i5) {
      return createElement35({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i5)
      });
    });
  };
}
function createElement35(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node.properties, type2 = node.type, TagName = node.tagName, value = node.value;
  if (type2 === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ import_react30.default.createElement(TagName, _extends({
      key
    }, props), children);
  }
}

// ../../node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};

// ../../node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = null != arguments[i5] ? arguments[i5] : {};
    i5 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var newLineRegex = /\n/g;
function getNewLines(str2) {
  return str2.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_5, i5) {
    var number = i5 + startingLineNumber;
    return /* @__PURE__ */ import_react31.default.createElement("span", {
      key: "line-".concat(i5),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number) : style
    }, "".concat(number, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ import_react31.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread2(_objectSpread2({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i5 = 0; i5 < tree.length; i5++) {
    var node = tree[i5];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node.children) {
      var classNames40 = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames40).forEach(function(i6) {
        return newTree.push(i6);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index2 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index2];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i5) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i5 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i5 === splitValue.length - 1) {
          var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index2 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index2;
    }
    index2++;
  };
  while (index2 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i5) {
    return createElement35({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i5)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code3 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code3);
    } else {
      return astGenerator.highlightAuto(code3);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code3, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e4) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code3 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest2 = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ import_react31.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code3
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest2, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest2, {
      className: rest2.className ? "".concat(generatorClassName, " ").concat(rest2.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return /* @__PURE__ */ import_react31.default.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ import_react31.default.createElement(CodeTag, codeTagProps, code3));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code3
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code: code3,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ import_react31.default.createElement(PreTag, preProps, /* @__PURE__ */ import_react31.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}

// ../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject4, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject4(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject4) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject4, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject4, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// ../../node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_extends();

// ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// ../../node_modules/@babel/runtime/helpers/esm/createClass.js
init_toPropertyKey();
function _defineProperties(target, props) {
  for (var i5 = 0; i5 < props.length; i5++) {
    var descriptor = props[i5];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o10, p3) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p4) {
    o11.__proto__ = p4;
    return o11;
  };
  return _setPrototypeOf(o10, p3);
}

// ../../node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
init_typeof();

// ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o10) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o11) {
    return o11.__proto__ || Object.getPrototypeOf(o11);
  };
  return _getPrototypeOf(o10);
}

// ../../node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_defineProperty();
var import_regenerator = __toESM(require_regenerator());
var import_react32 = __toESM(require_react());
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e4) {
    return false;
  }
}
var async_syntax_highlighter_default = function(options) {
  var loader3 = options.loader, isLanguageRegistered2 = options.isLanguageRegistered, registerLanguage2 = options.registerLanguage, languageLoaders = options.languageLoaders, noAsyncLoadingLanguages = options.noAsyncLoadingLanguages;
  var ReactAsyncHighlighter = /* @__PURE__ */ function(_React$PureComponent) {
    _inherits(ReactAsyncHighlighter2, _React$PureComponent);
    var _super = _createSuper(ReactAsyncHighlighter2);
    function ReactAsyncHighlighter2() {
      _classCallCheck(this, ReactAsyncHighlighter2);
      return _super.apply(this, arguments);
    }
    _createClass(ReactAsyncHighlighter2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this = this;
        if (!ReactAsyncHighlighter2.astGeneratorPromise) {
          ReactAsyncHighlighter2.loadAstGenerator();
        }
        if (!ReactAsyncHighlighter2.astGenerator) {
          ReactAsyncHighlighter2.astGeneratorPromise.then(function() {
            _this.forceUpdate();
          });
        }
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "loadLanguage",
      value: function loadLanguage() {
        var _this2 = this;
        var language = this.props.language;
        if (language === "text") {
          return;
        }
        ReactAsyncHighlighter2.loadLanguage(language).then(function() {
          return _this2.forceUpdate();
        })["catch"](function() {
        });
      }
    }, {
      key: "normalizeLanguage",
      value: function normalizeLanguage2(language) {
        return ReactAsyncHighlighter2.isSupportedLanguage(language) ? language : "text";
      }
    }, {
      key: "render",
      value: function render() {
        return /* @__PURE__ */ import_react32.default.createElement(ReactAsyncHighlighter2.highlightInstance, _extends({}, this.props, {
          language: this.normalizeLanguage(this.props.language),
          astGenerator: ReactAsyncHighlighter2.astGenerator
        }));
      }
    }], [{
      key: "preload",
      value: function preload2() {
        return ReactAsyncHighlighter2.loadAstGenerator();
      }
    }, {
      key: "loadLanguage",
      value: function() {
        var _loadLanguage = _asyncToGenerator(/* @__PURE__ */ import_regenerator.default.mark(function _callee(language) {
          var languageLoader;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  languageLoader = languageLoaders[language];
                  if (!(typeof languageLoader === "function")) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return", languageLoader(ReactAsyncHighlighter2.registerLanguage));
                case 5:
                  throw new Error("Language ".concat(language, " not supported"));
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function loadLanguage(_x) {
          return _loadLanguage.apply(this, arguments);
        }
        return loadLanguage;
      }()
    }, {
      key: "isSupportedLanguage",
      value: function isSupportedLanguage(language) {
        return ReactAsyncHighlighter2.isRegistered(language) || typeof languageLoaders[language] === "function";
      }
    }, {
      key: "loadAstGenerator",
      value: function loadAstGenerator() {
        ReactAsyncHighlighter2.astGeneratorPromise = loader3().then(function(astGenerator) {
          ReactAsyncHighlighter2.astGenerator = astGenerator;
          if (registerLanguage2) {
            ReactAsyncHighlighter2.languages.forEach(function(language, name) {
              return registerLanguage2(astGenerator, name, language);
            });
          }
        });
        return ReactAsyncHighlighter2.astGeneratorPromise;
      }
    }]);
    return ReactAsyncHighlighter2;
  }(import_react32.default.PureComponent);
  _defineProperty(ReactAsyncHighlighter, "astGenerator", null);
  _defineProperty(ReactAsyncHighlighter, "highlightInstance", highlight_default(null, {}));
  _defineProperty(ReactAsyncHighlighter, "astGeneratorPromise", null);
  _defineProperty(ReactAsyncHighlighter, "languages", /* @__PURE__ */ new Map());
  _defineProperty(ReactAsyncHighlighter, "supportedLanguages", options.supportedLanguages || Object.keys(languageLoaders || {}));
  _defineProperty(ReactAsyncHighlighter, "isRegistered", function(language) {
    if (noAsyncLoadingLanguages) {
      return true;
    }
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (!ReactAsyncHighlighter.astGenerator) {
      return ReactAsyncHighlighter.languages.has(language);
    }
    return isLanguageRegistered2(ReactAsyncHighlighter.astGenerator, language);
  });
  _defineProperty(ReactAsyncHighlighter, "registerLanguage", function(name, language) {
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (ReactAsyncHighlighter.astGenerator) {
      return registerLanguage2(ReactAsyncHighlighter.astGenerator, name, language);
    } else {
      ReactAsyncHighlighter.languages.set(name, language);
    }
  });
  return ReactAsyncHighlighter;
};

// ../../node_modules/react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js
var import_regenerator2 = __toESM(require_regenerator());
var create_language_async_loader_default = function(name, loader3) {
  return /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ import_regenerator2.default.mark(function _callee(registerLanguage2) {
      var module;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return loader3();
            case 2:
              module = _context.sent;
              registerLanguage2(name, module["default"] || module);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// ../../node_modules/react-syntax-highlighter/dist/esm/async-languages/hljs.js
var hljs_default = {
  oneC: create_language_async_loader_default("oneC", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oneC" */
      "/myst_assets_folder/_shared/1c-MHGWKMBU.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_abnf" */
      "/myst_assets_folder/_shared/abnf-H5EOJU5I.js"
    );
  }),
  accesslog: create_language_async_loader_default("accesslog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_accesslog" */
      "/myst_assets_folder/_shared/accesslog-26TXF36J.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_actionscript" */
      "/myst_assets_folder/_shared/actionscript-URKB2GAW.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ada" */
      "/myst_assets_folder/_shared/ada-E76XDXKR.js"
    );
  }),
  angelscript: create_language_async_loader_default("angelscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_angelscript" */
      "/myst_assets_folder/_shared/angelscript-WQKK53P2.js"
    );
  }),
  apache: create_language_async_loader_default("apache", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_apache" */
      "/myst_assets_folder/_shared/apache-YMG342ZQ.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_applescript" */
      "/myst_assets_folder/_shared/applescript-MOOLDF45.js"
    );
  }),
  arcade: create_language_async_loader_default("arcade", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arcade" */
      "/myst_assets_folder/_shared/arcade-DFFDL6I4.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arduino" */
      "/myst_assets_folder/_shared/arduino-HJBIFQTP.js"
    );
  }),
  armasm: create_language_async_loader_default("armasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_armasm" */
      "/myst_assets_folder/_shared/armasm-2USUE5BZ.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_asciidoc" */
      "/myst_assets_folder/_shared/asciidoc-PZYBP5RZ.js"
    );
  }),
  aspectj: create_language_async_loader_default("aspectj", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_aspectj" */
      "/myst_assets_folder/_shared/aspectj-GHIZVSQR.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autohotkey" */
      "/myst_assets_folder/_shared/autohotkey-KR2SMGSD.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autoit" */
      "/myst_assets_folder/_shared/autoit-GVOUXSYQ.js"
    );
  }),
  avrasm: create_language_async_loader_default("avrasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_avrasm" */
      "/myst_assets_folder/_shared/avrasm-4T6X3NWK.js"
    );
  }),
  awk: create_language_async_loader_default("awk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_awk" */
      "/myst_assets_folder/_shared/awk-UK4J2WVU.js"
    );
  }),
  axapta: create_language_async_loader_default("axapta", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_axapta" */
      "/myst_assets_folder/_shared/axapta-AR6IZC3T.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bash" */
      "/myst_assets_folder/_shared/bash-FZTXAYMB.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_basic" */
      "/myst_assets_folder/_shared/basic-ZDA2M3HM.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bnf" */
      "/myst_assets_folder/_shared/bnf-4DXNWTVZ.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_brainfuck" */
      "/myst_assets_folder/_shared/brainfuck-WBCGGNCT.js"
    );
  }),
  cLike: create_language_async_loader_default("cLike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cLike" */
      "/myst_assets_folder/_shared/c-like-ZISFRDMK.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_c" */
      "/myst_assets_folder/_shared/c-DRLI5UX7.js"
    );
  }),
  cal: create_language_async_loader_default("cal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cal" */
      "/myst_assets_folder/_shared/cal-IFAXRS36.js"
    );
  }),
  capnproto: create_language_async_loader_default("capnproto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_capnproto" */
      "/myst_assets_folder/_shared/capnproto-FXZHDEBZ.js"
    );
  }),
  ceylon: create_language_async_loader_default("ceylon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ceylon" */
      "/myst_assets_folder/_shared/ceylon-4AE5V4IA.js"
    );
  }),
  clean: create_language_async_loader_default("clean", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clean" */
      "/myst_assets_folder/_shared/clean-BFWXERNJ.js"
    );
  }),
  clojureRepl: create_language_async_loader_default("clojureRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojureRepl" */
      "/myst_assets_folder/_shared/clojure-repl-YPX2YXMS.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojure" */
      "/myst_assets_folder/_shared/clojure-LKLOJ57P.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cmake" */
      "/myst_assets_folder/_shared/cmake-ZIVROEQD.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coffeescript" */
      "/myst_assets_folder/_shared/coffeescript-3OG4VSZD.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coq" */
      "/myst_assets_folder/_shared/coq-LOG5YZWQ.js"
    );
  }),
  cos: create_language_async_loader_default("cos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cos" */
      "/myst_assets_folder/_shared/cos-E22MF3DB.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cpp" */
      "/myst_assets_folder/_shared/cpp-H6YRHWOK.js"
    );
  }),
  crmsh: create_language_async_loader_default("crmsh", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crmsh" */
      "/myst_assets_folder/_shared/crmsh-WS7T5MVS.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crystal" */
      "/myst_assets_folder/_shared/crystal-OYIWXL5P.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csharp" */
      "/myst_assets_folder/_shared/csharp-HCSJ2ADA.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csp" */
      "/myst_assets_folder/_shared/csp-XCQFOTZ4.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_css" */
      "/myst_assets_folder/_shared/css-JPNILUVY.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_d" */
      "/myst_assets_folder/_shared/d-UOA55URV.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dart" */
      "/myst_assets_folder/_shared/dart-NTKQOJ2B.js"
    );
  }),
  delphi: create_language_async_loader_default("delphi", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_delphi" */
      "/myst_assets_folder/_shared/delphi-HDKNI54B.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_diff" */
      "/myst_assets_folder/_shared/diff-4AAW2IBS.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_django" */
      "/myst_assets_folder/_shared/django-JLC6LLAG.js"
    );
  }),
  dns: create_language_async_loader_default("dns", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dns" */
      "/myst_assets_folder/_shared/dns-GE4OEAIA.js"
    );
  }),
  dockerfile: create_language_async_loader_default("dockerfile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dockerfile" */
      "/myst_assets_folder/_shared/dockerfile-IJZ2IBH3.js"
    );
  }),
  dos: create_language_async_loader_default("dos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dos" */
      "/myst_assets_folder/_shared/dos-G4DXODOP.js"
    );
  }),
  dsconfig: create_language_async_loader_default("dsconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dsconfig" */
      "/myst_assets_folder/_shared/dsconfig-TV7GEKFV.js"
    );
  }),
  dts: create_language_async_loader_default("dts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dts" */
      "/myst_assets_folder/_shared/dts-KNEI4MQS.js"
    );
  }),
  dust: create_language_async_loader_default("dust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dust" */
      "/myst_assets_folder/_shared/dust-S24GE5NR.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ebnf" */
      "/myst_assets_folder/_shared/ebnf-RW3SWHIK.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elixir" */
      "/myst_assets_folder/_shared/elixir-GNCLYP3H.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elm" */
      "/myst_assets_folder/_shared/elm-35DVSYY4.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erb" */
      "/myst_assets_folder/_shared/erb-2SS2OBHN.js"
    );
  }),
  erlangRepl: create_language_async_loader_default("erlangRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlangRepl" */
      "/myst_assets_folder/_shared/erlang-repl-KJDFF2FP.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlang" */
      "/myst_assets_folder/_shared/erlang-SDQVBHKA.js"
    );
  }),
  excel: create_language_async_loader_default("excel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_excel" */
      "/myst_assets_folder/_shared/excel-G2SWGXTX.js"
    );
  }),
  fix: create_language_async_loader_default("fix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fix" */
      "/myst_assets_folder/_shared/fix-2M4LSMD3.js"
    );
  }),
  flix: create_language_async_loader_default("flix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_flix" */
      "/myst_assets_folder/_shared/flix-AOSLYJOZ.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fortran" */
      "/myst_assets_folder/_shared/fortran-CYDMD2Q4.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fsharp" */
      "/myst_assets_folder/_shared/fsharp-IB2HV44P.js"
    );
  }),
  gams: create_language_async_loader_default("gams", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gams" */
      "/myst_assets_folder/_shared/gams-I6SYZBQQ.js"
    );
  }),
  gauss: create_language_async_loader_default("gauss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gauss" */
      "/myst_assets_folder/_shared/gauss-FEPW5DZR.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gcode" */
      "/myst_assets_folder/_shared/gcode-67SW3DYT.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gherkin" */
      "/myst_assets_folder/_shared/gherkin-AR37YGU5.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_glsl" */
      "/myst_assets_folder/_shared/glsl-P3NAVFG3.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gml" */
      "/myst_assets_folder/_shared/gml-UP3NI2XI.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_go" */
      "/myst_assets_folder/_shared/go-ACEDT3KZ.js"
    );
  }),
  golo: create_language_async_loader_default("golo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_golo" */
      "/myst_assets_folder/_shared/golo-UTSRFOLF.js"
    );
  }),
  gradle: create_language_async_loader_default("gradle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gradle" */
      "/myst_assets_folder/_shared/gradle-QI6HECFL.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_groovy" */
      "/myst_assets_folder/_shared/groovy-XOBHWGRB.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haml" */
      "/myst_assets_folder/_shared/haml-ER7WEXME.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_handlebars" */
      "/myst_assets_folder/_shared/handlebars-HF5AGIMZ.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haskell" */
      "/myst_assets_folder/_shared/haskell-J5OD36TD.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haxe" */
      "/myst_assets_folder/_shared/haxe-AL5NS6WV.js"
    );
  }),
  hsp: create_language_async_loader_default("hsp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hsp" */
      "/myst_assets_folder/_shared/hsp-AAHX6ZXX.js"
    );
  }),
  htmlbars: create_language_async_loader_default("htmlbars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_htmlbars" */
      "/myst_assets_folder/_shared/htmlbars-SP7I4KNP.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_http" */
      "/myst_assets_folder/_shared/http-7VNYFBDG.js"
    );
  }),
  hy: create_language_async_loader_default("hy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hy" */
      "/myst_assets_folder/_shared/hy-WTESAGC2.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_inform7" */
      "/myst_assets_folder/_shared/inform7-SIOMGB54.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ini" */
      "/myst_assets_folder/_shared/ini-374QS4C3.js"
    );
  }),
  irpf90: create_language_async_loader_default("irpf90", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_irpf90" */
      "/myst_assets_folder/_shared/irpf90-LJDNY6OC.js"
    );
  }),
  isbl: create_language_async_loader_default("isbl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_isbl" */
      "/myst_assets_folder/_shared/isbl-WSA5V4A7.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_java" */
      "/myst_assets_folder/_shared/java-6GLYUCNU.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_javascript" */
      "/myst_assets_folder/_shared/javascript-BF666MBQ.js"
    );
  }),
  jbossCli: create_language_async_loader_default("jbossCli", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_jbossCli" */
      "/myst_assets_folder/_shared/jboss-cli-MKUQ7IXI.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_json" */
      "/myst_assets_folder/_shared/json-KLQCI67V.js"
    );
  }),
  juliaRepl: create_language_async_loader_default("juliaRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_juliaRepl" */
      "/myst_assets_folder/_shared/julia-repl-ADD3T65E.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_julia" */
      "/myst_assets_folder/_shared/julia-55O2AJKT.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_kotlin" */
      "/myst_assets_folder/_shared/kotlin-ZTYIY7PK.js"
    );
  }),
  lasso: create_language_async_loader_default("lasso", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lasso" */
      "/myst_assets_folder/_shared/lasso-OMAZMCIV.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_latex" */
      "/myst_assets_folder/_shared/latex-PDQILGQC.js"
    );
  }),
  ldif: create_language_async_loader_default("ldif", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ldif" */
      "/myst_assets_folder/_shared/ldif-2Q5ZAGOR.js"
    );
  }),
  leaf: create_language_async_loader_default("leaf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_leaf" */
      "/myst_assets_folder/_shared/leaf-6QLAPFHU.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_less" */
      "/myst_assets_folder/_shared/less-7K3UGFMN.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lisp" */
      "/myst_assets_folder/_shared/lisp-J4UBE7QR.js"
    );
  }),
  livecodeserver: create_language_async_loader_default("livecodeserver", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livecodeserver" */
      "/myst_assets_folder/_shared/livecodeserver-QU2ZANUL.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livescript" */
      "/myst_assets_folder/_shared/livescript-L5DFJP24.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_llvm" */
      "/myst_assets_folder/_shared/llvm-5PD432JF.js"
    );
  }),
  lsl: create_language_async_loader_default("lsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lsl" */
      "/myst_assets_folder/_shared/lsl-MBEE77AS.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lua" */
      "/myst_assets_folder/_shared/lua-FLUELXU6.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_makefile" */
      "/myst_assets_folder/_shared/makefile-UBA35Z2R.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_markdown" */
      "/myst_assets_folder/_shared/markdown-E6Q2HGEO.js"
    );
  }),
  mathematica: create_language_async_loader_default("mathematica", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mathematica" */
      "/myst_assets_folder/_shared/mathematica-MK5EDHHX.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_matlab" */
      "/myst_assets_folder/_shared/matlab-6WLBCELN.js"
    );
  }),
  maxima: create_language_async_loader_default("maxima", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_maxima" */
      "/myst_assets_folder/_shared/maxima-VDWAGASY.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mel" */
      "/myst_assets_folder/_shared/mel-DCVR6EFC.js"
    );
  }),
  mercury: create_language_async_loader_default("mercury", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mercury" */
      "/myst_assets_folder/_shared/mercury-2MVJ5LYS.js"
    );
  }),
  mipsasm: create_language_async_loader_default("mipsasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mipsasm" */
      "/myst_assets_folder/_shared/mipsasm-RDO6HFVO.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mizar" */
      "/myst_assets_folder/_shared/mizar-TYWOGBG5.js"
    );
  }),
  mojolicious: create_language_async_loader_default("mojolicious", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mojolicious" */
      "/myst_assets_folder/_shared/mojolicious-EL4GHFQJ.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_monkey" */
      "/myst_assets_folder/_shared/monkey-3ZLYCIJB.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_moonscript" */
      "/myst_assets_folder/_shared/moonscript-A2RP65W4.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_n1ql" */
      "/myst_assets_folder/_shared/n1ql-NQKIGSIM.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nginx" */
      "/myst_assets_folder/_shared/nginx-W565FNZ3.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nim" */
      "/myst_assets_folder/_shared/nim-MH46TOOD.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nix" */
      "/myst_assets_folder/_shared/nix-5LP3WIEH.js"
    );
  }),
  nodeRepl: create_language_async_loader_default("nodeRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nodeRepl" */
      "/myst_assets_folder/_shared/node-repl-VEP7FG72.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nsis" */
      "/myst_assets_folder/_shared/nsis-MGN4YEZH.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_objectivec" */
      "/myst_assets_folder/_shared/objectivec-GP5QMJX2.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ocaml" */
      "/myst_assets_folder/_shared/ocaml-VKKSC4VB.js"
    );
  }),
  openscad: create_language_async_loader_default("openscad", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_openscad" */
      "/myst_assets_folder/_shared/openscad-EJTVYL5A.js"
    );
  }),
  oxygene: create_language_async_loader_default("oxygene", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oxygene" */
      "/myst_assets_folder/_shared/oxygene-ZFVMIADE.js"
    );
  }),
  parser3: create_language_async_loader_default("parser3", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_parser3" */
      "/myst_assets_folder/_shared/parser3-4ROQMPSM.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_perl" */
      "/myst_assets_folder/_shared/perl-JX4WVWW3.js"
    );
  }),
  pf: create_language_async_loader_default("pf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pf" */
      "/myst_assets_folder/_shared/pf-7FCDULWS.js"
    );
  }),
  pgsql: create_language_async_loader_default("pgsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pgsql" */
      "/myst_assets_folder/_shared/pgsql-XQMFM66V.js"
    );
  }),
  phpTemplate: create_language_async_loader_default("phpTemplate", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_phpTemplate" */
      "/myst_assets_folder/_shared/php-template-UA2EPYFC.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_php" */
      "/myst_assets_folder/_shared/php-Z36J4EVH.js"
    );
  }),
  plaintext: create_language_async_loader_default("plaintext", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_plaintext" */
      "/myst_assets_folder/_shared/plaintext-N4DHMJTU.js"
    );
  }),
  pony: create_language_async_loader_default("pony", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pony" */
      "/myst_assets_folder/_shared/pony-MMCU33FL.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_powershell" */
      "/myst_assets_folder/_shared/powershell-NHOQDQJK.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_processing" */
      "/myst_assets_folder/_shared/processing-BNTUHALF.js"
    );
  }),
  profile: create_language_async_loader_default("profile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_profile" */
      "/myst_assets_folder/_shared/profile-AUZ7M6AC.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_prolog" */
      "/myst_assets_folder/_shared/prolog-PCUS7NE4.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_properties" */
      "/myst_assets_folder/_shared/properties-JADFWFSU.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_protobuf" */
      "/myst_assets_folder/_shared/protobuf-QVYQHUH2.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_puppet" */
      "/myst_assets_folder/_shared/puppet-7GU24XSN.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_purebasic" */
      "/myst_assets_folder/_shared/purebasic-2ED2BKHR.js"
    );
  }),
  pythonRepl: create_language_async_loader_default("pythonRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pythonRepl" */
      "/myst_assets_folder/_shared/python-repl-QY5XDIQ5.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_python" */
      "/myst_assets_folder/_shared/python-HEIED5XX.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_q" */
      "/myst_assets_folder/_shared/q-QEBGLUX7.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_qml" */
      "/myst_assets_folder/_shared/qml-VKVYILLG.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_r" */
      "/myst_assets_folder/_shared/r-6ETPU5SA.js"
    );
  }),
  reasonml: create_language_async_loader_default("reasonml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_reasonml" */
      "/myst_assets_folder/_shared/reasonml-UA3FJLD2.js"
    );
  }),
  rib: create_language_async_loader_default("rib", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rib" */
      "/myst_assets_folder/_shared/rib-FAOIL4QA.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_roboconf" */
      "/myst_assets_folder/_shared/roboconf-GTPXFHUD.js"
    );
  }),
  routeros: create_language_async_loader_default("routeros", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_routeros" */
      "/myst_assets_folder/_shared/routeros-N7MBREZD.js"
    );
  }),
  rsl: create_language_async_loader_default("rsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rsl" */
      "/myst_assets_folder/_shared/rsl-TXVN6DSZ.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruby" */
      "/myst_assets_folder/_shared/ruby-J6RG2H5T.js"
    );
  }),
  ruleslanguage: create_language_async_loader_default("ruleslanguage", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruleslanguage" */
      "/myst_assets_folder/_shared/ruleslanguage-AYRMGHWL.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rust" */
      "/myst_assets_folder/_shared/rust-IFOIUIGA.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sas" */
      "/myst_assets_folder/_shared/sas-JMOH6BUE.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scala" */
      "/myst_assets_folder/_shared/scala-NLBOJPPF.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scheme" */
      "/myst_assets_folder/_shared/scheme-ZEKOZCPE.js"
    );
  }),
  scilab: create_language_async_loader_default("scilab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scilab" */
      "/myst_assets_folder/_shared/scilab-XYGY3IVE.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scss" */
      "/myst_assets_folder/_shared/scss-3H6M7FJA.js"
    );
  }),
  shell: create_language_async_loader_default("shell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_shell" */
      "/myst_assets_folder/_shared/shell-RC2W7ULP.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smali" */
      "/myst_assets_folder/_shared/smali-G25PSYAR.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smalltalk" */
      "/myst_assets_folder/_shared/smalltalk-QV5ZCHJC.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sml" */
      "/myst_assets_folder/_shared/sml-DA2LKWQT.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqf" */
      "/myst_assets_folder/_shared/sqf-TLPTGZZH.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sql" */
      "/myst_assets_folder/_shared/sql-OVPQZRSX.js"
    );
  }),
  sqlMore: create_language_async_loader_default("sqlMore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqlMore" */
      "/myst_assets_folder/_shared/sql_more-ZOEYJCKZ.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stan" */
      "/myst_assets_folder/_shared/stan-LICKPVL5.js"
    );
  }),
  stata: create_language_async_loader_default("stata", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stata" */
      "/myst_assets_folder/_shared/stata-2GIMPXYU.js"
    );
  }),
  step21: create_language_async_loader_default("step21", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_step21" */
      "/myst_assets_folder/_shared/step21-Y5TJV4KA.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stylus" */
      "/myst_assets_folder/_shared/stylus-HYOK2JCK.js"
    );
  }),
  subunit: create_language_async_loader_default("subunit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_subunit" */
      "/myst_assets_folder/_shared/subunit-ZH4LHJ2S.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_swift" */
      "/myst_assets_folder/_shared/swift-G55EACVL.js"
    );
  }),
  taggerscript: create_language_async_loader_default("taggerscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_taggerscript" */
      "/myst_assets_folder/_shared/taggerscript-5UBHPCUO.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tap" */
      "/myst_assets_folder/_shared/tap-NGPU6GRX.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tcl" */
      "/myst_assets_folder/_shared/tcl-N47MYKOO.js"
    );
  }),
  thrift: create_language_async_loader_default("thrift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_thrift" */
      "/myst_assets_folder/_shared/thrift-ZATOPCSG.js"
    );
  }),
  tp: create_language_async_loader_default("tp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tp" */
      "/myst_assets_folder/_shared/tp-XG7QZC23.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_twig" */
      "/myst_assets_folder/_shared/twig-FNFVUMG4.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_typescript" */
      "/myst_assets_folder/_shared/typescript-7EIWPJ6U.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vala" */
      "/myst_assets_folder/_shared/vala-YP4EJJ5C.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbnet" */
      "/myst_assets_folder/_shared/vbnet-KPUVC7VK.js"
    );
  }),
  vbscriptHtml: create_language_async_loader_default("vbscriptHtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscriptHtml" */
      "/myst_assets_folder/_shared/vbscript-html-MJ2DEVVI.js"
    );
  }),
  vbscript: create_language_async_loader_default("vbscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscript" */
      "/myst_assets_folder/_shared/vbscript-N3EPFU2E.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_verilog" */
      "/myst_assets_folder/_shared/verilog-M6UE4D47.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vhdl" */
      "/myst_assets_folder/_shared/vhdl-524NIHAM.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vim" */
      "/myst_assets_folder/_shared/vim-YS3L7KO4.js"
    );
  }),
  x86asm: create_language_async_loader_default("x86asm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_x86asm" */
      "/myst_assets_folder/_shared/x86asm-PDBHV5LO.js"
    );
  }),
  xl: create_language_async_loader_default("xl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xl" */
      "/myst_assets_folder/_shared/xl-WA44LWTM.js"
    );
  }),
  xml: create_language_async_loader_default("xml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xml" */
      "/myst_assets_folder/_shared/xml-DO3ZHFJZ.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xquery" */
      "/myst_assets_folder/_shared/xquery-SSG3J2NB.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_yaml" */
      "/myst_assets_folder/_shared/yaml-PAVDEIIH.js"
    );
  }),
  zephir: create_language_async_loader_default("zephir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_zephir" */
      "/myst_assets_folder/_shared/zephir-BAYEEMF7.js"
    );
  })
};

// ../../node_modules/react-syntax-highlighter/dist/esm/light-async.js
var light_async_default = async_syntax_highlighter_default({
  loader: function loader() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/lowlight-import" */
      "/myst_assets_folder/_shared/core-OR4OBBXG.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered(instance, language) {
    return !!checkForListedLanguage_default(instance, language);
  },
  languageLoaders: hljs_default,
  registerLanguage: function registerLanguage(instance, name, language) {
    return instance.registerLanguage(name, language);
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/styles/hljs/xcode.js
var xcode_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#fff",
    "color": "black"
  },
  "xml .hljs-meta": {
    "color": "#c0c0c0"
  },
  "hljs-comment": {
    "color": "#007400"
  },
  "hljs-quote": {
    "color": "#007400"
  },
  "hljs-tag": {
    "color": "#aa0d91"
  },
  "hljs-attribute": {
    "color": "#aa0d91"
  },
  "hljs-keyword": {
    "color": "#aa0d91"
  },
  "hljs-selector-tag": {
    "color": "#aa0d91"
  },
  "hljs-literal": {
    "color": "#aa0d91"
  },
  "hljs-name": {
    "color": "#aa0d91"
  },
  "hljs-variable": {
    "color": "#3F6E74"
  },
  "hljs-template-variable": {
    "color": "#3F6E74"
  },
  "hljs-code": {
    "color": "#c41a16"
  },
  "hljs-string": {
    "color": "#c41a16"
  },
  "hljs-meta-string": {
    "color": "#c41a16"
  },
  "hljs-regexp": {
    "color": "#0E0EFF"
  },
  "hljs-link": {
    "color": "#0E0EFF"
  },
  "hljs-title": {
    "color": "#1c00cf"
  },
  "hljs-symbol": {
    "color": "#1c00cf"
  },
  "hljs-bullet": {
    "color": "#1c00cf"
  },
  "hljs-number": {
    "color": "#1c00cf"
  },
  "hljs-section": {
    "color": "#643820"
  },
  "hljs-meta": {
    "color": "#643820"
  },
  "hljs-class .hljs-title": {
    "color": "#5c2699"
  },
  "hljs-type": {
    "color": "#5c2699"
  },
  "hljs-built_in": {
    "color": "#5c2699"
  },
  "hljs-builtin-name": {
    "color": "#5c2699"
  },
  "hljs-params": {
    "color": "#5c2699"
  },
  "hljs-attr": {
    "color": "#836C28"
  },
  "hljs-subst": {
    "color": "#000"
  },
  "hljs-formula": {
    "backgroundColor": "#eee",
    "fontStyle": "italic"
  },
  "hljs-addition": {
    "backgroundColor": "#baeeba"
  },
  "hljs-deletion": {
    "backgroundColor": "#ffc8bd"
  },
  "hljs-selector-id": {
    "color": "#9b703f"
  },
  "hljs-selector-class": {
    "color": "#9b703f"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  }
};

// ../../node_modules/react-syntax-highlighter/dist/esm/styles/hljs/vs2015.js
var vs2015_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#1E1E1E",
    "color": "#DCDCDC"
  },
  "hljs-keyword": {
    "color": "#569CD6"
  },
  "hljs-literal": {
    "color": "#569CD6"
  },
  "hljs-symbol": {
    "color": "#569CD6"
  },
  "hljs-name": {
    "color": "#569CD6"
  },
  "hljs-link": {
    "color": "#569CD6",
    "textDecoration": "underline"
  },
  "hljs-built_in": {
    "color": "#4EC9B0"
  },
  "hljs-type": {
    "color": "#4EC9B0"
  },
  "hljs-number": {
    "color": "#B8D7A3"
  },
  "hljs-class": {
    "color": "#B8D7A3"
  },
  "hljs-string": {
    "color": "#D69D85"
  },
  "hljs-meta-string": {
    "color": "#D69D85"
  },
  "hljs-regexp": {
    "color": "#9A5334"
  },
  "hljs-template-tag": {
    "color": "#9A5334"
  },
  "hljs-subst": {
    "color": "#DCDCDC"
  },
  "hljs-function": {
    "color": "#DCDCDC"
  },
  "hljs-title": {
    "color": "#DCDCDC"
  },
  "hljs-params": {
    "color": "#DCDCDC"
  },
  "hljs-formula": {
    "color": "#DCDCDC"
  },
  "hljs-comment": {
    "color": "#57A64A",
    "fontStyle": "italic"
  },
  "hljs-quote": {
    "color": "#57A64A",
    "fontStyle": "italic"
  },
  "hljs-doctag": {
    "color": "#608B4E"
  },
  "hljs-meta": {
    "color": "#9B9B9B"
  },
  "hljs-meta-keyword": {
    "color": "#9B9B9B"
  },
  "hljs-tag": {
    "color": "#9B9B9B"
  },
  "hljs-variable": {
    "color": "#BD63C5"
  },
  "hljs-template-variable": {
    "color": "#BD63C5"
  },
  "hljs-attr": {
    "color": "#9CDCFE"
  },
  "hljs-attribute": {
    "color": "#9CDCFE"
  },
  "hljs-builtin-name": {
    "color": "#9CDCFE"
  },
  "hljs-section": {
    "color": "gold"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-bullet": {
    "color": "#D7BA7D"
  },
  "hljs-selector-tag": {
    "color": "#D7BA7D"
  },
  "hljs-selector-id": {
    "color": "#D7BA7D"
  },
  "hljs-selector-class": {
    "color": "#D7BA7D"
  },
  "hljs-selector-attr": {
    "color": "#D7BA7D"
  },
  "hljs-selector-pseudo": {
    "color": "#D7BA7D"
  },
  "hljs-addition": {
    "backgroundColor": "#144212",
    "display": "inline-block",
    "width": "100%"
  },
  "hljs-deletion": {
    "backgroundColor": "#600",
    "display": "inline-block",
    "width": "100%"
  }
};

// ../../packages/myst-to-react/dist/code.js
var import_classnames10 = __toESM(require_classnames(), 1);
function normalizeLanguage(lang) {
  switch (lang) {
    case "html":
      return "xml";
    default:
      return lang;
  }
}
function CodeBlock(props) {
  const { isLight } = useTheme();
  const { value, lang, identifier, emphasizeLines, showLineNumbers, className, showCopy = true, startingLineNumber = 1, filename, shadow, background, border } = props;
  const highlightLines = new Set(emphasizeLines);
  return (0, import_jsx_runtime23.jsxs)("div", { id: identifier, className: (0, import_classnames10.default)("relative group not-prose overflow-auto", className, {
    "shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 my-5 text-sm": shadow,
    "bg-stone-200/10": background,
    "border border-l-4 border-l-blue-400 border-gray-200 dark:border-l-blue-400 dark:border-gray-800": border
  }), children: [filename && (0, import_jsx_runtime23.jsxs)("div", { className: "flex flex-row pl-2 bg-white border-b dark:bg-slate-600 dark:border-slate-300", children: [(0, import_jsx_runtime23.jsx)(DocumentIcon_default, { width: "16px", height: "16px", className: "self-center flex-none inline-block text-gray-500 dark:text-gray-100" }), (0, import_jsx_runtime23.jsx)("div", { className: "self-center p-2 text-sm leading-3 prose text-slate-600 dark:text-white", children: filename })] }), (0, import_jsx_runtime23.jsx)(light_async_default, { language: normalizeLanguage(lang), startingLineNumber, showLineNumbers, style: isLight ? Object.assign(Object.assign({}, xcode_default), { hljs: Object.assign(Object.assign({}, xcode_default.hljs), { background: "transparent" }) }) : vs2015_default, wrapLines: true, lineNumberContainerStyle: {
    // This stops page content shifts
    display: "inline-block",
    float: "left",
    minWidth: "1.25em",
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none",
    borderLeft: "4px solid transparent"
  }, lineProps: (line) => {
    if (typeof line === "boolean")
      return {};
    return highlightLines.has(line) ? {
      "data-line-number": `${line}`,
      "data-highlight": "true"
    } : { "data-line-number": `${line}` };
  }, customStyle: { padding: "0.8rem" }, children: value }), showCopy && (0, import_jsx_runtime23.jsx)(CopyIcon, { text: value, className: (0, import_classnames10.default)("absolute right-1", { "top-[32px]": filename, "top-1": !filename }) })] });
}
var code2 = ({ node }) => {
  return (0, import_jsx_runtime23.jsx)(CodeBlock, { identifier: node.html_id, "data-mdast-node-type": node.type, "data-mdast-node-id": node.key, value: node.value || "", lang: node.lang, filename: node.filename, emphasizeLines: node.emphasizeLines, showLineNumbers: node.showLineNumbers, startingLineNumber: node.startingLineNumber, shadow: true, border: node.executable, background: !node.executable, className: (0, import_classnames10.default)({ hidden: node.visibility === "remove" }, node.class) });
};
function isColor(maybeColorHash) {
  if (!maybeColorHash || maybeColorHash.length > 9)
    return void 0;
  if (!(/* @__PURE__ */ new Set([4, 7, 9])).has(maybeColorHash.length))
    return void 0;
  const match = /^#([0-9A-Fa-f]{3,8})$/.exec(maybeColorHash);
  if (!match)
    return void 0;
  const color2 = match[1];
  return color2;
}
var inlineCode = ({ node }) => {
  if (isColor(node.value)) {
    return (0, import_jsx_runtime23.jsxs)("code", { className: "px-1 rounded bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-100", children: [node.value, (0, import_jsx_runtime23.jsx)("span", { style: { backgroundColor: node.value }, className: "inline-block w-[10px] h-[10px] rounded-full ml-1" })] });
  }
  if (node.children && node.children.length > 0) {
    return (0, import_jsx_runtime23.jsx)("code", { children: (0, import_jsx_runtime23.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime23.jsx)("code", { children: node.value });
};
var CODE_RENDERERS = {
  code: code2,
  inlineCode
};
var code_default = CODE_RENDERERS;

// ../../packages/myst-to-react/dist/math.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var mathRenderer = ({ node }) => {
  if (node.type === "math") {
    if (node.error || !node.html) {
      return (0, import_jsx_runtime24.jsxs)("pre", { title: node.message, children: [(0, import_jsx_runtime24.jsxs)("span", { className: "text-red-500", children: [(0, import_jsx_runtime24.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), node.message, "\n\n"] }), node.value] });
    }
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime24.jsxs)("div", { id, className: "flex my-5 group", children: [(0, import_jsx_runtime24.jsx)("div", { dangerouslySetInnerHTML: { __html: node.html }, className: "flex-grow overflow-x-auto overflow-y-hidden" }), node.enumerator && (0, import_jsx_runtime24.jsx)("div", { className: "relative self-center flex-none pl-2 m-0 text-right select-none", children: (0, import_jsx_runtime24.jsxs)(HashLink, { id, kind: "Equation", className: "text-inherit hover:text-inherit", children: ["(", node.enumerator, ")"] }) })] });
  }
  if (node.error || !node.html) {
    return (0, import_jsx_runtime24.jsx)(InlineError, { value: node.value, message: node.message });
  }
  return (0, import_jsx_runtime24.jsx)("span", { dangerouslySetInnerHTML: { __html: node.html } });
};
var MATH_RENDERERS = {
  math: mathRenderer,
  inlineMath: mathRenderer
};
var math_default = MATH_RENDERERS;

// ../../packages/myst-to-react/dist/reactive.js
var import_react33 = __toESM(require_react(), 1);
var RVar = ({ node }) => {
  return (0, import_react33.createElement)("r-var", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format
  });
};
var RDisplay = ({ node }) => {
  return (0, import_react33.createElement)("r-display", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format
  });
};
var RDynamic = ({ node }) => {
  return (0, import_react33.createElement)("r-dynamic", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction,
    format: node.format
  });
};
var RRange = ({ node }) => {
  return (0, import_react33.createElement)("r-range", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction
  });
};
var REACTIVE_RENDERERS = {
  "r:var": RVar,
  "r:display": RDisplay,
  "r:dynamic": RDynamic,
  "r:range": RRange
};
var reactive_default = REACTIVE_RENDERERS;

// ../../packages/myst-to-react/dist/iframe.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_classnames11 = __toESM(require_classnames(), 1);
function getStyleValue(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return getStyleValue(Number(width.replace("%", "")));
    } else if (width.endsWith("px")) {
      const px = getStyleValue(Number(width.replace("px", "")));
      return px ? px / 750 : 70;
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
var IFrame = ({ node }) => {
  const width = getStyleValue(node.width) || 70;
  return (0, import_jsx_runtime25.jsx)("div", { id: node.label || void 0, style: { textAlign: node.align || "center" }, className: (0, import_classnames11.default)("leading-[0]", node.class), children: (0, import_jsx_runtime25.jsx)("div", { className: "relative inline-block", style: {
    paddingBottom: "60%",
    width: `min(max(${width}%, 500px), 100%)`
  }, children: (0, import_jsx_runtime25.jsx)("iframe", { width: "100%", height: "100%", src: node.src, allowFullScreen: true, allow: "autoplay", style: {
    width: "100%",
    height: "100%",
    position: "absolute",
    top: 0,
    left: 0,
    border: "none"
  } }) }) });
};
var IFRAME_RENDERERS = {
  iframe: IFrame
};
var iframe_default = IFRAME_RENDERERS;

// ../../packages/myst-to-react/dist/image.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function getStyleValue2(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return width;
    } else if (width.endsWith("px")) {
      return Number(width.replace("px", ""));
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
function alignToMargin(align) {
  switch (align) {
    case "left":
      return { marginRight: "auto" };
    case "right":
      return { marginLeft: "auto" };
    case "center":
      return { margin: "0 auto" };
    default:
      return {};
  }
}
function Video({ className, id, src, urlSource, align = "center", width, height }) {
  return (0, import_jsx_runtime26.jsx)("video", {
    // className={className}
    id,
    style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)),
    src,
    "data-canonical-url": urlSource,
    autoPlay: true,
    // For autoplay, the element needs to be muted to actually start!
    muted: true,
    "webkit-playsinline": "true",
    playsInline: true,
    loop: true
  });
}
function Picture({ className, id, src, srcOptimized, urlSource, align = "center", alt, width, height }) {
  if (src.endsWith(".mp4") || (urlSource === null || urlSource === void 0 ? void 0 : urlSource.endsWith(".mp4"))) {
    return (0, import_jsx_runtime26.jsx)(Video, { className, id, width, height, align, src, urlSource });
  }
  const image = (0, import_jsx_runtime26.jsx)("img", { id, style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)), src, alt, "data-canonical-url": urlSource });
  if (!srcOptimized)
    return image;
  return (0, import_jsx_runtime26.jsxs)("picture", { className, children: [(0, import_jsx_runtime26.jsx)("source", { srcSet: srcOptimized, type: "image/webp" }), image] });
}
var Image2 = ({ node }) => {
  return (0, import_jsx_runtime26.jsx)(Picture, {
    className: node.class,
    id: node.html_id || node.identifier || node.key,
    src: node.url,
    srcOptimized: node.urlOptimized,
    alt: node.alt || node.title,
    width: node.width || void 0,
    height: node.height || void 0,
    align: node.align,
    // Note that sourceUrl is for backwards compatibility
    urlSource: node.urlSource || node.sourceUrl
  });
};
var IMAGE_RENDERERS = {
  image: Image2
};
var image_default = IMAGE_RENDERERS;

// ../../packages/myst-to-react/dist/links/index.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-to-react/dist/links/wiki.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/swr/core/dist/index.mjs
var import_react35 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);

// ../../node_modules/swr/_internal/dist/index.mjs
var import_react34 = __toESM(require_react(), 1);
var noop = () => {
};
var UNDEFINED = (
  /*#__NOINLINE__*/
  noop()
);
var OBJECT = Object;
var isUndefined = (v2) => v2 === UNDEFINED;
var isFunction = (v2) => typeof v2 == "function";
var mergeObjects = (a4, b4) => ({
  ...a4,
  ...b4
});
var isPromiseLike = (x4) => isFunction(x4.then);
var table = /* @__PURE__ */ new WeakMap();
var counter = 0;
var stableHash = (arg) => {
  const type2 = typeof arg;
  const constructor = arg && arg.constructor;
  const isDate = constructor == Date;
  let result2;
  let index2;
  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
    result2 = table.get(arg);
    if (result2)
      return result2;
    result2 = ++counter + "~";
    table.set(arg, result2);
    if (constructor == Array) {
      result2 = "@";
      for (index2 = 0; index2 < arg.length; index2++) {
        result2 += stableHash(arg[index2]) + ",";
      }
      table.set(arg, result2);
    }
    if (constructor == OBJECT) {
      result2 = "#";
      const keys2 = OBJECT.keys(arg).sort();
      while (!isUndefined(index2 = keys2.pop())) {
        if (!isUndefined(arg[index2])) {
          result2 += index2 + ":" + stableHash(arg[index2]) + ",";
        }
      }
      table.set(arg, result2);
    }
  } else {
    result2 = isDate ? arg.toJSON() : type2 == "symbol" ? arg.toString() : type2 == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result2;
};
var SWRGlobalState = /* @__PURE__ */ new WeakMap();
var EMPTY_CACHE = {};
var INITIAL_CACHE = {};
var STR_UNDEFINED = "undefined";
var isWindowDefined = typeof window != STR_UNDEFINED;
var isDocumentDefined = typeof document != STR_UNDEFINED;
var hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
var createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev = cache2.get(key);
        if (!(key in INITIAL_CACHE)) {
          INITIAL_CACHE[key] = prev;
        }
        state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => {
      if (!isUndefined(key)) {
        if (key in INITIAL_CACHE)
          return INITIAL_CACHE[key];
      }
      return !isUndefined(key) && cache2.get(key) || EMPTY_CACHE;
    }
  ];
};
var online = true;
var isOnline = () => online;
var [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop,
  noop
];
var isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
var initFocus = (callback) => {
  if (isDocumentDefined) {
    document.addEventListener("visibilitychange", callback);
  }
  onWindowEvent("focus", callback);
  return () => {
    if (isDocumentDefined) {
      document.removeEventListener("visibilitychange", callback);
    }
    offWindowEvent("focus", callback);
  };
};
var initReconnect = (callback) => {
  const onOnline = () => {
    online = true;
    callback();
  };
  const onOffline = () => {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return () => {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
var preset = {
  isOnline,
  isVisible
};
var defaultConfigOptions = {
  initFocus,
  initReconnect
};
var IS_REACT_LEGACY = !import_react34.default.useId;
var IS_SERVER = !isWindowDefined || "Deno" in window;
var rAF = (f6) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f6) : setTimeout(f6, 1);
var useIsomorphicLayoutEffect = IS_SERVER ? import_react34.useEffect : import_react34.useLayoutEffect;
var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
var slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
var serialize = (key) => {
  if (isFunction(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = key;
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [
    key,
    args
  ];
};
var __timestamp = 0;
var getTimestamp = () => ++__timestamp;
var FOCUS_EVENT = 0;
var RECONNECT_EVENT = 1;
var MUTATE_EVENT = 2;
var ERROR_REVALIDATE_EVENT = 3;
var events = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT,
  FOCUS_EVENT,
  MUTATE_EVENT,
  RECONNECT_EVENT
};
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args;
  const options = mergeObjects({
    populateCache: true,
    throwOnError: true
  }, typeof _opts === "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const revalidate = options.revalidate !== false;
  const rollbackOnError = (error) => {
    return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
  };
  const throwOnError = options.throwOnError;
  if (isFunction(_key)) {
    const keyFilter = _key;
    const matchedKeys = [];
    const it2 = cache2.keys();
    for (const key of it2) {
      if (
        // Skip the special useSWRInfinite and useSWRSubscription keys.
        !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
      ) {
        matchedKeys.push(key);
      }
    }
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize(_k);
    if (!key)
      return;
    const [get2, set3] = createCacheHelper(cache2, key);
    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
    const startRevalidate = () => {
      const revalidators = EVENT_REVALIDATORS[key];
      if (revalidate) {
        delete FETCH[key];
        delete PRELOAD[key];
        if (revalidators && revalidators[0]) {
          return revalidators[0](MUTATE_EVENT).then(() => get2().data);
        }
      }
      return get2().data;
    };
    if (args.length < 3) {
      return startRevalidate();
    }
    let data = _data;
    let error;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData);
    const state = get2();
    const displayedData = state.data;
    const currentData = state._c;
    const committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData) {
      optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
      set3({
        data: optimisticData,
        _c: committedData
      });
    }
    if (isFunction(data)) {
      try {
        data = data(committedData);
      } catch (err) {
        error = err;
      }
    }
    if (data && isPromiseLike(data)) {
      data = await data.catch((err) => {
        error = err;
      });
      if (beforeMutationTs !== MUTATION[key][0]) {
        if (error)
          throw error;
        return data;
      } else if (error && hasOptimisticData && rollbackOnError(error)) {
        populateCache = true;
        set3({
          data: committedData,
          _c: UNDEFINED
        });
      }
    }
    if (populateCache) {
      if (!error) {
        if (isFunction(populateCache)) {
          const populateCachedData = populateCache(data, committedData);
          set3({
            data: populateCachedData,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        } else {
          set3({
            data,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        }
      }
    }
    MUTATION[key][1] = getTimestamp();
    Promise.resolve(startRevalidate()).then(() => {
      set3({
        _c: UNDEFINED
      });
    });
    if (error) {
      if (throwOnError)
        throw error;
      return;
    }
    return data;
  }
}
var revalidateAllKeys = (revalidators, type2) => {
  for (const key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type2);
  }
};
var initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options);
    const EVENT_REVALIDATORS = {};
    const mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop;
    const subscriptions = {};
    const subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      subscriptions[key] = subs;
      subs.push(callback);
      return () => subs.splice(subs.indexOf(callback), 1);
    };
    const setter = (key, value, prev) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs) {
        for (const fn of subs) {
          fn(value, prev);
        }
      }
    };
    const initProvider = () => {
      if (!SWRGlobalState.has(provider)) {
        SWRGlobalState.set(provider, [
          EVENT_REVALIDATORS,
          {},
          {},
          {},
          mutate2,
          setter,
          subscribe
        ]);
        if (!IS_SERVER) {
          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
          unmount = () => {
            releaseFocus && releaseFocus();
            releaseReconnect && releaseReconnect();
            SWRGlobalState.delete(provider);
          };
        }
      }
    };
    initProvider();
    return [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
};
var onErrorRetry = (_5, __, config, revalidate, opts) => {
  const maxRetryCount = config.errorRetryCount;
  const currentRetryCount = opts.retryCount;
  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout, opts);
};
var compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);
var [cache, mutate] = initCache(/* @__PURE__ */ new Map());
var defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop,
    onSuccess: noop,
    onError: noop,
    onErrorRetry,
    onDiscarded: noop,
    // switches
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => false,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
);
var mergeConfigs = (a4, b4) => {
  const v2 = mergeObjects(a4, b4);
  if (b4) {
    const { use: u1, fallback: f1 } = a4;
    const { use: u22, fallback: f22 } = b4;
    if (u1 && u22) {
      v2.use = u1.concat(u22);
    }
    if (f1 && f22) {
      v2.fallback = mergeObjects(f1, f22);
    }
  }
  return v2;
};
var SWRConfigContext = (0, import_react34.createContext)({});
var SWRConfig = (props) => {
  const { value } = props;
  const parentConfig = (0, import_react34.useContext)(SWRConfigContext);
  const isFunctionalConfig = isFunction(value);
  const config = (0, import_react34.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [
    isFunctionalConfig,
    parentConfig,
    value
  ]);
  const extendedConfig = (0, import_react34.useMemo)(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [
    isFunctionalConfig,
    parentConfig,
    config
  ]);
  const provider = config && config.provider;
  const cacheContextRef = (0, import_react34.useRef)(UNDEFINED);
  if (provider && !cacheContextRef.current) {
    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);
  }
  const cacheContext = cacheContextRef.current;
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(() => {
    if (cacheContext) {
      cacheContext[2] && cacheContext[2]();
      return cacheContext[3];
    }
  }, []);
  return (0, import_react34.createElement)(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};
var INFINITE_PREFIX = "$inf$";
var enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
var use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
var setupDevTools = () => {
  if (enableDevtools) {
    window.__SWR_DEVTOOLS_REACT__ = import_react34.default;
  }
};
var normalize = (args) => {
  return isFunction(args[1]) ? [
    args[0],
    args[1],
    args[2] || {}
  ] : [
    args[0],
    null,
    (args[1] === null ? args[2] : args[1]) || {}
  ];
};
var useSWRConfig = () => {
  return mergeObjects(defaultConfig, (0, import_react34.useContext)(SWRConfigContext));
};
var middleware = (useSWRNext) => (key_, fetcher_, config) => {
  const fetcher7 = fetcher_ && ((...args) => {
    const [key] = serialize(key_);
    const [, , , PRELOAD] = SWRGlobalState.get(cache);
    if (key.startsWith(INFINITE_PREFIX)) {
      return fetcher_(...args);
    }
    const req = PRELOAD[key];
    if (isUndefined(req))
      return fetcher_(...args);
    delete PRELOAD[key];
    return req;
  });
  return useSWRNext(key_, fetcher7, config);
};
var BUILT_IN_MIDDLEWARE = use.concat(middleware);
var withArgs = (hook) => {
  return function useSWRArgs(...args) {
    const fallbackConfig = useSWRConfig();
    const [key, fn, _config] = normalize(args);
    const config = mergeConfigs(fallbackConfig, _config);
    let next = hook;
    const { use: use3 } = config;
    const middleware2 = (use3 || []).concat(BUILT_IN_MIDDLEWARE);
    for (let i5 = middleware2.length; i5--; ) {
      next = middleware2[i5](next);
    }
    return next(key, fn || config.fetcher || null, config);
  };
};
var subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return () => {
    const index2 = keyedRevalidators.indexOf(callback);
    if (index2 >= 0) {
      keyedRevalidators[index2] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
var withMiddleware = (useSWR2, middleware2) => {
  return (...args) => {
    const [key, fn, config] = normalize(args);
    const uses = (config.use || []).concat(middleware2);
    return useSWR2(key, fn, {
      ...config,
      use: uses
    });
  };
};
setupDevTools();

// ../../node_modules/swr/core/dist/index.mjs
var use2 = import_react35.default.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then((v2) => {
      promise.status = "fulfilled";
      promise.value = v2;
    }, (e4) => {
      promise.status = "rejected";
      promise.reason = e4;
    });
    throw promise;
  }
});
var WITH_DEDUPE = {
  dedupe: true
};
var useSWRHandler = (_key, fetcher7, config) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;
  const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
  const [key, fnArg] = serialize(_key);
  const initialMountedRef = (0, import_react35.useRef)(false);
  const unmountedRef = (0, import_react35.useRef)(false);
  const keyRef = (0, import_react35.useRef)(key);
  const fetcherRef = (0, import_react35.useRef)(fetcher7);
  const configRef = (0, import_react35.useRef)(config);
  const getConfig = () => configRef.current;
  const isActive = () => getConfig().isVisible() && getConfig().isOnline();
  const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
  const stateDependencies = (0, import_react35.useRef)({}).current;
  const fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;
  const isEqual3 = (prev, current) => {
    for (const _5 in stateDependencies) {
      const t10 = _5;
      if (t10 === "data") {
        if (!compare2(prev[t10], current[t10])) {
          if (!isUndefined(prev[t10])) {
            return false;
          }
          if (!compare2(returnedData, current[t10])) {
            return false;
          }
        }
      } else {
        if (current[t10] !== prev[t10]) {
          return false;
        }
      }
    }
    return true;
  };
  const getSnapshot = (0, import_react35.useMemo)(() => {
    const shouldStartRequest = (() => {
      if (!key)
        return false;
      if (!fetcher7)
        return false;
      if (!isUndefined(revalidateOnMount))
        return revalidateOnMount;
      if (getConfig().isPaused())
        return false;
      if (suspense)
        return false;
      if (!isUndefined(revalidateIfStale))
        return revalidateIfStale;
      return true;
    })();
    const getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      delete snapshot._k;
      if (!shouldStartRequest) {
        return snapshot;
      }
      return {
        isValidating: true,
        isLoading: true,
        ...snapshot
      };
    };
    const cachedData2 = getCache();
    const initialData = getInitialCache();
    const clientSnapshot = getSelectedCache(cachedData2);
    const serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
    let memorizedSnapshot = clientSnapshot;
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache());
        const compareResult = isEqual3(newSnapshot, memorizedSnapshot);
        if (compareResult) {
          memorizedSnapshot.data = newSnapshot.data;
          memorizedSnapshot.isLoading = newSnapshot.isLoading;
          memorizedSnapshot.isValidating = newSnapshot.isValidating;
          memorizedSnapshot.error = newSnapshot.error;
          return memorizedSnapshot;
        } else {
          memorizedSnapshot = newSnapshot;
          return newSnapshot;
        }
      },
      () => serverSnapshot
    ];
  }, [
    cache2,
    key
  ]);
  const cached = (0, import_shim.useSyncExternalStore)((0, import_react35.useCallback)(
    (callback) => subscribeCache(key, (current, prev) => {
      if (!isEqual3(prev, current))
        callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]);
  const isInitialMount = !initialMountedRef.current;
  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
  const cachedData = cached.data;
  const data = isUndefined(cachedData) ? fallback : cachedData;
  const error = cached.error;
  const laggyDataRef = (0, import_react35.useRef)(data);
  const returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data;
  const shouldDoInitialRevalidation = (() => {
    if (hasRevalidator && !isUndefined(error))
      return false;
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : revalidateIfStale;
    return isUndefined(data) || revalidateIfStale;
  })();
  const defaultValidatingState = !!(key && fetcher7 && isInitialMount && shouldDoInitialRevalidation);
  const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
  const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
  const revalidate = (0, import_react35.useCallback)(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
        return false;
      }
      let newData;
      let startAt;
      let loading = true;
      const opts = revalidateOpts || {};
      const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
      const callbackSafeguard = () => {
        if (IS_REACT_LEGACY) {
          return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
        }
        return key === keyRef.current;
      };
      const finalState = {
        isValidating: false,
        isLoading: false
      };
      const finishRequestAndUpdateState = () => {
        setCache(finalState);
      };
      const cleanupState = () => {
        const requestInfo = FETCH[key];
        if (requestInfo && requestInfo[1] === startAt) {
          delete FETCH[key];
        }
      };
      const initialState = {
        isValidating: true
      };
      if (isUndefined(getCache().data)) {
        initialState.isLoading = true;
      }
      try {
        if (shouldStartNewRequest) {
          setCache(initialState);
          if (config.loadingTimeout && isUndefined(getCache().data)) {
            setTimeout(() => {
              if (loading && callbackSafeguard()) {
                getConfig().onLoadingSlow(key, config);
              }
            }, config.loadingTimeout);
          }
          FETCH[key] = [
            currentFetcher(fnArg),
            getTimestamp()
          ];
        }
        [newData, startAt] = FETCH[key];
        newData = await newData;
        if (shouldStartNewRequest) {
          setTimeout(cleanupState, config.dedupingInterval);
        }
        if (!FETCH[key] || FETCH[key][1] !== startAt) {
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0)) {
          finishRequestAndUpdateState();
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        const cacheData = getCache().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData;
        if (shouldStartNewRequest) {
          if (callbackSafeguard()) {
            getConfig().onSuccess(newData, key, config);
          }
        }
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig();
        const { shouldRetryOnError } = currentConfig;
        if (!currentConfig.isPaused()) {
          finalState.error = err;
          if (shouldStartNewRequest && callbackSafeguard()) {
            currentConfig.onError(err, key, currentConfig);
            if (shouldRetryOnError === true || isFunction(shouldRetryOnError) && shouldRetryOnError(err)) {
              if (isActive()) {
                currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
                  const revalidators = EVENT_REVALIDATORS[key];
                  if (revalidators && revalidators[0]) {
                    revalidators[0](events.ERROR_REVALIDATE_EVENT, _opts);
                  }
                }, {
                  retryCount: (opts.retryCount || 0) + 1,
                  dedupe: true
                });
              }
            }
          }
        }
      }
      loading = false;
      finishRequestAndUpdateState();
      return true;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  );
  const boundMutate = (0, import_react35.useCallback)(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => {
      return internalMutate(cache2, keyRef.current, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher7;
    configRef.current = config;
    if (!isUndefined(cachedData)) {
      laggyDataRef.current = cachedData;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (!key)
      return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    const onRevalidate = (type2, opts = {}) => {
      if (type2 == events.FOCUS_EVENT) {
        const now = Date.now();
        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type2 == events.RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type2 == events.MUTATE_EVENT) {
        return revalidate();
      } else if (type2 == events.ERROR_REVALIDATE_EVENT) {
        return revalidate(opts);
      }
      return;
    };
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    setCache({
      _k: fnArg
    });
    if (shouldDoInitialRevalidation) {
      if (isUndefined(data) || IS_SERVER) {
        softRevalidate();
      } else {
        rAF(softRevalidate);
      }
    }
    return () => {
      unmountedRef.current = true;
      unsubEvents();
    };
  }, [
    key
  ]);
  useIsomorphicLayoutEffect(() => {
    let timer;
    function next() {
      const interval = isFunction(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
      if (interval && timer !== -1) {
        timer = setTimeout(execute, interval);
      }
    }
    function execute() {
      if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next);
      } else {
        next();
      }
    }
    next();
    return () => {
      if (timer) {
        clearTimeout(timer);
        timer = -1;
      }
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]);
  (0, import_react35.useDebugValue)(returnedData);
  if (suspense && isUndefined(data) && key) {
    if (!IS_REACT_LEGACY && IS_SERVER) {
      throw new Error("Fallback data is required when using suspense in SSR.");
    }
    fetcherRef.current = fetcher7;
    configRef.current = config;
    unmountedRef.current = false;
    const req = PRELOAD[key];
    if (!isUndefined(req)) {
      const promise = boundMutate(req);
      use2(promise);
    }
    if (isUndefined(error)) {
      const promise = revalidate(WITH_DEDUPE);
      if (!isUndefined(returnedData)) {
        promise.status = "fulfilled";
        promise.value = true;
      }
      use2(promise);
    } else {
      throw error;
    }
  }
  return {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return returnedData;
    },
    get error() {
      stateDependencies.error = true;
      return error;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    },
    get isLoading() {
      stateDependencies.isLoading = true;
      return isLoading;
    }
  };
};
var SWRConfig2 = OBJECT.defineProperty(SWRConfig, "defaultValue", {
  value: defaultConfig
});
var useSWR = withArgs(useSWRHandler);

// ../../packages/myst-to-react/dist/links/wiki.js
var WikiTextMark = () => (0, import_jsx_runtime27.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", id: "svg3400", viewBox: "0 0 500 85", className: "h-4", children: (0, import_jsx_runtime27.jsxs)("g", { transform: "translate(-357.71336,-784.65111)", children: [(0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 412.98736,806.72288 c 0,0 -1.468,-2.984 -1.968,-3.976 -3.336,-6.612 -3.264,-6.964 -6.636,-7.408 -0.944,-0.124 -1.432,-0.244 -1.432,-0.712 v -2.092 l 0.284,-0.204 c 6.092,-0.008 19.648,-0.008 19.648,-0.008 l 0.52,0.172 v 2.084 c 0,0.476 -0.34,0.72 -1.032,0.72 l -1.424,0.204 c -3.6,0.28 -3.012,1.752 -0.62,6.516 l 22.708,46.46 0.776,0.212 20.16,-47.844 c 0.7,-1.928 0.592,-3.296 -0.308,-4.1 -0.904,-0.784 -1.54,-1.248 -3.876,-1.344 l -1.892,-0.096 c -0.232,0 -0.452,-0.084 -0.664,-0.24 -0.208,-0.148 -0.316,-0.344 -0.316,-0.58 v -1.992 l 0.288,-0.204 c 5.68,0 22.776,0 22.776,0 l 0.232,0.204 v 1.992 c 0,0.54 -0.308,0.812 -0.916,0.812 -2.984,0.132 -5.196,0.78 -6.628,1.936 -1.436,1.164 -2.556,2.768 -3.36,4.852 0,0 -18.54,42.436 -24.884,56.54 -2.428,4.624 -4.816,4.2 -6.916,-0.132 -4.436,-9.136 -16.928,-36.852 -16.928,-36.852 l -7.592,-14.92 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 449.37136,792.29888 c 0,0 -12.812,-0.04 -18.516,0 l -0.284,0.204 v 1.984 c 0,0.244 0.104,0.436 0.312,0.584 0.212,0.156 0.428,0.236 0.66,0.236 l 0.916,0.1 c 2.332,0.096 3.404,0.708 3.724,1.092 0.556,0.68 0.832,1.416 -0.516,4.356 l -23.92,47.708 -0.628,-0.164 c 0,0 -17.132,-36.124 -22.092,-48.208 -0.516,-1.252 -0.748,-2.18 -0.748,-2.752 0,-1.228 1.108,-1.892 3.324,-1.984 l 2.584,-0.108 c 0.684,0 1.032,-0.264 1.032,-0.812 v -1.984 l -0.232,-0.204 c 0,0 -20.52,-0.024 -24.76,0 l -0.232,0.204 v 2.084 c 0,0.376 0.476,0.608 1.432,0.712 2.604,0.14 4.316,0.556 5.14,1.248 0.82,0.7 1.688,2.468 2.84,5.224 6.228,14.96 19.46,41.656 25.904,56.86 1.856,4.152 4.188,4.796 7.02,-0.128 4.904,-9.096 18.2,-36.872 18.2,-36.872 l 10.472,-19.584 c 1.22,-2.068 2.396,-3.912 2.992,-4.772 1.092,-1.572 1.704,-1.868 4.688,-2.008 0.608,0 0.916,-0.272 0.916,-0.82 v -1.984 l -0.228,-0.212 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 488.32736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 519.01936,854.23088 c 0,2.288 1.352,3.432 4.368,3.952 l 1.144,0.212 c 0.312,0.1 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -6.552,-0.212 -9.672,-0.212 -2.912,0 -11.44,0.212 -11.44,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.12,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.144,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.528,0.208 11.752,0.208 2.916,0 9.464,-0.208 9.464,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.416 -0.624,0.52 l -1.144,0.212 c -3.224,0.62 -4.368,1.144 -4.368,3.228 v 15.704 c 3.432,0 5.408,-1.764 9.984,-6.656 4.16,-4.58 7.384,-8.42 7.384,-10.4 0,-0.836 -0.936,-1.768 -3.016,-2.084 -0.416,-0.1 -0.624,-0.208 -0.624,-0.52 v -2.396 l 0.104,-0.1 c 0,0 8.424,0.208 11.44,0.208 2.704,0 7.28,-0.208 7.28,-0.208 l 0.312,0.1 v 2.396 c 0,0.312 -0.312,0.52 -0.832,0.52 -4.056,0.312 -6.864,0.52 -10.608,4.784 l -8.944,10.292 c -1.768,1.876 -2.392,3.016 -2.392,3.852 0,0.624 0.416,1.14 0.936,1.764 l 15.704,18.928 c 1.248,1.452 3.744,2.08 5.824,2.492 l 0.52,0.1 c 0.312,0.104 0.728,0.312 0.728,0.624 v 2.184 l -0.312,0.104 c 0,0 -5.512,-0.104 -8.424,-0.104 -2.6,0 -6.344,0.104 -6.344,0.104 l -0.104,-0.104 v -1.248 c 0,-1.356 -0.104,-2.492 -1.56,-4.156 l -11.544,-14.356 c -1.56,-2.084 -3.224,-2.596 -5.512,-2.596 v 15.404 l 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 575.08736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.248,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 597.55936,819.80288 c 0,-3.224 -1.352,-3.328 -6.24,-3.64 -0.624,0 -0.728,-0.308 -0.728,-0.52 v -2.392 l 0.208,-0.104 c 1.56,0 7.696,0.208 10.712,0.208 2.912,0 7.072,-0.208 10.92,-0.208 14.76,0 17.464,7.276 17.464,12.692 0,6.244 -3.016,16.016 -17.776,16.016 -2.6,0 -4.68,-0.212 -6.556,-1.04 v 13.928 c 0,2.288 1.248,2.812 4.58,3.328 l 2.084,0.312 c 0.416,0.104 0.728,0.212 0.728,0.624 v 2.184 l -0.1,0.208 c 0,0 -8.32,-0.208 -11.544,-0.208 -2.912,0 -10.712,0.208 -10.712,0.208 l -0.104,-0.208 v -2.184 c 0,-0.416 0.208,-0.52 0.624,-0.624 l 2.184,-0.312 c 3.224,-0.416 4.264,-1.352 4.264,-3.328 l -0.008,-34.94 0,0 z m 8.008,18.1 c 2.08,0.836 4.68,0.936 6.76,0.936 6.244,0 9.248,-3.752 9.248,-11.752 0,-8.944 -4.056,-10.92 -9.768,-10.92 -4.996,0 -6.244,0.936 -6.244,3.64 l 0.004,18.096 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 647.80736,861.19888 c -3.12,0 -10.292,0.212 -10.292,0.212 l -0.108,-0.212 v -2.288 c 0,-0.204 0.108,-0.516 0.624,-0.516 l 2.396,-0.212 c 3.228,-0.312 4.164,-2.392 4.164,-4.468 v -34.32 c 0,-2.4 -1.252,-2.812 -4.164,-3.016 l -2.396,-0.216 c -0.624,-0.096 -0.624,-0.308 -0.624,-0.416 v -2.396 l 0.108,-0.208 c 0,0 8.108,0.208 11.228,0.208 h 15.288 c 3.12,0 10.508,-0.208 10.508,-0.208 l 0.212,0.208 c 0.1,4.472 0.828,8.536 1.56,12.484 l -2.596,0.416 c -1.14,-3.852 -3.116,-9.36 -9.772,-9.36 h -8.32 c -1.976,0 -3.016,0.728 -3.016,2.492 v 15.084 h 7.796 c 2.916,0 3.64,-1.248 4.06,-3.328 l 0.62,-2.184 c 0,-0.312 0.212,-0.524 0.624,-0.524 h 1.764 c 0.212,0 0.212,0.108 0.212,0.312 -0.212,2.288 -0.624,5.204 -0.624,7.7 0,2.596 0.416,4.784 0.624,7.176 l -0.212,0.212 h -1.764 c -0.516,0 -0.732,-0.212 -0.732,-0.524 l -0.52,-2.284 c -0.416,-2.084 -1.352,-3.228 -4.064,-3.228 h -7.792 v 15.916 c 0,1.972 1.136,3.948 3.016,3.948 h 9.88 c 5.304,0 8.22,-3.328 9.464,-8.74 l 2.596,0.312 -2.084,11.956 -0.208,0.208 c 0,0 -6.136,-0.208 -9.256,-0.208 l -18.2,0.012 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 686.91936,858.39488 2.392,-0.212 c 3.124,-0.312 4.164,-1.248 4.164,-4.468 v -34.32 c 0,-2.712 -0.736,-2.712 -4.164,-3.016 l -2.28,-0.216 c -0.416,0 -0.736,-0.208 -0.736,-0.52 v -2.288 l 0.1,-0.208 c 0,0 9.156,0.208 11.032,0.208 1.968,0 11.024,-0.208 13.728,-0.208 17.368,0 25.9,10.816 25.9,24.648 0,18.204 -12.9,23.604 -24.44,23.604 -8.32,0 -11.956,-0.208 -15.18,-0.208 -3.124,0 -11.028,0.208 -11.028,0.208 l -0.104,-0.208 v -2.184 c -0.008,-0.3 0.204,-0.612 0.616,-0.612 z m 23.196,0 c 11.436,0 17.892,-4.26 17.892,-18.828 0,-10.812 -2.396,-23.404 -19.868,-23.404 -4.056,0 -6.656,0.624 -6.656,3.232 v 34.32 c 0,2.904 0.724,4.68 8.632,4.68 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 761.60736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.124,-0.212 -2.916,0 -11.024,0.212 -11.024,0.212 l -0.212,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.084,-0.212 c 3.428,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.084,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.432,0.208 2.808,0 10.82,-0.208 10.82,-0.208 l 0.1,0.208 v 2.288 c 0,0.312 -0.212,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 l 0.008,34.632 0,0 z" }), (0, import_jsx_runtime27.jsx)("path", { fill: "currentColor", d: "m 793.64736,858.18288 3.016,0.212 c 0.416,0 0.832,0.312 0.832,0.828 v 1.976 l -0.208,0.212 c 0,0 -11.336,-0.212 -13.832,-0.212 -2.708,0 -9.364,0.212 -9.364,0.212 l -0.212,-0.212 v -1.976 c 0,-0.516 0.312,-0.828 0.836,-0.828 4.58,-0.312 7.172,-1.148 10.084,-7.804 l 23.084,-54.084 c 1.14,-2.704 1.976,-3.748 3.54,-3.748 1.452,0 1.976,1.044 2.804,3.124 l 21.32,56.368 c 1.46,4.06 3.54,5.616 7.7,6.032 l 1.144,0.1 c 0.52,0 1.04,0.312 1.04,0.836 v 1.972 l -0.312,0.208 c 0,0 -8.008,-0.208 -12.064,-0.208 -3.64,0 -13.836,0.208 -13.836,0.208 l -0.1,-0.208 v -1.972 c 0,-0.524 0.208,-0.836 0.736,-0.836 l 2.912,-0.208 c 3.948,-0.308 5.412,-1.564 4.368,-4.472 l -6.344,-17.58 h -21.632 c -2.496,0 -3.12,0.416 -3.636,1.764 l -6.036,15.084 c -1.04,2.608 0.312,4.9 4.16,5.212 z m 25.48,-26.424 -10.088,-27.764 h -0.208 l -10.4,26.416 c -0.416,1.044 0.308,1.352 2.596,1.352 h 18.1 z" })] }) });
var fetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
var ENGLISH_WIKIPEDIA = "https://en.wikipedia.org/";
function createWikiUrl(name, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}wiki/${name}`;
}
function createWikiApiUrl(name, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}api/rest_v1/page/summary/${name}`;
}
function WikiChild({ page, wiki, load: load2 }) {
  var _a, _b;
  const { data, error } = useSWR(load2 ? createWikiApiUrl(page, wiki) : null, fetcher);
  const { thumbnail, extract, content_urls } = data !== null && data !== void 0 ? data : {};
  const url = (_b = (_a = content_urls === null || content_urls === void 0 ? void 0 : content_urls.desktop) === null || _a === void 0 ? void 0 : _a.page) !== null && _b !== void 0 ? _b : createWikiUrl(page);
  const image = thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.source;
  if (error) {
    return (0, import_jsx_runtime27.jsxs)("span", { children: [(0, import_jsx_runtime27.jsxs)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime27.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), (0, import_jsx_runtime27.jsx)(WikiTextMark, {})] }), (0, import_jsx_runtime27.jsxs)("div", { className: "mt-2", children: ['Error loading "', page, '" from wikipedia.'] })] });
  }
  return (0, import_jsx_runtime27.jsx)(LinkCard, { loading: !data, url, title: (0, import_jsx_runtime27.jsx)(WikiTextMark, {}), thumbnail: image, description: extract });
}
function WikiLink({ children, page, url, wiki }) {
  return (0, import_jsx_runtime27.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime27.jsx)(WikiChild, { wiki, page, load: load2 }), children: (0, import_jsx_runtime27.jsx)("a", { href: url, className: "italic", target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/rrid.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var fetcher2 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function RRIDChild({ rrid }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { data, error } = useSWR(`https://scicrunch.org/resolver/${rrid}.json`, fetcher2);
  if (!data && !error) {
    return (0, import_jsx_runtime28.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const hit = (_b = (_a = data === null || data === void 0 ? void 0 : data.hits) === null || _a === void 0 ? void 0 : _a.hits) === null || _b === void 0 ? void 0 : _b[0];
  if (error || !hit) {
    return (0, import_jsx_runtime28.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: ["Error loading ", rrid, "."] });
  }
  const { name: title, curie, description, supercategory, keywords, types: categories } = (_d = (_c = hit === null || hit === void 0 ? void 0 : hit._source) === null || _c === void 0 ? void 0 : _c.item) !== null && _d !== void 0 ? _d : {};
  const category = (_e = supercategory === null || supercategory === void 0 ? void 0 : supercategory[0]) === null || _e === void 0 ? void 0 : _e.name;
  const types2 = (_f = categories === null || categories === void 0 ? void 0 : categories.map(({ name }) => name)) !== null && _f !== void 0 ? _f : [];
  const tags = (_g = keywords === null || keywords === void 0 ? void 0 : keywords.map(({ keyword }) => keyword)) !== null && _g !== void 0 ? _g : [];
  return (0, import_jsx_runtime28.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", children: [(0, import_jsx_runtime28.jsxs)("p", { className: "text-sm font-light", children: ["RRID: ", category] }), (0, import_jsx_runtime28.jsxs)("div", { className: "mb-4 text-xl font-bold", children: [title, " ", (0, import_jsx_runtime28.jsx)("code", { children: curie })] }), (0, import_jsx_runtime28.jsx)("p", { className: "text-md", children: description }), types2.length > 0 && (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [(0, import_jsx_runtime28.jsx)("div", { className: "my-2 text-xs font-thin", children: "Categories" }), (0, import_jsx_runtime28.jsx)("div", { className: "flex flex-wrap ml-1", children: types2 === null || types2 === void 0 ? void 0 : types2.map((tag) => (0, import_jsx_runtime28.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] }), tags.length > 0 && (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [(0, import_jsx_runtime28.jsx)("div", { className: "my-2 text-xs font-thin", children: "Tags" }), (0, import_jsx_runtime28.jsx)("div", { className: "flex flex-wrap ml-1", children: tags === null || tags === void 0 ? void 0 : tags.map((tag) => (0, import_jsx_runtime28.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] })] });
}
function RRIDLink({ rrid }) {
  return (0, import_jsx_runtime28.jsx)(HoverPopover, { card: (0, import_jsx_runtime28.jsx)(RRIDChild, { rrid }), children: (0, import_jsx_runtime28.jsxs)("a", { href: `https://scicrunch.org/resolver/${rrid}`, target: "_blank", rel: "noopener noreferrer", children: ["RRID: ", (0, import_jsx_runtime28.jsx)("cite", { className: "italic", children: rrid })] }) });
}

// ../../packages/myst-to-react/dist/links/ror.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@scienceicons/react/24/solid/esm/CcByIcon.js
var React47 = __toESM(require_react(), 1);
function CcByIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React47.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React47.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React47.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.8-1.7-2.8-4-2.8-6.7s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4zm2.6 5.6v4h-1.1v4.7h-3v-4.7H9.4v-4c0-.2.1-.3.2-.4.1-.2.2-.2.4-.2h4c.2 0 .3.1.4.2.2.1.2.2.2.4zm-4-2.5c0-.9.5-1.4 1.4-1.4s1.4.5 1.4 1.4c0 .9-.5 1.4-1.4 1.4s-1.4-.5-1.4-1.4z"
  }));
}
var ForwardRef35 = React47.forwardRef(CcByIcon);
var CcByIcon_default = ForwardRef35;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNcIcon.js
var React48 = __toESM(require_react(), 1);
function CcNcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React48.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React48.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React48.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.9-1.9-2.9-4.2-2.9-6.9s1-5 2.9-6.9c2-1.7 4.3-2.7 7-2.7zM4.4 9.4C4.2 10.2 4 11 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4.6-.5 1-1.1 1.3-1.7l-3.7-1.6c-.1.6-.4 1.1-.9 1.5-.5.4-1.1.6-1.8.7V18h-1.1v-1.5c-1.1 0-2.1-.4-3-1.2l1.3-1.4c.6.6 1.4.9 2.2.9.3 0 .6-.1.9-.2.2-.2.4-.4.4-.7 0-.2-.1-.4-.3-.6l-.9-.4-1.1-.6-1.5-.7-5.1-2.2zM12 4c-2.2 0-4.1.8-5.6 2.3-.4.4-.7.9-1.1 1.3L9 9.3c.2-.5.5-.9 1-1.2.5-.3 1-.5 1.6-.5V6.1h1.1v1.5c.9 0 1.7.3 2.4.9l-1.3 1.3c-.5-.4-1.1-.6-1.7-.6-.3 0-.6.1-.8.2-.2.1-.3.3-.3.6 0 .1 0 .2.1.2l1.2.6.9.4 1.6.7 5 2.2c.2-.7.2-1.4.2-2.1 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4z"
  }));
}
var ForwardRef36 = React48.forwardRef(CcNcIcon);
var CcNcIcon_default = ForwardRef36;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNdIcon.js
var React49 = __toESM(require_react(), 1);
function CcNdIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React49.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React49.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React49.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm3.7 5.7v1.7H8.6V9.7h7.1zm0 3.1v1.7H8.6v-1.7h7.1z"
  }));
}
var ForwardRef37 = React49.forwardRef(CcNdIcon);
var CcNdIcon_default = ForwardRef37;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcSaIcon.js
var React50 = __toESM(require_react(), 1);
function CcSaIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React50.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React50.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React50.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm-4.3 6.6c.2-1.2.7-2.1 1.4-2.8.8-.7 1.7-1 2.8-1 1.5 0 2.8.5 3.7 1.5.9 1 1.4 2.3 1.4 3.8s-.5 2.7-1.4 3.7c-.9 1-2.2 1.5-3.7 1.5-1.1 0-2.1-.3-2.9-1-.8-.7-1.3-1.6-1.4-2.8h2.5c.1 1.2.8 1.8 2.1 1.8.7 0 1.2-.3 1.7-.9.4-.6.6-1.4.6-2.4s-.2-1.8-.6-2.4c-.4-.5-.9-.8-1.7-.8-1.3 0-2 .6-2.2 1.7h.7l-1.9 1.9-1.9-1.9.8.1z"
  }));
}
var ForwardRef38 = React50.forwardRef(CcSaIcon);
var CcSaIcon_default = ForwardRef38;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcZeroIcon.js
var React51 = __toESM(require_react(), 1);
function CcZeroIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React51.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React51.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React51.createElement("path", {
    d: "M12 6.4c-3.2 0-4 3-4 5.6 0 2.6.8 5.6 4 5.6s4-3 4-5.6c0-2.6-.8-5.6-4-5.6zm0 2.1h.4c.2.2.3.5.1.9l-2.1 3.9c-.1-.5-.1-1-.1-1.4 0-1 0-3.4 1.7-3.4zm1.6 1.8c.1.6.1 1.2.1 1.7 0 1.1-.1 3.5-1.7 3.5h-.4-.1-.1c-.4-.2-.6-.4-.3-.9l2.5-4.3z"
  }), /* @__PURE__ */ React51.createElement("path", {
    d: "M12 2.2c-2.7 0-5 .9-6.8 2.8-1 1-1.7 2.1-2.2 3.3-.5 1.2-.8 2.4-.8 3.7 0 1.3.2 2.5.7 3.7.5 1.2 1.2 2.2 2.1 3.2.9.9 2 1.6 3.2 2.1 1.2.5 2.4.7 3.7.7 1.3 0 2.5-.3 3.7-.8 1.2-.5 2.3-1.2 3.2-2.2.9-.9 1.6-1.9 2.1-3.1.5-1.2.7-2.4.7-3.8 0-1.3-.2-2.6-.7-3.7-.3-1-1-2.1-1.9-3-2-1.9-4.3-2.9-7-2.9zM12 4c2.2 0 4.1.8 5.7 2.3.7.8 1.3 1.7 1.7 2.6.4 1 .6 2 .6 3.1 0 2.2-.8 4.1-2.3 5.6-.8.8-1.7 1.4-2.7 1.8-1 .4-2 .6-3 .6-1.1 0-2.1-.2-3-.6-1-.4-1.8-1-2.6-1.7C5.6 16.9 5 16 4.6 15c-.4-1-.6-2-.6-3 0-1.1.2-2.1.6-3 .4-1 1-1.9 1.8-2.6C7.9 4.8 9.8 4 12 4z"
  }));
}
var ForwardRef39 = React51.forwardRef(CcZeroIcon);
var CcZeroIcon_default = ForwardRef39;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcIcon.js
var React52 = __toESM(require_react(), 1);
function CcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React52.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React52.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React52.createElement("path", {
    d: "M12 2.2c2.7 0 5 1 7 2.9.9.9 1.6 2 2.1 3.1.5 1.2.7 2.4.7 3.8 0 1.3-.2 2.6-.7 3.8-.5 1.2-1.2 2.2-2.1 3.1-1 .9-2 1.7-3.2 2.2-1.2.5-2.5.7-3.7.7s-2.6-.3-3.8-.8c-1.2-.5-2.2-1.2-3.2-2.1s-1.6-2-2.1-3.2-.8-2.4-.8-3.7c0-1.3.2-2.5.7-3.7S4.2 6 5.1 5.1C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C5.6 7.1 5 8 4.6 9c-.4 1-.6 2-.6 3s.2 2.1.6 3c.4 1 1 1.8 1.8 2.6S8 19 9 19.4c1 .4 2 .6 3 .6s2.1-.2 3-.6c1-.4 1.9-1 2.7-1.8 1.5-1.5 2.3-3.3 2.3-5.6 0-1.1-.2-2.1-.6-3.1-.4-1-1-1.8-1.7-2.6C16.1 4.8 14.2 4 12 4zm-.1 6.4l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.5.3-1 .4-1.5.4-.9 0-1.6-.3-2.1-.8-.5-.6-.8-1.3-.8-2.3 0-.9.3-1.7.8-2.2.6-.6 1.3-.8 2.1-.8 1.2 0 2.1.4 2.6 1.4zm5.6 0l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.4.2-.9.3-1.4.3-.9 0-1.6-.3-2.1-.8s-.8-1.3-.8-2.2c0-.9.3-1.7.8-2.2.5-.5 1.2-.8 2-.8 1.2 0 2.1.4 2.6 1.4z"
  }));
}
var ForwardRef40 = React52.forwardRef(CcIcon);
var CcIcon_default = ForwardRef40;

// ../../node_modules/@scienceicons/react/24/solid/esm/EmailIcon.js
var React53 = __toESM(require_react(), 1);
function EmailIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React53.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React53.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React53.createElement("path", {
    d: "M21.8 18c0 1.1-.9 2-1.9 2H4.2c-1.1 0-1.9-.9-1.9-2V9.9c0-.5.3-.7.8-.4l7.8 4.7c.7.4 1.7.4 2.4 0L21 9.5c.4-.2.8-.1.8.4V18z"
  }), /* @__PURE__ */ React53.createElement("path", {
    d: "M21.8 6c0-1.1-.9-2-1.9-2H4.2c-1.1 0-2 .9-2 2v.4c0 .5.3 1.1.8 1.3l8.5 5.1c.2.1.7.1.9 0l8.6-5c.4-.3.8-.9.8-1.3-.1-.1-.1-.5 0-.5z"
  }));
}
var ForwardRef41 = React53.forwardRef(EmailIcon);
var EmailIcon_default = ForwardRef41;

// ../../node_modules/@scienceicons/react/24/solid/esm/GithubIcon.js
var React54 = __toESM(require_react(), 1);
function GithubIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React54.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React54.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React54.createElement("path", {
    d: "M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"
  }));
}
var ForwardRef42 = React54.forwardRef(GithubIcon);
var GithubIcon_default = ForwardRef42;

// ../../node_modules/@scienceicons/react/24/solid/esm/JupyterIcon.js
var React55 = __toESM(require_react(), 1);
function JupyterIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React55.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React55.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React55.createElement("path", {
    d: "M20.2 1.7c0 .8-.5 1.4-1.3 1.5-.8 0-1.4-.5-1.5-1.3 0-.8.5-1.4 1.3-1.5.8-.1 1.5.5 1.5 1.3zM12 17.9c-3.7 0-7-1.3-8.7-3.3 1.8 4.8 7.1 7.3 11.9 5.5 2.5-.9 4.5-2.9 5.5-5.5-1.7 2-4.9 3.3-8.7 3.3zM12 5.1c3.7 0 7 1.3 8.7 3.3-1.8-4.8-7.1-7.3-11.9-5.5-2.5.9-4.5 2.9-5.5 5.5 1.7-2 5-3.3 8.7-3.3zM6.9 21.8c.1 1-.7 1.8-1.7 1.9-1 .1-1.8-.7-1.9-1.7 0-1 .7-1.8 1.7-1.9 1-.1 1.8.7 1.9 1.7zM3.7 4.6c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1c0 .5-.4 1-1 1z"
  }));
}
var ForwardRef43 = React55.forwardRef(JupyterIcon);
var JupyterIcon_default = ForwardRef43;

// ../../node_modules/@scienceicons/react/24/solid/esm/OpenAccessIcon.js
var React56 = __toESM(require_react(), 1);
function OpenAccessIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React56.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React56.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React56.createElement("path", {
    d: "M17.1 12.6h-2V7.5c0-1.7-1.4-3.1-3-3.1-.8 0-1.6.3-2.2.9-.6.5-.9 1.3-.9 2.2v.7H7v-.7c0-1.4.5-2.7 1.5-3.7s2.2-1.5 3.6-1.5 2.6.5 3.6 1.5 1.5 2.3 1.5 3.7v5.1z"
  }), /* @__PURE__ */ React56.createElement("path", {
    d: "M12 21.8c-.8 0-1.6-.2-2.3-.5-.7-.3-1.4-.8-1.9-1.3-.6-.6-1-1.2-1.3-2-.3-.8-.5-1.6-.5-2.4s.2-1.6.5-2.4c.3-.7.7-1.4 1.3-2s1.2-1 1.9-1.3c.7-.3 1.5-.5 2.3-.5.8 0 1.6.2 2.3.5.7.3 1.4.8 1.9 1.3.6.6 1 1.2 1.3 2 .3.8.5 1.6.5 2.4s-.2 1.6-.5 2.4c-.3.7-.7 1.4-1.3 2-.6.6-1.2 1-1.9 1.3-.7.3-1.5.5-2.3.5zm0-10.3c-2.2 0-4 1.8-4 4.1s1.8 4.1 4 4.1 4-1.8 4-4.1-1.8-4.1-4-4.1z"
  }), /* @__PURE__ */ React56.createElement("circle", {
    cx: 12,
    cy: 15.6,
    r: 1.7
  }));
}
var ForwardRef44 = React56.forwardRef(OpenAccessIcon);
var OpenAccessIcon_default = ForwardRef44;

// ../../node_modules/@scienceicons/react/24/solid/esm/OrcidIcon.js
var React57 = __toESM(require_react(), 1);
function OrcidIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React57.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React57.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React57.createElement("path", {
    d: "M21.8 12c0 5.4-4.4 9.8-9.8 9.8S2.2 17.4 2.2 12 6.6 2.2 12 2.2s9.8 4.4 9.8 9.8zM8.2 5.8c-.4 0-.8.3-.8.8s.3.8.8.8.8-.4.8-.8-.3-.8-.8-.8zm2.3 9.6h1.2v-6h1.8c2.3 0 3.3 1.4 3.3 3s-1.5 3-3.3 3h-3v1.1H9V8.3H7.7v8.2h5.9c3.3 0 4.5-2.2 4.5-4.1s-1.2-4.1-4.3-4.1h-3.2l-.1 7.1z"
  }));
}
var ForwardRef45 = React57.forwardRef(OrcidIcon);
var OrcidIcon_default = ForwardRef45;

// ../../node_modules/@scienceicons/react/24/solid/esm/OsiIcon.js
var React58 = __toESM(require_react(), 1);
function OsiIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React58.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React58.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React58.createElement("path", {
    d: "M13.2 15.6c1.4-.5 2.1-1.6 2.1-3.3S13.8 8.9 12 8.9c-1.9 0-3.3 1.6-3.3 3.3 0 1.8.8 3 2.2 3.4l-2.3 5.9c-3.1-.8-6.3-4.6-6.3-9.3 0-5.5 4.3-10 9.7-10s9.8 4.5 9.8 10c0 4.7-3.1 8.5-6.3 9.3l-2.3-5.9z"
  }));
}
var ForwardRef46 = React58.forwardRef(OsiIcon);
var OsiIcon_default = ForwardRef46;

// ../../node_modules/@scienceicons/react/24/solid/esm/RorIcon.js
var React59 = __toESM(require_react(), 1);
function RorIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React59.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React59.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React59.createElement("path", {
    d: "M10 4.2L8.3 6.8 6.6 4.2H10zM17.1 4.2l-1.7 2.6-1.7-2.6h3.4zM6.6 19.8l1.7-2.6 1.7 2.6H6.6zM13.7 19.8l1.7-2.6 1.7 2.6h-3.4zM20.8 12.5c.6-.1 1.1-.4 1.4-.8.3-.4.5-.9.5-1.5 0-.5-.1-.9-.3-1.2-.2-.3-.4-.6-.7-.8-.3-.2-.6-.3-1-.4-.4-.1-.8-.1-1.2-.1h-3.3v2.6c0-.1-.1-.2-.1-.2-.2-.6-.6-1-1-1.4-.4-.4-.9-.7-1.5-.9-.6-.2-1.2-.3-1.9-.3s-1.3.1-1.9.3c-.5.1-1 .4-1.4.8-.3.4-.6.8-.9 1.3 0-.3-.1-.6-.2-.9-.2-.4-.4-.6-.7-.8-.3-.2-.6-.3-1-.4s-.8-.2-1.3-.2H1v8.5h1.9v-3.4h.9l1.8 3.4h2.3l-2.2-3.6c.6-.1 1.1-.4 1.4-.8v-.1.2c0 .7.1 1.3.3 1.8.2.6.6 1 1 1.4.4.4.9.7 1.5.9.6.2 1.2.3 1.9.3s1.3-.1 1.9-.3c.6-.2 1.1-.5 1.5-.9.4-.4.7-.9 1-1.4 0-.1.1-.2.1-.2V16H18v-3.4h.9l1.8 3.4H23l-2.2-3.5zM5.4 10.7c-.1.2-.2.3-.3.3-.2.1-.3.1-.5.1H2.9V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3 0 .5-.1.6zm8.8 2.3c-.1.3-.3.6-.5.9-.2.2-.5.4-.8.6-.3.1-.7.2-1.1.2-.4 0-.8-.1-1.1-.2-.3-.1-.6-.3-.8-.6-.2-.2-.4-.5-.5-.9-.1-.3-.2-.7-.2-1.1 0-.4.1-.8.2-1.1s.3-.6.5-.9c.2-.2.5-.4.8-.6.3-.1.7-.2 1.1-.2.4 0 .8.1 1.1.2.3.1.6.3.8.6.2.2.4.5.5.9.1.3.2.7.2 1.1 0 .4 0 .7-.2 1.1zm6.4-2.3c-.1.1-.2.2-.4.3-.2.1-.3.1-.5.1H18V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3.1.5 0 .6z"
  }));
}
var ForwardRef47 = React59.forwardRef(RorIcon);
var RorIcon_default = ForwardRef47;

// ../../node_modules/@scienceicons/react/24/solid/esm/TwitterIcon.js
var React60 = __toESM(require_react(), 1);
function TwitterIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React60.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React60.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React60.createElement("path", {
    d: "M22.7 5.4c-.8.3-1.7.6-2.5.7.9-.5 1.6-1.4 1.9-2.4-.9.5-1.8.9-2.8 1.1-1.7-1.8-4.4-1.9-6.2-.2-1.1 1.1-1.6 2.7-1.3 4.2-3.5-.3-6.8-1.9-9-4.7-.4.7-.6 1.5-.6 2.2 0 1.5.7 2.8 1.9 3.6-.7 0-1.4-.2-2-.5v.1c0 2.1 1.5 3.9 3.5 4.3-.6.2-1.3.2-2 .1.6 1.8 2.2 3 4.1 3-1.6 1.2-3.5 1.9-5.4 1.9-.3 0-.7 0-1-.1 2 1.3 4.3 2 6.7 2 8.1 0 12.5-6.7 12.5-12.5v-.6c.8-.6 1.6-1.3 2.2-2.2"
  }));
}
var ForwardRef48 = React60.forwardRef(TwitterIcon);
var TwitterIcon_default = ForwardRef48;

// ../../packages/myst-to-react/dist/links/ror.js
var fetcher3 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function RORChild({ ror }) {
  var _a, _b, _c, _d;
  const { data, error } = useSWR(`https://api.ror.org/organizations/${ror}`, fetcher3);
  if (!data && !error) {
    return (0, import_jsx_runtime29.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  if (error) {
    return (0, import_jsx_runtime29.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: ["Error loading ", ror, "."] });
  }
  const country_name = (_a = data === null || data === void 0 ? void 0 : data.country) === null || _a === void 0 ? void 0 : _a.country_name;
  const basicLinks = (_b = data === null || data === void 0 ? void 0 : data.links.map((url) => ({ url }))) !== null && _b !== void 0 ? _b : [];
  const wikiLink = data.wikipedia_url ? [{ text: "Wikipedia", url: data.wikipedia_url }] : [];
  const links = [...basicLinks, ...wikiLink];
  return (0, import_jsx_runtime29.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", children: [(0, import_jsx_runtime29.jsxs)("p", { className: "flex items-stretch gap-2 text-sm font-light", children: [(0, import_jsx_runtime29.jsx)(RorIcon_default, { width: "1.25rem", height: "1.25rem", className: "self-center inline-block" }), (0, import_jsx_runtime29.jsx)("a", { href: `https://ror.org/${ror}`, className: "self-center", target: "_blank", rel: "noopener noreferrer", children: (0, import_jsx_runtime29.jsx)("code", { children: ror }) })] }), (0, import_jsx_runtime29.jsx)("div", { className: "mb-4 text-xl font-bold", children: data.name }), (0, import_jsx_runtime29.jsxs)("dl", { className: "mb-4 text-sm", children: [(0, import_jsx_runtime29.jsx)("dt", { children: "Country" }), (0, import_jsx_runtime29.jsx)("dd", { children: country_name }), links.length > 0 && (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, { children: [(0, import_jsx_runtime29.jsx)("dt", { children: "Links" }), links.map(({ url, text }) => (0, import_jsx_runtime29.jsx)("dd", { children: (0, import_jsx_runtime29.jsx)("a", { href: url, children: text || url }) }))] }), ((_c = data.acronyms) === null || _c === void 0 ? void 0 : _c.length) > 0 && (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, { children: [(0, import_jsx_runtime29.jsx)("dt", { children: "Acronyms" }), data.acronyms.map((text) => (0, import_jsx_runtime29.jsx)("dd", { children: text }))] }), ((_d = data.labels) === null || _d === void 0 ? void 0 : _d.length) > 0 && (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, { children: [(0, import_jsx_runtime29.jsx)("dt", { children: "Labels" }), data.labels.map(({ label, iso639 }) => (0, import_jsx_runtime29.jsxs)("dd", { children: [label, iso639 ? ` (${iso639})` : null] }))] })] })] });
}
function RORLink({ node, ror }) {
  return (0, import_jsx_runtime29.jsx)(HoverPopover, { card: (0, import_jsx_runtime29.jsx)(RORChild, { ror }), children: (0, import_jsx_runtime29.jsx)("a", { href: `https://ror.org/${ror}`, target: "_blank", rel: "noopener noreferrer", children: (0, import_jsx_runtime29.jsx)(MyST, { ast: node.children }) }) });
}

// ../../packages/myst-to-react/dist/links/github.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);
var fetcher4 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.text();
  throw new Error(`Content returned with status ${res.status}.`);
});
var jsonFetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function extToLanguage(ext) {
  var _a;
  return (_a = {
    ts: "typescript",
    js: "javascript",
    py: "python",
    md: "markdown",
    yml: "yaml"
  }[ext !== null && ext !== void 0 ? ext : ""]) !== null && _a !== void 0 ? _a : ext;
}
function useLoadWhenOpen(open, url, loader3) {
  const [cached, setCached] = (0, import_react36.useState)();
  const { data, error } = useSWR(open ? url : null, loader3);
  (0, import_react36.useEffect)(() => {
    setCached(cached || data);
  }, [cached, url, data]);
  return { data: cached, error };
}
function GithubFilePreview({ url, raw, org, repo, file, from, to, open }) {
  const { data, error } = useLoadWhenOpen(open, raw, fetcher4);
  let code3 = data;
  if (error) {
    return (0, import_jsx_runtime30.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: [(0, import_jsx_runtime30.jsx)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime30.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }) }), (0, import_jsx_runtime30.jsxs)("div", { className: "mt-2", children: ['Error loading "', file, '" from GitHub.'] })] });
  }
  const lang = extToLanguage(file === null || file === void 0 ? void 0 : file.split(".").pop());
  let startingLineNumber = 1;
  let emphasizeLines = [];
  const offset2 = 5;
  if (code3 && from && to) {
    startingLineNumber = from;
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(from - 1, to).join("\n");
  } else if (code3 && from) {
    startingLineNumber = from + 1 - offset2;
    emphasizeLines = [from];
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(Math.max(0, from - offset2), from + offset2).join("\n");
  } else {
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(0, 10).join("\n");
  }
  const description = code3 ? (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, { children: (0, import_jsx_runtime30.jsx)(CodeBlock, { value: code3, lang, filename: file, showLineNumbers: true, startingLineNumber, emphasizeLines, showCopy: false }) }) : null;
  return (0, import_jsx_runtime30.jsx)(LinkCard, { loading: !code3, url, title: `GitHub - ${org}/${repo}`, description, className: "hover-document article max-w-[80vw]" });
}
function useWhiteTextColor(bgColor) {
  const color2 = bgColor.charAt(0) === "#" ? bgColor.substring(1, 7) : bgColor;
  const r4 = parseInt(color2.substring(0, 2), 16);
  const g4 = parseInt(color2.substring(2, 4), 16);
  const b4 = parseInt(color2.substring(4, 6), 16);
  return r4 * 0.299 + g4 * 0.587 + b4 * 0.114 <= 186;
}
function GithubIssuePreview({ url, org, repo, issue_number, open }) {
  var _a, _b;
  const { data, error } = useLoadWhenOpen(open, `https://api.github.com/repos/${org}/${repo}/issues/${issue_number}`, jsonFetcher);
  if (!data && !error) {
    return (0, import_jsx_runtime30.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const resp = data;
  if (error) {
    return (0, import_jsx_runtime30.jsxs)("div", { className: "hover-document article", children: [(0, import_jsx_runtime30.jsx)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime30.jsx)(ArrowTopRightOnSquareIcon_default, { className: "float-right w-4 h-4" }) }), (0, import_jsx_runtime30.jsx)("div", { className: "mt-2", children: "Error loading from GitHub." })] });
  }
  const dateString = new Date(resp.created_at).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  return (0, import_jsx_runtime30.jsxs)("div", { className: "hover-document article w-[400px] sm:max-w-[400px] p-3", children: [(0, import_jsx_runtime30.jsxs)("div", { className: "text-xs font-light", children: [org, "/", repo] }), (0, import_jsx_runtime30.jsxs)("div", { className: "my-2 text-lg font-bold dark:text-white", children: [resp.state === "open" && (0, import_jsx_runtime30.jsx)(PlusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-green-700 -translate-y-px dark:text-green-500" }), resp.state === "closed" && (0, import_jsx_runtime30.jsx)(CheckCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-purple-700 -translate-y-px dark:text-purple-500" }), resp.title] }), (0, import_jsx_runtime30.jsxs)("div", { className: "text-xs font-light", children: ["#", issue_number, " opened on ", dateString, " by", " ", (0, import_jsx_runtime30.jsxs)("span", { className: "font-normal", children: ["@", resp.user.login] })] }), (0, import_jsx_runtime30.jsx)("p", { className: "text-md max-h-[4rem] overflow-hidden", children: resp.body }), ((_a = resp.labels) === null || _a === void 0 ? void 0 : _a.length) > 0 && (0, import_jsx_runtime30.jsx)("div", { className: "flex flex-wrap", children: (_b = resp.labels) === null || _b === void 0 ? void 0 : _b.map((label) => (0, import_jsx_runtime30.jsx)("span", { className: (0, import_classnames12.default)("mr-1 text-xs inline-flex items-center px-2 py-0.5 rounded-full", {
    "text-white": useWhiteTextColor(label.color)
  }), style: { backgroundColor: `#${label.color}` }, children: label.name }, label.id)) })] });
}
function GithubLink({ kind, children, url, org, repo, raw, file, from, to, issue_number }) {
  return (0, import_jsx_runtime30.jsx)(HoverPopover, { card: ({ load: load2 }) => {
    if (kind === "file") {
      return (0, import_jsx_runtime30.jsx)(GithubFilePreview, { url, raw, file, from, to, open: load2, org, repo });
    }
    if (kind === "issue") {
      return (0, import_jsx_runtime30.jsx)(GithubIssuePreview, { url, open: load2, org, issue_number, repo });
    }
  }, children: (0, import_jsx_runtime30.jsx)("a", { href: url, className: "italic", target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/index.js
function getPageInfo(site, path) {
  var _a;
  if (!site)
    return void 0;
  const [projectSlug, pageSlug] = path.replace(/^\//, "").split("/");
  const project = (_a = site.projects) === null || _a === void 0 ? void 0 : _a.find((p3) => p3.slug === projectSlug || !p3.slug && !pageSlug);
  if (!project)
    return void 0;
  return project.pages.find((p3) => p3.slug === (pageSlug || projectSlug));
}
function InternalLink({ url, children }) {
  const Link2 = useLinkProvider();
  const site = useSiteManifest();
  const page = getPageInfo(site, url);
  const baseurl = useBaseurl();
  const skipPreview = !page || !page.description && !page.thumbnail;
  if (!page || skipPreview) {
    return (0, import_jsx_runtime31.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", children });
  }
  return (0, import_jsx_runtime31.jsx)(HoverPopover, { card: (0, import_jsx_runtime31.jsx)(LinkCard, { internal: true, url, title: page.title, description: page.description, thumbnail: page.thumbnailOptimized || page.thumbnail }), children: (0, import_jsx_runtime31.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", children }) });
}
var link = ({ node }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  const protocol = node.protocol;
  switch (protocol) {
    case "wiki":
      return (0, import_jsx_runtime31.jsx)(WikiLink, { url: node.url, page: (_b = node.data) === null || _b === void 0 ? void 0 : _b.page, wiki: (_c = node.data) === null || _c === void 0 ? void 0 : _c.wiki, children: (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }) });
    case "github":
      return (0, import_jsx_runtime31.jsx)(GithubLink, { kind: (_d = node.data) === null || _d === void 0 ? void 0 : _d.kind, url: node.url, org: (_e = node.data) === null || _e === void 0 ? void 0 : _e.org, repo: (_f = node.data) === null || _f === void 0 ? void 0 : _f.repo, raw: (_g = node.data) === null || _g === void 0 ? void 0 : _g.raw, file: (_h = node.data) === null || _h === void 0 ? void 0 : _h.file, from: (_j = node.data) === null || _j === void 0 ? void 0 : _j.from, to: (_k = node.data) === null || _k === void 0 ? void 0 : _k.to, issue_number: (_l = node.data) === null || _l === void 0 ? void 0 : _l.issue_number, children: (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }) });
    case "rrid":
      return (0, import_jsx_runtime31.jsx)(RRIDLink, { rrid: (_m = node.data) === null || _m === void 0 ? void 0 : _m.rrid });
    case "ror":
      return (0, import_jsx_runtime31.jsx)(RORLink, { node, ror: (_o = node.data) === null || _o === void 0 ? void 0 : _o.ror });
    default:
      if (internal) {
        return (0, import_jsx_runtime31.jsx)(InternalLink, { url: node.url, children: (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }) });
      }
      return (0, import_jsx_runtime31.jsx)("a", { target: "_blank", href: node.url, rel: "noreferrer", children: (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }) });
  }
};
var linkBlock = ({ node }) => {
  var _a;
  const iconClass5 = "self-center transition-transform flex-none ml-3";
  const containerClass = "flex-1 p-4 my-5 block border font-normal hover:border-blue-500 dark:hover:border-blue-400 no-underline hover:text-blue-600 dark:hover:text-blue-400 text-gray-600 dark:text-gray-100 border-gray-200 dark:border-gray-500 rounded shadow-sm hover:shadow-lg dark:shadow-neutral-700";
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  const nested = (0, import_jsx_runtime31.jsxs)("div", { className: "flex h-full align-middle", children: [(0, import_jsx_runtime31.jsxs)("div", { className: "flex-grow", children: [node.title, (0, import_jsx_runtime31.jsx)("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: (0, import_jsx_runtime31.jsx)(MyST, { ast: node.children }) })] }), internal && (0, import_jsx_runtime31.jsx)(LinkIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 }), !internal && (0, import_jsx_runtime31.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 })] });
  if (internal) {
    return (0, import_jsx_runtime31.jsx)("a", { href: node.url, className: containerClass, children: nested });
  }
  return (0, import_jsx_runtime31.jsx)("a", { className: containerClass, target: "_blank", rel: "noopener noreferrer", href: node.url, children: nested });
};
var LINK_RENDERERS = {
  link,
  linkBlock
};
var links_default = LINK_RENDERERS;

// ../../packages/myst-to-react/dist/heading.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);
var Heading = ({ node }) => {
  const { enumerator, depth, key, identifier, html_id } = node;
  const id = html_id || identifier || key;
  const textContent = (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [enumerator && (0, import_jsx_runtime32.jsx)("span", { className: "mr-3 select-none", children: enumerator }), (0, import_jsx_runtime32.jsx)("span", { className: "heading-text", children: (0, import_jsx_runtime32.jsx)(MyST, { ast: node.children }) }), (0, import_jsx_runtime32.jsx)(HashLink, { id, kind: "Section", className: "px-2 font-normal", hover: true, hideInPopup: true })] });
  return (0, import_react37.createElement)(`h${depth}`, {
    id,
    className: "relative group"
  }, textContent);
};
var HEADING_RENDERERS = {
  heading: Heading
};
var heading_default = HEADING_RENDERERS;

// ../../packages/myst-to-react/dist/crossReference.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/myst-frontmatter/dist/utils/normalizeString.js
function normalizeJsonToString(value) {
  return JSON.stringify(Object.entries(value).filter(([, val]) => val !== void 0).sort());
}

// ../../node_modules/myst-frontmatter/dist/utils/referenceStash.js
function pseudoUniqueId(kind, index2, file) {
  let suffix = "";
  if (file) {
    const fileParts = file.replace("\\", "/").split("/");
    const nameParts = fileParts[fileParts.length - 1].split(".");
    if (nameParts.length === 1) {
      suffix = `-${nameParts[0]}`;
    } else {
      suffix = `-${nameParts.slice(0, nameParts.length - 1).join("-")}`;
    }
  }
  return `${kind}${suffix}-generated-uid-${index2}`;
}
function stashPlaceholder(value) {
  return { id: value, name: value };
}
function isStashPlaceholder(object2) {
  var _a;
  if (!object2.name || !object2.id || object2.name !== object2.id)
    return false;
  const nKeys = Object.keys(object2).length;
  if (nKeys === 2)
    return true;
  return nKeys === 3 && ((_a = object2.nameParsed) === null || _a === void 0 ? void 0 : _a.literal) === object2.id;
}
function validateAndStashObject(input, stash, kind, validateFn, opts) {
  var _a, _b, _c;
  const lookup = {};
  const lookupNorm2Id = {};
  (_a = stash[kind]) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
    if (item.id) {
      lookup[item.id] = item;
      lookupNorm2Id[normalizeJsonToString({ ...item, id: void 0 })] = item.id;
    }
  });
  if (typeof input === "string" && Object.keys(lookup).includes(input)) {
    return input;
  }
  const value = validateFn(input, opts);
  if (!value)
    return;
  let warnOnDuplicate = !isStashPlaceholder(value);
  if (!value.id) {
    if (lookupNorm2Id[normalizeJsonToString(value)]) {
      value.id = lookupNorm2Id[normalizeJsonToString(value)];
      warnOnDuplicate = false;
    } else {
      value.id = pseudoUniqueId(kind, (_c = (_b = stash[kind]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, opts.file);
    }
  }
  if (!Object.keys(lookup).includes(value.id)) {
    lookup[value.id] = value;
  } else if (isStashPlaceholder(lookup[value.id])) {
    lookup[value.id] = value;
  } else if (warnOnDuplicate) {
    validationWarning(`duplicate id for ${kind} found in frontmatter: ${value.id}`, opts);
  }
  stash[kind] = Object.values(lookup);
  return value.id;
}

// ../../node_modules/myst-frontmatter/dist/utils/validators.js
var GITHUB_USERNAME_REPO_REGEX = "^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$";
function validateDoi(value, opts) {
  const doiString = validateString(value, opts);
  if (doiString !== void 0) {
    if (doi.validate(doiString, { strict: true })) {
      return doiString;
    } else {
      validationError("must be valid DOI", opts);
    }
  }
  return void 0;
}
function validateGithubUrl(value, opts) {
  let github = value;
  if (typeof github === "string") {
    const repo = github.match(GITHUB_USERNAME_REPO_REGEX);
    if (repo) {
      github = `https://github.com/${repo}`;
    }
  }
  return validateUrl(github, {
    ...incrementOptions("github", opts),
    includes: "github"
  });
}
function validateStringOrNumber(input, opts) {
  if (typeof input === "string")
    return validateString(input, opts);
  if (typeof input === "number")
    return input;
  return validationError("must be string or number", opts);
}

// ../../node_modules/myst-frontmatter/dist/affiliations/validators.js
var AFFILIATION_KEYS = [
  "id",
  "address",
  "city",
  "state",
  "postal_code",
  "country",
  "name",
  "department",
  "collaboration",
  "isni",
  "ringgold",
  "ror",
  "doi",
  "url",
  "email",
  "phone",
  "fax"
];
var AFFILIATION_ALIASES = {
  ref: "id",
  // Used in QMD to reference an affiliation
  region: "state",
  province: "state",
  zipcode: "postal_code",
  zip_code: "postal_code",
  website: "url",
  institution: "name"
};
function validateAffiliation(input, opts) {
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  } else {
    validationWarning("affiliation should include name/institution", opts);
  }
  if (defined(value.department)) {
    output.department = validateString(value.department, incrementOptions("department", opts));
  }
  if (defined(value.address)) {
    output.address = validateString(value.address, incrementOptions("address", opts));
  }
  if (defined(value.city)) {
    output.city = validateString(value.city, incrementOptions("city", opts));
  }
  if (defined(value.state)) {
    output.state = validateString(value.state, incrementOptions("state", opts));
  }
  if (defined(value.postal_code)) {
    output.postal_code = validateString(value.postal_code, {
      coerceNumber: true,
      ...incrementOptions("postal_code", opts)
    });
  }
  if (defined(value.country)) {
    output.country = validateString(value.country, incrementOptions("country", opts));
  }
  if (defined(value.isni)) {
    output.isni = validateString(value.isni, incrementOptions("isni", opts));
  }
  if (defined(value.ror)) {
    output.ror = validateString(value.ror, incrementOptions("ror", opts));
  }
  if (defined(value.ringgold)) {
    output.ringgold = validateNumber(value.ringgold, {
      min: 1e3,
      max: 999999,
      ...incrementOptions("ringgold", opts)
    });
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.collaboration)) {
    output.collaboration = validateBoolean(value.collaboration, incrementOptions("collaboration", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/biblio/validators.js
var BIBLIO_KEYS = ["volume", "issue", "first_page", "last_page"];
function validateBiblio(input, opts) {
  const value = validateObjectKeys(input, { optional: BIBLIO_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.volume)) {
    output.volume = validateStringOrNumber(value.volume, incrementOptions("volume", opts));
  }
  if (defined(value.issue)) {
    output.issue = validateStringOrNumber(value.issue, incrementOptions("issue", opts));
  }
  if (defined(value.first_page)) {
    output.first_page = validateStringOrNumber(value.first_page, incrementOptions("first_page", opts));
  }
  if (defined(value.last_page)) {
    output.last_page = validateStringOrNumber(value.last_page, incrementOptions("last_page", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/utils/parseName.js
function startsWithUpperCase(word) {
  for (const letter of word) {
    if (letter.toLowerCase() === letter.toUpperCase())
      continue;
    return letter === letter.toUpperCase();
  }
  return true;
}
function parseName(literal) {
  var _a, _b;
  const displayParts = literal.split(",");
  if (displayParts.length === 1) {
    return { literal, ...parseGivenParticleFamily(literal) };
  }
  const lastPart = (_a = displayParts.pop()) === null || _a === void 0 ? void 0 : _a.trim();
  const givenAndParticle = parseGivenParticle(lastPart);
  if (displayParts.length === 1) {
    return { literal, ...givenAndParticle, ...parseParticleFamily(displayParts[0]) };
  }
  const suffix = (_b = displayParts.pop()) === null || _b === void 0 ? void 0 : _b.trim();
  const particleAndFamily = parseParticleFamily(displayParts.join(","));
  if (!suffix)
    return { literal, ...givenAndParticle, ...particleAndFamily };
  return { literal, ...givenAndParticle, ...particleAndFamily, suffix };
}
function parseGivenParticle(name) {
  const nameParts = name === null || name === void 0 ? void 0 : name.trim().split(/\s+/);
  if (!(nameParts === null || nameParts === void 0 ? void 0 : nameParts.length))
    return {};
  let given = nameParts.shift();
  if (!given)
    return {};
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  if (!nameParts.length)
    return { given };
  return { given, dropping_particle: nameParts.join(" ") };
}
function parseParticleFamily(name) {
  const nameParts = name.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (nameParts.length && startsWithUpperCase(nameParts[0])) {
    return { family: [...nameParts, family].join(" ") };
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { family };
  return { non_dropping_particle: nameParts.join(" "), family };
}
function parseGivenParticleFamily(name) {
  const nameParts = name.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (!nameParts.length)
    return { family };
  let given = nameParts.shift();
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { given, family };
  return { given, non_dropping_particle: nameParts.join(" "), family };
}
function formatName(name, alwaysReversed = false) {
  const { literal, given, dropping_particle, non_dropping_particle, family, suffix } = name;
  if (literal)
    return literal;
  const hasCommas = [given, dropping_particle, non_dropping_particle, family, suffix].join("").includes(",");
  if (!alwaysReversed && !hasCommas && !dropping_particle && !suffix) {
    const formattedName = [given, non_dropping_particle, family].filter(Boolean).join(" ");
    const reParsedName = parseName(formattedName);
    delete reParsedName.literal;
    const serializedParsedName = JSON.stringify(Object.entries(reParsedName).sort());
    const serializedSourceName = JSON.stringify(Object.entries(name).sort());
    if (serializedParsedName === serializedSourceName) {
      return formattedName;
    }
  }
  let output = ",";
  if (suffix || hasCommas)
    output = `${output}${suffix ? " " : ""}${suffix !== null && suffix !== void 0 ? suffix : ""},`;
  if (given)
    output = `${output} ${given}`;
  if (family)
    output = `${family}${output}`;
  if (dropping_particle)
    output = `${output} ${dropping_particle}`;
  if (non_dropping_particle)
    output = `${non_dropping_particle} ${output}`;
  if (output === ",")
    return "";
  return output;
}

// ../../node_modules/myst-frontmatter/dist/contributors/validators.js
var PERSON_KEYS = [
  "id",
  "userId",
  "name",
  "nameParsed",
  "orcid",
  "corresponding",
  "equal_contributor",
  "deceased",
  "email",
  "roles",
  "affiliations",
  "collaborations",
  "twitter",
  "github",
  "url",
  "note",
  "phone",
  "fax"
];
var PERSON_ALIASES = {
  ref: "id",
  // Used in QMD to reference a contributor
  role: "roles",
  "equal-contributor": "equal_contributor",
  affiliation: "affiliations",
  website: "url"
};
var NAME_KEYS = [
  "literal",
  "given",
  "family",
  "suffix",
  "non_dropping_particle",
  "dropping_particle"
];
var NAME_ALIASES = {
  surname: "family",
  last: "family",
  forename: "given",
  first: "given",
  particle: "non_dropping_particle",
  "non-dropping-particle": "non_dropping_particle",
  "dropping-particle": "dropping_particle"
};
function validateName(input, opts) {
  let output;
  let raiseCommaWarnings = false;
  if (typeof input === "string") {
    output = parseName(input);
    raiseCommaWarnings = true;
  } else {
    const value = validateObjectKeys(input, { optional: NAME_KEYS, alias: NAME_ALIASES }, opts);
    if (value === void 0)
      return void 0;
    output = {};
    if (defined(value.literal)) {
      output.literal = validateString(value.literal, incrementOptions("literal", opts));
    }
    if (defined(value.given)) {
      output.given = validateString(value.given, incrementOptions("given", opts));
    }
    if (defined(value.non_dropping_particle)) {
      output.non_dropping_particle = validateString(value.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    }
    if (defined(value.dropping_particle)) {
      output.dropping_particle = validateString(value.dropping_particle, incrementOptions("dropping_particle", opts));
    }
    if (defined(value.family)) {
      output.family = validateString(value.family, incrementOptions("family", opts));
    }
    if (defined(value.suffix)) {
      output.suffix = validateString(value.suffix, incrementOptions("suffix", opts));
    }
    if (Object.keys(output).length === 1 && output.literal) {
      output = { ...output, ...parseName(output.literal) };
      raiseCommaWarnings = true;
    } else if (!output.literal) {
      output.literal = formatName(output);
      if (output.literal.startsWith(",")) {
        validationWarning(`unexpected comma at beginning of name: ${output.literal} - you may need to define 'name.literal' explicitly`, opts);
      }
    }
  }
  if (raiseCommaWarnings) {
    const warnOnComma = (part, o10) => {
      if (part && part.includes(",")) {
        validationWarning(`unexpected comma in name part: ${part} - you may need to define 'name' explicitly as an object`, o10);
      }
    };
    warnOnComma(output.given, incrementOptions("given", opts));
    warnOnComma(output.family, incrementOptions("family", opts));
    warnOnComma(output.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    warnOnComma(output.dropping_particle, incrementOptions("dropping_particle", opts));
    warnOnComma(output.suffix, incrementOptions("suffix", opts));
  }
  return output;
}
function validateContributor(input, stash, opts) {
  var _a, _b, _c;
  const inputAff = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, {
    ...opts,
    suppressErrors: true,
    suppressWarnings: true
  });
  if ((inputAff === null || inputAff === void 0 ? void 0 : inputAff.collaboration) === true) {
    return validateAffiliation(input, opts);
  }
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: PERSON_KEYS, alias: PERSON_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (inputAff && Object.keys(inputAff).length > Object.keys(value).length) {
    validationWarning('contributor may be a collaboration, not a person - if so, add "collaboration: true"', opts);
  }
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.userId)) {
    output.userId = validateString(value.userId, incrementOptions("userId", opts));
  }
  if (defined(value.nameParsed)) {
    output.nameParsed = validateName(value.nameParsed, incrementOptions("nameParsed", opts));
    output.name = value.name ? validateString(value.name, incrementOptions("name", opts)) : (_a = output.nameParsed) === null || _a === void 0 ? void 0 : _a.literal;
    if (output.name !== ((_b = output.nameParsed) === null || _b === void 0 ? void 0 : _b.literal)) {
      validationWarning(`"name" and "parsedName.literal" should match`, opts);
    }
  } else if (defined(value.name)) {
    output.nameParsed = validateName(value.name, incrementOptions("name", opts));
    output.name = (_c = output.nameParsed) === null || _c === void 0 ? void 0 : _c.literal;
  } else {
    validationWarning("contributor should include name", opts);
  }
  if (defined(value.orcid)) {
    const orcidOpts = incrementOptions("orcid", opts);
    const id = orcid.normalize(value.orcid);
    if (id) {
      output.orcid = id;
    } else {
      validationError(`ORCID "${value.orcid}" is not valid, try an ID of the form "0000-0000-0000-0000"`, orcidOpts);
    }
  }
  if (defined(value.corresponding)) {
    const correspondingOpts = incrementOptions("corresponding", opts);
    output.corresponding = validateBoolean(value.corresponding, correspondingOpts);
    if (value.corresponding && !defined(value.email)) {
      validationError(`must include email for corresponding author`, correspondingOpts);
      output.corresponding = false;
    }
  }
  if (defined(value.equal_contributor)) {
    output.equal_contributor = validateBoolean(value.equal_contributor, incrementOptions("equal_contributor", opts));
  }
  if (defined(value.deceased)) {
    output.deceased = validateBoolean(value.deceased, incrementOptions("deceased", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  if (defined(value.roles)) {
    const rolesOpts = incrementOptions("roles", opts);
    let roles = value.roles;
    if (typeof roles === "string") {
      roles = roles.split(/[,;]/);
    }
    output.roles = validateList(roles, rolesOpts, (r4) => {
      const roleString = validateString(r4, rolesOpts);
      if (roleString === void 0)
        return void 0;
      const role = credit.normalize(roleString);
      if (!role) {
        validationWarning(`unknown value "${roleString}" - should be a CRediT role - see https://credit.niso.org/`, rolesOpts);
        return roleString.trim();
      }
      return role;
    });
  }
  if (defined(value.collaborations)) {
    validationError('collaborations must be defined in frontmatter as affiliations with "collaboration: true"', incrementOptions("collaborations", opts));
  }
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    if (!Array.isArray(affiliations)) {
      affiliations = [affiliations];
    }
    output.affiliations = validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  if (defined(value.twitter)) {
    output.twitter = validateString(value.twitter, incrementOptions("twitter", opts));
  }
  if (defined(value.github)) {
    output.github = validateString(value.github, incrementOptions("github", opts));
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  if (defined(value.note)) {
    output.note = validateString(value.note, incrementOptions("note", opts));
  }
  if (isStashPlaceholder(output) || !output.nameParsed)
    return output;
  if (value.nameParsed || value.name && typeof value.name !== "string")
    return output;
  const suffix = " - if this is intended, you may define 'name' explicitly as an object";
  if (!output.nameParsed.given) {
    validationWarning(`No given name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  if (!output.nameParsed.family) {
    validationWarning(`No family name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/project/types.js
var PAGE_KNOWN_PARTS = [
  "abstract",
  "summary",
  "keypoints",
  "dedication",
  "epigraph",
  "data_availability",
  "acknowledgments"
];
var PROJECT_AND_PAGE_FRONTMATTER_KEYS = [
  "date",
  "doi",
  "arxiv",
  "open_access",
  "license",
  "binder",
  "source",
  "subject",
  "biblio",
  "oxa",
  "numbering",
  "bibliography",
  "math",
  "abbreviations",
  "exports",
  "downloads",
  "settings",
  // We maybe want to move this into site frontmatter in the future
  "parts",
  ...PAGE_KNOWN_PARTS,
  // Do not add any project specific keys here!
  ...SITE_FRONTMATTER_KEYS
];
var PROJECT_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the project
  "id",
  "references",
  "requirements",
  "resources",
  "thebe",
  "toc"
];

// ../../node_modules/myst-frontmatter/dist/page/types.js
var PAGE_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the page
  "label",
  "kernelspec",
  "jupytext",
  "tags",
  "content_includes_title"
];

// ../../node_modules/myst-frontmatter/dist/exports/types.js
var ExportFormats;
(function(ExportFormats2) {
  ExportFormats2["pdf"] = "pdf";
  ExportFormats2["tex"] = "tex";
  ExportFormats2["pdftex"] = "pdf+tex";
  ExportFormats2["typst"] = "typst";
  ExportFormats2["docx"] = "docx";
  ExportFormats2["xml"] = "xml";
  ExportFormats2["md"] = "md";
  ExportFormats2["meca"] = "meca";
})(ExportFormats || (ExportFormats = {}));

// ../../node_modules/myst-toc/dist/toc.js
var COMMON_ENTRY_KEYS = ["title"];
function validateCommonEntry(entry, opts) {
  const output = {};
  if (defined(entry.title)) {
    output.title = validateString(entry.title, incrementOptions("title", opts));
  }
  return output;
}
function validateFileEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["file"],
    optional: [...COMMON_ENTRY_KEYS, "children"]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const file = validateString(intermediate.file, incrementOptions("file", opts));
  if (!file) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  let output = { file, ...commonEntry };
  if (defined(entry.children)) {
    const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
    output = { children, ...output };
  }
  return output;
}
function validateURLEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["url"],
    optional: [...COMMON_ENTRY_KEYS, "children"]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const url = validateString(intermediate.url, incrementOptions("url", opts));
  if (!url) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  let output = { url, ...commonEntry };
  if (defined(entry.children)) {
    const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
    output = { children, ...output };
  }
  return output;
}
function validatePatternEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["pattern"],
    optional: [...COMMON_ENTRY_KEYS, "children"]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const pattern = validateString(intermediate.pattern, incrementOptions("pattern", opts));
  if (!pattern) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  return { pattern, ...commonEntry };
}
function validateParentEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["title", "children"],
    optional: [...COMMON_ENTRY_KEYS]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const title = validateString(intermediate.title, incrementOptions("title", opts));
  if (!title) {
    return void 0;
  }
  const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
  if (!children) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  return {
    children,
    title,
    ...commonEntry
  };
}
function validateEntry(entry, opts) {
  const intermediate = validateObject(entry, opts);
  if (!intermediate) {
    return void 0;
  }
  if (defined(intermediate.file)) {
    return validateFileEntry(intermediate, opts);
  } else if (defined(intermediate.url)) {
    return validateURLEntry(intermediate, opts);
  } else if (defined(intermediate.pattern)) {
    return validatePatternEntry(intermediate, opts);
  } else if (defined(intermediate.title)) {
    return validateParentEntry(intermediate, opts);
  } else {
    return validationError("expected an entry with 'file', 'url', 'pattern', or 'title'", opts);
  }
}
function validateTOC(toc, opts) {
  return validateList(toc, opts, (item, ind) => validateEntry(item, incrementOptions(`${ind}`, opts)));
}

// ../../node_modules/myst-frontmatter/dist/exports/validators.js
var EXPORT_KEY_OBJECT = {
  required: [],
  optional: [
    "format",
    "template",
    "output",
    "zip",
    "id",
    "name",
    "renderer",
    "articles",
    "top_level",
    "sub_articles"
  ],
  alias: {
    article: "articles",
    sub_article: "sub_articles"
  }
};
var EXPORT_ARTICLE_KEY_OBJECT = {
  optional: [
    "file",
    "title",
    "level",
    ...PAGE_FRONTMATTER_KEYS,
    ...Object.keys(FRONTMATTER_ALIASES)
  ]
};
var EXT_TO_FORMAT = {
  ".pdf": ExportFormats.pdf,
  ".tex": ExportFormats.tex,
  ".doc": ExportFormats.docx,
  ".docx": ExportFormats.docx,
  ".md": ExportFormats.md,
  ".zip": ExportFormats.meca,
  ".meca": ExportFormats.meca,
  ".xml": ExportFormats.xml,
  ".jats": ExportFormats.xml,
  ".typ": ExportFormats.typst,
  ".typst": ExportFormats.typst
};
var RESERVED_EXPORT_KEYS = [
  ...EXPORT_KEY_OBJECT.required,
  ...EXPORT_KEY_OBJECT.optional,
  ...Object.keys(EXPORT_KEY_OBJECT.alias),
  ...PROJECT_FRONTMATTER_KEYS,
  ...Object.keys(FRONTMATTER_ALIASES)
];
var MULTI_ARTICLE_EXPORT_FORMATS = [
  ExportFormats.typst,
  ExportFormats.pdf,
  ExportFormats.tex,
  ExportFormats.pdftex
];
function validateExportsList(input, opts) {
  if (input === void 0)
    return void 0;
  const exportsOptions = { coerce: true, ...incrementOptions("exports", opts) };
  const output = validateList(input, exportsOptions, (exp, ind) => {
    return validateExport(exp, incrementOptions(`exports.${ind}`, opts));
  });
  if (!output || output.length === 0)
    return void 0;
  const duplicates = /* @__PURE__ */ new Set();
  output.forEach((exp, ind) => {
    if (exp.id && output.slice(ind + 1).map(({ id }) => id).includes(exp.id)) {
      duplicates.add(exp.id);
    }
  });
  if (duplicates.size) {
    validationError(`duplicate export ids: ${[...duplicates].join(", ")}`, exportsOptions);
  }
  return output;
}
function validateExportFormat(input, opts) {
  if (input === void 0)
    return void 0;
  if (input === "tex+pdf")
    input = "pdf+tex";
  if (input === "jats")
    input = "xml";
  const format2 = validateEnum(input, { ...opts, enum: ExportFormats });
  return format2;
}
function validateExportArticle(input, opts) {
  if (typeof input === "string") {
    input = { file: input };
  }
  const value = validateObjectKeys(input, EXPORT_ARTICLE_KEY_OBJECT, opts);
  if (!value)
    return void 0;
  const output = { ...value };
  if (defined(value.file)) {
    output.file = validateString(value.file, opts);
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.level)) {
    output.level = validateNumber(value.level, {
      min: -1,
      max: 6,
      integer: true,
      ...incrementOptions("level", opts)
    });
  }
  if (!output.title && !output.file) {
    return validationError("export articles must specify file or part/chapter title", opts);
  }
  return output;
}
function articlesWithFile(articles) {
  var _a;
  return (_a = articles === null || articles === void 0 ? void 0 : articles.filter((article) => {
    return !!article.file;
  })) !== null && _a !== void 0 ? _a : [];
}
function singleArticleWithFile(articles) {
  return articlesWithFile(articles)[0];
}
function validateExport(input, opts) {
  if (typeof input === "string") {
    let format3;
    let output2;
    if (input.startsWith(".")) {
      Object.entries(EXT_TO_FORMAT).forEach(([ext, fmt]) => {
        if (input === ext)
          format3 = fmt;
      });
    } else if (input.includes(".")) {
      output2 = input;
    }
    if (!format3 && !output2) {
      format3 = validateExportFormat(input, opts);
      if (!format3)
        return void 0;
    }
    input = { format: format3, output: output2 };
  }
  const value = validateObjectKeys(input, EXPORT_KEY_OBJECT, {
    ...opts,
    suppressWarnings: true,
    keepExtraKeys: true
  });
  if (value === void 0)
    return void 0;
  let format2;
  let output;
  let template2;
  if (value.template === null) {
    template2 = null;
  } else if (defined(value.template)) {
    template2 = validateString(value.template, incrementOptions("template", opts));
  }
  if (defined(value.output)) {
    const outputOpts = incrementOptions("output", opts);
    const outputString = validateString(value.output, outputOpts);
    if (outputString) {
      Object.keys(EXT_TO_FORMAT).forEach((ext) => {
        if (outputString.endsWith(ext))
          output = outputString;
      });
      if (!outputString.slice(1).includes(".")) {
        output = outputString;
      }
      if (!output) {
        return validationError(`unknown export output extension: ${outputString}`, outputOpts);
      }
    }
  }
  if (defined(value.format)) {
    format2 = validateExportFormat(value.format, incrementOptions("format", opts));
    if (!format2)
      return void 0;
  }
  if (!format2 && !template2 && !output) {
    return validationError("export must specify one of: format, template, or output", opts);
  }
  const validExport = { ...value, format: format2, output, template: template2 };
  if (defined(value.id)) {
    validExport.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.zip)) {
    validExport.zip = validateBoolean(value.zip, incrementOptions("zip", opts));
  }
  if (defined(value.articles)) {
    const articles = validateList(value.articles, { coerce: true, ...incrementOptions("articles", opts) }, (item, ind) => validateExportArticle(item, incrementOptions(`articles.${ind}`, opts)));
    const singleArticle = singleArticleWithFile(articles);
    if (articles === null || articles === void 0 ? void 0 : articles.length) {
      if (!singleArticle) {
        validationError("no files found in export article list", opts);
        validExport.articles = void 0;
      } else if (articles.length > 1 && validExport.format && !MULTI_ARTICLE_EXPORT_FORMATS.includes(validExport.format)) {
        if (validExport.format === ExportFormats.xml && !defined(value.sub_articles)) {
          validationError("multiple articles are not supported for 'jats' export - instead specify one article with additional sub_articles", opts);
        } else {
          validationError("multiple articles are only supported for 'tex', 'typst', and 'pdf' exports", opts);
        }
        validExport.articles = [singleArticle];
      } else {
        validExport.articles = articles;
      }
    } else {
      validExport.articles = void 0;
    }
  }
  if (defined(value.top_level)) {
    validExport.top_level = validateChoice(value.top_level || "sections", {
      ...incrementOptions("top_level", opts),
      choices: ["parts", "chapters", "sections"]
    });
  }
  if (defined(value.sub_articles)) {
    if (validExport.format !== ExportFormats.xml) {
      validationError("sub_articles are only supported for 'jats' export", opts);
      validExport.sub_articles = void 0;
    } else {
      validExport.sub_articles = validateList(value.sub_articles, { coerce: true, ...incrementOptions("sub_articles", opts) }, (file, ind) => {
        return validateString(file, incrementOptions(`sub_articles.${ind}`, opts));
      });
    }
  }
  if (defined(value.toc)) {
    const tocOpts = incrementOptions("toc", opts);
    if (validExport.articles || validExport.sub_articles) {
      validationError("export cannot define both toc and articles/sub_articles; ignoring toc", tocOpts);
      validExport.toc = void 0;
    } else if (typeof value.toc === "string") {
      validExport.tocFile = value.toc;
      validExport.toc = void 0;
    } else {
      validExport.toc = validateTOC(value.toc, tocOpts);
    }
  }
  return validExport;
}

// ../../node_modules/myst-frontmatter/dist/downloads/validators.js
var DOWNLOAD_KEY_OBJECT = {
  required: [],
  optional: ["title", "url", "id", "filename", "format", "static"],
  alias: {
    ref: "id",
    file: "url"
  }
};
function validateDownload(input, opts) {
  if (typeof input === "string") {
    input = { url: input };
  }
  const value = validateObjectKeys(input, DOWNLOAD_KEY_OBJECT, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.url)) {
    output.url = validateString(value.url, incrementOptions("url", opts));
  }
  if (output.url && output.id) {
    return validationError(`download must define only one of id and file/url, not both`, opts);
  }
  if (!output.url && !output.id) {
    return validationError(`download must define either id or file/url`, opts);
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.filename)) {
    output.filename = validateString(value.filename, incrementOptions("filename", opts));
  }
  if (defined(value.format)) {
    output.format = validateExportFormat(value.format, incrementOptions("format", opts));
  }
  if (defined(value.static)) {
    output.static = validateBoolean(value.static, incrementOptions("static", opts));
  }
  return output;
}
function validateDownloadsList(input, opts) {
  if (input === void 0)
    return void 0;
  const downloadOptions = { coerce: true, ...incrementOptions("downloads", opts) };
  const output = validateList(input, downloadOptions, (exp, ind) => {
    return validateDownload(exp, incrementOptions(`downloads.${ind}`, opts));
  });
  if (!output)
    return void 0;
  const duplicateIds = /* @__PURE__ */ new Set();
  const duplicateUrls = /* @__PURE__ */ new Set();
  output.forEach((download, ind) => {
    if (download.id && output.slice(ind + 1).map(({ id }) => id).includes(download.id)) {
      duplicateIds.add(download.id);
    }
    if (download.url && output.slice(ind + 1).map(({ url }) => url).includes(download.url)) {
      duplicateUrls.add(download.url);
    }
  });
  if (duplicateIds.size) {
    validationError(`duplicate download ids: ${[...duplicateIds].join(", ")}`, downloadOptions);
  }
  if (duplicateUrls.size) {
    validationError(`duplicate download urls: ${[...duplicateUrls].join(", ")}`, downloadOptions);
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/funding/validators.js
var AWARD_KEYS = ["id", "name", "description", "sources", "recipients", "investigators"];
var AWARD_ALIASES = { source: "sources", recipient: "recipients", investigator: "investigators" };
var FUNDING_KEYS = ["statement", "open_access", "awards"];
var FUNDING_ALIASES = { award: "awards" };
function validateAward(input, stash, opts) {
  const value = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, { ...incrementOptions("id", opts), coerceNumber: true });
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.sources)) {
    output.sources = validateList(value.sources, { coerce: true, ...incrementOptions("sources", opts) }, (source, index2) => {
      return validateAndStashObject(source, stash, "affiliations", validateAffiliation, incrementOptions(`sources.${index2}`, opts));
    });
  }
  if (defined(value.recipients)) {
    output.recipients = validateList(value.recipients, { coerce: true, ...incrementOptions("recipients", opts) }, (recipient, index2) => {
      return validateAndStashObject(recipient, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`recipients.${index2}`, opts));
    });
  }
  if (defined(value.investigators)) {
    output.investigators = validateList(value.investigators, { coerce: true, ...incrementOptions("investigators", opts) }, (investigator, index2) => {
      return validateAndStashObject(investigator, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`investigators.${index2}`, opts));
    });
  }
  return output;
}
function validateFunding(input, stash, opts) {
  if (typeof input === "string") {
    input = { statement: input };
  }
  const valueAsObj = validateObject(input, opts);
  if (valueAsObj === void 0)
    return void 0;
  const value = validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
  if (value === void 0)
    return void 0;
  if (!value.awards) {
    validateKeys(valueAsObj, {
      optional: [...FUNDING_KEYS, ...AWARD_KEYS],
      alias: { ...FUNDING_ALIASES, ...AWARD_ALIASES }
    }, opts);
    const valueAsAward = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
    if (valueAsAward && Object.keys(valueAsAward).length > 0) {
      value.awards = [
        validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true })
      ];
    }
  } else {
    validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, opts);
  }
  const output = {};
  if (defined(value.statement)) {
    output.statement = validateString(value.statement, incrementOptions("statement", opts));
  }
  if (defined(value.open_access)) {
    output.open_access = validateString(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.awards)) {
    output.awards = validateList(value.awards, { coerce: true, ...incrementOptions("awards", opts) }, (award, index2) => {
      return validateAward(award, stash, incrementOptions(`awards.${index2}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/jupytext/validators.js
var TEXT_REPRESENTATION_KEYS = ["extension", "format_name", "format_version", "jupytext_version"];
var JUPYTEXT_KEYS = ["formats", "text_representation"];
function validateTextRepresentation(input, opts) {
  const value = validateObjectKeys(input, { optional: TEXT_REPRESENTATION_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.extension)) {
    output.extension = validateString(value.extension, incrementOptions("extension", opts));
  }
  if (defined(value.format_name)) {
    output.format_name = validateString(value.format_name, incrementOptions("format_name", opts));
  }
  if (defined(value.format_version)) {
    const format_version = typeof value.format_version === "number" ? String(value.format_version) : value.format_version;
    output.format_version = validateString(format_version, incrementOptions("format_version", opts));
  }
  if (defined(value.jupytext_version)) {
    output.jupytext_version = validateString(value.jupytext_version, incrementOptions("jupytext_version", opts));
  }
  return output;
}
function validateJupytext(input, opts) {
  const value = validateObjectKeys(input, { optional: JUPYTEXT_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.formats)) {
    output.formats = validateString(value.formats, incrementOptions("formats", opts));
  }
  if (defined(value.text_representation)) {
    output.text_representation = validateTextRepresentation(value.text_representation, incrementOptions("text_representation", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/kernelspec/validators.js
var KERNELSPEC_KEYS = ["name", "language", "display_name", "argv", "env"];
function validateKernelSpec(input, opts) {
  const value = validateObjectKeys(input, { optional: KERNELSPEC_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.language)) {
    output.language = validateString(value.language, incrementOptions("language", opts));
  }
  if (defined(value.display_name)) {
    output.display_name = validateString(value.display_name, incrementOptions("display_name", opts));
  }
  if (defined(value.env)) {
    output.env = validateObject(value.env, incrementOptions("env", opts));
  }
  if (defined(value.argv)) {
    output.argv = validateList(value.argv, incrementOptions("argv", opts), (arg, index2) => {
      return validateString(arg, incrementOptions(`argv.${index2}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/licenses/licenses.js
var licenses = {
  "0BSD": {
    name: "BSD Zero Clause License",
    osi: true
  },
  "3D-Slicer-1.0": {
    name: "3D Slicer License v1.0"
  },
  AAL: {
    name: "Attribution Assurance License",
    osi: true
  },
  Abstyles: {
    name: "Abstyles License"
  },
  "AdaCore-doc": {
    name: "AdaCore Doc License"
  },
  "Adobe-2006": {
    name: "Adobe Systems Incorporated Source Code License Agreement"
  },
  "Adobe-Display-PostScript": {
    name: "Adobe Display PostScript License"
  },
  "Adobe-Glyph": {
    name: "Adobe Glyph List License"
  },
  "Adobe-Utopia": {
    name: "Adobe Utopia Font License"
  },
  ADSL: {
    name: "Amazon Digital Services License"
  },
  "AFL-1.1": {
    name: "Academic Free License v1.1",
    osi: true,
    free: true
  },
  "AFL-1.2": {
    name: "Academic Free License v1.2",
    osi: true,
    free: true
  },
  "AFL-2.0": {
    name: "Academic Free License v2.0",
    osi: true,
    free: true
  },
  "AFL-2.1": {
    name: "Academic Free License v2.1",
    osi: true,
    free: true
  },
  "AFL-3.0": {
    name: "Academic Free License v3.0",
    osi: true,
    free: true
  },
  Afmparse: {
    name: "Afmparse License"
  },
  "AGPL-1.0-only": {
    name: "Affero General Public License v1.0 only"
  },
  "AGPL-1.0-or-later": {
    name: "Affero General Public License v1.0 or later"
  },
  "AGPL-3.0-only": {
    name: "GNU Affero General Public License v3.0 only",
    osi: true,
    free: true
  },
  "AGPL-3.0-or-later": {
    name: "GNU Affero General Public License v3.0 or later",
    osi: true,
    free: true
  },
  Aladdin: {
    name: "Aladdin Free Public License"
  },
  "AMD-newlib": {
    name: "AMD newlib License"
  },
  AMDPLPA: {
    name: "AMD's plpa_map.c License"
  },
  AML: {
    name: "Apple MIT License"
  },
  "AML-glslang": {
    name: "AML glslang variant License"
  },
  AMPAS: {
    name: "Academy of Motion Picture Arts and Sciences BSD"
  },
  "ANTLR-PD": {
    name: "ANTLR Software Rights Notice"
  },
  "ANTLR-PD-fallback": {
    name: "ANTLR Software Rights Notice with license fallback"
  },
  "any-OSI": {
    name: "Any OSI License"
  },
  "Apache-1.0": {
    name: "Apache License 1.0",
    free: true
  },
  "Apache-1.1": {
    name: "Apache License 1.1",
    osi: true,
    free: true
  },
  "Apache-2.0": {
    name: "Apache License 2.0",
    osi: true,
    free: true
  },
  APAFML: {
    name: "Adobe Postscript AFM License"
  },
  "APL-1.0": {
    name: "Adaptive Public License 1.0",
    osi: true
  },
  "App-s2p": {
    name: "App::s2p License"
  },
  "APSL-1.0": {
    name: "Apple Public Source License 1.0",
    osi: true
  },
  "APSL-1.1": {
    name: "Apple Public Source License 1.1",
    osi: true
  },
  "APSL-1.2": {
    name: "Apple Public Source License 1.2",
    osi: true
  },
  "APSL-2.0": {
    name: "Apple Public Source License 2.0",
    osi: true,
    free: true
  },
  "Arphic-1999": {
    name: "Arphic Public License"
  },
  "Artistic-1.0": {
    name: "Artistic License 1.0",
    osi: true
  },
  "Artistic-1.0-cl8": {
    name: "Artistic License 1.0 w/clause 8",
    osi: true
  },
  "Artistic-1.0-Perl": {
    name: "Artistic License 1.0 (Perl)",
    osi: true
  },
  "Artistic-2.0": {
    name: "Artistic License 2.0",
    osi: true,
    free: true
  },
  "ASWF-Digital-Assets-1.0": {
    name: "ASWF Digital Assets License version 1.0"
  },
  "ASWF-Digital-Assets-1.1": {
    name: "ASWF Digital Assets License 1.1"
  },
  Baekmuk: {
    name: "Baekmuk License"
  },
  Bahyph: {
    name: "Bahyph License"
  },
  Barr: {
    name: "Barr License"
  },
  "bcrypt-Solar-Designer": {
    name: "bcrypt Solar Designer License"
  },
  Beerware: {
    name: "Beerware License"
  },
  "Bitstream-Charter": {
    name: "Bitstream Charter Font License"
  },
  "Bitstream-Vera": {
    name: "Bitstream Vera Font License"
  },
  "BitTorrent-1.0": {
    name: "BitTorrent Open Source License v1.0"
  },
  "BitTorrent-1.1": {
    name: "BitTorrent Open Source License v1.1",
    free: true
  },
  blessing: {
    name: "SQLite Blessing"
  },
  "BlueOak-1.0.0": {
    name: "Blue Oak Model License 1.0.0",
    osi: true
  },
  "Boehm-GC": {
    name: "Boehm-Demers-Weiser GC License"
  },
  Borceux: {
    name: "Borceux license"
  },
  "Brian-Gladman-2-Clause": {
    name: "Brian Gladman 2-Clause License"
  },
  "Brian-Gladman-3-Clause": {
    name: "Brian Gladman 3-Clause License"
  },
  "BSD-1-Clause": {
    name: "BSD 1-Clause License",
    osi: true
  },
  "BSD-2-Clause": {
    name: 'BSD 2-Clause "Simplified" License',
    osi: true,
    free: true
  },
  "BSD-2-Clause-Darwin": {
    name: "BSD 2-Clause - Ian Darwin variant"
  },
  "BSD-2-Clause-first-lines": {
    name: "BSD 2-Clause - first lines requirement"
  },
  "BSD-2-Clause-Patent": {
    name: "BSD-2-Clause Plus Patent License",
    osi: true
  },
  "BSD-2-Clause-Views": {
    name: "BSD 2-Clause with views sentence"
  },
  "BSD-3-Clause": {
    name: 'BSD 3-Clause "New" or "Revised" License',
    osi: true,
    free: true
  },
  "BSD-3-Clause-acpica": {
    name: "BSD 3-Clause acpica variant"
  },
  "BSD-3-Clause-Attribution": {
    name: "BSD with attribution"
  },
  "BSD-3-Clause-Clear": {
    name: "BSD 3-Clause Clear License",
    free: true
  },
  "BSD-3-Clause-flex": {
    name: "BSD 3-Clause Flex variant"
  },
  "BSD-3-Clause-HP": {
    name: "Hewlett-Packard BSD variant license"
  },
  "BSD-3-Clause-LBNL": {
    name: "Lawrence Berkeley National Labs BSD variant license",
    osi: true
  },
  "BSD-3-Clause-Modification": {
    name: "BSD 3-Clause Modification"
  },
  "BSD-3-Clause-No-Military-License": {
    name: "BSD 3-Clause No Military License"
  },
  "BSD-3-Clause-No-Nuclear-License": {
    name: "BSD 3-Clause No Nuclear License"
  },
  "BSD-3-Clause-No-Nuclear-License-2014": {
    name: "BSD 3-Clause No Nuclear License 2014"
  },
  "BSD-3-Clause-No-Nuclear-Warranty": {
    name: "BSD 3-Clause No Nuclear Warranty"
  },
  "BSD-3-Clause-Open-MPI": {
    name: "BSD 3-Clause Open MPI variant"
  },
  "BSD-3-Clause-Sun": {
    name: "BSD 3-Clause Sun Microsystems"
  },
  "BSD-4-Clause": {
    name: 'BSD 4-Clause "Original" or "Old" License',
    free: true
  },
  "BSD-4-Clause-Shortened": {
    name: "BSD 4 Clause Shortened"
  },
  "BSD-4-Clause-UC": {
    name: "BSD-4-Clause (University of California-Specific)"
  },
  "BSD-4.3RENO": {
    name: "BSD 4.3 RENO License"
  },
  "BSD-4.3TAHOE": {
    name: "BSD 4.3 TAHOE License"
  },
  "BSD-Advertising-Acknowledgement": {
    name: "BSD Advertising Acknowledgement License"
  },
  "BSD-Attribution-HPND-disclaimer": {
    name: "BSD with Attribution and HPND disclaimer"
  },
  "BSD-Inferno-Nettverk": {
    name: "BSD-Inferno-Nettverk"
  },
  "BSD-Protection": {
    name: "BSD Protection License"
  },
  "BSD-Source-beginning-file": {
    name: "BSD Source Code Attribution - beginning of file variant"
  },
  "BSD-Source-Code": {
    name: "BSD Source Code Attribution"
  },
  "BSD-Systemics": {
    name: "Systemics BSD variant license"
  },
  "BSD-Systemics-W3Works": {
    name: "Systemics W3Works BSD variant license"
  },
  "BSL-1.0": {
    name: "Boost Software License 1.0",
    osi: true,
    free: true
  },
  "BUSL-1.1": {
    name: "Business Source License 1.1"
  },
  "bzip2-1.0.6": {
    name: "bzip2 and libbzip2 License v1.0.6"
  },
  "C-UDA-1.0": {
    name: "Computational Use of Data Agreement v1.0"
  },
  "CAL-1.0": {
    name: "Cryptographic Autonomy License 1.0",
    osi: true
  },
  "CAL-1.0-Combined-Work-Exception": {
    name: "Cryptographic Autonomy License 1.0 (Combined Work Exception)",
    osi: true
  },
  Caldera: {
    name: "Caldera License"
  },
  "Caldera-no-preamble": {
    name: "Caldera License (without preamble)"
  },
  Catharon: {
    name: "Catharon License"
  },
  "CATOSL-1.1": {
    name: "Computer Associates Trusted Open Source License 1.1",
    osi: true
  },
  "CC-BY-1.0": {
    name: "Creative Commons Attribution 1.0 Generic",
    CC: true
  },
  "CC-BY-2.0": {
    name: "Creative Commons Attribution 2.0 Generic",
    CC: true
  },
  "CC-BY-2.5": {
    name: "Creative Commons Attribution 2.5 Generic",
    CC: true
  },
  "CC-BY-2.5-AU": {
    name: "Creative Commons Attribution 2.5 Australia",
    CC: true
  },
  "CC-BY-3.0": {
    name: "Creative Commons Attribution 3.0 Unported",
    CC: true
  },
  "CC-BY-3.0-AT": {
    name: "Creative Commons Attribution 3.0 Austria",
    CC: true
  },
  "CC-BY-3.0-AU": {
    name: "Creative Commons Attribution 3.0 Australia",
    CC: true
  },
  "CC-BY-3.0-DE": {
    name: "Creative Commons Attribution 3.0 Germany",
    CC: true
  },
  "CC-BY-3.0-IGO": {
    name: "Creative Commons Attribution 3.0 IGO",
    CC: true
  },
  "CC-BY-3.0-NL": {
    name: "Creative Commons Attribution 3.0 Netherlands",
    CC: true
  },
  "CC-BY-3.0-US": {
    name: "Creative Commons Attribution 3.0 United States",
    CC: true
  },
  "CC-BY-4.0": {
    name: "Creative Commons Attribution 4.0 International",
    free: true,
    CC: true
  },
  "CC-BY-NC-1.0": {
    name: "Creative Commons Attribution Non Commercial 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.0": {
    name: "Creative Commons Attribution Non Commercial 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.5": {
    name: "Creative Commons Attribution Non Commercial 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-3.0": {
    name: "Creative Commons Attribution Non Commercial 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-4.0": {
    name: "Creative Commons Attribution Non Commercial 4.0 International",
    CC: true
  },
  "CC-BY-NC-ND-1.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.5": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-ND-3.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-ND-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-ND-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-ND-4.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-NC-SA-1.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-2.0-FR": {
    name: "Creative Commons Attribution-NonCommercial-ShareAlike 2.0 France",
    CC: true
  },
  "CC-BY-NC-SA-2.0-UK": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-NC-SA-2.5": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-SA-3.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-SA-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-SA-4.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 4.0 International",
    CC: true
  },
  "CC-BY-ND-1.0": {
    name: "Creative Commons Attribution No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.0": {
    name: "Creative Commons Attribution No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.5": {
    name: "Creative Commons Attribution No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-ND-3.0": {
    name: "Creative Commons Attribution No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-ND-3.0-DE": {
    name: "Creative Commons Attribution No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-ND-4.0": {
    name: "Creative Commons Attribution No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-SA-1.0": {
    name: "Creative Commons Attribution Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0": {
    name: "Creative Commons Attribution Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0-UK": {
    name: "Creative Commons Attribution Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-SA-2.1-JP": {
    name: "Creative Commons Attribution Share Alike 2.1 Japan",
    CC: true
  },
  "CC-BY-SA-2.5": {
    name: "Creative Commons Attribution Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-SA-3.0": {
    name: "Creative Commons Attribution Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-SA-3.0-AT": {
    name: "Creative Commons Attribution Share Alike 3.0 Austria",
    CC: true
  },
  "CC-BY-SA-3.0-DE": {
    name: "Creative Commons Attribution Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-SA-3.0-IGO": {
    name: "Creative Commons Attribution-ShareAlike 3.0 IGO",
    CC: true
  },
  "CC-BY-SA-4.0": {
    name: "Creative Commons Attribution Share Alike 4.0 International",
    free: true,
    CC: true
  },
  "CC-PDDC": {
    name: "Creative Commons Public Domain Dedication and Certification",
    CC: true
  },
  "CC0-1.0": {
    name: "Creative Commons Zero v1.0 Universal",
    free: true,
    CC: true
  },
  "CDDL-1.0": {
    name: "Common Development and Distribution License 1.0",
    osi: true,
    free: true
  },
  "CDDL-1.1": {
    name: "Common Development and Distribution License 1.1"
  },
  "CDL-1.0": {
    name: "Common Documentation License 1.0"
  },
  "CDLA-Permissive-1.0": {
    name: "Community Data License Agreement Permissive 1.0"
  },
  "CDLA-Permissive-2.0": {
    name: "Community Data License Agreement Permissive 2.0"
  },
  "CDLA-Sharing-1.0": {
    name: "Community Data License Agreement Sharing 1.0"
  },
  "CECILL-1.0": {
    name: "CeCILL Free Software License Agreement v1.0"
  },
  "CECILL-1.1": {
    name: "CeCILL Free Software License Agreement v1.1"
  },
  "CECILL-2.0": {
    name: "CeCILL Free Software License Agreement v2.0",
    free: true
  },
  "CECILL-2.1": {
    name: "CeCILL Free Software License Agreement v2.1",
    osi: true
  },
  "CECILL-B": {
    name: "CeCILL-B Free Software License Agreement",
    free: true
  },
  "CECILL-C": {
    name: "CeCILL-C Free Software License Agreement",
    free: true
  },
  "CERN-OHL-1.1": {
    name: "CERN Open Hardware Licence v1.1"
  },
  "CERN-OHL-1.2": {
    name: "CERN Open Hardware Licence v1.2"
  },
  "CERN-OHL-P-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Permissive",
    osi: true
  },
  "CERN-OHL-S-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Strongly Reciprocal",
    osi: true
  },
  "CERN-OHL-W-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Weakly Reciprocal",
    osi: true
  },
  CFITSIO: {
    name: "CFITSIO License"
  },
  "check-cvs": {
    name: "check-cvs License"
  },
  checkmk: {
    name: "Checkmk License"
  },
  ClArtistic: {
    name: "Clarified Artistic License",
    free: true
  },
  Clips: {
    name: "Clips License"
  },
  "CMU-Mach": {
    name: "CMU Mach License"
  },
  "CMU-Mach-nodoc": {
    name: "CMU    Mach - no notices-in-documentation variant"
  },
  "CNRI-Jython": {
    name: "CNRI Jython License"
  },
  "CNRI-Python": {
    name: "CNRI Python License",
    osi: true
  },
  "CNRI-Python-GPL-Compatible": {
    name: "CNRI Python Open Source GPL Compatible License Agreement"
  },
  "COIL-1.0": {
    name: "Copyfree Open Innovation License"
  },
  "Community-Spec-1.0": {
    name: "Community Specification License 1.0"
  },
  "Condor-1.1": {
    name: "Condor Public License v1.1",
    free: true
  },
  "copyleft-next-0.3.0": {
    name: "copyleft-next 0.3.0"
  },
  "copyleft-next-0.3.1": {
    name: "copyleft-next 0.3.1"
  },
  "Cornell-Lossless-JPEG": {
    name: "Cornell Lossless JPEG License"
  },
  "CPAL-1.0": {
    name: "Common Public Attribution License 1.0",
    osi: true,
    free: true
  },
  "CPL-1.0": {
    name: "Common Public License 1.0",
    osi: true,
    free: true
  },
  "CPOL-1.02": {
    name: "Code Project Open License 1.02"
  },
  Cronyx: {
    name: "Cronyx License"
  },
  Crossword: {
    name: "Crossword License"
  },
  CrystalStacker: {
    name: "CrystalStacker License"
  },
  "CUA-OPL-1.0": {
    name: "CUA Office Public License v1.0",
    osi: true
  },
  Cube: {
    name: "Cube License"
  },
  curl: {
    name: "curl License"
  },
  "cve-tou": {
    name: "Common Vulnerability Enumeration ToU License"
  },
  "D-FSL-1.0": {
    name: "Deutsche Freie Software Lizenz"
  },
  "DEC-3-Clause": {
    name: "DEC 3-Clause License"
  },
  diffmark: {
    name: "diffmark license"
  },
  "DL-DE-BY-2.0": {
    name: "Data licence Germany \u2013 attribution \u2013 version 2.0"
  },
  "DL-DE-ZERO-2.0": {
    name: "Data licence Germany \u2013 zero \u2013 version 2.0"
  },
  DOC: {
    name: "DOC License"
  },
  Dotseqn: {
    name: "Dotseqn License"
  },
  "DRL-1.0": {
    name: "Detection Rule License 1.0"
  },
  "DRL-1.1": {
    name: "Detection Rule License 1.1"
  },
  DSDP: {
    name: "DSDP License"
  },
  dtoa: {
    name: "David M. Gay dtoa License"
  },
  dvipdfm: {
    name: "dvipdfm License"
  },
  "ECL-1.0": {
    name: "Educational Community License v1.0",
    osi: true
  },
  "ECL-2.0": {
    name: "Educational Community License v2.0",
    osi: true,
    free: true
  },
  "EFL-1.0": {
    name: "Eiffel Forum License v1.0",
    osi: true
  },
  "EFL-2.0": {
    name: "Eiffel Forum License v2.0",
    osi: true,
    free: true
  },
  eGenix: {
    name: "eGenix.com Public License 1.1.0"
  },
  "Elastic-2.0": {
    name: "Elastic License 2.0"
  },
  Entessa: {
    name: "Entessa Public License v1.0",
    osi: true
  },
  EPICS: {
    name: "EPICS Open License"
  },
  "EPL-1.0": {
    name: "Eclipse Public License 1.0",
    osi: true,
    free: true
  },
  "EPL-2.0": {
    name: "Eclipse Public License 2.0",
    osi: true,
    free: true
  },
  "ErlPL-1.1": {
    name: "Erlang Public License v1.1"
  },
  "etalab-2.0": {
    name: "Etalab Open License 2.0"
  },
  EUDatagrid: {
    name: "EU DataGrid Software License",
    osi: true,
    free: true
  },
  "EUPL-1.0": {
    name: "European Union Public License 1.0"
  },
  "EUPL-1.1": {
    name: "European Union Public License 1.1",
    osi: true,
    free: true
  },
  "EUPL-1.2": {
    name: "European Union Public License 1.2",
    osi: true,
    free: true
  },
  Eurosym: {
    name: "Eurosym License"
  },
  Fair: {
    name: "Fair License",
    osi: true
  },
  FBM: {
    name: "Fuzzy Bitmap License"
  },
  "FDK-AAC": {
    name: "Fraunhofer FDK AAC Codec Library"
  },
  "Ferguson-Twofish": {
    name: "Ferguson Twofish License"
  },
  "Frameworx-1.0": {
    name: "Frameworx Open License 1.0",
    osi: true
  },
  "FreeBSD-DOC": {
    name: "FreeBSD Documentation License"
  },
  FreeImage: {
    name: "FreeImage Public License v1.0"
  },
  FSFAP: {
    name: "FSF All Permissive License",
    free: true
  },
  "FSFAP-no-warranty-disclaimer": {
    name: "FSF All Permissive License (without Warranty)"
  },
  FSFUL: {
    name: "FSF Unlimited License"
  },
  FSFULLR: {
    name: "FSF Unlimited License (with License Retention)"
  },
  FSFULLRWD: {
    name: "FSF Unlimited License (With License Retention and Warranty Disclaimer)"
  },
  FTL: {
    name: "Freetype Project License",
    free: true
  },
  Furuseth: {
    name: "Furuseth License"
  },
  fwlw: {
    name: "fwlw License"
  },
  "GCR-docs": {
    name: "Gnome GCR Documentation License"
  },
  GD: {
    name: "GD License"
  },
  "GFDL-1.1-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - invariants"
  },
  "GFDL-1.1-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - invariants"
  },
  "GFDL-1.1-no-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - no invariants"
  },
  "GFDL-1.1-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - no invariants"
  },
  "GFDL-1.1-only": {
    name: "GNU Free Documentation License v1.1 only",
    free: true
  },
  "GFDL-1.1-or-later": {
    name: "GNU Free Documentation License v1.1 or later",
    free: true
  },
  "GFDL-1.2-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - invariants"
  },
  "GFDL-1.2-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - invariants"
  },
  "GFDL-1.2-no-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - no invariants"
  },
  "GFDL-1.2-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - no invariants"
  },
  "GFDL-1.2-only": {
    name: "GNU Free Documentation License v1.2 only",
    free: true
  },
  "GFDL-1.2-or-later": {
    name: "GNU Free Documentation License v1.2 or later",
    free: true
  },
  "GFDL-1.3-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - invariants"
  },
  "GFDL-1.3-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - invariants"
  },
  "GFDL-1.3-no-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - no invariants"
  },
  "GFDL-1.3-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - no invariants"
  },
  "GFDL-1.3-only": {
    name: "GNU Free Documentation License v1.3 only",
    free: true
  },
  "GFDL-1.3-or-later": {
    name: "GNU Free Documentation License v1.3 or later",
    free: true
  },
  Giftware: {
    name: "Giftware License"
  },
  GL2PS: {
    name: "GL2PS License"
  },
  Glide: {
    name: "3dfx Glide License"
  },
  Glulxe: {
    name: "Glulxe License"
  },
  GLWTPL: {
    name: "Good Luck With That Public License"
  },
  gnuplot: {
    name: "gnuplot License",
    free: true
  },
  "GPL-1.0-only": {
    name: "GNU General Public License v1.0 only"
  },
  "GPL-1.0-or-later": {
    name: "GNU General Public License v1.0 or later"
  },
  "GPL-2.0-only": {
    name: "GNU General Public License v2.0 only",
    osi: true,
    free: true
  },
  "GPL-2.0-or-later": {
    name: "GNU General Public License v2.0 or later",
    osi: true,
    free: true
  },
  "GPL-3.0-only": {
    name: "GNU General Public License v3.0 only",
    osi: true,
    free: true
  },
  "GPL-3.0-or-later": {
    name: "GNU General Public License v3.0 or later",
    osi: true,
    free: true
  },
  "Graphics-Gems": {
    name: "Graphics Gems License"
  },
  "gSOAP-1.3b": {
    name: "gSOAP Public License v1.3b"
  },
  gtkbook: {
    name: "gtkbook License"
  },
  Gutmann: {
    name: "Gutmann License"
  },
  HaskellReport: {
    name: "Haskell Language Report License"
  },
  hdparm: {
    name: "hdparm License"
  },
  "Hippocratic-2.1": {
    name: "Hippocratic License 2.1"
  },
  "HP-1986": {
    name: "Hewlett-Packard 1986 License"
  },
  "HP-1989": {
    name: "Hewlett-Packard 1989 License"
  },
  HPND: {
    name: "Historical Permission Notice and Disclaimer",
    osi: true,
    free: true
  },
  "HPND-DEC": {
    name: "Historical Permission Notice and Disclaimer - DEC variant"
  },
  "HPND-doc": {
    name: "Historical Permission Notice and Disclaimer - documentation variant"
  },
  "HPND-doc-sell": {
    name: "Historical Permission Notice and Disclaimer - documentation sell variant"
  },
  "HPND-export-US": {
    name: "HPND with US Government export control warning"
  },
  "HPND-export-US-acknowledgement": {
    name: "HPND with US Government export control warning and acknowledgment"
  },
  "HPND-export-US-modify": {
    name: "HPND with US Government export control warning and modification rqmt"
  },
  "HPND-export2-US": {
    name: "HPND with US Government export control and 2 disclaimers"
  },
  "HPND-Fenneberg-Livingston": {
    name: "Historical Permission Notice and Disclaimer - Fenneberg-Livingston variant"
  },
  "HPND-INRIA-IMAG": {
    name: "Historical Permission Notice and Disclaimer    - INRIA-IMAG variant"
  },
  "HPND-Intel": {
    name: "Historical Permission Notice and Disclaimer - Intel variant"
  },
  "HPND-Kevlin-Henney": {
    name: "Historical Permission Notice and Disclaimer - Kevlin Henney variant"
  },
  "HPND-Markus-Kuhn": {
    name: "Historical Permission Notice and Disclaimer - Markus Kuhn variant"
  },
  "HPND-merchantability-variant": {
    name: "Historical Permission Notice and Disclaimer - merchantability variant"
  },
  "HPND-MIT-disclaimer": {
    name: "Historical Permission Notice and Disclaimer with MIT disclaimer"
  },
  "HPND-Pbmplus": {
    name: "Historical Permission Notice and Disclaimer - Pbmplus variant"
  },
  "HPND-sell-MIT-disclaimer-xserver": {
    name: "Historical Permission Notice and Disclaimer - sell xserver variant with MIT disclaimer"
  },
  "HPND-sell-regexpr": {
    name: "Historical Permission Notice and Disclaimer - sell regexpr variant"
  },
  "HPND-sell-variant": {
    name: "Historical Permission Notice and Disclaimer - sell variant"
  },
  "HPND-sell-variant-MIT-disclaimer": {
    name: "HPND sell variant with MIT disclaimer"
  },
  "HPND-sell-variant-MIT-disclaimer-rev": {
    name: "HPND sell variant with MIT disclaimer - reverse"
  },
  "HPND-UC": {
    name: "Historical Permission Notice and Disclaimer - University of California variant"
  },
  "HPND-UC-export-US": {
    name: "Historical Permission Notice and Disclaimer - University of California, US export warning"
  },
  HTMLTIDY: {
    name: "HTML Tidy License"
  },
  "IBM-pibs": {
    name: "IBM PowerPC Initialization and Boot Software"
  },
  ICU: {
    name: "ICU License",
    osi: true
  },
  "IEC-Code-Components-EULA": {
    name: "IEC    Code Components End-user licence agreement"
  },
  IJG: {
    name: "Independent JPEG Group License",
    free: true
  },
  "IJG-short": {
    name: "Independent JPEG Group License - short"
  },
  ImageMagick: {
    name: "ImageMagick License"
  },
  iMatix: {
    name: "iMatix Standard Function Library Agreement",
    free: true
  },
  Imlib2: {
    name: "Imlib2 License",
    free: true
  },
  "Info-ZIP": {
    name: "Info-ZIP License"
  },
  "Inner-Net-2.0": {
    name: "Inner Net License v2.0"
  },
  Intel: {
    name: "Intel Open Source License",
    osi: true,
    free: true
  },
  "Intel-ACPI": {
    name: "Intel ACPI Software License Agreement"
  },
  "Interbase-1.0": {
    name: "Interbase Public License v1.0"
  },
  IPA: {
    name: "IPA Font License",
    osi: true,
    free: true
  },
  "IPL-1.0": {
    name: "IBM Public License v1.0",
    osi: true,
    free: true
  },
  ISC: {
    name: "ISC License",
    osi: true,
    free: true
  },
  "ISC-Veillard": {
    name: "ISC Veillard variant"
  },
  Jam: {
    name: "Jam License",
    osi: true
  },
  "JasPer-2.0": {
    name: "JasPer License"
  },
  "JPL-image": {
    name: "JPL Image Use Policy"
  },
  JPNIC: {
    name: "Japan Network Information Center License"
  },
  JSON: {
    name: "JSON License"
  },
  Kastrup: {
    name: "Kastrup License"
  },
  Kazlib: {
    name: "Kazlib License"
  },
  "Knuth-CTAN": {
    name: "Knuth CTAN License"
  },
  "LAL-1.2": {
    name: "Licence Art Libre 1.2"
  },
  "LAL-1.3": {
    name: "Licence Art Libre 1.3"
  },
  Latex2e: {
    name: "Latex2e License"
  },
  "Latex2e-translated-notice": {
    name: "Latex2e with translated notice permission"
  },
  Leptonica: {
    name: "Leptonica License"
  },
  "LGPL-2.0-only": {
    name: "GNU Library General Public License v2 only",
    osi: true
  },
  "LGPL-2.0-or-later": {
    name: "GNU Library General Public License v2 or later",
    osi: true
  },
  "LGPL-2.1-only": {
    name: "GNU Lesser General Public License v2.1 only",
    osi: true,
    free: true
  },
  "LGPL-2.1-or-later": {
    name: "GNU Lesser General Public License v2.1 or later",
    osi: true,
    free: true
  },
  "LGPL-3.0-only": {
    name: "GNU Lesser General Public License v3.0 only",
    osi: true,
    free: true
  },
  "LGPL-3.0-or-later": {
    name: "GNU Lesser General Public License v3.0 or later",
    osi: true,
    free: true
  },
  LGPLLR: {
    name: "Lesser General Public License For Linguistic Resources"
  },
  Libpng: {
    name: "libpng License"
  },
  "libpng-2.0": {
    name: "PNG Reference Library version 2"
  },
  "libselinux-1.0": {
    name: "libselinux public domain notice"
  },
  libtiff: {
    name: "libtiff License"
  },
  "libutil-David-Nugent": {
    name: "libutil David Nugent License"
  },
  "LiLiQ-P-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 Permissive version 1.1",
    osi: true
  },
  "LiLiQ-R-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 version 1.1",
    osi: true
  },
  "LiLiQ-Rplus-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 forte version 1.1",
    osi: true
  },
  "Linux-man-pages-1-para": {
    name: "Linux man-pages - 1 paragraph"
  },
  "Linux-man-pages-copyleft": {
    name: "Linux man-pages Copyleft"
  },
  "Linux-man-pages-copyleft-2-para": {
    name: "Linux man-pages Copyleft - 2 paragraphs"
  },
  "Linux-man-pages-copyleft-var": {
    name: "Linux man-pages Copyleft Variant"
  },
  "Linux-OpenIB": {
    name: "Linux Kernel Variant of OpenIB.org license"
  },
  LOOP: {
    name: "Common Lisp LOOP License"
  },
  "LPD-document": {
    name: "LPD Documentation License"
  },
  "LPL-1.0": {
    name: "Lucent Public License Version 1.0",
    osi: true
  },
  "LPL-1.02": {
    name: "Lucent Public License v1.02",
    osi: true,
    free: true
  },
  "LPPL-1.0": {
    name: "LaTeX Project Public License v1.0"
  },
  "LPPL-1.1": {
    name: "LaTeX Project Public License v1.1"
  },
  "LPPL-1.2": {
    name: "LaTeX Project Public License v1.2",
    free: true
  },
  "LPPL-1.3a": {
    name: "LaTeX Project Public License v1.3a",
    free: true
  },
  "LPPL-1.3c": {
    name: "LaTeX Project Public License v1.3c",
    osi: true
  },
  lsof: {
    name: "lsof License"
  },
  "Lucida-Bitmap-Fonts": {
    name: "Lucida Bitmap Fonts License"
  },
  "LZMA-SDK-9.11-to-9.20": {
    name: "LZMA SDK License (versions 9.11 to 9.20)"
  },
  "LZMA-SDK-9.22": {
    name: "LZMA SDK License (versions 9.22 and beyond)"
  },
  "Mackerras-3-Clause": {
    name: "Mackerras 3-Clause License"
  },
  "Mackerras-3-Clause-acknowledgment": {
    name: "Mackerras 3-Clause - acknowledgment variant"
  },
  magaz: {
    name: "magaz License"
  },
  mailprio: {
    name: "mailprio License"
  },
  MakeIndex: {
    name: "MakeIndex License"
  },
  "Martin-Birgmeier": {
    name: "Martin Birgmeier License"
  },
  "McPhee-slideshow": {
    name: "McPhee Slideshow License"
  },
  metamail: {
    name: "metamail License"
  },
  Minpack: {
    name: "Minpack License"
  },
  MirOS: {
    name: "The MirOS Licence",
    osi: true
  },
  MIT: {
    name: "MIT License",
    osi: true,
    free: true
  },
  "MIT-0": {
    name: "MIT No Attribution",
    osi: true
  },
  "MIT-advertising": {
    name: "Enlightenment License (e16)"
  },
  "MIT-CMU": {
    name: "CMU License"
  },
  "MIT-enna": {
    name: "enna License"
  },
  "MIT-feh": {
    name: "feh License"
  },
  "MIT-Festival": {
    name: "MIT Festival Variant"
  },
  "MIT-Khronos-old": {
    name: "MIT Khronos - old variant"
  },
  "MIT-Modern-Variant": {
    name: "MIT License Modern Variant",
    osi: true
  },
  "MIT-open-group": {
    name: "MIT Open Group variant"
  },
  "MIT-testregex": {
    name: "MIT testregex Variant"
  },
  "MIT-Wu": {
    name: "MIT Tom Wu Variant"
  },
  MITNFA: {
    name: "MIT +no-false-attribs license"
  },
  MMIXware: {
    name: "MMIXware License"
  },
  Motosoto: {
    name: "Motosoto License",
    osi: true
  },
  "MPEG-SSG": {
    name: "MPEG Software Simulation"
  },
  "mpi-permissive": {
    name: "mpi Permissive License"
  },
  mpich2: {
    name: "mpich2 License"
  },
  "MPL-1.0": {
    name: "Mozilla Public License 1.0",
    osi: true
  },
  "MPL-1.1": {
    name: "Mozilla Public License 1.1",
    osi: true,
    free: true
  },
  "MPL-2.0": {
    name: "Mozilla Public License 2.0",
    osi: true,
    free: true
  },
  "MPL-2.0-no-copyleft-exception": {
    name: "Mozilla Public License 2.0 (no copyleft exception)",
    osi: true
  },
  mplus: {
    name: "mplus Font License"
  },
  "MS-LPL": {
    name: "Microsoft Limited Public License"
  },
  "MS-PL": {
    name: "Microsoft Public License",
    osi: true,
    free: true
  },
  "MS-RL": {
    name: "Microsoft Reciprocal License",
    osi: true,
    free: true
  },
  MTLL: {
    name: "Matrix Template Library License"
  },
  "MulanPSL-1.0": {
    name: "Mulan Permissive Software License, Version 1"
  },
  "MulanPSL-2.0": {
    name: "Mulan Permissive Software License, Version 2",
    osi: true
  },
  Multics: {
    name: "Multics License",
    osi: true
  },
  Mup: {
    name: "Mup License"
  },
  "NAIST-2003": {
    name: "Nara Institute of Science and Technology License (2003)"
  },
  "NASA-1.3": {
    name: "NASA Open Source Agreement 1.3",
    osi: true
  },
  Naumen: {
    name: "Naumen Public License",
    osi: true
  },
  "NBPL-1.0": {
    name: "Net Boolean Public License v1"
  },
  "NCBI-PD": {
    name: "NCBI Public Domain Notice"
  },
  "NCGL-UK-2.0": {
    name: "Non-Commercial Government Licence"
  },
  NCL: {
    name: "NCL Source Code License"
  },
  NCSA: {
    name: "University of Illinois/NCSA Open Source License",
    osi: true,
    free: true
  },
  "Net-SNMP": {
    name: "Net-SNMP License"
  },
  NetCDF: {
    name: "NetCDF license"
  },
  Newsletr: {
    name: "Newsletr License"
  },
  NGPL: {
    name: "Nethack General Public License",
    osi: true
  },
  "NICTA-1.0": {
    name: "NICTA Public Software License, Version 1.0"
  },
  "NIST-PD": {
    name: "NIST Public Domain Notice"
  },
  "NIST-PD-fallback": {
    name: "NIST Public Domain Notice with license fallback"
  },
  "NIST-Software": {
    name: "NIST Software License"
  },
  "NLOD-1.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 1.0"
  },
  "NLOD-2.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 2.0"
  },
  NLPL: {
    name: "No Limit Public License"
  },
  Nokia: {
    name: "Nokia Open Source License",
    osi: true,
    free: true
  },
  NOSL: {
    name: "Netizen Open Source License",
    free: true
  },
  Noweb: {
    name: "Noweb License"
  },
  "NPL-1.0": {
    name: "Netscape Public License v1.0",
    free: true
  },
  "NPL-1.1": {
    name: "Netscape Public License v1.1",
    free: true
  },
  "NPOSL-3.0": {
    name: "Non-Profit Open Software License 3.0",
    osi: true
  },
  NRL: {
    name: "NRL License"
  },
  NTP: {
    name: "NTP License",
    osi: true
  },
  "NTP-0": {
    name: "NTP No Attribution"
  },
  "O-UDA-1.0": {
    name: "Open Use of Data Agreement v1.0"
  },
  OAR: {
    name: "OAR License"
  },
  "OCCT-PL": {
    name: "Open CASCADE Technology Public License"
  },
  "OCLC-2.0": {
    name: "OCLC Research Public License 2.0",
    osi: true
  },
  "ODbL-1.0": {
    name: "Open Data Commons Open Database License v1.0",
    free: true
  },
  "ODC-By-1.0": {
    name: "Open Data Commons Attribution License v1.0"
  },
  OFFIS: {
    name: "OFFIS License"
  },
  "OFL-1.0": {
    name: "SIL Open Font License 1.0",
    free: true
  },
  "OFL-1.0-no-RFN": {
    name: "SIL Open Font License 1.0 with no Reserved Font Name"
  },
  "OFL-1.0-RFN": {
    name: "SIL Open Font License 1.0 with Reserved Font Name"
  },
  "OFL-1.1": {
    name: "SIL Open Font License 1.1",
    osi: true,
    free: true
  },
  "OFL-1.1-no-RFN": {
    name: "SIL Open Font License 1.1 with no Reserved Font Name",
    osi: true
  },
  "OFL-1.1-RFN": {
    name: "SIL Open Font License 1.1 with Reserved Font Name",
    osi: true
  },
  "OGC-1.0": {
    name: "OGC Software License, Version 1.0"
  },
  "OGDL-Taiwan-1.0": {
    name: "Taiwan Open Government Data License, version 1.0"
  },
  "OGL-Canada-2.0": {
    name: "Open Government Licence - Canada"
  },
  "OGL-UK-1.0": {
    name: "Open Government Licence v1.0"
  },
  "OGL-UK-2.0": {
    name: "Open Government Licence v2.0"
  },
  "OGL-UK-3.0": {
    name: "Open Government Licence v3.0"
  },
  OGTSL: {
    name: "Open Group Test Suite License",
    osi: true
  },
  "OLDAP-1.1": {
    name: "Open LDAP Public License v1.1"
  },
  "OLDAP-1.2": {
    name: "Open LDAP Public License v1.2"
  },
  "OLDAP-1.3": {
    name: "Open LDAP Public License v1.3"
  },
  "OLDAP-1.4": {
    name: "Open LDAP Public License v1.4"
  },
  "OLDAP-2.0": {
    name: "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)"
  },
  "OLDAP-2.0.1": {
    name: "Open LDAP Public License v2.0.1"
  },
  "OLDAP-2.1": {
    name: "Open LDAP Public License v2.1"
  },
  "OLDAP-2.2": {
    name: "Open LDAP Public License v2.2"
  },
  "OLDAP-2.2.1": {
    name: "Open LDAP Public License v2.2.1"
  },
  "OLDAP-2.2.2": {
    name: "Open LDAP Public License 2.2.2"
  },
  "OLDAP-2.3": {
    name: "Open LDAP Public License v2.3",
    free: true
  },
  "OLDAP-2.4": {
    name: "Open LDAP Public License v2.4"
  },
  "OLDAP-2.5": {
    name: "Open LDAP Public License v2.5"
  },
  "OLDAP-2.6": {
    name: "Open LDAP Public License v2.6"
  },
  "OLDAP-2.7": {
    name: "Open LDAP Public License v2.7",
    free: true
  },
  "OLDAP-2.8": {
    name: "Open LDAP Public License v2.8",
    osi: true
  },
  "OLFL-1.3": {
    name: "Open Logistics Foundation License Version 1.3",
    osi: true
  },
  OML: {
    name: "Open Market License"
  },
  "OpenPBS-2.3": {
    name: "OpenPBS v2.3 Software License"
  },
  OpenSSL: {
    name: "OpenSSL License",
    free: true
  },
  "OpenSSL-standalone": {
    name: "OpenSSL License - standalone"
  },
  OpenVision: {
    name: "OpenVision License"
  },
  "OPL-1.0": {
    name: "Open Public License v1.0"
  },
  "OPL-UK-3.0": {
    name: "United    Kingdom Open Parliament Licence v3.0"
  },
  "OPUBL-1.0": {
    name: "Open Publication License v1.0"
  },
  "OSET-PL-2.1": {
    name: "OSET Public License version 2.1",
    osi: true
  },
  "OSL-1.0": {
    name: "Open Software License 1.0",
    osi: true,
    free: true
  },
  "OSL-1.1": {
    name: "Open Software License 1.1",
    free: true
  },
  "OSL-2.0": {
    name: "Open Software License 2.0",
    osi: true,
    free: true
  },
  "OSL-2.1": {
    name: "Open Software License 2.1",
    osi: true,
    free: true
  },
  "OSL-3.0": {
    name: "Open Software License 3.0",
    osi: true,
    free: true
  },
  PADL: {
    name: "PADL License"
  },
  "Parity-6.0.0": {
    name: "The Parity Public License 6.0.0"
  },
  "Parity-7.0.0": {
    name: "The Parity Public License 7.0.0"
  },
  "PDDL-1.0": {
    name: "Open Data Commons Public Domain Dedication & License 1.0"
  },
  "PHP-3.0": {
    name: "PHP License v3.0",
    osi: true
  },
  "PHP-3.01": {
    name: "PHP License v3.01",
    osi: true,
    free: true
  },
  Pixar: {
    name: "Pixar License"
  },
  pkgconf: {
    name: "pkgconf License"
  },
  Plexus: {
    name: "Plexus Classworlds License"
  },
  pnmstitch: {
    name: "pnmstitch License"
  },
  "PolyForm-Noncommercial-1.0.0": {
    name: "PolyForm Noncommercial License 1.0.0"
  },
  "PolyForm-Small-Business-1.0.0": {
    name: "PolyForm Small Business License 1.0.0"
  },
  PostgreSQL: {
    name: "PostgreSQL License",
    osi: true
  },
  PPL: {
    name: "Peer Production License"
  },
  "PSF-2.0": {
    name: "Python Software Foundation License 2.0"
  },
  psfrag: {
    name: "psfrag License"
  },
  psutils: {
    name: "psutils License"
  },
  "Python-2.0": {
    name: "Python License 2.0",
    osi: true,
    free: true
  },
  "Python-2.0.1": {
    name: "Python License 2.0.1"
  },
  "python-ldap": {
    name: "Python ldap License"
  },
  Qhull: {
    name: "Qhull License"
  },
  "QPL-1.0": {
    name: "Q Public License 1.0",
    osi: true,
    free: true
  },
  "QPL-1.0-INRIA-2004": {
    name: "Q Public License 1.0 - INRIA 2004 variant"
  },
  radvd: {
    name: "radvd License"
  },
  Rdisc: {
    name: "Rdisc License"
  },
  "RHeCos-1.1": {
    name: "Red Hat eCos Public License v1.1"
  },
  "RPL-1.1": {
    name: "Reciprocal Public License 1.1",
    osi: true
  },
  "RPL-1.5": {
    name: "Reciprocal Public License 1.5",
    osi: true
  },
  "RPSL-1.0": {
    name: "RealNetworks Public Source License v1.0",
    osi: true,
    free: true
  },
  "RSA-MD": {
    name: "RSA Message-Digest License"
  },
  RSCPL: {
    name: "Ricoh Source Code Public License",
    osi: true
  },
  Ruby: {
    name: "Ruby License",
    free: true
  },
  "SAX-PD": {
    name: "Sax Public Domain Notice"
  },
  "SAX-PD-2.0": {
    name: "Sax Public Domain Notice 2.0"
  },
  Saxpath: {
    name: "Saxpath License"
  },
  SCEA: {
    name: "SCEA Shared Source License"
  },
  SchemeReport: {
    name: "Scheme Language Report License"
  },
  Sendmail: {
    name: "Sendmail License"
  },
  "Sendmail-8.23": {
    name: "Sendmail License 8.23"
  },
  "SGI-B-1.0": {
    name: "SGI Free Software License B v1.0"
  },
  "SGI-B-1.1": {
    name: "SGI Free Software License B v1.1"
  },
  "SGI-B-2.0": {
    name: "SGI Free Software License B v2.0",
    free: true
  },
  "SGI-OpenGL": {
    name: "SGI OpenGL License"
  },
  SGP4: {
    name: "SGP4 Permission Notice"
  },
  "SHL-0.5": {
    name: "Solderpad Hardware License v0.5"
  },
  "SHL-0.51": {
    name: "Solderpad Hardware License, Version 0.51"
  },
  "SimPL-2.0": {
    name: "Simple Public License 2.0",
    osi: true
  },
  SISSL: {
    name: "Sun Industry Standards Source License v1.1",
    osi: true,
    free: true
  },
  "SISSL-1.2": {
    name: "Sun Industry Standards Source License v1.2"
  },
  SL: {
    name: "SL License"
  },
  Sleepycat: {
    name: "Sleepycat License",
    osi: true,
    free: true
  },
  SMLNJ: {
    name: "Standard ML of New Jersey License",
    free: true
  },
  SMPPL: {
    name: "Secure Messaging Protocol Public License"
  },
  SNIA: {
    name: "SNIA Public License 1.1"
  },
  snprintf: {
    name: "snprintf License"
  },
  softSurfer: {
    name: "softSurfer License"
  },
  Soundex: {
    name: "Soundex License"
  },
  "Spencer-86": {
    name: "Spencer License 86"
  },
  "Spencer-94": {
    name: "Spencer License 94"
  },
  "Spencer-99": {
    name: "Spencer License 99"
  },
  "SPL-1.0": {
    name: "Sun Public License v1.0",
    osi: true,
    free: true
  },
  "ssh-keyscan": {
    name: "ssh-keyscan License"
  },
  "SSH-OpenSSH": {
    name: "SSH OpenSSH license"
  },
  "SSH-short": {
    name: "SSH short notice"
  },
  "SSLeay-standalone": {
    name: "SSLeay License - standalone"
  },
  "SSPL-1.0": {
    name: "Server Side Public License, v 1"
  },
  "SugarCRM-1.1.3": {
    name: "SugarCRM Public License v1.1.3"
  },
  "Sun-PPP": {
    name: "Sun PPP License"
  },
  "Sun-PPP-2000": {
    name: "Sun PPP License (2000)"
  },
  SunPro: {
    name: "SunPro License"
  },
  SWL: {
    name: "Scheme Widget Library (SWL) Software License Agreement"
  },
  swrule: {
    name: "swrule License"
  },
  Symlinks: {
    name: "Symlinks License"
  },
  "TAPR-OHL-1.0": {
    name: "TAPR Open Hardware License v1.0"
  },
  TCL: {
    name: "TCL/TK License"
  },
  "TCP-wrappers": {
    name: "TCP Wrappers License"
  },
  TermReadKey: {
    name: "TermReadKey License"
  },
  "TGPPL-1.0": {
    name: "Transitive Grace Period Public Licence 1.0"
  },
  threeparttable: {
    name: "threeparttable License"
  },
  TMate: {
    name: "TMate Open Source License"
  },
  "TORQUE-1.1": {
    name: "TORQUE v2.5+ Software License v1.1"
  },
  TOSL: {
    name: "Trusster Open Source License"
  },
  TPDL: {
    name: "Time::ParseDate License"
  },
  "TPL-1.0": {
    name: "THOR Public License 1.0"
  },
  TTWL: {
    name: "Text-Tabs+Wrap License"
  },
  TTYP0: {
    name: "TTYP0 License"
  },
  "TU-Berlin-1.0": {
    name: "Technische Universitaet Berlin License 1.0"
  },
  "TU-Berlin-2.0": {
    name: "Technische Universitaet Berlin License 2.0"
  },
  UCAR: {
    name: "UCAR License"
  },
  "UCL-1.0": {
    name: "Upstream Compatibility License v1.0",
    osi: true
  },
  ulem: {
    name: "ulem License"
  },
  "UMich-Merit": {
    name: "Michigan/Merit Networks License"
  },
  "Unicode-3.0": {
    name: "Unicode License v3",
    osi: true
  },
  "Unicode-DFS-2015": {
    name: "Unicode License Agreement - Data Files and Software (2015)"
  },
  "Unicode-DFS-2016": {
    name: "Unicode License Agreement - Data Files and Software (2016)",
    osi: true
  },
  "Unicode-TOU": {
    name: "Unicode Terms of Use"
  },
  UnixCrypt: {
    name: "UnixCrypt License"
  },
  Unlicense: {
    name: "The Unlicense",
    osi: true,
    free: true
  },
  "UPL-1.0": {
    name: "Universal Permissive License v1.0",
    osi: true,
    free: true
  },
  "URT-RLE": {
    name: "Utah Raster Toolkit Run Length Encoded License"
  },
  Vim: {
    name: "Vim License",
    free: true
  },
  VOSTROM: {
    name: "VOSTROM Public License for Open Source"
  },
  "VSL-1.0": {
    name: "Vovida Software License v1.0",
    osi: true
  },
  W3C: {
    name: "W3C Software Notice and License (2002-12-31)",
    osi: true,
    free: true
  },
  "W3C-19980720": {
    name: "W3C Software Notice and License (1998-07-20)"
  },
  "W3C-20150513": {
    name: "W3C Software Notice and Document License (2015-05-13)"
  },
  w3m: {
    name: "w3m License"
  },
  "Watcom-1.0": {
    name: "Sybase Open Watcom Public License 1.0",
    osi: true
  },
  "Widget-Workshop": {
    name: "Widget Workshop License"
  },
  Wsuipa: {
    name: "Wsuipa License"
  },
  WTFPL: {
    name: "Do What The F*ck You Want To Public License",
    free: true
  },
  X11: {
    name: "X11 License",
    free: true
  },
  "X11-distribute-modifications-variant": {
    name: "X11 License Distribution Modification Variant"
  },
  "Xdebug-1.03": {
    name: "Xdebug License v 1.03"
  },
  Xerox: {
    name: "Xerox License"
  },
  Xfig: {
    name: "Xfig License"
  },
  "XFree86-1.1": {
    name: "XFree86 License 1.1",
    free: true
  },
  xinetd: {
    name: "xinetd License",
    free: true
  },
  "xkeyboard-config-Zinoviev": {
    name: "xkeyboard-config Zinoviev License"
  },
  xlock: {
    name: "xlock License"
  },
  Xnet: {
    name: "X.Net License",
    osi: true
  },
  xpp: {
    name: "XPP License"
  },
  XSkat: {
    name: "XSkat License"
  },
  xzoom: {
    name: "xzoom License"
  },
  "YPL-1.0": {
    name: "Yahoo! Public License v1.0"
  },
  "YPL-1.1": {
    name: "Yahoo! Public License v1.1",
    free: true
  },
  Zed: {
    name: "Zed License"
  },
  Zeeff: {
    name: "Zeeff License"
  },
  "Zend-2.0": {
    name: "Zend License v2.0",
    free: true
  },
  "Zimbra-1.3": {
    name: "Zimbra Public License v1.3",
    free: true
  },
  "Zimbra-1.4": {
    name: "Zimbra Public License v1.4"
  },
  Zlib: {
    name: "zlib License",
    osi: true,
    free: true
  },
  "zlib-acknowledgement": {
    name: "zlib/libpng License with Acknowledgement"
  },
  "ZPL-1.1": {
    name: "Zope Public License 1.1"
  },
  "ZPL-2.0": {
    name: "Zope Public License 2.0",
    osi: true,
    free: true
  },
  "ZPL-2.1": {
    name: "Zope Public License 2.1",
    osi: true,
    free: true
  }
};
var licenses_default = licenses;

// ../../node_modules/myst-frontmatter/dist/licenses/validators.js
var import_spdx_correct = __toESM(require_spdx_correct(), 1);
function correctLicense(license) {
  if (!license)
    return void 0;
  const value = (0, import_spdx_correct.default)(license);
  if (value)
    return value;
  if (license.toUpperCase() === "CC-BY")
    return "CC-BY-4.0";
  return void 0;
}
function createURL(license) {
  var _a, _b;
  if (license.CC) {
    const match = /^([CBYSAND0-]+)(?:(?:-)([0-9].[0-9]))?(?:(?:-)([A-Z]{2}))?$/.exec(license.id);
    if (!match) {
      throw new Error("Creative Commons license not found");
    }
    const kind = match[1].toUpperCase();
    const version2 = (_a = match[2]) !== null && _a !== void 0 ? _a : "4.0";
    const extra = (_b = match[3]) !== null && _b !== void 0 ? _b : "";
    let link2 = "";
    switch (kind) {
      case "CC-BY":
        link2 = `/by/${version2}/`;
        break;
      case "CC-BY-SA":
        link2 = `/by-sa/${version2}/`;
        break;
      case "CC-BY-NC":
        link2 = `/by-nc/${version2}/`;
        break;
      case "CC-BY-NC-SA":
        link2 = `/by-nc-sa/${version2}/`;
        break;
      case "CC-BY-ND":
        link2 = `/by-nd/${version2}/`;
        break;
      case "CC-BY-NC-ND":
        link2 = `/by-nc-nd/${version2}/`;
        break;
      case "CC-ZERO":
      case "CC-0":
      case "CC0":
        link2 = "/zero/1.0/";
        break;
      case "CC-PDDC":
        link2 = "/publicdomain/";
        break;
      default:
        break;
    }
    if (extra)
      link2 += `${extra}/`;
    return `https://creativecommons.org/licenses${link2}`;
  }
  if (license.osi) {
    return `https://opensource.org/licenses/${license.id}`;
  }
  return `https://spdx.org/licenses/${license.id}`;
}
function validateLicense(input, opts) {
  if (typeof input === "object") {
    const revalidated = validateLicense(input.id, {
      ...opts,
      suppressErrors: true,
      suppressWarnings: true
    });
    let equal = Boolean(revalidated);
    if (revalidated) {
      Object.entries(revalidated).forEach(([key, val]) => {
        if (val !== input[key])
          equal = false;
      });
    }
    if (!equal) {
      return validationError(`invalid license object - use a valid license ID string instead, see https://spdx.org/licenses/`, opts);
    }
    return revalidated;
  }
  const valueUnvalidated = validateString(input, opts);
  if (valueUnvalidated === void 0)
    return void 0;
  const value = correctLicense(valueUnvalidated);
  if (!value) {
    return validationError(`invalid value "${valueUnvalidated}" - must be a valid license ID, see https://spdx.org/licenses/`, opts);
  }
  if (value !== valueUnvalidated) {
    validationWarning(`The SPDX ID for the license is "${value}". Corrected from "${valueUnvalidated}".`, opts);
  }
  const spdx = { id: value, ...licenses_default[value] };
  const url = createURL(spdx);
  return { ...spdx, url };
}
function validateLicenses(input, opts) {
  let contentOpts;
  if (typeof input === "string") {
    input = { content: input };
    contentOpts = opts;
  } else {
    contentOpts = incrementOptions("content", opts);
  }
  const value = validateObjectKeys(input, { optional: ["content", "code"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.content)) {
    output.content = validateLicense(value.content, contentOpts);
  }
  if (defined(value.code) && value.code !== value.content) {
    output.code = validateLicense(value.code, incrementOptions("code", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/venues/validators.js
function validateVenue(input, opts) {
  let titleOpts;
  if (typeof input === "string") {
    input = { title: input };
    titleOpts = opts;
  } else {
    titleOpts = incrementOptions("title", opts);
  }
  const value = validateObjectKeys(input, { optional: ["title", "url"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, titleOpts);
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/site/validators.js
function validateSiteFrontmatterKeys(value, opts) {
  var _a, _b, _c, _d, _e;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.short_title)) {
    output.short_title = validateString(value.short_title, incrementOptions("short_title", opts));
  }
  if (defined(value.subtitle)) {
    output.subtitle = validateString(value.subtitle, incrementOptions("subtitle", opts));
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  if (defined(value.tags)) {
    output.tags = validateList(value.tags, incrementOptions("tags", opts), (file, index2) => {
      return validateString(file, incrementOptions(`tags.${index2}`, opts));
    });
  }
  const stash = {};
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  if (defined(value.authors)) {
    stash.authorIds = validateList(value.authors, { coerce: true, ...incrementOptions("authors", opts) }, (author, index2) => {
      return validateAndStashObject(author, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`authors.${index2}`, opts));
    });
  }
  if (defined(value.contributors)) {
    validateList(value.contributors, { coerce: true, ...incrementOptions("contributors", opts) }, (contributor, index2) => {
      return validateAndStashObject(contributor, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`contributors.${index2}`, opts));
    });
  }
  if (defined(value.reviewers)) {
    output.reviewers = validateList(value.reviewers, { coerce: true, ...incrementOptions("reviewers", opts) }, (reviewer, ind) => {
      return validateAndStashObject(reviewer, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`reviewers.${ind}`, opts));
    });
  }
  if (defined(value.editors)) {
    output.editors = validateList(value.editors, { coerce: true, ...incrementOptions("editors", opts) }, (editor, ind) => {
      return validateAndStashObject(editor, stash, "contributors", (v2, o10) => validateContributor(v2, stash, o10), incrementOptions(`editors.${ind}`, opts));
    });
  }
  if (defined(value.venue)) {
    output.venue = validateVenue(value.venue, incrementOptions("venue", opts));
  }
  if (defined(value.github)) {
    output.github = validateGithubUrl(value.github, incrementOptions("github", opts));
  }
  if (defined(value.keywords)) {
    let keywords = value.keywords;
    if (typeof keywords === "string") {
      keywords = keywords.split(/[,;]/).map((k) => k.trim());
    }
    output.keywords = validateList(keywords, incrementOptions("keywords", opts), (word, ind) => {
      return validateString(word, incrementOptions(`keywords.${ind}`, opts));
    });
  }
  if (defined(value.funding)) {
    output.funding = validateList(value.funding, { coerce: true, ...incrementOptions("funding", opts) }, (fund, index2) => {
      return validateFunding(fund, stash, incrementOptions(`funding.${index2}`, opts));
    });
  }
  if (defined(value.copyright)) {
    output.copyright = validateString(value.copyright, incrementOptions("copyright", opts));
  }
  if (defined(value.options)) {
    const optionsOptions = incrementOptions("options", opts);
    const options = validateObject(value.options, optionsOptions);
    if (options) {
      Object.entries(options).forEach(([key, val]) => {
        var _a2;
        if (RESERVED_EXPORT_KEYS.includes(key)) {
          validationError(`options cannot include reserved key ${key}`, optionsOptions);
        } else {
          ((_a2 = output.options) !== null && _a2 !== void 0 ? _a2 : output.options = {})[key] = val;
        }
      });
    }
  }
  const stashContribAuthors = (_a = stash.contributors) === null || _a === void 0 ? void 0 : _a.filter((contrib) => {
    var _a2;
    return (_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id);
  });
  const stashContribNonAuthors = (_b = stash.contributors) === null || _b === void 0 ? void 0 : _b.filter((contrib) => {
    var _a2;
    return !((_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id));
  });
  if (stashContribAuthors === null || stashContribAuthors === void 0 ? void 0 : stashContribAuthors.length) {
    output.authors = stashContribAuthors;
    const correspondingAuthor = (_c = output.authors) === null || _c === void 0 ? void 0 : _c.find((a4) => a4.corresponding);
    const personWithEmail = (_d = output.authors) === null || _d === void 0 ? void 0 : _d.find((a4) => a4.email && !a4.collaboration && a4.corresponding === void 0);
    if (!correspondingAuthor && personWithEmail) {
      personWithEmail.corresponding = true;
    }
  }
  if (stashContribNonAuthors === null || stashContribNonAuthors === void 0 ? void 0 : stashContribNonAuthors.length) {
    output.contributors = stashContribNonAuthors;
  }
  if ((_e = stash.affiliations) === null || _e === void 0 ? void 0 : _e.length) {
    output.affiliations = stash.affiliations;
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validatorsMystToTex.js
var MYST_TO_TEX_SETTINGS = ["codeStyle", "beamer"];
var MYST_TO_TEX_SETTINGS_ALIAS = {
  code_style: "codeStyle"
};
function validateMystToTexSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: MYST_TO_TEX_SETTINGS, alias: MYST_TO_TEX_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.codeStyle)) {
    const codeStyle = validateChoice(settings.codeStyle, {
      ...incrementOptions("codeStyle", opts),
      choices: ["verbatim", "minted", "listings"]
    });
    if (codeStyle)
      output.codeStyle = codeStyle;
  }
  if (defined(settings.beamer)) {
    const beamer = validateBoolean(settings.beamer, incrementOptions("beamer", opts));
    if (beamer != null)
      output.beamer = beamer;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validators.js
var OUTPUT_REMOVAL_OPTIONS = [
  "show",
  "remove",
  "remove-warn",
  "remove-error",
  "warn",
  "error"
];
var PROJECT_SETTINGS = [
  "output_stderr",
  "output_stdout",
  "output_matplotlib_strings",
  "myst_to_tex"
];
var PROJECT_SETTINGS_ALIAS = {
  stderr_output: "output_stderr",
  stdout_output: "output_stdout",
  mystToTex: "myst_to_tex",
  tex: "myst_to_tex"
  // The default is the renderer, not the parser
};
function validateProjectAndPageSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: PROJECT_SETTINGS, alias: PROJECT_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.output_stderr)) {
    const output_stderr = validateChoice(settings.output_stderr, {
      ...incrementOptions("output_stderr", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stderr)
      output.output_stderr = output_stderr;
  }
  if (defined(settings.output_stdout)) {
    const output_stdout = validateChoice(settings.output_stdout, {
      ...incrementOptions("output_stdout", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stdout)
      output.output_stdout = output_stdout;
  }
  if (defined(settings.output_matplotlib_strings)) {
    const output_matplotlib_strings = validateChoice(settings.output_matplotlib_strings, {
      ...incrementOptions("output_matplotlib_strings", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_matplotlib_strings)
      output.output_matplotlib_strings = output_matplotlib_strings;
  }
  if (defined(settings.myst_to_tex)) {
    const myst_to_tex = validateMystToTexSettings(settings.myst_to_tex, incrementOptions("myst_to_tex", opts));
    if (myst_to_tex)
      output.myst_to_tex = myst_to_tex;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/math/validators.js
function validateMathMacro(input, opts) {
  if (typeof input === "string") {
    input = { macro: input };
  }
  const value = validateObjectKeys(input, { required: ["macro"], optional: ["title", "description"] }, opts);
  if (!value)
    return;
  const macro = validateString(value.macro, incrementOptions("macro", opts));
  if (!macro)
    return;
  const output = { macro };
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  return output;
}
function validateMathMacroObject(input, opts) {
  const value = validateObject(input, opts);
  if (!value)
    return;
  const validMacros = Object.entries(value).map(([key, val]) => {
    const macro = validateMathMacro(val, incrementOptions(key, opts));
    if (!macro)
      return false;
    return [key, macro];
  }).filter((valid2) => !!valid2);
  return Object.fromEntries(validMacros);
}

// ../../node_modules/myst-frontmatter/dist/project/validators.js
function validateProjectAndPageFrontmatterKeys(value, opts) {
  const output = validateSiteFrontmatterKeys(value, opts);
  if (defined(value.date)) {
    output.date = validateDate(value.date, incrementOptions("date", opts));
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.arxiv)) {
    output.arxiv = validateUrl(value.arxiv, {
      ...incrementOptions("arxiv", opts),
      includes: "arxiv.org"
    });
  }
  if (defined(value.open_access)) {
    output.open_access = validateBoolean(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.license)) {
    output.license = validateLicenses(value.license, incrementOptions("license", opts));
  }
  if (defined(value.binder)) {
    output.binder = validateUrl(value.binder, incrementOptions("binder", opts));
  }
  if (defined(value.source)) {
    output.source = validateUrl(value.source, incrementOptions("source", opts));
  }
  if (defined(value.subject)) {
    output.subject = validateString(value.subject, {
      ...incrementOptions("subject", opts),
      maxLength: 40
    });
  }
  if (defined(value.bibliography)) {
    output.bibliography = validateList(value.bibliography, { coerce: true, ...incrementOptions("bibliography", opts) }, (req, index2) => {
      return validateString(req, incrementOptions(`bibliography.${index2}`, opts));
    });
  }
  if (defined(value.biblio)) {
    output.biblio = validateBiblio(value.biblio, incrementOptions("biblio", opts));
  }
  if (defined(value.oxa)) {
    output.oxa = validateString(value.oxa, incrementOptions("oxa", opts));
  }
  if (defined(value.numbering)) {
    output.numbering = validateNumbering(value.numbering, incrementOptions("numbering", opts));
  }
  if (defined(value.math)) {
    output.math = validateMathMacroObject(value.math, incrementOptions("math", opts));
  }
  if (defined(value.abbreviations)) {
    const abbreviationsOpts = incrementOptions("abbreviations", opts);
    const abbreviations = validateObject(value.abbreviations, abbreviationsOpts);
    if (abbreviations) {
      const stringKeys = Object.keys(abbreviations).filter((key) => {
        return validateString(abbreviations[key], incrementOptions(key, abbreviationsOpts));
      });
      output.abbreviations = filterKeys(abbreviations, stringKeys);
    }
  }
  if (defined(value.exports)) {
    const exports = validateExportsList(value.exports, opts);
    if (exports)
      output.exports = exports;
  }
  if (defined(value.downloads)) {
    const downloads = validateDownloadsList(value.downloads, opts);
    if (downloads)
      output.downloads = downloads;
  }
  if (value.thumbnail === null) {
    output.thumbnail = null;
  } else if (defined(value.thumbnail)) {
    output.thumbnail = validateString(value.thumbnail, incrementOptions("thumbnail", opts));
  }
  if (defined(value.thumbnailOptimized)) {
    output.thumbnailOptimized = value.thumbnailOptimized;
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  if (defined(value.settings)) {
    const settings = validateProjectAndPageSettings(value.settings, incrementOptions("settings", opts));
    if (settings)
      output.settings = settings;
  }
  const partsOptions = incrementOptions("parts", opts);
  let parts;
  if (defined(value.parts)) {
    parts = validateObjectKeys(value.parts, { optional: PAGE_KNOWN_PARTS, alias: FRONTMATTER_ALIASES }, { keepExtraKeys: true, suppressWarnings: true, ...partsOptions });
  }
  PAGE_KNOWN_PARTS.forEach((partKey) => {
    if (defined(value[partKey])) {
      parts !== null && parts !== void 0 ? parts : parts = {};
      if (parts[partKey]) {
        validationError(`duplicate value for part ${partKey}`, partsOptions);
      } else {
        parts[partKey] = value[partKey];
      }
    }
  });
  if (parts) {
    const partsEntries = Object.entries(parts).map(([k, v2]) => {
      return [
        k,
        validateList(v2, { coerce: true, ...incrementOptions(k, partsOptions) }, (item, index2) => {
          return validateString(item, incrementOptions(`${k}.${index2}`, partsOptions));
        })
      ];
    }).filter((entry) => {
      var _a;
      return !!((_a = entry[1]) === null || _a === void 0 ? void 0 : _a.length);
    });
    if (partsEntries.length > 0) {
      output.parts = Object.fromEntries(partsEntries);
    }
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/page/validators.js
function validatePageFrontmatterKeys(value, opts) {
  const output = validateProjectAndPageFrontmatterKeys(value, opts);
  if (defined(value.label)) {
    output.label = validateString(value.label, incrementOptions("label", opts));
  }
  if (defined(value.kernelspec)) {
    output.kernelspec = validateKernelSpec(value.kernelspec, incrementOptions("kernelspec", opts));
  }
  if (defined(value.jupytext)) {
    output.jupytext = validateJupytext(value.jupytext, incrementOptions("jupytext", opts));
  }
  if (defined(value.content_includes_title)) {
    output.content_includes_title = validateBoolean(value.content_includes_title, incrementOptions("content_includes_title", opts));
  }
  return output;
}
function validatePageFrontmatter(input, opts) {
  const value = validateObjectKeys(input, { optional: PAGE_FRONTMATTER_KEYS, alias: { ...FRONTMATTER_ALIASES, name: "label" } }, opts) || {};
  return validatePageFrontmatterKeys(value, opts);
}

// ../../packages/myst-to-react/dist/crossReference.js
var fetcher5 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function XrefChildren({ load: load2, identifier }) {
  const data = useSelectNodes({ load: load2, identifier });
  if (!data)
    return null;
  if (data.loading) {
    return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: "Loading..." });
  }
  if (data.error) {
    return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: "Error loading remote page." });
  }
  if (!data.nodes || data.nodes.length === 0) {
    return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: (0, import_jsx_runtime33.jsx)(InlineError, { value: identifier || "No Label", message: "Cross Reference Not Found" }) });
  }
  return (0, import_jsx_runtime33.jsx)(MyST, { ast: data === null || data === void 0 ? void 0 : data.nodes });
}
function createRemoteBaseUrl(url, remoteBaseUrl) {
  if (remoteBaseUrl && (url === null || url === void 0 ? void 0 : url.startsWith(remoteBaseUrl))) {
    return url;
  }
  return `${remoteBaseUrl || ""}${url || ""}`;
}
function createExternalUrl({ url, remoteBaseUrl, dataUrl, baseurl }) {
  if (!!remoteBaseUrl || // The parent reference is external
  (dataUrl === null || dataUrl === void 0 ? void 0 : dataUrl.startsWith("http"))) {
    if (!dataUrl) {
      console.error("Expected external URL to provide a dataUrl");
      return null;
    }
    return createRemoteBaseUrl(dataUrl, remoteBaseUrl);
  }
  if (dataUrl) {
    return withBaseurl(dataUrl, baseurl);
  }
  return `${withBaseurl(url, baseurl)}.json`;
}
function useFetchMdast({ remote, url, remoteBaseUrl, dataUrl }) {
  const baseurl = useBaseurl();
  const lookupUrl = createExternalUrl({ url, remoteBaseUrl, dataUrl, baseurl });
  return useSWR(remote ? lookupUrl : null, fetcher5);
}
function useSelectNodes({ load: load2, identifier }) {
  var _a;
  const references = useReferences();
  const { remote, url, remoteBaseUrl, dataUrl } = useXRefState();
  if (!load2)
    return;
  const { data, error } = useFetchMdast({ remote, url, remoteBaseUrl, dataUrl });
  const mdast = (_a = data === null || data === void 0 ? void 0 : data.mdast) !== null && _a !== void 0 ? _a : references === null || references === void 0 ? void 0 : references.article;
  const { nodes, htmlId } = selectMdastNodes(mdast, identifier, 3);
  return { htmlId, nodes, loading: remote && !data, error: remote && error };
}
function CrossReferenceHover({ url: urlIn, dataUrl: dataUrlIn, remote: remoteIn, remoteBaseUrl: remoteBaseUrlIn, children, identifier, htmlId = "" }) {
  var _a;
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const parent = useXRefState();
  const remoteBaseUrl = remoteBaseUrlIn !== null && remoteBaseUrlIn !== void 0 ? remoteBaseUrlIn : parent.remoteBaseUrl;
  const remote = !!remoteBaseUrl || parent.remote || remoteIn;
  const url = parent.remote ? urlIn !== null && urlIn !== void 0 ? urlIn : parent.url : urlIn;
  const dataUrl = parent.remote ? dataUrlIn !== null && dataUrlIn !== void 0 ? dataUrlIn : parent.dataUrl : dataUrlIn;
  const external = !!remoteBaseUrl || ((_a = url === null || url === void 0 ? void 0 : url.startsWith("http")) !== null && _a !== void 0 ? _a : false);
  const scroll = (e4) => {
    e4.preventDefault();
    if (!htmlId)
      return;
    const el = document.getElementById(htmlId);
    scrollToElement(el, { htmlId });
  };
  return (0, import_jsx_runtime33.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime33.jsx)(XRefProvider, { remote, remoteBaseUrl, url, dataUrl, children: (0, import_jsx_runtime33.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] overflow-auto", children: [remoteBaseUrl && (0, import_jsx_runtime33.jsxs)("div", { className: "w-full px-3 py-1 text-xs border-b bg-gray-50", children: [(0, import_jsx_runtime33.jsx)("strong", { className: "text-gray-700", children: "Source: " }), (0, import_jsx_runtime33.jsx)("a", { className: "text-gray-700", href: `${createRemoteBaseUrl(url, remoteBaseUrl)}${htmlId ? `#${htmlId}` : ""}`, target: "_blank", children: remoteBaseUrl })] }), (0, import_jsx_runtime33.jsx)("div", { className: "px-3", children: (0, import_jsx_runtime33.jsx)(XrefChildren, { load: load2, identifier }) })] }) }), children: (0, import_jsx_runtime33.jsxs)("span", { children: [remote && external && (0, import_jsx_runtime33.jsx)("a", { href: `${createRemoteBaseUrl(url, remoteBaseUrl)}${htmlId ? `#${htmlId}` : ""}`, target: "_blank", className: "hover-link", children }), remote && !external && (0, import_jsx_runtime33.jsx)(Link2, { to: `${withBaseurl(url, baseurl)}${htmlId ? `#${htmlId}` : ""}`, prefetch: "intent", className: "hover-link", children }), !remote && (0, import_jsx_runtime33.jsx)("a", { href: `#${htmlId}`, onClick: scroll, className: "hover-link", children })] }) });
}
var CrossReferenceNode = ({ node }) => {
  if (!node.children) {
    return (0, import_jsx_runtime33.jsx)(InlineError, { value: node.label || node.identifier || "No Label", message: "Cross Reference Not Found" });
  }
  const { remote, url, dataUrl, remoteBaseUrl, identifier, html_id } = node;
  return (0, import_jsx_runtime33.jsxs)(CrossReferenceHover, { identifier, htmlId: html_id, remote, url, dataUrl, remoteBaseUrl, children: [node.prefix && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [node.prefix, " "] }), (0, import_jsx_runtime33.jsx)(MyST, { ast: node.children }), node.suffix || null] });
};
var CROSS_REFERENCE_RENDERERS = {
  crossReference: CrossReferenceNode
};
var crossReference_default = CROSS_REFERENCE_RENDERERS;

// ../../packages/myst-to-react/dist/tabs.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_classnames13 = __toESM(require_classnames(), 1);
var import_react38 = __toESM(require_react(), 1);
var TabSetContext = (0, import_react38.createContext)(void 0);
function TabSetStateProvider({ active, children }) {
  return (0, import_jsx_runtime34.jsx)(TabSetContext.Provider, { value: active, children });
}
function TabSet({ tabs, children }) {
  var _a, _b, _c, _d;
  const [lastClickedTab, onClickSyncedTab] = (_a = useTabSet()) !== null && _a !== void 0 ? _a : [];
  const [active, setActive] = (0, import_react38.useState)((_c = (_b = tabs.find((t10) => t10.selected)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : (_d = tabs === null || tabs === void 0 ? void 0 : tabs[0]) === null || _d === void 0 ? void 0 : _d.id);
  const onClick = (tab) => {
    setActive(tab.id);
    if (tab.sync) {
      if (!onClickSyncedTab) {
        console.error("TabStateProvider is not defined, synced tabs will not work.");
      }
      onClickSyncedTab === null || onClickSyncedTab === void 0 ? void 0 : onClickSyncedTab(tab.sync);
    }
  };
  (0, import_react38.useEffect)(() => {
    if (!lastClickedTab)
      return;
    const tab = tabs.find((item) => item.sync === lastClickedTab);
    if (!tab)
      return;
    setActive(tab === null || tab === void 0 ? void 0 : tab.id);
  }, [tabs, lastClickedTab, setActive]);
  return (0, import_jsx_runtime34.jsx)(TabSetStateProvider, { active, children: (0, import_jsx_runtime34.jsxs)("div", { className: "my-5", children: [(0, import_jsx_runtime34.jsx)("div", { className: "flex flex-row overflow-x-auto border-b border-b-gray-100", children: tabs.map((tab) => {
    return (0, import_jsx_runtime34.jsx)("div", { className: (0, import_classnames13.default)("flex-none px-3 py-1 font-semibold cursor-pointer", {
      "text-blue-600 border-b-2 border-b-blue-600 dark:border-b-white dark:text-white": active === tab.id,
      "text-gray-500 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-100": active !== tab.id
    }), onClick: () => onClick(tab), children: tab.title }, tab.id);
  }) }), (0, import_jsx_runtime34.jsx)("div", { className: "flex shadow", children: (0, import_jsx_runtime34.jsx)("div", { className: "w-full px-6", children }) })] }) });
}
function TabItem({ id, children }) {
  const active = (0, import_react38.useContext)(TabSetContext);
  const open = active === id;
  return (0, import_jsx_runtime34.jsx)("div", { className: (0, import_classnames13.default)({ hidden: !open }), children });
}
var TabSetRenderer = ({ node }) => {
  const tabs = selectAll("tabItem", node).map((tab) => ({
    title: tab.title,
    id: tab.key,
    sync: tab.sync
  }));
  return (0, import_jsx_runtime34.jsx)(TabSet, { tabs, children: (0, import_jsx_runtime34.jsx)(MyST, { ast: node.children }) });
};
var TabItemRenderer = ({ node }) => {
  return (0, import_jsx_runtime34.jsx)(TabItem, { id: node.key, children: (0, import_jsx_runtime34.jsx)(MyST, { ast: node.children }) });
};
var TAB_RENDERERS = {
  tabSet: TabSetRenderer,
  tabItem: TabItemRenderer
};
var tabs_default = TAB_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/chemicalFormula.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function parseFormula(formula) {
  return [...formula !== null && formula !== void 0 ? formula : ""].reduce((acc, current) => {
    const last2 = acc.pop();
    const letter = current === "+" ? "\u207A" : current === "-" ? "\u207B" : current;
    const isNumber = letter.match(/[0-9]/);
    const lastIsNumber = last2 === null || last2 === void 0 ? void 0 : last2.match(/[0-9]/);
    if (isNumber) {
      if (lastIsNumber) {
        return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
      }
      return [...acc, last2, letter].filter((v2) => !!v2);
    }
    if (lastIsNumber) {
      return [...acc, last2, letter].filter((v2) => !!v2);
    }
    return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
  }, []);
}
var ChemicalFormula = ({ node }) => {
  const parts = parseFormula(node.value);
  return (0, import_jsx_runtime35.jsx)("span", { className: "text-inherit", "aria-roledescription": "Chemical Formula", children: parts.map((letter, index2) => {
    if (letter.match(/[0-9]/))
      return (0, import_jsx_runtime35.jsx)("sub", { children: letter }, index2);
    return (0, import_jsx_runtime35.jsx)("span", { children: letter }, index2);
  }) });
};
var CHEM_RENDERERS = {
  chemicalFormula: ChemicalFormula
};
var chemicalFormula_default = CHEM_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/siunits.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var SIUnits = ({ node }) => {
  var _a;
  const space = node.number == null ? "" : " ";
  const title = `${(_a = node.number) !== null && _a !== void 0 ? _a : ""}${space}${node.alt}`;
  return (0, import_jsx_runtime36.jsx)("span", { title, children: node.value });
};
var SI_RENDERERS = {
  si: SIUnits
};
var siunits_default = SI_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/index.js
var EXT_RENDERERS = Object.assign(Object.assign({}, chemicalFormula_default), siunits_default);
var extensions_default = EXT_RENDERERS;

// ../../packages/myst-to-react/dist/inlineExpression.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var InlineExpression = ({ node }) => {
  var _a, _b, _c;
  if (!node.result) {
    return (0, import_jsx_runtime37.jsx)(InlineError, { value: `Unexecuted inline expression for: ${node.value}` });
  }
  if (((_a = node.result) === null || _a === void 0 ? void 0 : _a.status) !== "ok") {
    return (0, import_jsx_runtime37.jsx)(InlineError, { value: `${(_b = node.result) === null || _b === void 0 ? void 0 : _b.ename}: ${(_c = node.result) === null || _c === void 0 ? void 0 : _c.evalue}` });
  }
  return (0, import_jsx_runtime37.jsx)(Tooltip, { title: (0, import_jsx_runtime37.jsx)("code", { children: node.value }), children: (0, import_jsx_runtime37.jsx)("span", { className: "border-b border-dotted cursor-help", children: (0, import_jsx_runtime37.jsx)(MyST, { ast: node.children }) }) });
};
var INLINE_EXPRESSION_RENDERERS = {
  inlineExpression: InlineExpression
};
var inlineExpression_default = INLINE_EXPRESSION_RENDERERS;

// ../../packages/myst-to-react/dist/proof.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_classnames14 = __toESM(require_classnames(), 1);
var ProofKind;
(function(ProofKind2) {
  ProofKind2["proof"] = "proof";
  ProofKind2["axiom"] = "axiom";
  ProofKind2["lemma"] = "lemma";
  ProofKind2["definition"] = "definition";
  ProofKind2["criterion"] = "criterion";
  ProofKind2["remark"] = "remark";
  ProofKind2["conjecture"] = "conjecture";
  ProofKind2["corollary"] = "corollary";
  ProofKind2["algorithm"] = "algorithm";
  ProofKind2["example"] = "example";
  ProofKind2["property"] = "property";
  ProofKind2["observation"] = "observation";
  ProofKind2["proposition"] = "proposition";
  ProofKind2["assumption"] = "assumption";
  ProofKind2["theorem"] = "theorem";
})(ProofKind || (ProofKind = {}));
function getClasses2(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function capitalize(kind) {
  if (!kind)
    return "";
  return kind.slice(0, 1).toUpperCase() + kind.slice(1);
}
function getColor({ kind }) {
  switch (kind) {
    case ProofKind.proof:
    case ProofKind.algorithm:
      return { color: "gray" };
    case ProofKind.lemma:
    case ProofKind.conjecture:
    case ProofKind.theorem:
      return { color: "purple" };
    case ProofKind.observation:
    case ProofKind.assumption:
    case ProofKind.axiom:
      return { color: "yellow" };
    case ProofKind.criterion:
    case ProofKind.corollary:
    case ProofKind.property:
      return { color: "orange" };
    case ProofKind.example:
      return { color: "green" };
    case ProofKind.remark:
      return { color: "red" };
    case ProofKind.definition:
    case ProofKind.proposition:
    default:
      return { color: "blue" };
  }
}
var WrapperElement2 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime38.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime38.jsx)("aside", { id, className, children });
};
var HeaderElement2 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime38.jsx)("summary", { className, children });
  return (0, import_jsx_runtime38.jsx)("div", { className, children });
};
var iconClass3 = "inline-block pl-2 mr-2 self-center flex-none";
function Proof({ title, kind, color: color2, dropdown, children, identifier, enumerator }) {
  return (0, import_jsx_runtime38.jsxs)(WrapperElement2, { id: identifier, dropdown, className: (0, import_classnames14.default)("my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }), children: [(0, import_jsx_runtime38.jsxs)(HeaderElement2, { dropdown, className: (0, import_classnames14.default)("m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [(0, import_jsx_runtime38.jsxs)("div", { className: (0, import_classnames14.default)("text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", "ml-4"), children: [(0, import_jsx_runtime38.jsxs)(HashLink, { id: identifier, kind: capitalize(kind), children: [capitalize(kind), " ", enumerator] }), " ", title && (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: ["(", title, ")"] })] }), dropdown && (0, import_jsx_runtime38.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime38.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames14.default)(iconClass3, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime38.jsx)("div", { className: (0, import_classnames14.default)("px-4", { "details-body": dropdown }), children })] });
}
var ProofRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses2(node.class);
  const { color: color2 } = getColor({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime38.jsx)(Proof, { identifier: node.html_id, title: useTitle ? (0, import_jsx_runtime38.jsx)(MyST, { ast: [title] }) : void 0, kind: node.kind, enumerator: node.enumerator, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime38.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime38.jsx)(MyST, { ast: node.children }) });
};
var PROOF_RENDERERS = {
  proof: ProofRenderer
};
var proof_default = PROOF_RENDERERS;

// ../../packages/myst-to-react/dist/exercise.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_classnames15 = __toESM(require_classnames(), 1);
function getClasses3(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s7) => s7.trim().toLowerCase()).filter((s7) => !!s7)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getColor2({ classes = [] }, defaultColor = "blue") {
  if (classes.includes("gray"))
    return { color: "gray" };
  if (classes.includes("purple"))
    return { color: "purple" };
  if (classes.includes("yellow"))
    return { color: "yellow" };
  if (classes.includes("orange"))
    return { color: "orange" };
  if (classes.includes("green"))
    return { color: "green" };
  if (classes.includes("red"))
    return { color: "red" };
  if (classes.includes("blue"))
    return { color: "blue" };
  return { color: defaultColor };
}
var WrapperElement3 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime39.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime39.jsx)("aside", { id, className, children });
};
var HeaderElement3 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime39.jsx)("summary", { className, children });
  return (0, import_jsx_runtime39.jsx)("div", { className, children });
};
var iconClass4 = "inline-block pl-2 mr-2 self-center flex-none";
function Callout({ title, color: color2, dropdown, children, identifier, Icon }) {
  return (0, import_jsx_runtime39.jsxs)(WrapperElement3, { id: identifier, dropdown, className: (0, import_classnames15.default)("my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }), children: [(0, import_jsx_runtime39.jsxs)(HeaderElement3, { dropdown, className: (0, import_classnames15.default)("m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [Icon && (0, import_jsx_runtime39.jsx)(Icon, { width: "2rem", height: "2rem", className: (0, import_classnames15.default)("inline-block pl-2 mr-2 self-center flex-none", (0, import_classnames15.default)({
    "text-gray-600": !color2 || color2 === "gray",
    "text-blue-600": color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-orange-600": color2 === "orange",
    "text-red-600": color2 === "red",
    "text-purple-600": color2 === "purple"
  })) }), (0, import_jsx_runtime39.jsx)("div", { className: (0, import_classnames15.default)(
    "text-neutral-900 dark:text-white grow self-center overflow-hidden break-words",
    { "ml-4": !Icon },
    // No icon!
    "group"
  ), children: title }), dropdown && (0, import_jsx_runtime39.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime39.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames15.default)(iconClass4, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime39.jsx)("div", { className: (0, import_classnames15.default)("px-4", { "details-body": dropdown }), children })] });
}
var ExerciseRenderer = ({ node }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const enumerator = node.enumerator;
  const titleNode = (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [(0, import_jsx_runtime39.jsxs)(HashLink, { id: identifier, kind: "Exercise", children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", "Exercise", enumerator != null && (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [" ", enumerator] })] }), useTitle && (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [" ", "(", (0, import_jsx_runtime39.jsx)(MyST, { ast: [title] }), ")"] })] });
  return (0, import_jsx_runtime39.jsx)(Callout, { identifier, title: titleNode, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime39.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime39.jsx)(MyST, { ast: node.children }) });
};
var SolutionRenderer = ({ node }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes }, "gray");
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const titleNode = (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", (0, import_jsx_runtime39.jsx)(MyST, { ast: [title] }), (0, import_jsx_runtime39.jsx)(HashLink, { id: identifier, kind: "Solution", hover: true, hideInPopup: true, children: " #" })] });
  return (0, import_jsx_runtime39.jsx)(Callout, { identifier, title: useTitle ? titleNode : void 0, color: color2, dropdown: isDropdown, children: useTitle ? (0, import_jsx_runtime39.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime39.jsx)(MyST, { ast: node.children }) });
};
var EXERCISE_RENDERERS = {
  exercise: ExerciseRenderer,
  solution: SolutionRenderer
};
var exercise_default = EXERCISE_RENDERERS;

// ../../packages/myst-to-react/dist/aside.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_classnames16 = __toESM(require_classnames(), 1);
function getAsideClass(kind) {
  switch (kind) {
    case "topic":
      return {
        container: "my-5 shadow dark:bg-stone-800 overflow-hidden dark:border-l-4 border-slate-400",
        title: "m-0 font-medium py-2 px-4 flex min-w-0 text-md border-y dark:border-y-0 bg-gray-50/80 dark:bg-slate-900",
        body: "px-4"
      };
    case "margin":
    case "sidebar":
    default:
      return {
        container: "text-sm lg:h-0 col-margin-right",
        title: "text-base font-semibold",
        body: ""
      };
  }
}
var AsideRenderer = ({ node }) => {
  const [title, ...rest2] = node.children;
  const classes = getAsideClass(node.kind);
  if (title.type !== "admonitionTitle") {
    return (0, import_jsx_runtime40.jsx)("aside", { className: (0, import_classnames16.default)(classes.container, node.class), children: (0, import_jsx_runtime40.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime40.jsxs)("aside", { className: (0, import_classnames16.default)(classes.container, node.class), children: [(0, import_jsx_runtime40.jsx)("div", { className: classes.title, children: (0, import_jsx_runtime40.jsx)(MyST, { ast: title }) }), (0, import_jsx_runtime40.jsx)("div", { className: classes.body, children: (0, import_jsx_runtime40.jsx)(MyST, { ast: rest2 }) })] });
};
var ASIDE_RENDERERS = {
  aside: AsideRenderer
};
var aside_default = ASIDE_RENDERERS;

// ../../packages/myst-to-react/dist/unknown.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var UnknownDirective = ({ node }) => {
  const titleNode = (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, { children: [(0, import_jsx_runtime41.jsx)("code", { children: node.name }), " - Unknown Directive"] });
  return (0, import_jsx_runtime41.jsx)(Callout, { title: titleNode, color: "red", dropdown: true, Icon: ExclamationTriangleIcon_default, children: (0, import_jsx_runtime41.jsx)("pre", { children: node.value }) });
};
var UNKNOWN_MYST_RENDERERS = {
  mystDirective: UnknownDirective
};
var unknown_default = UNKNOWN_MYST_RENDERERS;

// ../../packages/myst-to-react/dist/index.js
var DEFAULT_RENDERERS = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, basic_default), unknown_default), image_default), links_default), code_default), math_default), cite_default), tabs_default), iframe_default), footnotes_default), admonitions_default), reactive_default), heading_default), crossReference_default), dropdown_default), card_default), grid_default), inlineExpression_default), extensions_default), proof_default), exercise_default), aside_default);

// ../../packages/site/src/components/ContentBlocks.tsx
var import_classnames22 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/embed.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/decoration.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/hooks.js
var import_react45 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/provider.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/actions.js
function isNavigatePayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.location === "string" && typeof maybePayload.mdast === "object" && Array.isArray(maybePayload.dependencies) && Array.isArray(maybePayload.computables);
}
function isSlugPayload(payload) {
  return typeof payload.slug === "string";
}
function isBuildStatusPayload(payload) {
  return typeof payload.status === "string" && isSlugPayload(payload);
}
function isAddMdastPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.mdast === "object";
}
function isAddNotebookPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.notebook === "object" && typeof maybePayload.rendermime === "object";
}
function isAddSessionPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.session === "object";
}

// ../../packages/jupyter/dist/execute/reducer.js
var __rest4 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function reducer(state, action) {
  var _a;
  switch (action.type) {
    case "NAVIGATE": {
      if (!isNavigatePayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid NAVIGATE payload");
      }
      const { kind, slug, location: location2, mdast, dependencies, computables } = action.payload;
      if (state.pages[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }), pages: Object.assign(Object.assign({}, state.pages), { [slug]: {
        kind,
        slug,
        location: location2,
        dependencies,
        computables,
        computable: computables.length > 0 || kind === SourceFileKind.Notebook,
        ready: false,
        scopes: {}
      } }) });
    }
    case "ADD_MDAST": {
      if (!isAddMdastPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_MDAST payload");
      }
      const { slug, mdast } = action.payload;
      if (state.mdast[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }) });
    }
    case "REQUEST_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid REQUEST_BUILD payload");
      }
      const { slug } = action.payload;
      if (!!state.builds[slug] && state.builds[slug].status === "pending")
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: {
        status: "pending"
      } }) });
    }
    case "BUILD_STATUS": {
      if (!isBuildStatusPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid BUILD_STATUS payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug]) {
        console.error(state, action.payload);
        throw new Error("Trying to set build status when there is no build state");
      }
      if (state.builds[slug].status === action.payload.status)
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: Object.assign(Object.assign({}, state.builds[slug]), { status: action.payload.status }) }) });
    }
    case "CLEAR_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid CLEAR_BUILD payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug])
        return state;
      const _b = state.builds, _c = slug, _5 = _b[_c], builds = __rest4(_b, [typeof _c === "symbol" ? _c : _c + ""]);
      return Object.assign(Object.assign({}, state), { builds });
    }
    case "SET_RENDERING_READY": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid SET_READY payload");
      }
      const { slug } = action.payload;
      if (state.pages[slug].ready)
        return state;
      const _d = state.builds, _e = slug, _5 = _d[_e], builds = __rest4(_d, [typeof _e === "symbol" ? _e : _e + ""]);
      const newState = Object.assign(Object.assign({}, state), { builds, pages: Object.assign(Object.assign({}, state.pages), { [slug]: Object.assign(Object.assign({}, state.pages[slug]), { ready: true }) }) });
      return newState;
    }
    case "ADD_NOTEBOOK": {
      if (!isAddNotebookPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_NOTEBOOK payload");
      }
      const { pageSlug, notebookSlug, notebook, rendermime } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add notebook when there is no rendering state");
      }
      if (state.pages[pageSlug].scopes[notebookSlug]) {
        console.warn("Trying to add notebook scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: {
        notebook,
        rendermime
      } }) }) }) });
    }
    case "ADD_SESSION": {
      if (!isAddSessionPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_SESSION payload");
      }
      const { pageSlug, notebookSlug, session } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add session when there is no rendering state");
      }
      if ((_a = state.pages[pageSlug].scopes[notebookSlug]) === null || _a === void 0 ? void 0 : _a.session) {
        console.warn("Trying to add session scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: Object.assign(Object.assign({}, state.pages[pageSlug].scopes[notebookSlug]), { session }) }) }) }) });
    }
  }
  return state;
}

// ../../packages/jupyter/dist/execute/selectors.js
function selectNotebookForPage(state, pageSlug, notebookSlug) {
  var _a, _b;
  return (_b = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]) === null || _b === void 0 ? void 0 : _b.notebook;
}
function selectIsComputable(state, slug) {
  var _a, _b;
  return (_b = (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.computable) !== null && _b !== void 0 ? _b : false;
}
function selectAreExecutionScopesBuilding(state, slug) {
  var _a;
  return !((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) && !!state.builds[slug];
}
function selectExecutionScopeStatus(state, slug) {
  var _a, _b, _c;
  return ((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) ? "ready" : (_c = (_b = state.builds[slug]) === null || _b === void 0 ? void 0 : _b.status) !== null && _c !== void 0 ? _c : "unknown";
}
function selectDependenciesToFetch(state) {
  return Object.entries(state.builds).filter(([, { status }]) => status === "fetching").reduce((targets, [slug]) => [
    ...targets,
    ...state.pages[slug].dependencies.filter((d6) => {
      var _a;
      return !state.mdast[(_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url];
    }).map((d6) => {
      var _a;
      return {
        slug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
        url: d6.url
      };
    })
  ], []);
}
function makeSelectScopeEventStatus(statusName) {
  return (state) => {
    return Object.entries(state.builds).filter(([, { status }]) => status === statusName).reduce((all, [slug]) => {
      const targets = [];
      if (state.pages[slug].kind === SourceFileKind.Notebook)
        targets.push({
          pageSlug: slug,
          notebookSlug: slug,
          location: state.pages[slug].location
        });
      targets.push(...state.pages[slug].dependencies.map((d6) => {
        var _a;
        return {
          pageSlug: slug,
          notebookSlug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
          location: d6.location
        };
      }));
      return [...all, ...targets];
    }, []);
  };
}
var selectScopeNotebooksToBuild = makeSelectScopeEventStatus("build-notebooks");
var selectSessionsToStart = makeSelectScopeEventStatus("start-session");
function selectAreAllDependenciesReady(state, slug) {
  var _a;
  return (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.dependencies.every((dep) => {
    var _a2;
    return !!state.mdast[(_a2 = dep.slug) !== null && _a2 !== void 0 ? _a2 : dep.url];
  });
}
function selectAreAllNotebookScopesBuilt(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a;
    return !!rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url];
  });
}
function selectAreAllSessionsStarted(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a, _b;
    return !!((_b = rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url]) === null || _b === void 0 ? void 0 : _b.session);
  });
}

// ../../packages/jupyter/dist/execute/leaf.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);
var import_thebe_react = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/execute/utils.js
function executableNodesFromBlock(block) {
  if (!block || block.type !== "block")
    return;
  let target = block;
  if (block.children && block.children.length === 1 && block.children[0].type === "container") {
    target = block.children[0];
  }
  if (target.children && target.children.length >= 2 && target.children[0].type === "code") {
    return { codeCell: target.children[0], output: target.children[1] };
  }
}
function notebookFromMdast(core2, config, pageSlug, notebookSlug, mdast, idkmap, rendermime) {
  const notebook = new core2.ThebeNotebook(notebookSlug, config, rendermime);
  notebook.cells = mdast.children.map((block) => {
    var _a, _b, _c;
    if (block.type !== "block")
      console.warn(`Unexpected block type ${block.type}`);
    const executableNodes = executableNodesFromBlock(block);
    if (executableNodes) {
      const { codeCell, output } = executableNodes;
      const target = {
        pageSlug,
        notebookSlug,
        cellId: block.key
      };
      idkmap[block.key] = target;
      idkmap[output.id] = target;
      if (block.identifier)
        idkmap[block.identifier] = target;
      if (codeCell.identifier)
        idkmap[codeCell.identifier] = target;
      if (output.identifier)
        idkmap[output.identifier] = target;
      return new core2.ThebeCodeCell(target.cellId, notebook.id, (_a = codeCell.value) !== null && _a !== void 0 ? _a : "", config, (_b = block.data) !== null && _b !== void 0 ? _b : {}, notebook.rendermime);
    } else {
      const cell = new core2.ThebeMarkdownCell(block.key, notebook.id, block.children.reduce((acc, child) => {
        var _a2;
        return acc + "\n" + ((_a2 = child.value) !== null && _a2 !== void 0 ? _a2 : "");
      }, ""), (_c = block.data) !== null && _c !== void 0 ? _c : {}, notebook.rendermime);
      return cell;
    }
  });
  return notebook;
}

// ../../packages/jupyter/dist/plotly.js
var import_react41 = __toESM(require_react(), 1);
function useLoadPlotly() {
  const [plotly, setPlotly] = (0, import_react41.useState)();
  (0, import_react41.useEffect)(() => {
    if (plotly)
      return;
    import("/myst_assets_folder/_shared/plotly-renderer-BWEXRS4J.js").then((module) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module
      });
      setPlotly(module);
    });
  }, [plotly]);
  return { plotly };
}
var PLOTLY_MIMETYPE = "application/vnd.plotly.v1+json";
function isPlotly(outputs) {
  return outputs.some((output) => {
    var _a;
    return Object.keys((_a = output.data) !== null && _a !== void 0 ? _a : []).includes(PLOTLY_MIMETYPE);
  });
}
function usePlotlyPassively(rendermime, outputs) {
  const isPlotlyOutput = isPlotly(outputs);
  const [loaded, setLoaded] = (0, import_react41.useState)(!isPlotlyOutput);
  (0, import_react41.useEffect)(() => {
    if (loaded || !isPlotlyOutput)
      return;
    import("/myst_assets_folder/_shared/plotly-renderer-BWEXRS4J.js").then((module) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module
      });
      rendermime.addFactory(module.rendererFactory, 41);
      setLoaded(true);
    });
  }, [loaded, isPlotlyOutput]);
  return { loaded };
}

// ../../packages/jupyter/dist/execute/leaf.js
function MdastFetcher({ slug, url, dispatch }) {
  const { data, error } = useFetchMdast({ remote: true, dataUrl: `${url}.json` });
  (0, import_react42.useEffect)(() => {
    if (!data)
      return;
    dispatch({ type: "ADD_MDAST", payload: { slug, mdast: data.mdast } });
  }, [data]);
  if (error) {
    return (0, import_jsx_runtime42.jsxs)("div", { children: ["error: ", slug, error.message] });
  }
  return null;
}
function NotebookBuilder({ pageSlug, notebookSlug, idkmap, state, dispatch }) {
  var _a;
  const { core: core2 } = (0, import_thebe_react.useThebeLoader)();
  const { config } = (0, import_thebe_react.useThebeConfig)();
  const lock = (0, import_react42.useRef)(false);
  const scopeHasNotebook = !!((_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]);
  const { plotly } = useLoadPlotly();
  (0, import_react42.useEffect)(() => {
    var _a2;
    if (!core2 || !config || !plotly || scopeHasNotebook || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: NotebookBuilder - ${notebookSlug} being added to scope ${pageSlug}`);
    const rendermime = core2 === null || core2 === void 0 ? void 0 : core2.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax);
    if (plotly)
      rendermime.addFactory(plotly.rendererFactory, 41);
    const notebook = notebookFromMdast(core2, config, pageSlug, notebookSlug, state.mdast[notebookSlug].root, idkmap, rendermime);
    const computables = (_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.computables;
    computables === null || computables === void 0 ? void 0 : computables.forEach((c6) => {
      if (idkmap[c6.label]) {
        idkmap[c6.outputKey] = idkmap[c6.label];
        idkmap[c6.embedKey] = idkmap[c6.label];
      }
    });
    dispatch({
      type: "ADD_NOTEBOOK",
      payload: { pageSlug, notebookSlug, rendermime, notebook }
    });
  }, [core2, config, pageSlug, notebookSlug, scopeHasNotebook, lock, plotly]);
  const allNotebooksAreBuilt = plotly && selectAreAllNotebookScopesBuilt(state, pageSlug);
  (0, import_react42.useEffect)(() => {
    if (!allNotebooksAreBuilt)
      return;
    dispatch({ type: "BUILD_STATUS", payload: { slug: pageSlug, status: "wait-for-server" } });
  }, [allNotebooksAreBuilt]);
  return null;
}
function SessionStarter({ pageSlug, notebookSlug, location: location2, state, dispatch }) {
  var _a;
  const { core: core2 } = (0, import_thebe_react.useThebeLoader)();
  const { config, server } = (0, import_thebe_react.useThebeServer)();
  const lock = (0, import_react42.useRef)(false);
  const scope = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug];
  (0, import_react42.useEffect)(() => {
    if (!core2 || !server || (scope === null || scope === void 0 ? void 0 : scope.session) || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: Starting session for ${pageSlug}-${notebookSlug} at ${location2}`);
    if (location2 === void 0) {
      console.warn("Article/Notebook json is missing the location field, this maybe break notebook execution when located outside of the root folder");
    }
    server.listRunningSessions().then((sessions) => {
      var _a2;
      console.debug("Jupyter: running sessions", sessions);
      let path = `/${pageSlug}-${notebookSlug}.ipynb`;
      console.debug("session starter path:", path);
      const match = (_a2 = location2 === null || location2 === void 0 ? void 0 : location2.match(/(.*)\/.*.ipynb$/)) !== null && _a2 !== void 0 ? _a2 : null;
      if (match) {
        console.debug("session starter match:", match);
        path = `${match[1]}/${pageSlug}-${notebookSlug}.ipynb`;
        console.debug("session starter path (modified):", path);
      }
      const existing = sessions.find((s7) => s7.path === path);
      if (existing) {
        console.debug(`session already exists for ${path}`, existing);
        server.connectToExistingSession(existing, scope.rendermime).then((sesh) => {
          var _a3;
          if (sesh == null) {
            console.error(`Could not connect to session for ${path}`);
            return;
          }
          console.debug(`reconnected to session for ${path}`, sesh);
          console.debug("restarting session", sesh);
          (_a3 = sesh.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().then(() => {
            const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
            notebook.attachSession(sesh);
            dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
          });
        });
      } else {
        server.startNewSession(scope.rendermime, Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.kernels), { path })).then((sesh) => {
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              console.error(`Could not start session for ${path}`);
              console.debug(`Available kernels: ${Object.keys(specs)}`);
            });
            return;
          }
          console.debug(`session started for ${path}`, sesh);
          const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
          notebook.attachSession(sesh);
          dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
        });
      }
    });
  }, [core2, config, scope, pageSlug, notebookSlug, lock]);
  const allSessionsAreStarted = selectAreAllSessionsStarted(state, pageSlug);
  (0, import_react42.useEffect)(() => {
    if (!allSessionsAreStarted)
      return;
    dispatch({
      type: "SET_RENDERING_READY",
      payload: { slug: pageSlug }
    });
  }, [allSessionsAreStarted]);
  return null;
}
function ServerMonitor({ state, dispatch }) {
  const { core: core2, load: load2, loading } = (0, import_thebe_react.useThebeLoader)();
  const { ready, error } = (0, import_thebe_react.useThebeServer)();
  (0, import_react42.useEffect)(() => {
    if (core2 || loading)
      return;
    load2();
  }, [core2, load2, loading]);
  (0, import_react42.useEffect)(() => {
    if (ready) {
      Object.entries(state.builds).forEach(([slug, { status }]) => {
        if (status === "wait-for-server") {
          dispatch({ type: "BUILD_STATUS", payload: { slug, status: "start-session" } });
        }
      });
    }
  }, [ready, state]);
  (0, import_react42.useEffect)(() => {
    if (!error)
      return;
  }, [error]);
  return null;
}

// ../../packages/jupyter/dist/execute/provider.js
var ExecuteScopeContext = import_react43.default.createContext(void 0);
function useScopeNavigate({ contents: { slug, location: location2, kind, mdast, dependencies }, state, dispatch }) {
  (0, import_react43.useEffect)(() => {
    if (state.pages[slug]) {
      console.debug(`Jupyter: ExecuteScopeProvider - ${slug} is already in scope`);
      return;
    }
    const computables = listComputables(mdast);
    dispatch({
      type: "NAVIGATE",
      payload: {
        kind,
        slug,
        location: location2 !== null && location2 !== void 0 ? location2 : kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/",
        mdast,
        dependencies: dependencies !== null && dependencies !== void 0 ? dependencies : [],
        computables
      }
    });
  }, [slug]);
}
function useExecutionScopeFetcher({ slug, state, dispatch }) {
  (0, import_react43.useEffect)(() => {
    if (!state.builds[slug])
      return;
    if (state.builds[slug].status === "pending") {
      dispatch({ type: "BUILD_STATUS", payload: { slug, status: "fetching" } });
    }
    if (state.builds[slug].status === "fetching") {
      if (selectAreAllDependenciesReady(state, slug)) {
        dispatch({ type: "BUILD_STATUS", payload: { slug, status: "build-notebooks" } });
      }
    }
  }, [state.builds, state.mdast]);
}
function listComputables(mdast) {
  return selectAll("container[kind=figure]:has(output), embed:has(output)", mdast).map((node) => {
    const { key, label, source } = node;
    const output = selectAll("output", node);
    return { embedKey: key, outputKey: output[0].key, label, source };
  });
}
function ExecuteScopeProvider({ children, enable, contents }) {
  var _a, _b;
  const computables = listComputables(contents.mdast);
  const fallbackLocation = contents.kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/";
  const initialState = {
    mdast: {
      [contents.slug]: { root: contents.mdast }
    },
    pages: {
      [contents.slug]: {
        computable: computables.length > 0 || contents.kind === SourceFileKind.Notebook,
        kind: contents.kind,
        slug: contents.slug,
        location: (_a = contents.location) !== null && _a !== void 0 ? _a : fallbackLocation,
        dependencies: (_b = contents.dependencies) !== null && _b !== void 0 ? _b : [],
        computables,
        ready: false,
        scopes: {}
      }
    },
    builds: {}
  };
  const [state, dispatch] = (0, import_react43.useReducer)(reducer, initialState);
  const idkmap = (0, import_react43.useRef)({});
  useScopeNavigate({ contents, state, dispatch });
  useExecutionScopeFetcher({ slug: contents.slug, state, dispatch });
  const fetchTargets = selectDependenciesToFetch(state);
  const notebookBuildTargets = selectScopeNotebooksToBuild(state);
  const sessionStartTargets = selectSessionsToStart(state);
  const memo = import_react43.default.useMemo(() => ({
    canCompute: enable,
    slug: contents.slug,
    location: contents.location,
    state,
    dispatch,
    idkmap: idkmap.current
  }), [state, contents.slug, enable]);
  if (typeof window !== "undefined") {
    window.executeScope = memo;
  }
  return (0, import_jsx_runtime43.jsxs)(ExecuteScopeContext.Provider, { value: memo, children: [(0, import_jsx_runtime43.jsxs)("div", { className: "hidden", children: [fetchTargets.length > 0 && (0, import_jsx_runtime43.jsx)("div", { className: "p-1 pl-4", children: fetchTargets.map(({ slug, url }) => (0, import_jsx_runtime43.jsx)(MdastFetcher, { slug, url, dispatch }, `fetch-${slug}`)) }), notebookBuildTargets.length > 0 && (0, import_jsx_runtime43.jsx)("div", { className: "p-1 pl-4", children: notebookBuildTargets.map(({ pageSlug, notebookSlug }) => (0, import_jsx_runtime43.jsx)(NotebookBuilder, { pageSlug, notebookSlug, idkmap: idkmap.current, state, dispatch }, `build-${pageSlug}-${notebookSlug}`)) }), sessionStartTargets.length > 0 && (0, import_jsx_runtime43.jsx)("div", { className: "p-1 pl-4", children: sessionStartTargets.map(({ pageSlug, notebookSlug, location: location2 }) => (0, import_jsx_runtime43.jsx)(SessionStarter, { pageSlug, notebookSlug, location: location2, state, dispatch }, `session-${pageSlug}-${notebookSlug}`)) })] }), (0, import_jsx_runtime43.jsx)(ServerMonitor, { state, dispatch }), children] });
}

// ../../packages/jupyter/dist/execute/busy.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var __rest5 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
var BusyScopeContext = import_react44.default.createContext(void 0);
function isSlugPayload2(payload) {
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && typeof payload.kind === "string";
}
function isCellPayload(payload) {
  return isSlugPayload2(payload) && typeof payload.cellId === "string" && typeof payload.kind === "string";
}
function isNotebookPayload(payload) {
  return isSlugPayload2(payload) && Array.isArray(payload.cellIds) && payload.cellIds.every((id) => typeof id === "string") && typeof payload.kind === "string";
}
function isErrorPayload(payload) {
  var _a, _b;
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && payload.errors === void 0 || ((_b = Array.isArray(payload.errors) && ((_a = payload.errors) === null || _a === void 0 ? void 0 : _a.every((error) => typeof error === "object"))) !== null && _b !== void 0 ? _b : false);
}
function reducer2(state, action) {
  var _a, _b, _c, _d, _e, _f, _g;
  switch (action.type) {
    case "SET_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("SET_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      if ((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId])
        return state;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_c = state[kind][pageSlug]) === null || _c === void 0 ? void 0 : _c[notebookSlug]), { [cellId]: true }) }) }) });
    }
    case "CLEAR_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("CLEAR_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      const _h = state[kind], _j = pageSlug, renderBusy = _h[_j], otherRenders = __rest5(_h, [typeof _j === "symbol" ? _j : _j + ""]);
      if (!renderBusy)
        return state;
      const _k = renderBusy, _l = notebookSlug, notebookBusy = _k[_l], otherNotebooks = __rest5(_k, [typeof _l === "symbol" ? _l : _l + ""]);
      if (!notebookBusy)
        return state;
      if (!notebookBusy[cellId])
        return state;
      const _m = notebookBusy, _o = cellId, cellBusy = _m[_o], otherCells = __rest5(_m, [typeof _o === "symbol" ? _o : _o + ""]);
      if (Object.keys(otherCells).length === 0 && Object.keys(otherNotebooks).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      if (Object.keys(otherCells).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [action.payload.pageSlug]: Object.assign(Object.assign({}, otherNotebooks), { [notebookSlug]: Object.assign({}, otherCells) }) }) });
    }
    case "SET_NOTEBOOK_BUSY": {
      if (!isNotebookPayload(action.payload)) {
        console.error("SET_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellIds, kind } = action.payload;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_d = state[kind][pageSlug]) === null || _d === void 0 ? void 0 : _d[notebookSlug]), cellIds.reduce((acc, cellId) => Object.assign(Object.assign({}, acc), { [cellId]: true }), {})) }) }) });
    }
    case "CLEAR_NOTEBOOK_BUSY": {
      if (!isSlugPayload2(action.payload)) {
        console.error("CLEAR_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, kind } = action.payload;
      if (!state[kind][pageSlug])
        return state;
      if (!((_e = state[kind][pageSlug]) === null || _e === void 0 ? void 0 : _e[notebookSlug]))
        return state;
      const _p = state[kind][pageSlug], _q = notebookSlug, notebookBusy = _p[_q], otherNotebooks = __rest5(_p, [typeof _q === "symbol" ? _q : _q + ""]);
      if (Object.keys(otherNotebooks).length === 0) {
        const _r = state[kind], _s = pageSlug, renderBusy = _r[_s], otherRenders = __rest5(_r, [typeof _s === "symbol" ? _s : _s + ""]);
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
    }
    case "SET_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("SET_ERROR payload must be an error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, errors } = action.payload;
      if (!errors) {
        console.error("SET_ERROR payload must have errors", action.payload);
        return state;
      }
      if (state.error[pageSlug])
        return state;
      if ((_f = state.error[pageSlug]) === null || _f === void 0 ? void 0 : _f[notebookSlug])
        return state;
      return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign(Object.assign({}, state.error[pageSlug]), { [notebookSlug]: errors }) }) });
    }
    case "CLEAR_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("CLEAR_ERROR payload must be a error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug } = action.payload;
      if (!state.error[pageSlug])
        return state;
      if (!((_g = state.error[pageSlug]) === null || _g === void 0 ? void 0 : _g[notebookSlug]))
        return state;
      const _t = state.error[pageSlug], _u = notebookSlug, notebookErrors = _t[_u], otherNotebooks = __rest5(_t, [typeof _u === "symbol" ? _u : _u + ""]);
      if (Object.keys(otherNotebooks).length > 0) {
        return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      const _v = state.error, _w = pageSlug, renderErrors = _v[_w], otherRenders = __rest5(_v, [typeof _w === "symbol" ? _w : _w + ""]);
      return Object.assign(Object.assign({}, state), { error: otherRenders });
    }
  }
  return state;
}
function BusyScopeProvider({ children }) {
  const [state, dispatch] = (0, import_react44.useReducer)(reducer2, { execute: {}, reset: {}, error: {} });
  const memo = import_react44.default.useMemo(() => ({ state, dispatch }), [state]);
  if (typeof window !== "undefined") {
    window.busyScopeState = memo.state;
  }
  return (0, import_jsx_runtime44.jsx)(BusyScopeContext.Provider, { value: memo, children });
}
function useBusyScope() {
  const context = import_react44.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { dispatch, state } = context;
  const cell = (0, import_react44.useCallback)((pageSlug, notebookSlug, cellId, kind) => selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind), [state]);
  const notebook = (0, import_react44.useCallback)((pageSlug, notebookSlug, kind) => selectNotebookIsBusy(state, pageSlug, notebookSlug, kind), [state]);
  const page = (0, import_react44.useCallback)((pageSlug, kind) => selectPageIsBusy(state, pageSlug, kind), [state]);
  const setCell = (0, import_react44.useCallback)((pageSlug, notebookSlug, cellId, kind) => {
    dispatch({ type: "SET_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } });
  }, [dispatch]);
  const clearCell = (0, import_react44.useCallback)((pageSlug, notebookSlug, cellId, kind) => dispatch({ type: "CLEAR_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } }), [dispatch]);
  const setNotebook = (0, import_react44.useCallback)((pageSlug, notebookSlug, cellIds, kind) => dispatch({ type: "SET_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, cellIds, kind } }), [dispatch]);
  const clearNotebook = (0, import_react44.useCallback)((pageSlug, notebookSlug, kind) => dispatch({ type: "CLEAR_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, kind } }), [dispatch]);
  const setError = (0, import_react44.useCallback)((pageSlug, notebookSlug, errors) => dispatch({ type: "SET_ERROR", payload: { pageSlug, notebookSlug, errors } }), [dispatch]);
  const clearError = (0, import_react44.useCallback)((pageSlug, notebookSlug) => dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } }), [dispatch]);
  return {
    cell,
    notebook,
    page,
    setCell,
    clearCell,
    setNotebook,
    clearNotebook,
    setError,
    clearError
  };
}
function useBusyErrors(pageSlug) {
  const context = import_react44.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { state, dispatch } = context;
  const clearErrors = () => {
    Object.keys(state.error[pageSlug]).forEach((notebookSlug) => {
      dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } });
    });
  };
  let items;
  if (Object.keys(state.error).length > 0 && state.error[pageSlug]) {
    items = Object.entries(state.error[pageSlug]).map(([notebookSlug, errors]) => ({
      pageSlug,
      notebookSlug,
      errors
    }));
  }
  return { items, clearErrors };
}
function selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind) {
  var _a, _b;
  return !!((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId]);
}
function selectNotebookIsBusy(state, pageSlug, notebookSlug, kind) {
  var _a;
  return !!((_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]);
}
function selectPageIsBusy(state, pageSlug, kind) {
  return !!state[kind][pageSlug];
}

// ../../packages/jupyter/dist/execute/hooks.js
var import_thebe_react2 = __toESM(require_dist3(), 1);
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function useExecutionScope({ clearOutputsOnExecute = false } = {}) {
  var _a;
  const context = import_react45.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react2.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useExecuteScope must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch } = context;
  const start = (0, import_react45.useCallback)((slug) => {
    console.debug(`Jupyter: Starting ${slug}`);
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug
      }
    });
  }, []);
  const execute = (slug) => {
    Object.entries(state.pages[slug].scopes).forEach(([notebookSlug, { notebook }]) => {
      busy.clearError(slug, notebookSlug);
      busy.setNotebook(slug, notebookSlug, notebook.code.map((c6) => c6.id), "execute");
    });
    if (clearOutputsOnExecute) {
      Object.values(state.pages[slug].scopes).forEach(({ notebook }) => {
        notebook.clear();
      });
    }
    setTimeout(() => __awaiter2(this, void 0, void 0, function* () {
      const handler = (_5, data) => {
        var _a2, _b;
        if (data.subject === "cell" && data.status === "idle") {
          const notebookSlug = (_a2 = data.object.notebookId) !== null && _a2 !== void 0 ? _a2 : "unknown";
          busy.clearCell(slug, notebookSlug, (_b = data.id) !== null && _b !== void 0 ? _b : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      yield Promise.all(Object.entries(state.pages[slug].scopes).map(([, { notebook }]) => __awaiter2(this, void 0, void 0, function* () {
        const execReturns = yield notebook.executeAll(true);
        const errs = (0, import_thebe_react2.findErrors)(execReturns);
        if (errs != null) {
          console.error("errors", errs);
          busy.setError(slug, notebook.id, errs);
          busy.clearNotebook(slug, notebook.id, "execute");
        }
      })));
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clearAll = (0, import_react45.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([, { notebook }]) => {
      notebook.clear();
    });
  }, [state]);
  const resetAll = (0, import_react45.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([notebookSlug, { notebook, session }]) => {
      busy.clearError(pageSlug, notebookSlug);
      busy.setNotebook(pageSlug, notebookSlug, notebook.code.map((c6) => c6.id), "reset");
      setTimeout(() => {
        var _a3;
        notebook.reset();
        (_a3 = session === null || session === void 0 ? void 0 : session.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().finally(() => {
          busy.clearNotebook(pageSlug, notebookSlug, "reset");
        });
      }, 300);
    });
  }, [state]);
  const ready = (_a = context.state.pages[context.slug]) === null || _a === void 0 ? void 0 : _a.ready;
  return Object.assign(Object.assign({}, context), { ready, start, clearAll, resetAll, execute });
}
function useNotebookExecution(id, clearOutputsOnExecute = false) {
  var _a, _b;
  const context = import_react45.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react2.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useNotebookExecution must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  const start = (0, import_react45.useCallback)(() => {
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug: context.slug
      }
    });
  }, [target]);
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const execute = () => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "execute");
    if (clearOutputsOnExecute)
      nb.clear();
    setTimeout(() => __awaiter2(this, void 0, void 0, function* () {
      const handler = (_5, data) => {
        var _a2;
        if (data.subject === "cell" && data.status === "idle") {
          busy.clearCell(pageSlug, notebookSlug, (_a2 = data.id) !== null && _a2 !== void 0 ? _a2 : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      const execReturns = yield nb.executeAll(true);
      const errs = (0, import_thebe_react2.findErrors)(execReturns);
      if (errs != null) {
        console.error("an error occurred during notebook execution");
        busy.setError(pageSlug, notebookSlug, errs);
        busy.clearNotebook(pageSlug, notebookSlug, "execute");
      }
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clear = (0, import_react45.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    nb.clear();
  }, [state]);
  const reset = (0, import_react45.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "reset");
    setTimeout(() => {
      var _a2, _b2;
      nb.reset();
      (_b2 = (_a2 = nb.session) === null || _a2 === void 0 ? void 0 : _a2.kernel) === null || _b2 === void 0 ? void 0 : _b2.restart().finally(() => {
        busy.clearNotebook(pageSlug, notebookSlug, "reset");
      });
    }, 300);
  }, [state]);
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return Object.assign(Object.assign({}, context), {
    ready,
    start,
    clear,
    reset,
    execute,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    executionCount: cell === null || cell === void 0 ? void 0 : cell.executionCount
  });
}
function useCellExecution(id, clearOutputsOnExecute = false) {
  var _a, _b, _c, _d;
  const busy = useBusyScope();
  const context = import_react45.default.useContext(ExecuteScopeContext);
  if (context === void 0) {
    throw new Error("useCellExecution must be used within a ExecuteScopeProvider");
  }
  const { state, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const kind = (_d = (_c = context.state.pages[context.slug]) === null || _c === void 0 ? void 0 : _c.kind) !== null && _d !== void 0 ? _d : SourceFileKind.Article;
  const execute = (0, import_react45.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on execute", { pageSlug, notebookSlug, cellId });
      return;
    }
    busy.setCell(pageSlug, notebookSlug, cell.id, "execute");
    if (clearOutputsOnExecute)
      cell.clear();
    setTimeout(() => {
      if (!cell)
        throw new Error("no cell found on execute");
      cell.execute().then(() => {
        if (!cell)
          throw new Error("no cell found after execute");
        busy.clearCell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute");
      });
    }, 100);
  }, [state, cell]);
  const clear = (0, import_react45.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on clear", { pageSlug, notebookSlug, cellId });
      return;
    }
    cell.clear();
  }, [state, cell]);
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return {
    canCompute: context.canCompute,
    kind,
    ready,
    execute,
    clear,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    cell
  };
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react3 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/controls/Buttons.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_classnames17 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/controls/Spinner.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function Spinner2({ size: size3 }) {
  return (0, import_jsx_runtime45.jsxs)("div", { role: "status", children: [(0, import_jsx_runtime45.jsxs)("svg", { "aria-hidden": "true", width: size3, height: size3, className: "mr-2 text-gray-200 animate-spin dark:text-gray-600 fill-green-600", viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime45.jsx)("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor" }), (0, import_jsx_runtime45.jsx)("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }), (0, import_jsx_runtime45.jsx)("span", { className: "sr-only", children: "Loading..." })] });
}

// ../../node_modules/swr/immutable/dist/index.mjs
var immutable = (useSWRNext) => (key, fetcher7, config) => {
  config.revalidateOnFocus = false;
  config.revalidateIfStale = false;
  config.revalidateOnReconnect = false;
  return useSWRNext(key, fetcher7, config);
};
var useSWRImmutable = withMiddleware(useSWR, immutable);

// ../../packages/jupyter/dist/hooks.js
var import_react46 = __toESM(require_react(), 1);
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function fetcher6(url) {
  return __awaiter3(this, void 0, void 0, function* () {
    const resp = yield fetch(url);
    if (resp.status === 200) {
      const content = yield resp.text();
      if (url.endsWith(".json")) {
        try {
          const data = JSON.parse(content);
          const keys2 = Object.keys(data);
          if (keys2.length === 2 && keys2.includes("content") && keys2.includes("content_type")) {
            return data;
          }
        } catch (error) {
        }
      }
      return { content };
    }
    throw new Error(`Content returned with status ${resp.status}.`);
  });
}
function useLongContent(content, url) {
  if (typeof document === "undefined") {
    return url ? {} : { data: { content: content !== null && content !== void 0 ? content : "" } };
  }
  const { data, error } = useSWRImmutable(url || null, fetcher6);
  if (!url)
    return { data: { content: content !== null && content !== void 0 ? content : "" } };
  return { data, error };
}
var arrayFetcher = (...urls) => {
  return Promise.all(urls.map((url) => fetcher6(url[0])));
};
function shallowCloneOutputs(outputs) {
  return outputs.map((output) => {
    if ("data" in output && output.data) {
      const data = output.data;
      return Object.assign(Object.assign({}, output), { data: Object.entries(data).reduce((acc, [mimetype, payload]) => {
        return Object.assign(Object.assign({}, acc), { [mimetype]: Object.assign({}, payload) });
      }, {}) });
    }
    return Object.assign({}, output);
  });
}
function useFetchAnyTruncatedContent(outputs) {
  const itemsWithPaths = [];
  const updated = shallowCloneOutputs(outputs);
  walkOutputs(updated, (obj) => {
    if ("content_type" in obj && obj.content_type.startsWith("image/"))
      return;
    if (obj.path) {
      itemsWithPaths.push(obj);
    }
  });
  const { data, error } = useSWRImmutable(itemsWithPaths.map(({ path }) => path), arrayFetcher);
  data === null || data === void 0 ? void 0 : data.forEach(({ content }, idx) => {
    const obj = itemsWithPaths[idx];
    if ("text" in obj) {
      obj.text = content;
    } else if ("traceback" in obj) {
      obj.traceback = content;
    } else {
      obj.content = content;
    }
    obj.path = void 0;
  });
  return {
    data: itemsWithPaths.length === 0 || data ? updated : void 0,
    error
  };
}

// ../../packages/jupyter/dist/controls/Buttons.js
function SpinnerStatusButton({ ready, busy, modified, onClick }) {
  let title = "Enable compute to make this figure interactive";
  if (ready) {
    title = modified ? "The figure has been modified" : "The figure is in its original state";
  }
  let icon = (0, import_jsx_runtime46.jsx)(PowerIcon_default, { width: "1.5rem", height: "1.5rem" });
  if (ready) {
    if (modified) {
      icon = (0, import_jsx_runtime46.jsx)(BoltIcon_default, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    } else {
      icon = (0, import_jsx_runtime46.jsx)(BoltIcon_default2, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    }
  }
  return (0, import_jsx_runtime46.jsxs)("div", { className: "relative flex text-sm", children: [(0, import_jsx_runtime46.jsx)("button", { className: (0, import_classnames17.default)("cursor-pointer text-gray-700 dark:text-white active:text-green-700 hover:opacity-100", {
    "opacity-10": busy,
    "opacity-70": !busy
  }), disabled: ready, title, "aria-label": `status`, onClick: onClick !== null && onClick !== void 0 ? onClick : () => ({}), children: icon }), busy && (0, import_jsx_runtime46.jsx)("span", { className: "absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime46.jsx)(Spinner2, { size: 24 }) })] });
}
function SpinnerButton({ ready, icon, busy, disabled, title, onClick }) {
  return (0, import_jsx_runtime46.jsxs)("div", { className: "relative flex text-sm", children: [(0, import_jsx_runtime46.jsx)("button", { className: (0, import_classnames17.default)(" text-gray-700 dark:text-white active:text-green-700 ", {
    "opacity-10 hover:opacity-10": busy,
    "opacity-70": !busy && !disabled,
    "cursor-pointer hover:opacity-100": !disabled,
    "cursor-not-allowed opacity-10 hover:opacity-10": disabled
  }), disabled: disabled || !ready || busy, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "run all cells", "aria-label": title !== null && title !== void 0 ? title : "run all cells", children: icon }), busy && (0, import_jsx_runtime46.jsx)("span", { className: "absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime46.jsx)(Spinner2, { size: 24 }) })] });
}
function Run({ ready, executing, disabled, title, onClick }) {
  return (0, import_jsx_runtime46.jsx)(SpinnerButton, { ready, busy: executing, disabled, title: title !== null && title !== void 0 ? title : "run all cells", onClick, icon: (0, import_jsx_runtime46.jsx)(PlayCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Restart({ ready, resetting, disabled, title, onClick }) {
  return (0, import_jsx_runtime46.jsx)(SpinnerButton, { ready, busy: resetting, disabled, title: title !== null && title !== void 0 ? title : "reset notebook", onClick, icon: (0, import_jsx_runtime46.jsx)(ArrowUturnLeftIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Clear({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime46.jsx)("button", { className: (0, import_classnames17.default)("flex text-gray-700 dark:text-white", {
    "cursor-not-allowed opacity-10": disabled || !ready,
    "active:text-green-700 opacity-70 hover:opacity-100 cursor-pointer": !disabled
  }), disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "clear", "aria-label": title !== null && title !== void 0 ? title : "clear", children: (0, import_jsx_runtime46.jsx)(MinusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Launch({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime46.jsx)("button", { className: "flex items-center text-gray-700 cursor-pointer dark:text-white active:text-green-700 opacity-70 hover:opacity-100", disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "launch in jupyter", "aria-label": title !== null && title !== void 0 ? title : "launch in jupyter", children: (0, import_jsx_runtime46.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
function ArticleStatusBadge({ id }) {
  const { connect, connecting } = (0, import_thebe_react3.useThebeServer)();
  const { slug, state, start, ready, executionCount } = useNotebookExecution(id);
  const building = selectAreExecutionScopesBuilding(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("ArticleStatusBadge: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start();
  };
  return (0, import_jsx_runtime47.jsx)(SpinnerStatusButton, { ready, busy: building || connecting, modified: executionCount != null, onClick: handleStart });
}
function ArticleRunNotebook({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime47.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute, title: "Run the notebook that creates this figure" });
}
function ArticleResetNotebook({ id }) {
  const { ready, notebookIsResetting, notebookIsBusy, reset } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime47.jsx)(Restart, { ready, resetting: notebookIsResetting, disabled: notebookIsBusy, onClick: reset, title: "Reset the figure to its original state and restart the kernel" });
}

// ../../packages/jupyter/dist/providers.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/utils.js
function isObject3(maybeObject) {
  return typeof maybeObject === "object" && maybeObject !== null;
}
function thebeFrontmatterToOptions(fm) {
  if (fm === void 0)
    return void 0;
  const { binder, server, lite, kernelName, disableSessionSaving, mathjaxConfig, mathjaxUrl } = fm !== null && fm !== void 0 ? fm : {};
  const thebeOptions = { mathjaxConfig, mathjaxUrl };
  if (disableSessionSaving) {
    thebeOptions.savedSessionOptions = { enabled: false };
  }
  if (kernelName) {
    thebeOptions.kernelOptions = {
      kernelName
    };
  }
  if (binder) {
    thebeOptions.useBinder = true;
    const { repo, ref, url, provider } = binder;
    thebeOptions.binderOptions = { repo, ref, binderUrl: url, repoProvider: provider };
  }
  if (lite === true) {
    thebeOptions.useJupyterLite = true;
  }
  if (isObject3(server)) {
    const { url, token } = server;
    thebeOptions.serverSettings = {};
    if (url)
      thebeOptions.serverSettings.baseUrl = url;
    if (token)
      thebeOptions.serverSettings.token = token;
  }
  return thebeOptions;
}

// ../../packages/jupyter/dist/providers.js
var import_thebe_react4 = __toESM(require_dist3(), 1);
var ComputeOptionsContext = import_react47.default.createContext(void 0);
function ComputeOptionsProvider({ features, optionOverrideFn, customRepoProviders, children }) {
  const project = useProjectManifest();
  const options = import_react47.default.useMemo(() => {
    if (!project)
      return;
    const thebeFrontmatter = project === null || project === void 0 ? void 0 : project.thebe;
    const githubBadgeUrl = project === null || project === void 0 ? void 0 : project.github;
    const binderBadgeUrl = project === null || project === void 0 ? void 0 : project.binder;
    const optionsFromFrontmatter = thebeFrontmatterToOptions(thebeFrontmatter);
    const optionsWithOverrides = optionOverrideFn ? optionOverrideFn(optionsFromFrontmatter) : optionsFromFrontmatter;
    return {
      enabled: !!optionsWithOverrides,
      thebe: optionsWithOverrides,
      githubBadgeUrl,
      binderBadgeUrl,
      features,
      customRepoProviders
    };
  }, [project, optionOverrideFn]);
  return (0, import_jsx_runtime48.jsx)(ComputeOptionsContext.Provider, { value: options, children });
}
function useComputeOptions() {
  return (0, import_react47.useContext)(ComputeOptionsContext);
}
function ThebeLoaderAndServer({ baseurl, connect, children }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const compute = useComputeOptions();
  return (0, import_jsx_runtime48.jsx)(import_thebe_react4.ThebeBundleLoaderProvider, { loadThebeLite: (_b = (_a = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _a === void 0 ? void 0 : _a.useJupyterLite) !== null && _b !== void 0 ? _b : false, publicPath: baseurl, children: (0, import_jsx_runtime48.jsx)(import_thebe_react4.ThebeServerProvider, { connect: connect !== null && connect !== void 0 ? connect : false, options: compute === null || compute === void 0 ? void 0 : compute.thebe, useBinder: (_d = (_c = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _c === void 0 ? void 0 : _c.useBinder) !== null && _d !== void 0 ? _d : false, useJupyterLite: (_f = (_e = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _e === void 0 ? void 0 : _e.useJupyterLite) !== null && _f !== void 0 ? _f : false, customRepoProviders: (_g = compute === null || compute === void 0 ? void 0 : compute.customRepoProviders) !== null && _g !== void 0 ? _g : [], children }) });
}

// ../../packages/jupyter/dist/decoration.js
var PlaceholderContext = import_react48.default.createContext({});
function PlaceholderProvider({ placeholder: placeholder2, children }) {
  const value = import_react48.default.useMemo(() => ({ placeholder: placeholder2 }), [placeholder2]);
  return (0, import_jsx_runtime49.jsx)(PlaceholderContext.Provider, { value, children });
}
function usePlaceholder() {
  const context = import_react48.default.useContext(PlaceholderContext);
  return context.placeholder;
}
function OutputDecoration({ outputId, placeholder: placeholder2, children, title = "Jupyter Notebook", url, remoteBaseUrl }) {
  const { kind } = useCellExecution(outputId);
  const compute = useComputeOptions();
  const Link2 = useLinkProvider();
  const top = useThemeTop();
  const baseurl = useBaseurl();
  const showComputeControls = (compute === null || compute === void 0 ? void 0 : compute.enabled) && (compute === null || compute === void 0 ? void 0 : compute.features.figureCompute) && kind === SourceFileKind.Article && !remoteBaseUrl;
  if (showComputeControls) {
    return (0, import_jsx_runtime49.jsxs)("div", { className: "mb-4 shadow", children: [(0, import_jsx_runtime49.jsx)("div", { className: "sticky z-[2] w-full bg-gray-100/80 backdrop-blur dark:bg-neutral-800/80 py-1 px-2", style: { top }, children: (0, import_jsx_runtime49.jsxs)("div", { className: "flex items-center", children: [(0, import_jsx_runtime49.jsxs)("div", { className: "flex items-center", children: [(0, import_jsx_runtime49.jsx)(JupyterIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block" }), (0, import_jsx_runtime49.jsx)("span", { className: "ml-2", children: "Source:" }), url && (0, import_jsx_runtime49.jsx)(Link2, { to: withBaseurl(url, remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : baseurl), className: "ml-2 no-underline text-normal hover:underline", children: title })] }), (0, import_jsx_runtime49.jsx)("div", { className: "flex-grow" }), (0, import_jsx_runtime49.jsx)(ArticleStatusBadge, { id: outputId }), (0, import_jsx_runtime49.jsx)(ArticleRunNotebook, { id: outputId }), (0, import_jsx_runtime49.jsx)(ArticleResetNotebook, { id: outputId })] }) }), (0, import_jsx_runtime49.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  if (kind === SourceFileKind.Article) {
    return (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [(0, import_jsx_runtime49.jsxs)("div", { className: "flex items-center justify-end text-xs", children: [(0, import_jsx_runtime49.jsx)(JupyterIcon_default, { width: "0.75rem", height: "0.75rem", className: "inline-block" }), (0, import_jsx_runtime49.jsx)("div", { className: "ml-1", children: "Source:" }), url && (0, import_jsx_runtime49.jsx)(Link2, { to: withBaseurl(url, remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : baseurl), className: "ml-1 no-underline text-normal hover:underline", children: title })] }), (0, import_jsx_runtime49.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  return (0, import_jsx_runtime49.jsx)(import_jsx_runtime49.Fragment, { children });
}

// ../../packages/jupyter/dist/embed.js
function Embed({ node }) {
  var _a, _b, _c, _d;
  const output = (_a = node.children) === null || _a === void 0 ? void 0 : _a.find((child) => child.type === "output");
  if (!output)
    return (0, import_jsx_runtime50.jsx)(MyST, { ast: node.children });
  return (0, import_jsx_runtime50.jsx)(OutputDecoration, { outputId: output.id, title: (_b = node.source) === null || _b === void 0 ? void 0 : _b.title, url: (_c = node.source) === null || _c === void 0 ? void 0 : _c.url, remoteBaseUrl: (_d = node.source) === null || _d === void 0 ? void 0 : _d.remoteBaseUrl, children: (0, import_jsx_runtime50.jsx)(MyST, { ast: node.children }) }, node.key);
}

// ../../packages/jupyter/dist/output.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_classnames19 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/safe.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/stream.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@curvenote/ansi-to-react/dist/index.js
var import_anser = __toESM(require_lib15(), 1);
var import_escape_carriage = __toESM(require_escape_carriage(), 1);
var React72 = __toESM(require_react(), 1);
function ansiToJSON(input, use_classes = false) {
  input = (0, import_escape_carriage.escapeCarriageReturn)(fixBackspace(input));
  return import_anser.default.ansiToJson(input, {
    json: true,
    remove_empty: true,
    use_classes
  });
}
function createClass(bundle) {
  let classNames40 = "";
  if (bundle.bg) {
    classNames40 += `${bundle.bg}-bg `;
  }
  if (bundle.fg) {
    classNames40 += `${bundle.fg}-fg `;
  }
  if (bundle.decoration) {
    classNames40 += `ansi-${bundle.decoration} `;
  }
  if (classNames40 === "") {
    return null;
  }
  classNames40 = classNames40.substring(0, classNames40.length - 1);
  return classNames40;
}
function createStyle(bundle) {
  const style = {};
  if (bundle.bg) {
    style.backgroundColor = `rgb(${bundle.bg})`;
  }
  if (bundle.fg) {
    style.color = `rgb(${bundle.fg})`;
  }
  switch (bundle.decoration) {
    case "bold":
      style.fontWeight = "bold";
      break;
    case "dim":
      style.opacity = "0.5";
      break;
    case "italic":
      style.fontStyle = "italic";
      break;
    case "hidden":
      style.visibility = "hidden";
      break;
    case "strikethrough":
      style.textDecoration = "line-through";
      break;
    case "underline":
      style.textDecoration = "underline";
      break;
    case "blink":
      style.textDecoration = "blink";
      break;
    default:
      break;
  }
  return style;
}
function convertBundleIntoReact(linkify, useClasses, bundle, key) {
  const style = useClasses ? null : createStyle(bundle);
  const className = useClasses ? createClass(bundle) : null;
  if (!linkify) {
    return React72.createElement("span", { style, key, className }, bundle.content);
  }
  const content = [];
  const linkRegex = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g;
  let index2 = 0;
  let match;
  while ((match = linkRegex.exec(bundle.content)) !== null) {
    const [, pre, url] = match;
    const startIndex = match.index + pre.length;
    if (startIndex > index2) {
      content.push(bundle.content.substring(index2, startIndex));
    }
    const href = url.startsWith("www.") ? `http://${url}` : url;
    content.push(React72.createElement("a", {
      key: index2,
      href,
      target: "_blank"
    }, `${url}`));
    index2 = linkRegex.lastIndex;
  }
  if (index2 < bundle.content.length) {
    content.push(bundle.content.substring(index2));
  }
  return React72.createElement("span", { style, key, className }, content);
}
function Ansi(props) {
  const { className, useClasses, children, linkify } = props;
  return React72.createElement("code", { className }, ansiToJSON(children !== null && children !== void 0 ? children : "", useClasses !== null && useClasses !== void 0 ? useClasses : false).map(convertBundleIntoReact.bind(null, linkify !== null && linkify !== void 0 ? linkify : false, useClasses !== null && useClasses !== void 0 ? useClasses : false)));
}
function fixBackspace(txt) {
  let tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}

// ../../packages/jupyter/dist/components.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var MaybeLongContent = ({ content, path, render }) => {
  const { error, data } = useLongContent(content, path);
  if (error) {
    return (0, import_jsx_runtime51.jsxs)("div", { className: "text-red-500", children: ["Error loading content: ", error.message] });
  }
  if (!data) {
    return (0, import_jsx_runtime51.jsx)("div", { children: "Fetching long content...." });
  }
  return (0, import_jsx_runtime51.jsx)("div", { children: render(data.content) });
};

// ../../packages/jupyter/dist/stream.js
function Stream({ output }) {
  return (0, import_jsx_runtime52.jsx)(MaybeLongContent, { content: ensureString(output.text), path: output.path, render: (content) => (0, import_jsx_runtime52.jsx)("pre", { className: "text-sm font-thin font-system", children: (0, import_jsx_runtime52.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) }) });
}

// ../../packages/jupyter/dist/error.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
function Error2({ output }) {
  return (0, import_jsx_runtime53.jsx)(MaybeLongContent, { content: ensureString(output.traceback), path: output.path, render: (content) => {
    return (0, import_jsx_runtime53.jsx)("pre", { className: "text-sm font-thin font-system jupyter-error", children: (0, import_jsx_runtime53.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) });
  } });
}

// ../../packages/jupyter/dist/safe.js
var RENDER_PRIORITY = [
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageBmp
];
function findSafeMimeOutputs(output) {
  const data = output.data;
  const image = RENDER_PRIORITY.reduce((acc, mimetype) => {
    if (acc)
      return acc;
    if (data && data[mimetype])
      return data[mimetype];
    return void 0;
  }, void 0);
  const text = data && data["text/plain"];
  return { image, text };
}
function OutputImage({ image, text }) {
  var _a;
  return (0, import_jsx_runtime54.jsx)("img", { src: image === null || image === void 0 ? void 0 : image.path, alt: (_a = text === null || text === void 0 ? void 0 : text.content) !== null && _a !== void 0 ? _a : "Image produced in Jupyter" });
}
function SafeOutput({ output }) {
  switch (output.output_type) {
    case "stream":
      return (0, import_jsx_runtime54.jsx)(Stream, { output });
    case "error":
      return (0, import_jsx_runtime54.jsx)(Error2, { output });
    case "display_data":
    case "execute_result":
    case "update_display_data": {
      const { image, text } = findSafeMimeOutputs(output);
      if (!image && !text)
        return null;
      if (image)
        return (0, import_jsx_runtime54.jsx)(OutputImage, { image, text });
      if (text)
        return (0, import_jsx_runtime54.jsx)("div", { className: "font-mono text-sm whitespace-pre-wrap", children: (0, import_jsx_runtime54.jsx)(Ansi, { children: text.content }) });
      return null;
    }
    default:
      console.warn(`Unknown output_type ${output["output_type"]}`);
      return null;
  }
}
function SafeOutputs({ keyStub, outputs }) {
  if (!outputs)
    return null;
  const components = outputs.map((output, idx) => (0, import_jsx_runtime54.jsx)(SafeOutput, { output }, `${keyStub}-${idx}`));
  return (0, import_jsx_runtime54.jsx)(import_jsx_runtime54.Fragment, { children: components });
}

// ../../packages/jupyter/dist/jupyter.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/convertImages.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function requestImageAsBase64String(src) {
  return __awaiter4(this, void 0, void 0, function* () {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    const base64String = new Promise((resolve, reject4) => {
      img.onload = function ol() {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          console.error("Could not get canvas context");
          return reject4();
        }
        canvas.height = img.naturalHeight;
        canvas.width = img.naturalWidth;
        ctx.drawImage(img, 0, 0);
        const dataURL = canvas.toDataURL("image/png");
        const [, base64] = dataURL.split(";base64,");
        resolve(base64);
      };
      img.src = src;
    });
    return base64String;
  });
}
function fetchAndEncodeOutputImages(outputs) {
  return __awaiter4(this, void 0, void 0, function* () {
    return Promise.all(outputs.map((output) => __awaiter4(this, void 0, void 0, function* () {
      if (!("data" in output))
        return output;
      const imageMimetypes = Object.keys(output.data).filter((mimetype) => mimetype !== "image/svg" && mimetype !== "image/svg+xml" && mimetype.startsWith("image/"));
      if (imageMimetypes.length === 0)
        return output;
      const images = yield Promise.all(imageMimetypes.map((mimetype) => __awaiter4(this, void 0, void 0, function* () {
        const data = output.data[mimetype];
        if (data.path) {
          const base64 = yield requestImageAsBase64String(data.path);
          return Object.assign(Object.assign({}, data), { content: base64 });
        }
        return data;
      })));
      imageMimetypes.forEach((mimetype, i5) => {
        output.data[mimetype] = images[i5];
      });
      return output;
    })));
  });
}

// ../../packages/jupyter/dist/jupyter.js
var import_thebe_react5 = __toESM(require_dist3(), 1);
var import_classnames18 = __toESM(require_classnames(), 1);
function ActiveOutputRenderer({ id, initialData, core: core2 }) {
  var _a;
  const exec = useCellExecution(id);
  const placeholder2 = usePlaceholder();
  const ref = (0, import_react50.useRef)(null);
  (0, import_react50.useEffect)(() => {
    var _a2, _b, _c;
    if (!ref.current || !(exec === null || exec === void 0 ? void 0 : exec.cell)) {
      console.debug(`Jupyter: No cell ref available for cell ${id}:${(_a2 = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a2 === void 0 ? void 0 : _a2.id}`);
      return;
    }
    const verb = exec.cell.isAttachedToDOM ? "reattaching" : "attaching";
    console.debug(`${verb} cell ${exec.cell.id} to DOM at:`, {
      el: ref.current,
      connected: ref.current.isConnected,
      data: (_b = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(initialData)) !== null && _b !== void 0 ? _b : initialData
    });
    exec.cell.attachToDOM(ref.current);
    if (exec.cell.executionCount == null) {
      exec.cell.initOutputs((_c = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(initialData, true, placeholder2 ? () => "" : void 0)) !== null && _c !== void 0 ? _c : initialData);
    }
  }, [ref === null || ref === void 0 ? void 0 : ref.current, exec === null || exec === void 0 ? void 0 : exec.cell]);
  const executed = ((_a = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a === void 0 ? void 0 : _a.executionCount) != null;
  console.debug(`Jupyter: Cell ${id} executed: ${executed}; Show output: ${executed || !placeholder2}`);
  return (0, import_jsx_runtime55.jsxs)("div", { children: [(0, import_jsx_runtime55.jsx)("div", { ref, "data-thebe-active-ref": "true", className: (0, import_classnames18.default)("relative", { "invisible h-0": !executed && placeholder2 }) }), placeholder2 && !executed && (0, import_jsx_runtime55.jsx)(MyST, { ast: placeholder2 })] });
}
function PassiveOutputRenderer({ id, data, core: core2 }) {
  const rendermime = core2.makeRenderMimeRegistry();
  const cell = (0, import_react50.useRef)(new core2.PassiveCellRenderer(id, rendermime, void 0));
  const ref = (0, import_react50.useRef)(null);
  const { loaded } = usePlotlyPassively(rendermime, data);
  (0, import_react50.useEffect)(() => {
    var _a, _b;
    if (!ref.current || !loaded)
      return;
    cell.current.attachToDOM((_a = ref.current) !== null && _a !== void 0 ? _a : void 0, true);
    cell.current.render((_b = core2 === null || core2 === void 0 ? void 0 : core2.stripWidgets(data)) !== null && _b !== void 0 ? _b : data);
  }, [ref, loaded]);
  return (0, import_jsx_runtime55.jsx)("div", { ref, "data-thebe-passive-ref": "true" });
}
var JupyterOutputs = import_react50.default.memo(({ id, outputs }) => {
  const { core: core2, load: load2 } = (0, import_thebe_react5.useThebeLoader)();
  const { inCrossRef } = useXRefState();
  const { data, error } = useFetchAnyTruncatedContent(outputs);
  const [fullOutputs, setFullOutputs] = (0, import_react50.useState)(null);
  const exec = useCellExecution(id);
  const placeholder2 = usePlaceholder();
  (0, import_react50.useEffect)(() => {
    if (core2)
      return;
    load2();
  }, [core2, load2]);
  (0, import_react50.useEffect)(() => {
    if (!data || fullOutputs != null)
      return;
    fetchAndEncodeOutputImages(data).then((out) => {
      const compactOutputs = convertToIOutputs(out, {});
      setFullOutputs(compactOutputs);
    });
  }, [id, data, fullOutputs]);
  if (error) {
    console.error(error);
    return (0, import_jsx_runtime55.jsxs)("div", { className: "text-red-500", children: ["Error rendering output: ", error.message] });
  }
  if (!inCrossRef && (exec === null || exec === void 0 ? void 0 : exec.ready)) {
    return (0, import_jsx_runtime55.jsxs)("div", { children: [!fullOutputs && (0, import_jsx_runtime55.jsx)("div", { className: "p-2.5", children: "Fetching full output data..." }), core2 && fullOutputs && (0, import_jsx_runtime55.jsx)(ActiveOutputRenderer, { id, initialData: fullOutputs, core: core2 }, id)] });
  }
  if (placeholder2) {
    return (0, import_jsx_runtime55.jsx)(MyST, { ast: placeholder2 });
  }
  return (0, import_jsx_runtime55.jsxs)("div", { children: [!fullOutputs && (0, import_jsx_runtime55.jsx)("div", { className: "p-2.5", children: "Loading..." }), fullOutputs && core2 && (0, import_jsx_runtime55.jsx)(PassiveOutputRenderer, { id, data: fullOutputs, core: core2, kind: SourceFileKind.Notebook })] });
});

// ../../packages/jupyter/dist/output.js
var import_react51 = __toESM(require_react(), 1);
var DIRECT_OUTPUT_TYPES = /* @__PURE__ */ new Set(["stream", "error"]);
var DIRECT_MIME_TYPES = /* @__PURE__ */ new Set([
  KnownCellOutputMimeTypes.TextPlain,
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageBmp
]);
function allOutputsAreSafe(outputs, directOutputTypes, directMimeTypes) {
  if (!outputs || outputs.length === 0)
    return true;
  return outputs.reduce((flag, output) => {
    if (directOutputTypes.has(output.output_type))
      return flag && true;
    const data = output.data;
    const mimetypes = data ? Object.keys(data) : [];
    const safe = "data" in output && Boolean(output.data) && mimetypes.every((mimetype) => directMimeTypes.has(mimetype));
    return flag && safe;
  }, true);
}
function JupyterOutput({ outputId, identifier, data, align, className }) {
  const { ready } = useCellExecution(outputId);
  const outputs = data;
  const allSafe = (0, import_react51.useMemo)(() => allOutputsAreSafe(outputs, DIRECT_OUTPUT_TYPES, DIRECT_MIME_TYPES), [outputs]);
  const placeholder2 = usePlaceholder();
  let component;
  if (allSafe && !ready) {
    if (placeholder2 && (!outputs || outputs.length === 0)) {
      if (placeholder2) {
        return (0, import_jsx_runtime56.jsx)(MyST, { ast: placeholder2 });
      }
    }
    component = (0, import_jsx_runtime56.jsx)(SafeOutputs, { keyStub: outputId, outputs });
  } else {
    component = (0, import_jsx_runtime56.jsx)(JupyterOutputs, { id: outputId, outputs });
  }
  return (0, import_jsx_runtime56.jsx)("div", { id: identifier || void 0, "data-mdast-node-id": outputId, className: (0, import_classnames19.default)("max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative", {
    "text-left": !align || align === "left",
    "text-center": align === "center",
    "text-right": align === "right",
    "mb-5": outputs && outputs.length > 0
  }, className), children: component });
}
function Output({ node }) {
  return (0, import_jsx_runtime56.jsx)(JupyterOutput, { className: (0, import_classnames19.default)({ hidden: node.visibility === "remove" }), outputId: node.id, identifier: node.identifier, align: node.align, data: node.data });
}

// ../../packages/jupyter/dist/figure.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_classnames20 = __toESM(require_classnames(), 1);
function Figure({ node }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { container: Container } = DEFAULT_RENDERERS;
  const isFromJupyer = ((_a = node.source) === null || _a === void 0 ? void 0 : _a.kind) === SourceFileKind.Notebook;
  const output = (_b = node.children) === null || _b === void 0 ? void 0 : _b.find((child) => child.type === "output");
  if (isFromJupyer && !!output) {
    const placeholder2 = (_c = node.children) === null || _c === void 0 ? void 0 : _c.find((child) => child.type === "image" && child.placeholder);
    const others = (_d = node.children) === null || _d === void 0 ? void 0 : _d.filter((child) => !(child.type === "image" && child.placeholder));
    return (0, import_jsx_runtime57.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames20.default)({ subcontainer: node.subcontainer }, node.class), children: (0, import_jsx_runtime57.jsx)(OutputDecoration, { outputId: output.id, placeholder: placeholder2, title: (_e = node.source) === null || _e === void 0 ? void 0 : _e.title, url: (_f = node.source) === null || _f === void 0 ? void 0 : _f.url, remoteBaseUrl: (_g = node.source) === null || _g === void 0 ? void 0 : _g.remoteBaseUrl, children: (0, import_jsx_runtime57.jsx)(MyST, { ast: others }) }, node.key) });
  }
  return (0, import_jsx_runtime57.jsx)(Container, { node });
}

// ../../packages/jupyter/dist/BinderBadge.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/ErrorTray.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var import_thebe_react6 = __toESM(require_dist3(), 1);
function ErrorDecoration({ children, idx }) {
  return (0, import_jsx_runtime59.jsxs)("div", { className: "relative py-3 mx-2 my-8 border rounded", children: [(0, import_jsx_runtime59.jsx)("div", { className: "absolute z-10 flex items-center bg-white -top-3 -left-2", children: idx && (0, import_jsx_runtime59.jsxs)("div", { className: "ml-1 text-sm text-gray-500", children: ["cell #: ", idx + 1] }) }), (0, import_jsx_runtime59.jsx)("div", { className: "mx-3", children })] });
}
function ErrorTrayMessage({ errors }) {
  const { core: core2 } = (0, import_thebe_react6.useThebeLoader)();
  const [cells, setCells] = (0, import_react52.useState)([]);
  const [refs, setRefs] = (0, import_react52.useState)([]);
  (0, import_react52.useEffect)(() => {
    if (!core2)
      return;
    const cs = errors.map(() => new core2.PassiveCellRenderer("any"));
    setRefs(errors.map((_5, idx) => (node) => {
      var _a;
      if (node) {
        cs[idx].attachToDOM(node);
        cs[idx].render((_a = errors[idx].error) !== null && _a !== void 0 ? _a : []);
      }
    }));
    setCells(cells);
  }, [core2, errors]);
  if (!core2)
    return null;
  return (0, import_jsx_runtime59.jsx)("div", { children: errors.map((error, idx) => (0, import_jsx_runtime59.jsx)("div", { className: "not-prose min-w-[400px]", children: (0, import_jsx_runtime59.jsx)(ErrorDecoration, { idx: error.index, children: (0, import_jsx_runtime59.jsx)("div", { className: "z-100", ref: refs[idx] }, error.id) }) }, `error-${error.id}`)) });
}
function ErrorTray({ pageSlug, index: index2 }) {
  const { items } = useBusyErrors(pageSlug);
  if (!items || items.length === 0)
    return null;
  if (index2 && index2)
    return null;
  return (0, import_jsx_runtime59.jsx)("div", { className: "relative px-4 pt-3 my-8 text-sm text-red-600 border border-red-400 rounded border-1", children: items.map(({ notebookSlug, errors }, i5) => {
    return (0, import_jsx_runtime59.jsxs)("div", { children: [(0, import_jsx_runtime59.jsxs)("div", { children: [(0, import_jsx_runtime59.jsx)("span", { className: "font-bold", children: "Error" }), " in notebook ", (0, import_jsx_runtime59.jsxs)("span", { children: ['"', notebookSlug, '"'] })] }), (0, import_jsx_runtime59.jsx)(ErrorTrayMessage, { errors })] }, `${notebookSlug}-${i5}`);
  }) });
}

// ../../packages/jupyter/dist/ConnectionStatusTray.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_thebe_react7 = __toESM(require_dist3(), 1);
function ConnectionStatusTray({ waitForSessions }) {
  var _a, _b, _c;
  const options = useComputeOptions();
  const { connecting, ready: serverReady, error: serverError, events: events2 } = (0, import_thebe_react7.useThebeServer)();
  const { slug, ready: scopeReady, state } = useExecutionScope();
  const [show, setShow] = (0, import_react53.useState)(false);
  const [unsub, setUnsub] = (0, import_react53.useState)();
  const [status, setStatus] = (0, import_react53.useState)("[client] Connecting...");
  const error = serverError;
  const ready = serverReady && (!waitForSessions || scopeReady);
  const busy = connecting || selectAreExecutionScopesBuilding(state, slug);
  const handleStatus = (event, data) => {
    setStatus(`[${data.subject}]: ${data.message}`);
  };
  (0, import_react53.useEffect)(() => {
    if (!events2)
      return;
    events2.on("status", handleStatus);
  }, [events2]);
  (0, import_react53.useEffect)(() => {
    if (!(options === null || options === void 0 ? void 0 : options.thebe))
      return;
    if (busy || error) {
      setShow(true);
    } else if (ready) {
      setTimeout(() => {
        setShow(false);
        unsub === null || unsub === void 0 ? void 0 : unsub();
        setUnsub(void 0);
      }, 1e3);
    }
  }, [options, busy, ready, error]);
  const host = ((_a = options === null || options === void 0 ? void 0 : options.thebe) === null || _a === void 0 ? void 0 : _a.useBinder) ? "Jupyter" : ((_b = options === null || options === void 0 ? void 0 : options.thebe) === null || _b === void 0 ? void 0 : _b.useJupyterLite) ? "JupyterLite" : "Local Server";
  if (show && error) {
    return (0, import_jsx_runtime60.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime60.jsxs)("div", { className: "mb-2 font-semibold text-center", children: ["\u26D4\uFE0F Error connecting to ", host, " \u26D4\uFE0F"] }), (0, import_jsx_runtime60.jsx)("div", { className: "my-1 max-h-[15rem] mono overflow-hidden text-ellipsis", children: error }), (0, import_jsx_runtime60.jsx)("div", { className: "flex justify-end", children: (0, import_jsx_runtime60.jsx)("div", { className: "text-xs cursor-pointer hover:underline", role: "button", onClick: () => setShow(false), children: "dismiss" }) })] });
  }
  if (show && ((_c = options === null || options === void 0 ? void 0 : options.thebe) === null || _c === void 0 ? void 0 : _c.useJupyterLite)) {
    return (0, import_jsx_runtime60.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime60.jsxs)("div", { className: "mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), !ready && (0, import_jsx_runtime60.jsx)("div", { className: "max-h-[5rem] mono overflow-hidden text-ellipsis", children: status }), ready && (0, import_jsx_runtime60.jsx)("div", { className: "max-h-[15rem] mono overflow-hidden text-ellipsis", children: "The in-browser JupyterLite server is ready, press run anytime." })] });
  }
  if (show) {
    return (0, import_jsx_runtime60.jsxs)("div", { className: "fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime60.jsxs)("div", { className: "mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), (0, import_jsx_runtime60.jsx)("div", { className: "max-h-[15rem] mono overflow-hidden text-ellipsis", children: status })] });
  }
  return null;
}

// ../../packages/jupyter/dist/controls/NotebookCellControls.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
function NotebookRunCell({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime61.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute });
}
function NotebookRunCellSpinnerOnly({ id }) {
  const { ready, cellIsExecuting } = useCellExecution(id);
  if (!ready || !cellIsExecuting)
    return null;
  return (0, import_jsx_runtime61.jsx)(Run, { ready, executing: cellIsExecuting, disabled: true, onClick: () => ({}), title: "executing cell..." });
}
function NotebookClearCell({ id }) {
  const { ready, notebookIsBusy, clear } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime61.jsx)(Clear, { ready, disabled: notebookIsBusy, onClick: clear, title: "Clear cell outputs" });
}

// ../../packages/jupyter/dist/controls/NotebookToolbar.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react8 = __toESM(require_dist3(), 1);
var import_classnames21 = __toESM(require_classnames(), 1);
function NotebookToolbar({ showLaunch = false }) {
  const { slug, ready, state, start, resetAll, clearAll, execute } = useExecutionScope();
  const busy = useBusyScope();
  const { connecting, connect, ready: serverReady, server, error: serverError } = (0, import_thebe_react8.useThebeServer)();
  const computable = selectIsComputable(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("NotebookToolbar: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start(slug);
  };
  const handleReset = () => resetAll(slug);
  const handleClear = () => clearAll(slug);
  const handleRun = () => execute(slug);
  const handleLaunch = () => {
    if (!serverReady || !(server === null || server === void 0 ? void 0 : server.settings))
      return;
    window.open(`${server.settings.baseUrl}?token=${server.settings.token}`, "_blank");
  };
  const building = selectAreExecutionScopesBuilding(state, slug);
  const status = selectExecutionScopeStatus(state, slug);
  const error = !!serverError;
  let title = "Connect to a compute server";
  if (error) {
    title = "Error connecting to compute server";
  } else if (building) {
    title = status;
  }
  if (computable)
    return (0, import_jsx_runtime62.jsx)("div", { className: "sticky top-[60px] flex justify-end w-full z-20 pointer-events-none", children: (0, import_jsx_runtime62.jsxs)("div", { className: "flex p-1 m-1 space-x-1 border rounded-full shadow pointer-events-auto border-stone-300 bg-white/80 dark:bg-stone-900/80 backdrop-blur", children: [!ready && (0, import_jsx_runtime62.jsxs)("div", { className: "rounded", children: [(0, import_jsx_runtime62.jsx)("button", { className: (0, import_classnames21.default)("flex text-center rounded-full cursor-pointer text-stone-800 dark:text-white hover:opacity-100 opacity-60", {
      "opacity-10 text-stone-100 dark:text-stone-700": connecting || building
    }), onClick: handleStart, disabled: building, "aria-label": "start compute environment", children: (0, import_jsx_runtime62.jsx)(PowerIcon_default, { className: "inline-block w-6 h-6 align-top", title: "enable compute" }) }), (connecting || building) && !error && (0, import_jsx_runtime62.jsx)("span", { className: "absolute top-1 left-1 z-10 w-[22px] h-[22px] opacity-100", title, children: (0, import_jsx_runtime62.jsx)(Spinner2, { size: 24 }) })] }), ready && (0, import_jsx_runtime62.jsx)(Run, { ready, executing: busy.page(slug, "execute"), onClick: handleRun, title: "Run all cells" }), ready && (0, import_jsx_runtime62.jsx)(Restart, { ready, resetting: busy.page(slug, "reset"), onClick: handleReset, disabled: busy.page(slug, "execute"), title: "Reset notebook and restart kernel" }), ready && (0, import_jsx_runtime62.jsx)(Clear, { ready, disabled: busy.page(slug, "execute") || busy.page(slug, "reset"), onClick: handleClear, title: "Clear all cells" }), showLaunch && ready && (0, import_jsx_runtime62.jsx)(Launch, { ready, disabled: false, onClick: handleLaunch, title: "Launch notebook in Jupyter" })] }) });
  return null;
}

// ../../packages/jupyter/dist/index.js
var OUTPUT_RENDERERS = {
  output: Output,
  embed: Embed,
  container: Figure
};
var dist_default = OUTPUT_RENDERERS;

// ../../packages/site/src/utils.ts
function extractKnownParts(tree) {
  const abstract = extractPart(tree, "abstract");
  const summary = extractPart(tree, "summary", { requireExplicitPart: true });
  const keypoints = extractPart(tree, ["keypoints"], { requireExplicitPart: true });
  const data_availability = extractPart(tree, ["data_availability", "data availability"]);
  const acknowledgments = extractPart(tree, ["acknowledgments", "acknowledgements"]);
  return { abstract, summary, keypoints, data_availability, acknowledgments };
}
function combineDownloads(siteDownloads, pageFrontmatter) {
  var _a;
  if (pageFrontmatter.downloads) {
    return pageFrontmatter.downloads;
  }
  if (siteDownloads) {
    return [...(_a = pageFrontmatter.exports) != null ? _a : [], ...siteDownloads];
  }
  return pageFrontmatter.exports;
}
function getChildren(content) {
  var _a;
  if ((content == null ? void 0 : content.type) === "root" && ((_a = content.children) == null ? void 0 : _a.length) === 1 && content.children[0].type === "block") {
    return content.children[0].children;
  }
  return content;
}
function isACodeCell(node) {
  return !!executableNodesFromBlock(node);
}

// ../../packages/site/src/components/ContentBlocks.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
function Block({
  id,
  pageKind,
  node,
  className
}) {
  var _a, _b;
  const grid = useGridSystemProvider();
  const subGrid = `${grid} subgrid-gap col-screen`;
  const dataClassName = typeof ((_a = node.data) == null ? void 0 : _a.class) === "string" ? (_b = node.data) == null ? void 0 : _b.class : void 0;
  const noSubGrid = dataClassName && dataClassName.includes("col-") || className && className.includes("col-");
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
    "div",
    {
      id,
      className: (0, import_classnames22.default)("relative group/block", className, dataClassName, {
        [subGrid]: !noSubGrid
      }),
      children: [
        pageKind === SourceFileKind.Notebook && isACodeCell(node) && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_jsx_dev_runtime.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "flex sticky top-[80px] z-10 opacity-70 group-hover/block:opacity-100 group-hover/block:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "absolute top-0 -right-[28px] flex md:flex-col", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookRunCellSpinnerOnly, { id }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 42,
            columnNumber: 15
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 41,
            columnNumber: 13
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 40,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "hidden sticky top-[80px] z-10 opacity-70 group-hover/block:opacity-100 group-hover/block:flex", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "absolute top-0 -right-[28px] flex md:flex-col", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookRunCell, { id }, void 0, false, {
              fileName: "../../packages/site/src/components/ContentBlocks.tsx",
              lineNumber: 47,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(NotebookClearCell, { id }, void 0, false, {
              fileName: "../../packages/site/src/components/ContentBlocks.tsx",
              lineNumber: 48,
              columnNumber: 15
            }, this)
          ] }, void 0, true, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 46,
            columnNumber: 13
          }, this) }, void 0, false, {
            fileName: "../../packages/site/src/components/ContentBlocks.tsx",
            lineNumber: 45,
            columnNumber: 11
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/ContentBlocks.tsx",
          lineNumber: 39,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(MyST, { ast: node.children }, void 0, false, {
          fileName: "../../packages/site/src/components/ContentBlocks.tsx",
          lineNumber: 53,
          columnNumber: 7
        }, this)
      ]
    },
    `block-${id}`,
    true,
    {
      fileName: "../../packages/site/src/components/ContentBlocks.tsx",
      lineNumber: 31,
      columnNumber: 5
    },
    this
  );
}
function ContentBlocks({
  mdast,
  pageKind = SourceFileKind.Article,
  className
}) {
  if (!mdast)
    return null;
  const blocks = mdast.children;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_jsx_dev_runtime.Fragment, { children: blocks.filter((node) => node.visibility !== "remove").map((node) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
    Block,
    {
      id: node.key,
      pageKind,
      node,
      className
    },
    node.key,
    false,
    {
      fileName: "../../packages/site/src/components/ContentBlocks.tsx",
      lineNumber: 74,
      columnNumber: 11
    },
    this
  )) }, void 0, false, {
    fileName: "../../packages/site/src/components/ContentBlocks.tsx",
    lineNumber: 70,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/FooterLinksBlock.tsx
var import_classnames23 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
var FooterLink = ({
  title,
  short_title,
  url,
  group: group2,
  right
}) => {
  const baseurl = useBaseurl();
  const Link2 = useLinkProvider();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
    Link2,
    {
      prefetch: "intent",
      className: "flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700",
      to: withBaseurl(url, baseurl),
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "flex h-full align-middle", children: [
        right && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
          ArrowLeftIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "self-center transition-transform group-hover:-translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 23,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: (0, import_classnames23.default)("flex-grow", { "text-right": right }), children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: group2 || " " }, void 0, false, {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 30,
            columnNumber: 11
          }, this),
          short_title || title
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
          lineNumber: 29,
          columnNumber: 9
        }, this),
        !right && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
          ArrowRightIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "self-center transition-transform group-hover:translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 34,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
        lineNumber: 21,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 16,
      columnNumber: 5
    },
    this
  );
};
function FooterLinksBlock({ links }) {
  var _a, _b, _c, _d, _e, _f;
  if (!links || !((_a = links.navigation) == null ? void 0 : _a.prev) && !((_b = links.navigation) == null ? void 0 : _b.next))
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "flex pt-10 mb-10 space-x-4", children: [
    ((_c = links.navigation) == null ? void 0 : _c.prev) && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(FooterLink, { ...(_d = links.navigation) == null ? void 0 : _d.prev, right: true }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 49,
      columnNumber: 34
    }, this),
    ((_e = links.navigation) == null ? void 0 : _e.next) && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(FooterLink, { ...(_f = links.navigation) == null ? void 0 : _f.next }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 50,
      columnNumber: 34
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
    lineNumber: 48,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/ContentReload.tsx
var import_react54 = __toESM(require_react(), 1);
var STORAGE_KEY = "myst";
async function mystLiveReloadConnect(config) {
  if (!config.port || window.mystLiveReloadConnected)
    return;
  window.mystLiveReloadConnected = true;
  setTimeout(() => {
    const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
    if (myst.scroll) {
      window.scrollTo(0, myst.scroll);
      sessionStorage.removeItem(STORAGE_KEY);
    }
  }, 30);
  console.log(`\u{1F50A} Listening to live content changes on port ${config.port}`);
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const host = location.hostname;
  const socketPath = `${protocol}//${host}:${config.port}/socket`;
  const ws = new WebSocket(socketPath);
  ws.onmessage = (message) => {
    const event = JSON.parse(message.data);
    if (event.type === "LOG") {
      console.log(event.message);
    }
    if (event.type === "RELOAD") {
      console.log("\u{1F680} Reloading window ...");
      console.log(`\u{1F4CC} Keeping scroll for page at ${window.scrollY}`);
      const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
      myst.scroll = window.scrollY;
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(myst));
      window.location.reload();
    }
  };
  ws.onopen = () => {
    if (config && typeof config.onOpen === "function") {
      config.onOpen();
    }
  };
  ws.onclose = () => {
    console.log("MyST content server web socket closed. Reconnecting...");
    setTimeout(
      () => mystLiveReloadConnect({
        ...config,
        onOpen: () => window.location.reload()
      }),
      1e3
    );
  };
  ws.onerror = (error) => {
    console.log("MyST content server web socket error:");
    console.error(error);
  };
}
function ContentReload({ port }) {
  (0, import_react54.useEffect)(() => {
    mystLiveReloadConnect({ port });
  }, []);
  return null;
}

// ../../packages/site/src/components/Bibliography.tsx
var import_classnames24 = __toESM(require_classnames(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime(), 1);
var HIDE_OVER_N_REFERENCES = 5;
function Bibliography({
  containerClassName,
  innerClassName
}) {
  var _a;
  const references = useReferences();
  const grid = useGridSystemProvider();
  const { order, data } = (_a = references == null ? void 0 : references.cite) != null ? _a : {};
  const filtered = order == null ? void 0 : order.filter((l7) => l7);
  const [hidden, setHidden] = (0, import_react55.useState)(true);
  if (!filtered || !data || filtered.length === 0)
    return null;
  const refs = hidden ? filtered.slice(0, HIDE_OVER_N_REFERENCES) : filtered;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
    "section",
    {
      id: "references",
      className: (0, import_classnames24.default)(grid, "subgrid-gap col-screen", containerClassName),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: innerClassName, children: [
          filtered.length > HIDE_OVER_N_REFERENCES && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
            "button",
            {
              onClick: () => setHidden(!hidden),
              className: "float-right p-1 px-2 text-xs border rounded hover:border-blue-500 dark:hover:border-blue-400",
              children: hidden ? "Show All" : "Collapse"
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 29,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("header", { className: "text-lg font-semibold text-stone-900 dark:text-white group", children: [
            "References",
            /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(HashLink, { id: "references", title: "Link to References", hover: true, className: "ml-2" }, void 0, false, {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 38,
              columnNumber: 11
            }, this)
          ] }, void 0, true, {
            fileName: "../../packages/site/src/components/Bibliography.tsx",
            lineNumber: 36,
            columnNumber: 9
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/Bibliography.tsx",
          lineNumber: 27,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          "div",
          {
            className: (0, import_classnames24.default)(
              "pl-3 mb-8 text-xs text-stone-500 dark:text-stone-300",
              innerClassName
            ),
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("ol", { children: [
              refs.map((label) => {
                const { html } = data[label];
                return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
                  "li",
                  {
                    className: "break-words",
                    id: `cite-${label}`,
                    dangerouslySetInnerHTML: { __html: html || "" }
                  },
                  label,
                  false,
                  {
                    fileName: "../../packages/site/src/components/Bibliography.tsx",
                    lineNumber: 51,
                    columnNumber: 15
                  },
                  this
                );
              }),
              filtered.length > HIDE_OVER_N_REFERENCES && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("li", { className: "text-center list-none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
                "button",
                {
                  onClick: () => setHidden(!hidden),
                  className: "p-2 border rounded hover:border-blue-500 dark:hover:border-blue-400",
                  children: hidden ? `Show all ${filtered.length} references` : "Collapse references"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Bibliography.tsx",
                  lineNumber: 61,
                  columnNumber: 15
                },
                this
              ) }, void 0, false, {
                fileName: "../../packages/site/src/components/Bibliography.tsx",
                lineNumber: 60,
                columnNumber: 13
              }, this)
            ] }, void 0, true, {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 47,
              columnNumber: 9
            }, this)
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Bibliography.tsx",
            lineNumber: 41,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Bibliography.tsx",
      lineNumber: 23,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Footnotes.tsx
var import_classnames25 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime(), 1);
function Footnotes({
  containerClassName,
  innerClassName
}) {
  const references = useReferences();
  const grid = useGridSystemProvider();
  const defs = selectAll("footnoteDefinition", references == null ? void 0 : references.article);
  const refs = selectAll("footnoteReference", references == null ? void 0 : references.article);
  if (defs.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
    "section",
    {
      id: "footnotes",
      className: (0, import_classnames25.default)(grid, "subgrid-gap col-screen", containerClassName),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: innerClassName, children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("header", { className: "text-lg font-semibold text-stone-900 dark:text-white group", children: [
          "Footnotes",
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(HashLink, { id: "footnotes", title: "Link to Footnotes", hover: true, className: "ml-2" }, void 0, false, {
            fileName: "../../packages/site/src/components/Footnotes.tsx",
            lineNumber: 28,
            columnNumber: 11
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/Footnotes.tsx",
          lineNumber: 26,
          columnNumber: 9
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Footnotes.tsx",
          lineNumber: 25,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
          "div",
          {
            className: (0, import_classnames25.default)(
              "pl-3 mb-8 text-xs text-stone-500 dark:text-stone-300",
              innerClassName
            ),
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("ol", { children: defs.map((fn) => {
              return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("li", { id: `fn-${fn.identifier}`, className: "group", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "flex flex-row", children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "break-words grow", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(MyST, { ast: fn.children }, void 0, false, {
                  fileName: "../../packages/site/src/components/Footnotes.tsx",
                  lineNumber: 43,
                  columnNumber: 21
                }, this) }, void 0, false, {
                  fileName: "../../packages/site/src/components/Footnotes.tsx",
                  lineNumber: 42,
                  columnNumber: 19
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "flex flex-col grow-0", children: refs.filter((ref) => ref.identifier === fn.identifier).map((ref) => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
                  HashLink,
                  {
                    id: `fnref-${ref.key}`,
                    title: "Link to Content",
                    hover: true,
                    className: "p-1",
                    children: "\u21A9",
                    scrollBehavior: "instant"
                  },
                  ref.key,
                  false,
                  {
                    fileName: "../../packages/site/src/components/Footnotes.tsx",
                    lineNumber: 49,
                    columnNumber: 25
                  },
                  this
                )) }, void 0, false, {
                  fileName: "../../packages/site/src/components/Footnotes.tsx",
                  lineNumber: 45,
                  columnNumber: 19
                }, this)
              ] }, void 0, true, {
                fileName: "../../packages/site/src/components/Footnotes.tsx",
                lineNumber: 41,
                columnNumber: 17
              }, this) }, fn.key, false, {
                fileName: "../../packages/site/src/components/Footnotes.tsx",
                lineNumber: 40,
                columnNumber: 15
              }, this);
            }) }, void 0, false, {
              fileName: "../../packages/site/src/components/Footnotes.tsx",
              lineNumber: 37,
              columnNumber: 9
            }, this)
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Footnotes.tsx",
            lineNumber: 31,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Footnotes.tsx",
      lineNumber: 21,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/frontmatter/dist/FrontmatterBlock.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_classnames29 = __toESM(require_classnames(), 1);

// ../../packages/frontmatter/dist/licenses.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_classnames26 = __toESM(require_classnames(), 1);
function CreativeCommonsBadge({ license, preamble = "", className }) {
  var _a;
  const match = /^([CBYSAND0-]+)(?:(?:-)([0-9].[0-9]))?$/.exec(license.id);
  if (!license.CC || !match)
    return null;
  const title = `${preamble}${(_a = license.name) !== null && _a !== void 0 ? _a : license.title} (${license.id})`;
  const kind = match[1].toUpperCase();
  return (0, import_jsx_runtime63.jsxs)("a", { href: license.url, target: "_blank", rel: "noopener noreferrer", className: (0, import_classnames26.default)("opacity-50 hover:opacity-100 text-inherit hover:text-inherit", className), "aria-label": title, children: [(0, import_jsx_runtime63.jsx)(CcIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mx-1", title }), (kind.startsWith("CC0") || kind.startsWith("CC-0") || kind.includes("ZERO")) && (0, import_jsx_runtime63.jsx)(CcZeroIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "CC0: Work is in the worldwide public domain" }), kind.includes("BY") && (0, import_jsx_runtime63.jsx)(CcByIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Credit must be given to the creator" }), kind.includes("NC") && (0, import_jsx_runtime63.jsx)(CcNcIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Only noncommercial uses of the work are permitted" }), kind.includes("SA") && (0, import_jsx_runtime63.jsx)(CcSaIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "Adaptations must be shared under the same terms" }), kind.includes("ND") && (0, import_jsx_runtime63.jsx)(CcNdIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1", title: "No derivatives or adaptations of the work are permitted" })] });
}
function SingleLicenseBadge({ license: possibleLicense, preamble = "", className }) {
  var _a;
  if (!possibleLicense)
    return null;
  const license = typeof possibleLicense === "string" ? { name: "", url: "", id: possibleLicense } : possibleLicense;
  if (!license || Object.keys(license).length === 0)
    return null;
  if (license.CC) {
    return (0, import_jsx_runtime63.jsx)(CreativeCommonsBadge, { license, preamble, className });
  }
  return (0, import_jsx_runtime63.jsxs)("a", { href: license.url || void 0, target: "_blank", rel: "noopener noreferrer", title: `${preamble}${(_a = license.name) !== null && _a !== void 0 ? _a : license.title} (${license.id})`, className: "text-inherit hover:text-inherit", children: [!license.osi && (0, import_jsx_runtime63.jsx)(ScaleIcon_default, { width: "1.25rem", height: "1.25rem", className: (0, import_classnames26.default)("mx-1 inline-block opacity-60 hover:opacity-100", className) }), license.osi && (0, import_jsx_runtime63.jsx)(OsiIcon_default, { width: "1.25rem", height: "1.25rem", className: (0, import_classnames26.default)("mx-1 inline-block opacity-60 hover:opacity-100 hover:text-[#599F46]", className) })] });
}
function LicenseBadges({ license, className }) {
  if (!license)
    return null;
  if (typeof license !== "string" && ("code" in license || "content" in license)) {
    return (0, import_jsx_runtime63.jsxs)(import_jsx_runtime63.Fragment, { children: [(0, import_jsx_runtime63.jsx)(SingleLicenseBadge, { license: license.content, preamble: "Content License: ", className }), (0, import_jsx_runtime63.jsx)(SingleLicenseBadge, { license: license.code, preamble: "Code License: ", className })] });
  }
  return (0, import_jsx_runtime63.jsx)(SingleLicenseBadge, { license, className });
}

// ../../packages/frontmatter/dist/downloads.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react56 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t10, e4, n4) => e4 in t10 ? i(t10, e4, { enumerable: true, configurable: true, writable: true, value: n4 }) : t10[e4] = n4;
var r = (t10, e4, n4) => (d(t10, typeof e4 != "symbol" ? e4 + "" : e4, n4), n4);
var o = class {
  constructor() {
    r(this, "current", this.detect());
    r(this, "handoffState", "pending");
    r(this, "currentId", 0);
  }
  set(e4) {
    this.current !== e4 && (this.handoffState = "pending", this.currentId = 0, this.current = e4);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var l = (e4, f6) => {
  s.isServer ? (0, import_react56.useEffect)(e4, f6) : (0, import_react56.useLayoutEffect)(e4, f6);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react57 = __toESM(require_react(), 1);
function s2(e4) {
  let r4 = (0, import_react57.useRef)(e4);
  return l(() => {
    r4.current = e4;
  }, [e4]), r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react58 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/micro-task.js
function t3(e4) {
  typeof queueMicrotask == "function" ? queueMicrotask(e4) : Promise.resolve().then(e4).catch((o10) => setTimeout(() => {
    throw o10;
  }));
}

// ../../node_modules/@headlessui/react/dist/utils/disposables.js
function o2() {
  let n4 = [], r4 = { addEventListener(e4, t10, s7, a4) {
    return e4.addEventListener(t10, s7, a4), r4.add(() => e4.removeEventListener(t10, s7, a4));
  }, requestAnimationFrame(...e4) {
    let t10 = requestAnimationFrame(...e4);
    return r4.add(() => cancelAnimationFrame(t10));
  }, nextFrame(...e4) {
    return r4.requestAnimationFrame(() => r4.requestAnimationFrame(...e4));
  }, setTimeout(...e4) {
    let t10 = setTimeout(...e4);
    return r4.add(() => clearTimeout(t10));
  }, microTask(...e4) {
    let t10 = { current: true };
    return t3(() => {
      t10.current && e4[0]();
    }), r4.add(() => {
      t10.current = false;
    });
  }, style(e4, t10, s7) {
    let a4 = e4.style.getPropertyValue(t10);
    return Object.assign(e4.style, { [t10]: s7 }), this.add(() => {
      Object.assign(e4.style, { [t10]: a4 });
    });
  }, group(e4) {
    let t10 = o2();
    return e4(t10), this.add(() => t10.dispose());
  }, add(e4) {
    return n4.push(e4), () => {
      let t10 = n4.indexOf(e4);
      if (t10 >= 0)
        for (let s7 of n4.splice(t10, 1))
          s7();
    };
  }, dispose() {
    for (let e4 of n4.splice(0))
      e4();
  } };
  return r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e4] = (0, import_react58.useState)(o2);
  return (0, import_react58.useEffect)(() => () => e4.dispose(), [e4]), e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react59 = __toESM(require_react(), 1);
var o4 = function(t10) {
  let e4 = s2(t10);
  return import_react59.default.useCallback((...r4) => e4.current(...r4), [e4]);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react60 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t4 = __toESM(require_react(), 1);
function s4() {
  let r4 = typeof document == "undefined";
  return "useSyncExternalStore" in t4 ? ((o10) => o10.useSyncExternalStore)(t4)(() => () => {
  }, () => false, () => !r4) : false;
}
function l2() {
  let r4 = s4(), [e4, n4] = t4.useState(s.isHandoffComplete);
  return e4 && s.isHandoffComplete === false && n4(false), t4.useEffect(() => {
    e4 !== true && n4(true);
  }, [e4]), t4.useEffect(() => s.handoff(), []), r4 ? false : e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var o5;
var I = (o5 = import_react60.default.useId) != null ? o5 : function() {
  let n4 = l2(), [e4, u4] = import_react60.default.useState(n4 ? () => s.nextId() : null);
  return l(() => {
    e4 === null && u4(s.nextId());
  }, [e4]), e4 != null ? "" + e4 : void 0;
};

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react63 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/match.js
function u(r4, n4, ...a4) {
  if (r4 in n4) {
    let e4 = n4[r4];
    return typeof e4 == "function" ? e4(...a4) : e4;
  }
  let t10 = new Error(`Tried to handle "${r4}" but there is no handler defined. Only defined handlers are: ${Object.keys(n4).map((e4) => `"${e4}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t10, u), t10;
}

// ../../node_modules/@headlessui/react/dist/utils/owner.js
function e3(r4) {
  return s.isServer ? null : r4 instanceof Node ? r4.ownerDocument : r4 != null && r4.hasOwnProperty("current") && r4.current instanceof Node ? r4.current.ownerDocument : document;
}

// ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var c2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e4) => `${e4}:not([tabindex='-1'])`).join(",");
var M = ((n4) => (n4[n4.First = 1] = "First", n4[n4.Previous = 2] = "Previous", n4[n4.Next = 4] = "Next", n4[n4.Last = 8] = "Last", n4[n4.WrapAround = 16] = "WrapAround", n4[n4.NoScroll = 32] = "NoScroll", n4))(M || {});
var N = ((o10) => (o10[o10.Error = 0] = "Error", o10[o10.Overflow = 1] = "Overflow", o10[o10.Success = 2] = "Success", o10[o10.Underflow = 3] = "Underflow", o10))(N || {});
var F = ((t10) => (t10[t10.Previous = -1] = "Previous", t10[t10.Next = 1] = "Next", t10))(F || {});
function f(e4 = document.body) {
  return e4 == null ? [] : Array.from(e4.querySelectorAll(c2)).sort((r4, t10) => Math.sign((r4.tabIndex || Number.MAX_SAFE_INTEGER) - (t10.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T = ((t10) => (t10[t10.Strict = 0] = "Strict", t10[t10.Loose = 1] = "Loose", t10))(T || {});
function h(e4, r4 = 0) {
  var t10;
  return e4 === ((t10 = e3(e4)) == null ? void 0 : t10.body) ? false : u(r4, { [0]() {
    return e4.matches(c2);
  }, [1]() {
    let l7 = e4;
    for (; l7 !== null; ) {
      if (l7.matches(c2))
        return true;
      l7 = l7.parentElement;
    }
    return false;
  } });
}
function D(e4) {
  let r4 = e3(e4);
  o2().nextFrame(() => {
    r4 && !h(r4.activeElement, 0) && y(e4);
  });
}
var w = ((t10) => (t10[t10.Keyboard = 0] = "Keyboard", t10[t10.Mouse = 1] = "Mouse", t10))(w || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e4) => {
  e4.metaKey || e4.altKey || e4.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e4) => {
  e4.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e4.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y(e4) {
  e4 == null || e4.focus({ preventScroll: true });
}
var S = ["textarea", "input"].join(",");
function H(e4) {
  var r4, t10;
  return (t10 = (r4 = e4 == null ? void 0 : e4.matches) == null ? void 0 : r4.call(e4, S)) != null ? t10 : false;
}
function I2(e4, r4 = (t10) => t10) {
  return e4.slice().sort((t10, l7) => {
    let o10 = r4(t10), i5 = r4(l7);
    if (o10 === null || i5 === null)
      return 0;
    let n4 = o10.compareDocumentPosition(i5);
    return n4 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n4 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _3(e4, r4) {
  return O(f(), r4, { relativeTo: e4 });
}
function O(e4, r4, { sorted: t10 = true, relativeTo: l7 = null, skipElements: o10 = [] } = {}) {
  let i5 = Array.isArray(e4) ? e4.length > 0 ? e4[0].ownerDocument : document : e4.ownerDocument, n4 = Array.isArray(e4) ? t10 ? I2(e4) : e4 : f(e4);
  o10.length > 0 && n4.length > 1 && (n4 = n4.filter((s7) => !o10.includes(s7))), l7 = l7 != null ? l7 : i5.activeElement;
  let E4 = (() => {
    if (r4 & 5)
      return 1;
    if (r4 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x4 = (() => {
    if (r4 & 1)
      return 0;
    if (r4 & 2)
      return Math.max(0, n4.indexOf(l7)) - 1;
    if (r4 & 4)
      return Math.max(0, n4.indexOf(l7)) + 1;
    if (r4 & 8)
      return n4.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p3 = r4 & 32 ? { preventScroll: true } : {}, d6 = 0, a4 = n4.length, u4;
  do {
    if (d6 >= a4 || d6 + a4 <= 0)
      return 0;
    let s7 = x4 + d6;
    if (r4 & 16)
      s7 = (s7 + a4) % a4;
    else {
      if (s7 < 0)
        return 3;
      if (s7 >= a4)
        return 1;
    }
    u4 = n4[s7], u4 == null || u4.focus(p3), d6 += E4;
  } while (u4 !== i5.activeElement);
  return r4 & 6 && H(u4) && u4.select(), 2;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react61 = __toESM(require_react(), 1);
function d2(e4, r4, n4) {
  let o10 = s2(r4);
  (0, import_react61.useEffect)(() => {
    function t10(u4) {
      o10.current(u4);
    }
    return document.addEventListener(e4, t10, n4), () => document.removeEventListener(e4, t10, n4);
  }, [e4, n4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react62 = __toESM(require_react(), 1);
function s5(e4, r4, n4) {
  let o10 = s2(r4);
  (0, import_react62.useEffect)(() => {
    function t10(i5) {
      o10.current(i5);
    }
    return window.addEventListener(e4, t10, n4), () => window.removeEventListener(e4, t10, n4);
  }, [e4, n4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
function h2(s7, m4, a4 = true) {
  let i5 = (0, import_react63.useRef)(false);
  (0, import_react63.useEffect)(() => {
    requestAnimationFrame(() => {
      i5.current = a4;
    });
  }, [a4]);
  function c6(e4, r4) {
    if (!i5.current || e4.defaultPrevented)
      return;
    let t10 = r4(e4);
    if (t10 === null || !t10.getRootNode().contains(t10) || !t10.isConnected)
      return;
    let E4 = function u4(n4) {
      return typeof n4 == "function" ? u4(n4()) : Array.isArray(n4) || n4 instanceof Set ? n4 : [n4];
    }(s7);
    for (let u4 of E4) {
      if (u4 === null)
        continue;
      let n4 = u4 instanceof HTMLElement ? u4 : u4.current;
      if (n4 != null && n4.contains(t10) || e4.composed && e4.composedPath().includes(n4))
        return;
    }
    return !h(t10, T.Loose) && t10.tabIndex !== -1 && e4.preventDefault(), m4(e4, t10);
  }
  let o10 = (0, import_react63.useRef)(null);
  d2("pointerdown", (e4) => {
    var r4, t10;
    i5.current && (o10.current = ((t10 = (r4 = e4.composedPath) == null ? void 0 : r4.call(e4)) == null ? void 0 : t10[0]) || e4.target);
  }, true), d2("mousedown", (e4) => {
    var r4, t10;
    i5.current && (o10.current = ((t10 = (r4 = e4.composedPath) == null ? void 0 : r4.call(e4)) == null ? void 0 : t10[0]) || e4.target);
  }, true), d2("click", (e4) => {
    o10.current && (c6(e4, () => o10.current), o10.current = null);
  }, true), d2("touchend", (e4) => c6(e4, () => e4.target instanceof HTMLElement ? e4.target : null), true), s5("blur", (e4) => c6(e4, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react64 = __toESM(require_react(), 1);
function i2(t10) {
  var n4;
  if (t10.type)
    return t10.type;
  let e4 = (n4 = t10.as) != null ? n4 : "button";
  if (typeof e4 == "string" && e4.toLowerCase() === "button")
    return "button";
}
function s6(t10, e4) {
  let [n4, u4] = (0, import_react64.useState)(() => i2(t10));
  return l(() => {
    u4(i2(t10));
  }, [t10.type, t10.as]), l(() => {
    n4 || e4.current && e4.current instanceof HTMLButtonElement && !e4.current.hasAttribute("type") && u4("button");
  }, [n4, e4]), n4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react65 = __toESM(require_react(), 1);
var u2 = Symbol();
function y2(...t10) {
  let n4 = (0, import_react65.useRef)(t10);
  (0, import_react65.useEffect)(() => {
    n4.current = t10;
  }, [t10]);
  let c6 = o4((e4) => {
    for (let o10 of n4.current)
      o10 != null && (typeof o10 == "function" ? o10(e4) : o10.current = e4);
  });
  return t10.every((e4) => e4 == null || (e4 == null ? void 0 : e4[u2])) ? void 0 : c6;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react66 = __toESM(require_react(), 1);
function F2({ container: e4, accept: t10, walk: r4, enabled: c6 = true }) {
  let o10 = (0, import_react66.useRef)(t10), l7 = (0, import_react66.useRef)(r4);
  (0, import_react66.useEffect)(() => {
    o10.current = t10, l7.current = r4;
  }, [t10, r4]), l(() => {
    if (!e4 || !c6)
      return;
    let n4 = e3(e4);
    if (!n4)
      return;
    let f6 = o10.current, p3 = l7.current, d6 = Object.assign((i5) => f6(i5), { acceptNode: f6 }), u4 = n4.createTreeWalker(e4, NodeFilter.SHOW_ELEMENT, d6, false);
    for (; u4.nextNode(); )
      p3(u4.currentNode);
  }, [e4, c6, o10, l7]);
}

// ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function f3(r4) {
  throw new Error("Unexpected object: " + r4);
}
var a2 = ((e4) => (e4[e4.First = 0] = "First", e4[e4.Previous = 1] = "Previous", e4[e4.Next = 2] = "Next", e4[e4.Last = 3] = "Last", e4[e4.Specific = 4] = "Specific", e4[e4.Nothing = 5] = "Nothing", e4))(a2 || {});
function x(r4, n4) {
  let t10 = n4.resolveItems();
  if (t10.length <= 0)
    return null;
  let l7 = n4.resolveActiveIndex(), s7 = l7 != null ? l7 : -1, d6 = (() => {
    switch (r4.focus) {
      case 0:
        return t10.findIndex((e4) => !n4.resolveDisabled(e4));
      case 1: {
        let e4 = t10.slice().reverse().findIndex((i5, c6, u4) => s7 !== -1 && u4.length - c6 - 1 >= s7 ? false : !n4.resolveDisabled(i5));
        return e4 === -1 ? e4 : t10.length - 1 - e4;
      }
      case 2:
        return t10.findIndex((e4, i5) => i5 <= s7 ? false : !n4.resolveDisabled(e4));
      case 3: {
        let e4 = t10.slice().reverse().findIndex((i5) => !n4.resolveDisabled(i5));
        return e4 === -1 ? e4 : t10.length - 1 - e4;
      }
      case 4:
        return t10.findIndex((e4) => n4.resolveId(e4) === r4.id);
      case 5:
        return null;
      default:
        f3(r4);
    }
  })();
  return d6 === -1 ? l7 : d6;
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var import_react67 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/class-names.js
function t6(...r4) {
  return Array.from(new Set(r4.flatMap((n4) => typeof n4 == "string" ? n4.split(" ") : []))).filter(Boolean).join(" ");
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var S2 = ((a4) => (a4[a4.None = 0] = "None", a4[a4.RenderStrategy = 1] = "RenderStrategy", a4[a4.Static = 2] = "Static", a4))(S2 || {});
var j = ((e4) => (e4[e4.Unmount = 0] = "Unmount", e4[e4.Hidden = 1] = "Hidden", e4))(j || {});
function X({ ourProps: r4, theirProps: t10, slot: e4, defaultTag: a4, features: s7, visible: n4 = true, name: f6 }) {
  let o10 = N2(t10, r4);
  if (n4)
    return c3(o10, e4, a4, f6);
  let u4 = s7 != null ? s7 : 0;
  if (u4 & 2) {
    let { static: l7 = false, ...p3 } = o10;
    if (l7)
      return c3(p3, e4, a4, f6);
  }
  if (u4 & 1) {
    let { unmount: l7 = true, ...p3 } = o10;
    return u(l7 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return c3({ ...p3, hidden: true, style: { display: "none" } }, e4, a4, f6);
    } });
  }
  return c3(o10, e4, a4, f6);
}
function c3(r4, t10 = {}, e4, a4) {
  let { as: s7 = e4, children: n4, refName: f6 = "ref", ...o10 } = g(r4, ["unmount", "static"]), u4 = r4.ref !== void 0 ? { [f6]: r4.ref } : {}, l7 = typeof n4 == "function" ? n4(t10) : n4;
  "className" in o10 && o10.className && typeof o10.className == "function" && (o10.className = o10.className(t10));
  let p3 = {};
  if (t10) {
    let i5 = false, m4 = [];
    for (let [y3, d6] of Object.entries(t10))
      typeof d6 == "boolean" && (i5 = true), d6 === true && m4.push(y3);
    i5 && (p3["data-headlessui-state"] = m4.join(" "));
  }
  if (s7 === import_react67.Fragment && Object.keys(R(o10)).length > 0) {
    if (!(0, import_react67.isValidElement)(l7) || Array.isArray(l7) && l7.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a4} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o10).map((d6) => `  - ${d6}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d6) => `  - ${d6}`).join(`
`)].join(`
`));
    let i5 = l7.props, m4 = typeof (i5 == null ? void 0 : i5.className) == "function" ? (...d6) => t6(i5 == null ? void 0 : i5.className(...d6), o10.className) : t6(i5 == null ? void 0 : i5.className, o10.className), y3 = m4 ? { className: m4 } : {};
    return (0, import_react67.cloneElement)(l7, Object.assign({}, N2(l7.props, R(g(o10, ["ref"]))), p3, u4, w2(l7.ref, u4.ref), y3));
  }
  return (0, import_react67.createElement)(s7, Object.assign({}, g(o10, ["ref"]), s7 !== import_react67.Fragment && u4, s7 !== import_react67.Fragment && p3), l7);
}
function w2(...r4) {
  return { ref: r4.every((t10) => t10 == null) ? void 0 : (t10) => {
    for (let e4 of r4)
      e4 != null && (typeof e4 == "function" ? e4(t10) : e4.current = t10);
  } };
}
function N2(...r4) {
  var a4;
  if (r4.length === 0)
    return {};
  if (r4.length === 1)
    return r4[0];
  let t10 = {}, e4 = {};
  for (let s7 of r4)
    for (let n4 in s7)
      n4.startsWith("on") && typeof s7[n4] == "function" ? ((a4 = e4[n4]) != null || (e4[n4] = []), e4[n4].push(s7[n4])) : t10[n4] = s7[n4];
  if (t10.disabled || t10["aria-disabled"])
    return Object.assign(t10, Object.fromEntries(Object.keys(e4).map((s7) => [s7, void 0])));
  for (let s7 in e4)
    Object.assign(t10, { [s7](n4, ...f6) {
      let o10 = e4[s7];
      for (let u4 of o10) {
        if ((n4 instanceof Event || (n4 == null ? void 0 : n4.nativeEvent) instanceof Event) && n4.defaultPrevented)
          return;
        u4(n4, ...f6);
      }
    } });
  return t10;
}
function D2(r4) {
  var t10;
  return Object.assign((0, import_react67.forwardRef)(r4), { displayName: (t10 = r4.displayName) != null ? t10 : r4.name });
}
function R(r4) {
  let t10 = Object.assign({}, r4);
  for (let e4 in t10)
    t10[e4] === void 0 && delete t10[e4];
  return t10;
}
function g(r4, t10 = []) {
  let e4 = Object.assign({}, r4);
  for (let a4 of t10)
    a4 in e4 && delete e4[a4];
  return e4;
}

// ../../node_modules/@headlessui/react/dist/utils/bugs.js
function r2(n4) {
  let e4 = n4.parentElement, l7 = null;
  for (; e4 && !(e4 instanceof HTMLFieldSetElement); )
    e4 instanceof HTMLLegendElement && (l7 = e4), e4 = e4.parentElement;
  let t10 = (e4 == null ? void 0 : e4.getAttribute("disabled")) === "";
  return t10 && i4(l7) ? false : t10;
}
function i4(n4) {
  if (!n4)
    return false;
  let e4 = n4.previousElementSibling;
  for (; e4 !== null; ) {
    if (e4 instanceof HTMLLegendElement)
      return false;
    e4 = e4.previousElementSibling;
  }
  return true;
}

// ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react68 = __toESM(require_react(), 1);
var n = (0, import_react68.createContext)(null);
n.displayName = "OpenClosedContext";
var d5 = ((e4) => (e4[e4.Open = 1] = "Open", e4[e4.Closed = 2] = "Closed", e4[e4.Closing = 4] = "Closing", e4[e4.Opening = 8] = "Opening", e4))(d5 || {});
function C() {
  return (0, import_react68.useContext)(n);
}
function c4({ value: o10, children: r4 }) {
  return import_react68.default.createElement(n.Provider, { value: o10 }, r4);
}

// ../../node_modules/@headlessui/react/dist/components/keyboard.js
var o7 = ((r4) => (r4.Space = " ", r4.Enter = "Enter", r4.Escape = "Escape", r4.Backspace = "Backspace", r4.Delete = "Delete", r4.ArrowLeft = "ArrowLeft", r4.ArrowUp = "ArrowUp", r4.ArrowRight = "ArrowRight", r4.ArrowDown = "ArrowDown", r4.Home = "Home", r4.End = "End", r4.PageUp = "PageUp", r4.PageDown = "PageDown", r4.Tab = "Tab", r4))(o7 || {});

// ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react69 = __toESM(require_react(), 1);
function t8(e4) {
  return [e4.screenX, e4.screenY];
}
function u3() {
  let e4 = (0, import_react69.useRef)([-1, -1]);
  return { wasMoved(r4) {
    let n4 = t8(r4);
    return e4.current[0] === n4[0] && e4.current[1] === n4[1] ? false : (e4.current = n4, true);
  }, update(r4) {
    e4.current = t8(r4);
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react70 = __toESM(require_react(), 1);
function n2(...e4) {
  return (0, import_react70.useMemo)(() => e3(...e4), [...e4]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react71 = __toESM(require_react(), 1);
function f4() {
  let e4 = (0, import_react71.useRef)(false);
  return l(() => (e4.current = true, () => {
    e4.current = false;
  }), []), e4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react72 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/get-text-value.js
var a3 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o9(e4) {
  var r4, i5;
  let n4 = (r4 = e4.innerText) != null ? r4 : "", t10 = e4.cloneNode(true);
  if (!(t10 instanceof HTMLElement))
    return n4;
  let u4 = false;
  for (let f6 of t10.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    f6.remove(), u4 = true;
  let l7 = u4 ? (i5 = t10.innerText) != null ? i5 : "" : n4;
  return a3.test(l7) && (l7 = l7.replace(a3, "")), l7;
}
function g2(e4) {
  let n4 = e4.getAttribute("aria-label");
  if (typeof n4 == "string")
    return n4.trim();
  let t10 = e4.getAttribute("aria-labelledby");
  if (t10) {
    let u4 = t10.split(" ").map((l7) => {
      let r4 = document.getElementById(l7);
      if (r4) {
        let i5 = r4.getAttribute("aria-label");
        return typeof i5 == "string" ? i5.trim() : o9(r4).trim();
      }
      return null;
    }).filter(Boolean);
    if (u4.length > 0)
      return u4.join(", ");
  }
  return o9(e4).trim();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
function b2(c6) {
  let t10 = (0, import_react72.useRef)(""), r4 = (0, import_react72.useRef)("");
  return o4(() => {
    let e4 = c6.current;
    if (!e4)
      return "";
    let u4 = e4.innerText;
    if (t10.current === u4)
      return r4.current;
    let n4 = g2(e4).trim().toLowerCase();
    return t10.current = u4, r4.current = n4, n4;
  });
}

// ../../node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react73 = __toESM(require_react(), 1);
var me = ((r4) => (r4[r4.Open = 0] = "Open", r4[r4.Closed = 1] = "Closed", r4))(me || {});
var de = ((r4) => (r4[r4.Pointer = 0] = "Pointer", r4[r4.Other = 1] = "Other", r4))(de || {});
var fe = ((a4) => (a4[a4.OpenMenu = 0] = "OpenMenu", a4[a4.CloseMenu = 1] = "CloseMenu", a4[a4.GoToItem = 2] = "GoToItem", a4[a4.Search = 3] = "Search", a4[a4.ClearSearch = 4] = "ClearSearch", a4[a4.RegisterItem = 5] = "RegisterItem", a4[a4.UnregisterItem = 6] = "UnregisterItem", a4))(fe || {});
function w3(e4, u4 = (r4) => r4) {
  let r4 = e4.activeItemIndex !== null ? e4.items[e4.activeItemIndex] : null, i5 = I2(u4(e4.items.slice()), (t10) => t10.dataRef.current.domRef.current), s7 = r4 ? i5.indexOf(r4) : null;
  return s7 === -1 && (s7 = null), { items: i5, activeItemIndex: s7 };
}
var Te = { [1](e4) {
  return e4.menuState === 1 ? e4 : { ...e4, activeItemIndex: null, menuState: 1 };
}, [0](e4) {
  return e4.menuState === 0 ? e4 : { ...e4, __demoMode: false, menuState: 0 };
}, [2]: (e4, u4) => {
  var s7;
  let r4 = w3(e4), i5 = x(u4, { resolveItems: () => r4.items, resolveActiveIndex: () => r4.activeItemIndex, resolveId: (t10) => t10.id, resolveDisabled: (t10) => t10.dataRef.current.disabled });
  return { ...e4, ...r4, searchQuery: "", activeItemIndex: i5, activationTrigger: (s7 = u4.trigger) != null ? s7 : 1 };
}, [3]: (e4, u4) => {
  let i5 = e4.searchQuery !== "" ? 0 : 1, s7 = e4.searchQuery + u4.value.toLowerCase(), o10 = (e4.activeItemIndex !== null ? e4.items.slice(e4.activeItemIndex + i5).concat(e4.items.slice(0, e4.activeItemIndex + i5)) : e4.items).find((l7) => {
    var m4;
    return ((m4 = l7.dataRef.current.textValue) == null ? void 0 : m4.startsWith(s7)) && !l7.dataRef.current.disabled;
  }), a4 = o10 ? e4.items.indexOf(o10) : -1;
  return a4 === -1 || a4 === e4.activeItemIndex ? { ...e4, searchQuery: s7 } : { ...e4, searchQuery: s7, activeItemIndex: a4, activationTrigger: 1 };
}, [4](e4) {
  return e4.searchQuery === "" ? e4 : { ...e4, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e4, u4) => {
  let r4 = w3(e4, (i5) => [...i5, { id: u4.id, dataRef: u4.dataRef }]);
  return { ...e4, ...r4 };
}, [6]: (e4, u4) => {
  let r4 = w3(e4, (i5) => {
    let s7 = i5.findIndex((t10) => t10.id === u4.id);
    return s7 !== -1 && i5.splice(s7, 1), i5;
  });
  return { ...e4, ...r4, activationTrigger: 1 };
} };
var U = (0, import_react73.createContext)(null);
U.displayName = "MenuContext";
function O2(e4) {
  let u4 = (0, import_react73.useContext)(U);
  if (u4 === null) {
    let r4 = new Error(`<${e4} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r4, O2), r4;
  }
  return u4;
}
function ye(e4, u4) {
  return u(u4.type, Te, e4, u4);
}
var Ie = import_react73.Fragment;
function Me(e4, u4) {
  let { __demoMode: r4 = false, ...i5 } = e4, s7 = (0, import_react73.useReducer)(ye, { __demoMode: r4, menuState: r4 ? 0 : 1, buttonRef: (0, import_react73.createRef)(), itemsRef: (0, import_react73.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: t10, itemsRef: o10, buttonRef: a4 }, l7] = s7, m4 = y2(u4);
  h2([a4, o10], (g4, R2) => {
    var p3;
    l7({ type: 1 }), h(R2, T.Loose) || (g4.preventDefault(), (p3 = a4.current) == null || p3.focus());
  }, t10 === 0);
  let I3 = o4(() => {
    l7({ type: 1 });
  }), A = (0, import_react73.useMemo)(() => ({ open: t10 === 0, close: I3 }), [t10, I3]), f6 = { ref: m4 };
  return import_react73.default.createElement(U.Provider, { value: s7 }, import_react73.default.createElement(c4, { value: u(t10, { [0]: d5.Open, [1]: d5.Closed }) }, X({ ourProps: f6, theirProps: i5, slot: A, defaultTag: Ie, name: "Menu" })));
}
var ge = "button";
function Re(e4, u4) {
  var R2;
  let r4 = I(), { id: i5 = `headlessui-menu-button-${r4}`, ...s7 } = e4, [t10, o10] = O2("Menu.Button"), a4 = y2(t10.buttonRef, u4), l7 = p(), m4 = o4((p3) => {
    switch (p3.key) {
      case o7.Space:
      case o7.Enter:
      case o7.ArrowDown:
        p3.preventDefault(), p3.stopPropagation(), o10({ type: 0 }), l7.nextFrame(() => o10({ type: 2, focus: a2.First }));
        break;
      case o7.ArrowUp:
        p3.preventDefault(), p3.stopPropagation(), o10({ type: 0 }), l7.nextFrame(() => o10({ type: 2, focus: a2.Last }));
        break;
    }
  }), I3 = o4((p3) => {
    switch (p3.key) {
      case o7.Space:
        p3.preventDefault();
        break;
    }
  }), A = o4((p3) => {
    if (r2(p3.currentTarget))
      return p3.preventDefault();
    e4.disabled || (t10.menuState === 0 ? (o10({ type: 1 }), l7.nextFrame(() => {
      var M4;
      return (M4 = t10.buttonRef.current) == null ? void 0 : M4.focus({ preventScroll: true });
    })) : (p3.preventDefault(), o10({ type: 0 })));
  }), f6 = (0, import_react73.useMemo)(() => ({ open: t10.menuState === 0 }), [t10]), g4 = { ref: a4, id: i5, type: s6(e4, t10.buttonRef), "aria-haspopup": "menu", "aria-controls": (R2 = t10.itemsRef.current) == null ? void 0 : R2.id, "aria-expanded": t10.menuState === 0, onKeyDown: m4, onKeyUp: I3, onClick: A };
  return X({ ourProps: g4, theirProps: s7, slot: f6, defaultTag: ge, name: "Menu.Button" });
}
var Ae = "div";
var be = S2.RenderStrategy | S2.Static;
function Ee(e4, u4) {
  var M4, b4;
  let r4 = I(), { id: i5 = `headlessui-menu-items-${r4}`, ...s7 } = e4, [t10, o10] = O2("Menu.Items"), a4 = y2(t10.itemsRef, u4), l7 = n2(t10.itemsRef), m4 = p(), I3 = C(), A = (() => I3 !== null ? (I3 & d5.Open) === d5.Open : t10.menuState === 0)();
  (0, import_react73.useEffect)(() => {
    let n4 = t10.itemsRef.current;
    n4 && t10.menuState === 0 && n4 !== (l7 == null ? void 0 : l7.activeElement) && n4.focus({ preventScroll: true });
  }, [t10.menuState, t10.itemsRef, l7]), F2({ container: t10.itemsRef.current, enabled: t10.menuState === 0, accept(n4) {
    return n4.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : n4.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(n4) {
    n4.setAttribute("role", "none");
  } });
  let f6 = o4((n4) => {
    var E4, P;
    switch (m4.dispose(), n4.key) {
      case o7.Space:
        if (t10.searchQuery !== "")
          return n4.preventDefault(), n4.stopPropagation(), o10({ type: 3, value: n4.key });
      case o7.Enter:
        if (n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), t10.activeItemIndex !== null) {
          let { dataRef: S4 } = t10.items[t10.activeItemIndex];
          (P = (E4 = S4.current) == null ? void 0 : E4.domRef.current) == null || P.click();
        }
        D(t10.buttonRef.current);
        break;
      case o7.ArrowDown:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Next });
      case o7.ArrowUp:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Previous });
      case o7.Home:
      case o7.PageUp:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.First });
      case o7.End:
      case o7.PageDown:
        return n4.preventDefault(), n4.stopPropagation(), o10({ type: 2, focus: a2.Last });
      case o7.Escape:
        n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), o2().nextFrame(() => {
          var S4;
          return (S4 = t10.buttonRef.current) == null ? void 0 : S4.focus({ preventScroll: true });
        });
        break;
      case o7.Tab:
        n4.preventDefault(), n4.stopPropagation(), o10({ type: 1 }), o2().nextFrame(() => {
          _3(t10.buttonRef.current, n4.shiftKey ? M.Previous : M.Next);
        });
        break;
      default:
        n4.key.length === 1 && (o10({ type: 3, value: n4.key }), m4.setTimeout(() => o10({ type: 4 }), 350));
        break;
    }
  }), g4 = o4((n4) => {
    switch (n4.key) {
      case o7.Space:
        n4.preventDefault();
        break;
    }
  }), R2 = (0, import_react73.useMemo)(() => ({ open: t10.menuState === 0 }), [t10]), p3 = { "aria-activedescendant": t10.activeItemIndex === null || (M4 = t10.items[t10.activeItemIndex]) == null ? void 0 : M4.id, "aria-labelledby": (b4 = t10.buttonRef.current) == null ? void 0 : b4.id, id: i5, onKeyDown: f6, onKeyUp: g4, role: "menu", tabIndex: 0, ref: a4 };
  return X({ ourProps: p3, theirProps: s7, slot: R2, defaultTag: Ae, features: be, visible: A, name: "Menu.Items" });
}
var Se = import_react73.Fragment;
function Pe(e4, u4) {
  let r4 = I(), { id: i5 = `headlessui-menu-item-${r4}`, disabled: s7 = false, ...t10 } = e4, [o10, a4] = O2("Menu.Item"), l7 = o10.activeItemIndex !== null ? o10.items[o10.activeItemIndex].id === i5 : false, m4 = (0, import_react73.useRef)(null), I3 = y2(u4, m4);
  l(() => {
    if (o10.__demoMode || o10.menuState !== 0 || !l7 || o10.activationTrigger === 0)
      return;
    let T3 = o2();
    return T3.requestAnimationFrame(() => {
      var v2, B2;
      (B2 = (v2 = m4.current) == null ? void 0 : v2.scrollIntoView) == null || B2.call(v2, { block: "nearest" });
    }), T3.dispose;
  }, [o10.__demoMode, m4, l7, o10.menuState, o10.activationTrigger, o10.activeItemIndex]);
  let A = b2(m4), f6 = (0, import_react73.useRef)({ disabled: s7, domRef: m4, get textValue() {
    return A();
  } });
  l(() => {
    f6.current.disabled = s7;
  }, [f6, s7]), l(() => (a4({ type: 5, id: i5, dataRef: f6 }), () => a4({ type: 6, id: i5 })), [f6, i5]);
  let g4 = o4(() => {
    a4({ type: 1 });
  }), R2 = o4((T3) => {
    if (s7)
      return T3.preventDefault();
    a4({ type: 1 }), D(o10.buttonRef.current);
  }), p3 = o4(() => {
    if (s7)
      return a4({ type: 2, focus: a2.Nothing });
    a4({ type: 2, focus: a2.Specific, id: i5 });
  }), M4 = u3(), b4 = o4((T3) => M4.update(T3)), n4 = o4((T3) => {
    M4.wasMoved(T3) && (s7 || l7 || a4({ type: 2, focus: a2.Specific, id: i5, trigger: 0 }));
  }), E4 = o4((T3) => {
    M4.wasMoved(T3) && (s7 || l7 && a4({ type: 2, focus: a2.Nothing }));
  }), P = (0, import_react73.useMemo)(() => ({ active: l7, disabled: s7, close: g4 }), [l7, s7, g4]);
  return X({ ourProps: { id: i5, ref: I3, role: "menuitem", tabIndex: s7 === true ? void 0 : -1, "aria-disabled": s7 === true ? true : void 0, disabled: void 0, onClick: R2, onFocus: p3, onPointerEnter: b4, onMouseEnter: b4, onPointerMove: n4, onMouseMove: n4, onPointerLeave: E4, onMouseLeave: E4 }, theirProps: t10, slot: P, defaultTag: Se, name: "Menu.Item" });
}
var ve = D2(Me);
var xe = D2(Re);
var he = D2(Ee);
var De = D2(Pe);
var it = Object.assign(ve, { Button: xe, Items: he, Item: De });

// ../../node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react74 = __toESM(require_react(), 1);
function c5(a4 = 0) {
  let [l7, r4] = (0, import_react74.useState)(a4), t10 = f4(), o10 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 | e4);
  }, [l7, t10]), m4 = (0, import_react74.useCallback)((e4) => Boolean(l7 & e4), [l7]), s7 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 & ~e4);
  }, [r4, t10]), g4 = (0, import_react74.useCallback)((e4) => {
    t10.current && r4((u4) => u4 ^ e4);
  }, [r4]);
  return { flags: l7, addFlag: o10, hasFlag: m4, removeFlag: s7, toggleFlag: g4 };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
var import_react75 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/once.js
function l6(r4) {
  let e4 = { called: false };
  return (...t10) => {
    if (!e4.called)
      return e4.called = true, r4(...t10);
  };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
function g3(t10, ...e4) {
  t10 && e4.length > 0 && t10.classList.add(...e4);
}
function v(t10, ...e4) {
  t10 && e4.length > 0 && t10.classList.remove(...e4);
}
function b3(t10, e4) {
  let n4 = o2();
  if (!t10)
    return n4.dispose;
  let { transitionDuration: m4, transitionDelay: a4 } = getComputedStyle(t10), [u4, p3] = [m4, a4].map((l7) => {
    let [r4 = 0] = l7.split(",").filter(Boolean).map((i5) => i5.includes("ms") ? parseFloat(i5) : parseFloat(i5) * 1e3).sort((i5, T3) => T3 - i5);
    return r4;
  }), o10 = u4 + p3;
  if (o10 !== 0) {
    n4.group((r4) => {
      r4.setTimeout(() => {
        e4(), r4.dispose();
      }, o10), r4.addEventListener(t10, "transitionrun", (i5) => {
        i5.target === i5.currentTarget && r4.dispose();
      });
    });
    let l7 = n4.addEventListener(t10, "transitionend", (r4) => {
      r4.target === r4.currentTarget && (e4(), l7());
    });
  } else
    e4();
  return n4.add(() => e4()), n4.dispose;
}
function M2(t10, e4, n4, m4) {
  let a4 = n4 ? "enter" : "leave", u4 = o2(), p3 = m4 !== void 0 ? l6(m4) : () => {
  };
  a4 === "enter" && (t10.removeAttribute("hidden"), t10.style.display = "");
  let o10 = u(a4, { enter: () => e4.enter, leave: () => e4.leave }), l7 = u(a4, { enter: () => e4.enterTo, leave: () => e4.leaveTo }), r4 = u(a4, { enter: () => e4.enterFrom, leave: () => e4.leaveFrom });
  return v(t10, ...e4.base, ...e4.enter, ...e4.enterTo, ...e4.enterFrom, ...e4.leave, ...e4.leaveFrom, ...e4.leaveTo, ...e4.entered), g3(t10, ...e4.base, ...o10, ...r4), u4.nextFrame(() => {
    v(t10, ...e4.base, ...o10, ...r4), g3(t10, ...e4.base, ...o10, ...l7), b3(t10, () => (v(t10, ...e4.base, ...o10), g3(t10, ...e4.base, ...e4.entered), p3()));
  }), u4.dispose;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
function E3({ immediate: t10, container: s7, direction: n4, classes: u4, onStart: a4, onStop: c6 }) {
  let l7 = f4(), d6 = p(), e4 = s2(n4);
  l(() => {
    t10 && (e4.current = "enter");
  }, [t10]), l(() => {
    let r4 = o2();
    d6.add(r4.dispose);
    let i5 = s7.current;
    if (i5 && e4.current !== "idle" && l7.current)
      return r4.dispose(), a4.current(e4.current), r4.add(M2(i5, u4.current, e4.current === "enter", () => {
        r4.dispose(), c6.current(e4.current);
      })), r4.dispose;
  }, [n4]);
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
function S3(t10 = "") {
  return t10.split(" ").filter((n4) => n4.trim().length > 1);
}
var _4 = (0, import_react75.createContext)(null);
_4.displayName = "TransitionContext";
var be2 = ((r4) => (r4.Visible = "visible", r4.Hidden = "hidden", r4))(be2 || {});
function Se2() {
  let t10 = (0, import_react75.useContext)(_4);
  if (t10 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t10;
}
function Ne() {
  let t10 = (0, import_react75.useContext)(M3);
  if (t10 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t10;
}
var M3 = (0, import_react75.createContext)(null);
M3.displayName = "NestingContext";
function U2(t10) {
  return "children" in t10 ? U2(t10.children) : t10.current.filter(({ el: n4 }) => n4.current !== null).filter(({ state: n4 }) => n4 === "visible").length > 0;
}
function oe(t10, n4) {
  let r4 = s2(t10), s7 = (0, import_react75.useRef)([]), y3 = f4(), D3 = p(), c6 = o4((i5, e4 = j.Hidden) => {
    let a4 = s7.current.findIndex(({ el: o10 }) => o10 === i5);
    a4 !== -1 && (u(e4, { [j.Unmount]() {
      s7.current.splice(a4, 1);
    }, [j.Hidden]() {
      s7.current[a4].state = "hidden";
    } }), D3.microTask(() => {
      var o10;
      !U2(s7) && y3.current && ((o10 = r4.current) == null || o10.call(r4));
    }));
  }), x4 = o4((i5) => {
    let e4 = s7.current.find(({ el: a4 }) => a4 === i5);
    return e4 ? e4.state !== "visible" && (e4.state = "visible") : s7.current.push({ el: i5, state: "visible" }), () => c6(i5, j.Unmount);
  }), p3 = (0, import_react75.useRef)([]), h4 = (0, import_react75.useRef)(Promise.resolve()), u4 = (0, import_react75.useRef)({ enter: [], leave: [], idle: [] }), v2 = o4((i5, e4, a4) => {
    p3.current.splice(0), n4 && (n4.chains.current[e4] = n4.chains.current[e4].filter(([o10]) => o10 !== i5)), n4 == null || n4.chains.current[e4].push([i5, new Promise((o10) => {
      p3.current.push(o10);
    })]), n4 == null || n4.chains.current[e4].push([i5, new Promise((o10) => {
      Promise.all(u4.current[e4].map(([f6, P]) => P)).then(() => o10());
    })]), e4 === "enter" ? h4.current = h4.current.then(() => n4 == null ? void 0 : n4.wait.current).then(() => a4(e4)) : a4(e4);
  }), d6 = o4((i5, e4, a4) => {
    Promise.all(u4.current[e4].splice(0).map(([o10, f6]) => f6)).then(() => {
      var o10;
      (o10 = p3.current.shift()) == null || o10();
    }).then(() => a4(e4));
  });
  return (0, import_react75.useMemo)(() => ({ children: s7, register: x4, unregister: c6, onStart: v2, onStop: d6, wait: h4, chains: u4 }), [x4, c6, s7, v2, d6, u4, h4]);
}
function xe2() {
}
var Pe2 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function se(t10) {
  var r4;
  let n4 = {};
  for (let s7 of Pe2)
    n4[s7] = (r4 = t10[s7]) != null ? r4 : xe2;
  return n4;
}
function Re2(t10) {
  let n4 = (0, import_react75.useRef)(se(t10));
  return (0, import_react75.useEffect)(() => {
    n4.current = se(t10);
  }, [t10]), n4;
}
var ye2 = "div";
var ae = S2.RenderStrategy;
function De2(t10, n4) {
  var K2, Q;
  let { beforeEnter: r4, afterEnter: s7, beforeLeave: y3, afterLeave: D3, enter: c6, enterFrom: x4, enterTo: p3, entered: h4, leave: u4, leaveFrom: v2, leaveTo: d6, ...i5 } = t10, e4 = (0, import_react75.useRef)(null), a4 = y2(e4, n4), o10 = (K2 = i5.unmount) == null || K2 ? j.Unmount : j.Hidden, { show: f6, appear: P, initial: T3 } = Se2(), [l7, j2] = (0, import_react75.useState)(f6 ? "visible" : "hidden"), q2 = Ne(), { register: O3, unregister: V } = q2;
  (0, import_react75.useEffect)(() => O3(e4), [O3, e4]), (0, import_react75.useEffect)(() => {
    if (o10 === j.Hidden && e4.current) {
      if (f6 && l7 !== "visible") {
        j2("visible");
        return;
      }
      return u(l7, { ["hidden"]: () => V(e4), ["visible"]: () => O3(e4) });
    }
  }, [l7, e4, O3, V, f6, o10]);
  let k = s2({ base: S3(i5.className), enter: S3(c6), enterFrom: S3(x4), enterTo: S3(p3), entered: S3(h4), leave: S3(u4), leaveFrom: S3(v2), leaveTo: S3(d6) }), w4 = Re2({ beforeEnter: r4, afterEnter: s7, beforeLeave: y3, afterLeave: D3 }), G2 = l2();
  (0, import_react75.useEffect)(() => {
    if (G2 && l7 === "visible" && e4.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e4, l7, G2]);
  let ue = T3 && !P, z2 = P && f6 && T3, Te2 = (() => !G2 || ue ? "idle" : f6 ? "enter" : "leave")(), H3 = c5(0), de2 = o4((g4) => u(g4, { enter: () => {
    H3.addFlag(d5.Opening), w4.current.beforeEnter();
  }, leave: () => {
    H3.addFlag(d5.Closing), w4.current.beforeLeave();
  }, idle: () => {
  } })), fe2 = o4((g4) => u(g4, { enter: () => {
    H3.removeFlag(d5.Opening), w4.current.afterEnter();
  }, leave: () => {
    H3.removeFlag(d5.Closing), w4.current.afterLeave();
  }, idle: () => {
  } })), A = oe(() => {
    j2("hidden"), V(e4);
  }, q2);
  E3({ immediate: z2, container: e4, classes: k, direction: Te2, onStart: s2((g4) => {
    A.onStart(e4, g4, de2);
  }), onStop: s2((g4) => {
    A.onStop(e4, g4, fe2), g4 === "leave" && !U2(A) && (j2("hidden"), V(e4));
  }) });
  let R2 = i5, me2 = { ref: a4 };
  return z2 ? R2 = { ...R2, className: t6(i5.className, ...k.current.enter, ...k.current.enterFrom) } : (R2.className = t6(i5.className, (Q = e4.current) == null ? void 0 : Q.className), R2.className === "" && delete R2.className), import_react75.default.createElement(M3.Provider, { value: A }, import_react75.default.createElement(c4, { value: u(l7, { ["visible"]: d5.Open, ["hidden"]: d5.Closed }) | H3.flags }, X({ ourProps: me2, theirProps: R2, defaultTag: ye2, features: ae, visible: l7 === "visible", name: "Transition.Child" })));
}
function He(t10, n4) {
  let { show: r4, appear: s7 = false, unmount: y3 = true, ...D3 } = t10, c6 = (0, import_react75.useRef)(null), x4 = y2(c6, n4);
  l2();
  let p3 = C();
  if (r4 === void 0 && p3 !== null && (r4 = (p3 & d5.Open) === d5.Open), ![true, false].includes(r4))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h4, u4] = (0, import_react75.useState)(r4 ? "visible" : "hidden"), v2 = oe(() => {
    u4("hidden");
  }), [d6, i5] = (0, import_react75.useState)(true), e4 = (0, import_react75.useRef)([r4]);
  l(() => {
    d6 !== false && e4.current[e4.current.length - 1] !== r4 && (e4.current.push(r4), i5(false));
  }, [e4, r4]);
  let a4 = (0, import_react75.useMemo)(() => ({ show: r4, appear: s7, initial: d6 }), [r4, s7, d6]);
  (0, import_react75.useEffect)(() => {
    if (r4)
      u4("visible");
    else if (!U2(v2))
      u4("hidden");
    else {
      let T3 = c6.current;
      if (!T3)
        return;
      let l7 = T3.getBoundingClientRect();
      l7.x === 0 && l7.y === 0 && l7.width === 0 && l7.height === 0 && u4("hidden");
    }
  }, [r4, v2]);
  let o10 = { unmount: y3 }, f6 = o4(() => {
    var T3;
    d6 && i5(false), (T3 = t10.beforeEnter) == null || T3.call(t10);
  }), P = o4(() => {
    var T3;
    d6 && i5(false), (T3 = t10.beforeLeave) == null || T3.call(t10);
  });
  return import_react75.default.createElement(M3.Provider, { value: v2 }, import_react75.default.createElement(_4.Provider, { value: a4 }, X({ ourProps: { ...o10, as: import_react75.Fragment, children: import_react75.default.createElement(le, { ref: x4, ...o10, ...D3, beforeEnter: f6, beforeLeave: P }) }, theirProps: {}, defaultTag: import_react75.Fragment, features: ae, visible: h4 === "visible", name: "Transition" })));
}
function Fe(t10, n4) {
  let r4 = (0, import_react75.useContext)(_4) !== null, s7 = C() !== null;
  return import_react75.default.createElement(import_react75.default.Fragment, null, !r4 && s7 ? import_react75.default.createElement(W, { ref: n4, ...t10 }) : import_react75.default.createElement(le, { ref: n4, ...t10 }));
}
var W = D2(He);
var le = D2(De2);
var Le = D2(Fe);
var tt = Object.assign(W, { Child: Le, Root: W });

// ../../packages/frontmatter/dist/downloads.js
var import_classnames27 = __toESM(require_classnames(), 1);
var import_react77 = __toESM(require_react(), 1);
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function triggerDirectDownload(url, filename) {
  return __awaiter5(this, void 0, void 0, function* () {
    const resp = yield fetch(url);
    const blob = yield resp.blob();
    return triggerBlobDownload(blob, filename);
  });
}
function triggerBlobDownload(blob, filename) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (window.navigator && window.navigator.msSaveOrOpenBlob)
      return window.navigator.msSaveOrOpenBlob(blob);
    const objectUrl = URL.createObjectURL(blob);
    const a4 = document.createElement("a");
    a4.href = objectUrl;
    a4.download = filename;
    a4.style.display = "none";
    a4.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window
    }));
    setTimeout(() => {
      URL.revokeObjectURL(objectUrl);
      a4.remove();
    }, 100);
    return true;
  });
}
var ICON_CLASS = "self-center flex-none inline-block mr-3";
function Download({ url, filename, format: format2, className, title, internal }) {
  if (!filename) {
    const icon = internal ? (0, import_jsx_runtime64.jsx)(DocumentIcon_default, { width: "1.25rem", height: "1.25rem", className: ICON_CLASS, "aria-hidden": "true" }) : (0, import_jsx_runtime64.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.25rem", height: "1.25rem", className: ICON_CLASS, "aria-hidden": "true" });
    return (0, import_jsx_runtime64.jsxs)("a", { className: (0, import_classnames27.default)(className, "flex no-underline"), href: url, target: !internal ? "_blank" : void 0, rel: !internal ? "noreferrer noopener" : void 0, children: [(0, import_jsx_runtime64.jsxs)("span", { className: "sr-only", children: ["Visit URL ", title !== null && title !== void 0 ? title : ""] }), icon, (0, import_jsx_runtime64.jsx)("span", { className: "w-max max-w-[200px] self-center", children: title !== null && title !== void 0 ? title : url })] });
  }
  const clickDownload = (0, import_react77.useCallback)((e4) => {
    e4.preventDefault();
    triggerDirectDownload(url, filename);
  }, [url, filename]);
  return (0, import_jsx_runtime64.jsxs)("a", { className: (0, import_classnames27.default)(className, "flex no-underline"), href: url, onClick: clickDownload, children: [(0, import_jsx_runtime64.jsxs)("span", { className: "sr-only", children: ["Download", format2 ? ` as ${format2}` : "", " ", title !== null && title !== void 0 ? title : ""] }), (0, import_jsx_runtime64.jsx)(DocumentArrowDownIcon_default, { width: "1.25rem", height: "1.25rem", className: ICON_CLASS, "aria-hidden": "true" }), (0, import_jsx_runtime64.jsx)("span", { className: "w-max max-w-[200px] self-center", children: title !== null && title !== void 0 ? title : filename })] });
}
function DownloadsDropdown({ exports }) {
  if (!exports || exports.length === 0)
    return null;
  return (0, import_jsx_runtime64.jsxs)(it, { as: "div", className: "relative flex inline-block mx-1 grow-0", children: [(0, import_jsx_runtime64.jsxs)(it.Button, { className: "relative ml-2 -mr-1", children: [(0, import_jsx_runtime64.jsx)("span", { className: "sr-only", children: "Downloads" }), (0, import_jsx_runtime64.jsx)(ArrowDownTrayIcon_default, { width: "1.25rem", height: "1.25rem", "aria-hidden": "true" })] }), (0, import_jsx_runtime64.jsx)(it.Items, { className: "absolute z-10 overflow-hidden bg-white rounded-sm shadow-lg -right-1 dark:bg-slate-800 ring-1 ring-black ring-opacity-5 focus:outline-none", children: exports.map((exp, index2) => (0, import_jsx_runtime64.jsx)(it.Item, { children: (0, import_jsx_runtime64.jsx)(Download, { className: "block p-3 no-underline hover:bg-stone-700 dark:hover:bg-stone-200 hover:text-white dark:hover:text-black", url: exp.url, filename: exp.filename, format: exp.format, title: exp.title, internal: exp.internal }) }, index2)) })] });
}

// ../../packages/frontmatter/dist/Authors.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
var import_classnames28 = __toESM(require_classnames(), 1);

// ../../packages/frontmatter/dist/AuthorPopover.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@radix-ui/react-popover/dist/index.mjs
init_extends();
var import_react81 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var import_react78 = __toESM(require_react(), 1);
var $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  (0, import_react78.useEffect)(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element2 = document.createElement("span");
  element2.setAttribute("data-radix-focus-guard", "");
  element2.tabIndex = 0;
  element2.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element2;
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
init_extends();
var import_react79 = __toESM(require_react(), 1);
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react79.forwardRef)((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = (0, import_react79.useState)(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = (0, import_react79.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = (0, import_react79.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react79.useEffect)(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container1.contains(relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleMutations = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations)
          if (mutation.removedNodes.length > 0)
            $d3863c46a17e8a28$var$focus(container1);
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container1)
        mutationObserver.observe(container1, {
          childList: true,
          subtree: true
        });
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  (0, import_react79.useEffect)(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = (0, import_react79.useCallback)((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first2, last2] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first2 && last2;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last2) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first2, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first2) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last2, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ (0, import_react79.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select: select2 = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select: select2
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first2 = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last2 = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first2,
    last2
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element2 of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element2, {
      upTo: container
    }))
      return element2;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}
function $d3863c46a17e8a28$var$focus(element2, { select: select2 = false } = {}) {
  if (element2 && element2.focus) {
    const previouslyFocusedElement = document.activeElement;
    element2.focus({
      preventScroll: true
    });
    if (element2 !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element2) && select2)
      element2.select();
  }
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
var $2AODx$react = __toESM(require_react(), 1);
var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x4) {
    return Boolean(x4);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_tslib_es6();
var React79 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
init_tslib_es6();
var React75 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react80 = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react80.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// ../../node_modules/use-sidecar/dist/es2015/medium.js
init_tslib_es6();
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x4) {
          return x4 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x4) {
          return cb2(x4);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x4) {
          pendingQueue.push(x4);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
init_tslib_es6();
var React74 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest2 = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React74.createElement(Target, __assign({}, rest2));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React75.forwardRef(function(props, parentRef) {
  var ref = React75.useRef(null);
  var _a = React75.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest2 = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest2), callbacks);
  return React75.createElement(
    React75.Fragment,
    null,
    enabled && React75.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React75.cloneElement(React75.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React75.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_tslib_es6();
var React78 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React77 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React76 = __toESM(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React76.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x4) {
  return parseInt(x4 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = React77.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React77.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s7 = _a[1], d6 = _a[2];
      if (s7 > d6) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x4, y3) {
  return x4[0] === y3[0] && x4[1] === y3[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter2 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React78.useRef([]);
  var touchStartRef = React78.useRef([0, 0]);
  var activeAxis = React78.useRef();
  var id = React78.useState(idCounter2++)[0];
  var Style2 = React78.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React78.useRef(props);
  React78.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React78.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React78.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React78.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e4) {
      return e4.name === event.type && e4.target === event.target && deltaCompare(e4.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React78.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e4) {
        return e4 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React78.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React78.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React78.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React78.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React78.createElement(
    React78.Fragment,
    null,
    inert ? React78.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React78.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React79.forwardRef(function(props, ref) {
  return React79.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-popover/dist/index.mjs
var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = (0, import_react81.useRef)(null);
  const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react81.useState)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react81.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: (0, import_react81.useCallback)(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: (0, import_react81.useCallback)(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ (0, import_react81.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger);
});
var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, /* @__PURE__ */ (0, import_react81.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react81.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = (0, import_react81.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = (0, import_react81.useRef)(false);
  (0, import_react81.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react81.createElement)(Combination_default, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = (0, import_react81.useRef)(false);
  const hasPointerDownOutsideRef = (0, import_react81.useRef)(false);
  return /* @__PURE__ */ (0, import_react81.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ (0, import_react81.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react81.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
var $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ (0, import_react81.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return /* @__PURE__ */ (0, import_react81.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

// ../../packages/frontmatter/dist/Affiliations.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var __rest6 = function(s7, e4) {
  var t10 = {};
  for (var p3 in s7)
    if (Object.prototype.hasOwnProperty.call(s7, p3) && e4.indexOf(p3) < 0)
      t10[p3] = s7[p3];
  if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p3 = Object.getOwnPropertySymbols(s7); i5 < p3.length; i5++) {
      if (e4.indexOf(p3[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p3[i5]))
        t10[p3[i5]] = s7[p3[i5]];
    }
  return t10;
};
function Affiliation({ affiliations, affiliationId }) {
  var _a, _b;
  if (!affiliations || affiliations.length === 0)
    return null;
  const affiliationsLookup = Object.fromEntries((_a = affiliations === null || affiliations === void 0 ? void 0 : affiliations.map((_a2) => {
    var { id } = _a2, rest2 = __rest6(_a2, ["id"]);
    return [id, rest2];
  })) !== null && _a !== void 0 ? _a : []);
  const affiliation = (_b = affiliationsLookup[affiliationId]) !== null && _b !== void 0 ? _b : { name: affiliationId };
  return (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [affiliation.name || affiliation.institution, " ", affiliation.ror && (0, import_jsx_runtime65.jsx)("a", { className: "ml-1", href: `https://ror.org/${affiliation.ror.replace(/(https?:\/\/)?ror\.org\//, "")}`, target: "_blank", rel: "noopener noreferrer", title: "Research Organization Registry", children: (0, import_jsx_runtime65.jsx)(RorIcon_default, { width: "1rem", height: "1rem", className: "inline-block" }) })] });
}

// ../../packages/frontmatter/dist/AuthorPopover.js
function Definition({ title, children }) {
  return (0, import_jsx_runtime66.jsxs)("div", { className: "px-4 py-2 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0", children: [(0, import_jsx_runtime66.jsx)("dt", { className: "text-sm font-medium leading-6 text-gray-900", children: title }), (0, import_jsx_runtime66.jsx)("dd", { className: "mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0", children })] });
}
var AuthorPopover = ({ author, affiliations, children }) => {
  var _a;
  if (!author)
    return (0, import_jsx_runtime66.jsx)(import_jsx_runtime66.Fragment, { children });
  return (0, import_jsx_runtime66.jsxs)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { children: [(0, import_jsx_runtime66.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: (0, import_jsx_runtime66.jsx)("button", { className: "focus:shadow-[0_0_0_2px] focus:shadow-black outline-none hover:underline", "aria-label": "Author Details", children }) }), (0, import_jsx_runtime66.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { children: (0, import_jsx_runtime66.jsxs)($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, { className: "hover-card-content rounded p-5 w-[400px] bg-white shadow", sideOffset: 5, children: [(0, import_jsx_runtime66.jsxs)("div", { className: "flex flex-col gap-2.5", children: [(0, import_jsx_runtime66.jsx)("p", { className: "text-mauve12 text-[15px] leading-[19px] font-medium mb-2.5", children: author.name }), (0, import_jsx_runtime66.jsx)("p", { className: "text-mauve12 text-[15px] leading-[19px] font-medium mb-2.5", children: (_a = author.affiliations) === null || _a === void 0 ? void 0 : _a.map((affiliationId) => (0, import_jsx_runtime66.jsx)(Affiliation, { affiliations, affiliationId }, affiliationId)) }), (0, import_jsx_runtime66.jsxs)("dl", { className: "divide-y divide-gray-100", children: [author.email && (0, import_jsx_runtime66.jsx)(Definition, { title: "Email", children: (0, import_jsx_runtime66.jsx)("a", { className: "ml-1", href: `mailto:${author.email}`, title: `${author.name} <${author.email}>`, target: "_blank", rel: "noopener noreferrer", children: author.email }) }), author.orcid && (0, import_jsx_runtime66.jsx)(Definition, { title: "ORCID", children: (0, import_jsx_runtime66.jsx)("a", { className: "ml-1", href: `https://orcid.org/${author.orcid}`, target: "_blank", rel: "noopener noreferrer", title: "ORCID (Open Researcher and Contributor ID)", children: author.orcid }) }), author.github && (0, import_jsx_runtime66.jsx)(Definition, { title: "GitHub", children: (0, import_jsx_runtime66.jsxs)("a", { className: "ml-1", href: `https://github.com/${author.github}`, target: "_blank", rel: "noopener noreferrer", title: `GitHub: ${author.github}`, children: ["@", author.github] }) }), author.twitter && (0, import_jsx_runtime66.jsx)(Definition, { title: "Twitter", children: (0, import_jsx_runtime66.jsxs)("a", { className: "ml-1", href: `https://twitter.com/${author.twitter}`, target: "_blank", rel: "noopener noreferrer", title: `Twitter: ${author.twitter}`, children: ["@", author.twitter] }) }), author.url && (0, import_jsx_runtime66.jsx)(Definition, { title: "Website", children: (0, import_jsx_runtime66.jsx)("a", { className: "ml-1", href: author.url, target: "_blank", rel: "noopener noreferrer", title: `Author Website`, children: author.url }) }), author.roles && (0, import_jsx_runtime66.jsx)(Definition, { title: "Roles", children: author.roles.join(", ") })] })] }), (0, import_jsx_runtime66.jsx)($cb5cc270b50c6fcd$export$21b07c8f274aebd5, { className: "fill-white" })] }) })] });
};

// ../../packages/frontmatter/dist/Authors.js
function Author({ author, affiliations, className }) {
  return (0, import_jsx_runtime67.jsxs)("span", { className: (0, import_classnames28.default)("font-semibold text-sm", className), children: [(0, import_jsx_runtime67.jsx)(AuthorPopover, { author, affiliations, children: author.name }), author.email && author.corresponding && (0, import_jsx_runtime67.jsx)("a", { className: "ml-1", href: `mailto:${author.email}`, title: `${author.name} <${author.email}>`, target: "_blank", rel: "noopener noreferrer", children: (0, import_jsx_runtime67.jsx)(EmailIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-blue-400 -translate-y-[0.1em]" }) }), author.orcid && (0, import_jsx_runtime67.jsx)("a", { className: "ml-1", href: `https://orcid.org/${author.orcid}`, target: "_blank", rel: "noopener noreferrer", title: "ORCID (Open Researcher and Contributor ID)", children: (0, import_jsx_runtime67.jsx)(OrcidIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-[#A9C751] -translate-y-[0.1em]" }) }), author.twitter && (0, import_jsx_runtime67.jsx)("a", { className: "ml-1", href: `https://twitter.com/${author.twitter}`, target: "_blank", rel: "noopener noreferrer", title: `Twitter: ${author.twitter}`, children: (0, import_jsx_runtime67.jsx)(TwitterIcon_default, { width: "1rem", height: "1rem", className: "inline-block text-gray-400 hover:text-[#1DA1F2] -translate-y-[0.1em]" }) })] });
}
function AuthorsList({ authors, affiliations }) {
  if (!authors || authors.length === 0)
    return null;
  return (0, import_jsx_runtime67.jsx)("div", { children: authors.map((a4, i5) => (0, import_jsx_runtime67.jsx)(Author, { author: a4, affiliations, className: (0, import_classnames28.default)("inline-block", {
    "text-comma": i5 < authors.length - 1
  }) }, a4.name)) });
}
function AuthorAndAffiliations({ authors, affiliations }) {
  if (!authors || authors.length === 0)
    return null;
  const hasAffliations = authors.reduce((r4, { affiliations: a4 }) => r4 || !!a4 && (a4 === null || a4 === void 0 ? void 0 : a4.length) > 0, false);
  if (!hasAffliations) {
    return (0, import_jsx_runtime67.jsx)("header", { className: "mt-4 not-prose", children: (0, import_jsx_runtime67.jsx)(AuthorsList, { authors, affiliations }) });
  }
  return (0, import_jsx_runtime67.jsx)("header", { className: "mt-4 not-prose", children: (0, import_jsx_runtime67.jsxs)("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-y-1", children: [authors.length > 1 && (0, import_jsx_runtime67.jsxs)(import_jsx_runtime67.Fragment, { children: [(0, import_jsx_runtime67.jsx)("div", { className: "pb-2 text-xs font-thin uppercase", children: "Authors" }), (0, import_jsx_runtime67.jsx)("div", { className: "pb-2 text-xs font-thin uppercase", children: "Affiliations" })] }), authors.map((author) => {
    var _a;
    return (0, import_jsx_runtime67.jsxs)(import_react82.default.Fragment, { children: [(0, import_jsx_runtime67.jsx)("div", { children: (0, import_jsx_runtime67.jsx)(Author, { author, affiliations }) }), (0, import_jsx_runtime67.jsx)("div", { className: "text-sm", children: (_a = author.affiliations) === null || _a === void 0 ? void 0 : _a.map((affiliationId) => {
      return (0, import_jsx_runtime67.jsx)("div", { children: (0, import_jsx_runtime67.jsx)(Affiliation, { affiliations, affiliationId }) }, affiliationId);
    }) })] }, author.name);
  })] }) });
}

// ../../packages/frontmatter/dist/FrontmatterBlock.js
function ExternalOrInternalLink2({ to, className, title, children }) {
  return (0, import_jsx_runtime68.jsx)("a", { href: to, className, title, children });
}
function DoiBadge({ doi: possibleLink, className }) {
  if (!possibleLink)
    return null;
  const doi2 = possibleLink.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, "");
  const url = `https://doi.org/${doi2}`;
  return (0, import_jsx_runtime68.jsx)("div", { className: (0, import_classnames29.default)("flex-none", className), title: "DOI (Digital Object Identifier)", children: (0, import_jsx_runtime68.jsx)("a", { className: "font-light no-underline hover:font-light hover:underline text-inherit hover:text-inherit", target: "_blank", rel: "noopener noreferrer", href: url, children: url }) });
}
function DateString({ date, format: format2 = {
  year: "numeric",
  month: "long",
  day: "numeric"
}, spacer }) {
  if (!date)
    return null;
  const d6 = new Date(date);
  const utcDate = new Date(d6.getUTCFullYear(), d6.getUTCMonth(), d6.getUTCDate());
  const dateString = utcDate.toLocaleDateString("en-US", format2);
  return (0, import_jsx_runtime68.jsx)("time", { dateTime: date, className: (0, import_classnames29.default)({ "text-spacer": spacer }), children: dateString });
}
function GitHubLink({ github: possibleLink }) {
  if (!possibleLink)
    return null;
  const github = possibleLink.replace(/^(https?:\/\/)?github\.com\//, "");
  return (0, import_jsx_runtime68.jsx)("a", { href: `https://github.com/${github}`, title: `GitHub Repository: ${github}`, target: "_blank", rel: "noopener noreferrer", className: "text-inherit hover:text-inherit", children: (0, import_jsx_runtime68.jsx)(GithubIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block mr-1 opacity-60 hover:opacity-100" }) });
}
function OpenAccessBadge({ open_access }) {
  if (!open_access)
    return null;
  return (0, import_jsx_runtime68.jsx)("a", { href: "https://en.wikipedia.org/wiki/Open_access", target: "_blank", rel: "noopener noreferrer", title: "Open Access", className: "text-inherit hover:text-inherit", children: (0, import_jsx_runtime68.jsx)(OpenAccessIcon_default, { width: "1.25rem", height: "1.25rem", className: "mr-1 inline-block opacity-60 hover:opacity-100 hover:text-[#E18435]" }) });
}
function Journal({ venue, biblio, className }) {
  if (!venue)
    return null;
  const { title, url } = typeof venue === "string" ? { title: venue, url: null } : venue;
  if (!title)
    return null;
  const { volume, issue } = biblio !== null && biblio !== void 0 ? biblio : {};
  return (0, import_jsx_runtime68.jsxs)("div", { className: (0, import_classnames29.default)("flex-none mr-2", className), children: [url ? (0, import_jsx_runtime68.jsx)(ExternalOrInternalLink2, { className: "font-semibold no-underline smallcaps", to: url, title, children: title }) : (0, import_jsx_runtime68.jsx)("span", { className: "font-semibold smallcaps", children: title }), volume != null && (0, import_jsx_runtime68.jsxs)("span", { className: "pl-2 ml-2 border-l", children: ["Volume ", volume, issue != null && (0, import_jsx_runtime68.jsxs)(import_jsx_runtime68.Fragment, { children: [", Issue ", issue] })] })] });
}
function FrontmatterBlock({ frontmatter, kind = SourceFileKind.Article, authorStyle = "block", hideBadges, hideExports, className }) {
  if (!frontmatter)
    return null;
  const { title, subtitle, subject, doi: doi2, open_access, license, github, venue, biblio, exports, downloads, date, authors } = frontmatter;
  const isJupyter = kind === SourceFileKind.Notebook;
  const hasExports = downloads ? downloads.length > 0 : exports && exports.length > 0;
  const hasAuthors = authors && authors.length > 0;
  const hasBadges = !!open_access || !!license || !!hasExports || !!isJupyter || !!github;
  const hasHeaders = !!subject || !!venue || !!biblio;
  const hasDateOrDoi = !!doi2 || !!date;
  const showHeaderBlock = hasHeaders || hasBadges && !hideBadges || hasExports && !hideExports;
  if (!title && !subtitle && !showHeaderBlock && !hasAuthors && !hasDateOrDoi) {
    return null;
  }
  return (0, import_jsx_runtime68.jsxs)("div", { id: "skip-to-frontmatter", "aria-label": "article frontmatter", className: (0, import_classnames29.default)(className), children: [showHeaderBlock && (0, import_jsx_runtime68.jsxs)("div", { className: "flex items-center h-6 mt-3 mb-5 text-sm font-light", children: [subject && (0, import_jsx_runtime68.jsx)("div", { className: (0, import_classnames29.default)("flex-none pr-2 smallcaps", {
    "border-r mr-2": venue
  }), children: subject }), (0, import_jsx_runtime68.jsx)(Journal, { venue, biblio }), (0, import_jsx_runtime68.jsx)("div", { className: "flex-grow" }), !hideBadges && (0, import_jsx_runtime68.jsxs)(import_jsx_runtime68.Fragment, { children: [(0, import_jsx_runtime68.jsx)(LicenseBadges, { license }), (0, import_jsx_runtime68.jsx)(OpenAccessBadge, { open_access }), (0, import_jsx_runtime68.jsx)(GitHubLink, { github }), isJupyter && (0, import_jsx_runtime68.jsx)("div", { className: "inline-block mr-1", children: (0, import_jsx_runtime68.jsx)(JupyterIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block", title: "Jupyter Notebook" }) })] }), !hideExports && (0, import_jsx_runtime68.jsx)(DownloadsDropdown, { exports: downloads !== null && downloads !== void 0 ? downloads : exports })] }), title && (0, import_jsx_runtime68.jsx)("h1", { className: "mb-0", children: title }), subtitle && (0, import_jsx_runtime68.jsx)("p", { className: "mt-2 mb-0 lead text-zinc-600 dark:text-zinc-400", children: subtitle }), hasAuthors && authorStyle === "list" && (0, import_jsx_runtime68.jsx)(AuthorsList, { authors: frontmatter.authors, affiliations: frontmatter.affiliations }), hasAuthors && authorStyle === "block" && (0, import_jsx_runtime68.jsx)(AuthorAndAffiliations, { authors: frontmatter.authors, affiliations: frontmatter.affiliations }), hasDateOrDoi && (0, import_jsx_runtime68.jsxs)("div", { className: "flex mt-2 text-sm font-light", children: [(0, import_jsx_runtime68.jsx)(DateString, { date, spacer: !!doi2 }), (0, import_jsx_runtime68.jsx)(DoiBadge, { doi: doi2 })] })] });
}

// ../../packages/site/src/components/Navigation/ThemeButton.tsx
var import_classnames30 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime(), 1);
function ThemeButton({ className = "w-8 h-8 mx-3" }) {
  const { isDark, nextTheme } = useTheme();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
    "button",
    {
      className: (0, import_classnames30.default)(
        "theme rounded-full border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800",
        className
      ),
      title: `Change theme to ${isDark ? "light" : "dark"} mode.`,
      "aria-label": `Change theme to ${isDark ? "light" : "dark"} mode.`,
      onClick: nextTheme,
      children: isDark ? /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(MoonIcon_default, { className: "h-full w-full p-0.5" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
        lineNumber: 19,
        columnNumber: 9
      }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(SunIcon_default, { className: "h-full w-full p-0.5" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
        lineNumber: 21,
        columnNumber: 9
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
      lineNumber: 9,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_react87 = __toESM(require_react(), 1);
var import_classnames34 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/Loading.tsx
var import_react84 = __toESM(require_react(), 1);
var import_classnames31 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime(), 1);
function useLoading() {
  const transitionState = useNavigation().state;
  const ref = (0, import_react84.useMemo)(() => ({}), []);
  const [showLoading, setShowLoading] = (0, import_react84.useState)(false);
  (0, import_react84.useEffect)(() => {
    if (transitionState === "loading") {
      ref.start = setTimeout(() => {
        setShowLoading(true);
      }, 150);
    } else {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
        setShowLoading(false);
        return;
      }
      ref.finish = setTimeout(() => {
        setShowLoading(false);
      }, 150);
    }
    return () => {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
      }
      if (ref.finish) {
        clearTimeout(ref.finish);
        delete ref.finish;
      }
    };
  }, [transitionState]);
  return { showLoading, isLoading: transitionState === "loading" };
}
function LoadingBar() {
  const { isLoading, showLoading } = useLoading();
  if (!showLoading)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "div",
    {
      className: (0, import_classnames31.default)(
        "w-screen h-[2px] bg-blue-500 absolute left-0 bottom-0 transition-transform",
        {
          "animate-load scale-x-40": isLoading,
          "scale-x-100": !isLoading
        }
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Loading.tsx",
      lineNumber: 49,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/HomeLink.tsx
var import_classnames32 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime(), 1);
function HomeLink({
  logo,
  logoDark,
  logoText,
  name
}) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const nothingSet = !logo && !logoText;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
    Link2,
    {
      className: "flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7",
      to: withBaseurl("/", baseurl),
      prefetch: "intent",
      children: [
        logo && /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "div",
          {
            className: (0, import_classnames32.default)("p-1 mr-3", {
              "dark:bg-white dark:rounded": !logoDark
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                "img",
                {
                  src: logo,
                  className: (0, import_classnames32.default)("h-9", { "dark:hidden": !!logoDark }),
                  alt: logoText || name,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
                  lineNumber: 30,
                  columnNumber: 11
                },
                this
              ),
              logoDark && /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                "img",
                {
                  src: logoDark,
                  className: "hidden h-9 dark:block",
                  alt: logoText || name,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
                  lineNumber: 37,
                  columnNumber: 13
                },
                this
              )
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
            lineNumber: 25,
            columnNumber: 9
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          "span",
          {
            className: (0, import_classnames32.default)("text-md sm:text-xl tracking-tight sm:mr-5", {
              "sr-only": !(logoText || nothingSet)
            }),
            children: logoText || "Made with MyST"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
            lineNumber: 46,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
      lineNumber: 19,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/ActionMenu.tsx
var import_react85 = __toESM(require_react(), 1);
var import_classnames33 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime(), 1);
function ActionMenu({ actions }) {
  if (!actions || actions.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(it, { as: "div", className: "relative", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(it.Button, { className: "flex text-sm bg-transparent rounded-full focus:outline-none", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 13,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex items-center text-stone-200 hover:text-white", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(EllipsisVerticalIcon_default, { width: "2rem", height: "2rem", className: "p-1" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 15,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 14,
        columnNumber: 11
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
      lineNumber: 12,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
      lineNumber: 11,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
      tt,
      {
        as: import_react85.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(it.Items, { className: "absolute right-0 w-48 py-1 mt-2 origin-top-right bg-white rounded-sm shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none", children: actions == null ? void 0 : actions.map((action) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(it.Item, { children: ({ active }) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
          "a",
          {
            href: action.url,
            className: (0, import_classnames33.default)(
              active ? "bg-gray-100" : "",
              "block px-4 py-2 text-sm text-gray-700"
            ),
            children: action.title
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
            lineNumber: 32,
            columnNumber: 17
          },
          this
        ) }, action.url, false, {
          fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
          lineNumber: 30,
          columnNumber: 13
        }, this)) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
          lineNumber: 28,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 19,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime(), 1);
var DEFAULT_NAV_HEIGHT = 60;
function ExternalOrInternalLink3({
  to,
  className,
  children,
  nav,
  prefetch = "intent"
}) {
  const Link2 = useLinkProvider();
  const NavLink2 = useNavLinkProvider();
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  if (to.startsWith("http") || to.startsWith("mailto:")) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("a", { href: to, target: "_blank", rel: "noopener noreferrer", className: staticClass, children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 37,
      columnNumber: 7
    }, this);
  }
  if (nav) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(NavLink2, { prefetch, to, className, children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 44,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(Link2, { prefetch, to, className: staticClass, children }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 50,
    columnNumber: 5
  }, this);
}
function NavItem({ item }) {
  var _a, _b;
  const NavLink2 = useNavLinkProvider();
  if (!("children" in item)) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "relative inline-block mx-2 grow-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
      ExternalOrInternalLink3,
      {
        nav: true,
        to: (_a = item.url) != null ? _a : "",
        className: ({ isActive }) => (0, import_classnames34.default)(
          "inline-flex items-center justify-center w-full mx-2 py-1 text-md font-medium dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75",
          {
            "border-b border-stone-200": isActive
          }
        ),
        children: item.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 61,
        columnNumber: 9
      },
      this
    ) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 60,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(it, { as: "div", className: "relative inline-block mx-2 grow-0", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "inline-block", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(it.Button, { className: "inline-flex items-center justify-center w-full py-1 mx-2 font-medium rounded-md text-md text-stone-900 dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("span", { children: item.title }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 82,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
        ChevronDownIcon_default,
        {
          width: "1.25rem",
          height: "1.25rem",
          className: "ml-2 -mr-1 text-violet-200 hover:text-violet-100"
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 83,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 81,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 80,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
      tt,
      {
        as: import_react87.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(it.Items, { className: "absolute w-48 py-1 mt-2 origin-top-left bg-white rounded-sm shadow-lg left-4 ring-1 ring-black ring-opacity-5 focus:outline-none", children: (_b = item.children) == null ? void 0 : _b.map((action) => {
          var _a2;
          return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(it.Item, { children: ((_a2 = action.url) == null ? void 0 : _a2.startsWith("http")) ? /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
            "a",
            {
              href: action.url || "",
              className: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black",
              target: "_blank",
              rel: "noopener noreferrer",
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 104,
              columnNumber: 17
            },
            this
          ) : /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
            NavLink2,
            {
              to: action.url || "",
              className: ({ isActive }) => (0, import_classnames34.default)(
                " block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black ",
                {
                  "text-black font-bold": isActive
                }
              ),
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 113,
              columnNumber: 17
            },
            this
          ) }, action.url, false, {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 101,
            columnNumber: 13
          }, this);
        }) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 99,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 90,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 79,
    columnNumber: 5
  }, this);
}
function NavItems({ nav }) {
  if (!nav)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "flex-grow hidden text-md lg:block", children: nav.map((item) => {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(NavItem, { item }, "url" in item ? item.url : item.title, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 140,
      columnNumber: 16
    }, this);
  }) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 138,
    columnNumber: 5
  }, this);
}
function TopNav() {
  var _a;
  const [open, setOpen] = useNavOpen();
  const config = useSiteManifest();
  const { title, nav, actions } = config != null ? config : {};
  const { logo, logo_dark, logo_text } = (_a = config == null ? void 0 : config.options) != null ? _a : {};
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 fixed w-screen top-0 z-30 h-[60px]", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("nav", { className: "flex items-center justify-between flex-wrap max-w-[1440px] mx-auto", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "block xl:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
          "button",
          {
            className: "flex items-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100",
            onClick: () => {
              setOpen(!open);
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(Bars3Icon_default, { width: "2rem", height: "2rem", className: "m-1" }, void 0, false, {
                fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                lineNumber: 162,
                columnNumber: 15
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
                fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                lineNumber: 163,
                columnNumber: 15
              }, this)
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 156,
            columnNumber: 13
          },
          this
        ) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 155,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(HomeLink, { name: title, logo, logoDark: logo_dark, logoText: logo_text }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 166,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 154,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "flex items-center flex-grow w-auto", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(NavItems, { nav }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 169,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "flex-grow block" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 170,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(ThemeButton, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 171,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "block sm:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(ActionMenu, { actions }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 173,
          columnNumber: 13
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 172,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "hidden sm:block", children: actions == null ? void 0 : actions.map((action, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
          ExternalOrInternalLink3,
          {
            className: "inline-block px-4 py-2 mx-1 mt-0 leading-none border rounded text-md border-stone-700 dark:border-white text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 hover:bg-neutral-100",
            to: action.url,
            children: action.title
          },
          action.url || index2,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 177,
            columnNumber: 15
          },
          this
        )) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 175,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 168,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 153,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(LoadingBar, {}, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 188,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 152,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/TableOfContents.tsx
var import_react92 = __toESM(require_react(), 1);
var import_classnames36 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/TableOfContentsItems.tsx
var import_react90 = __toESM(require_react(), 1);
var import_classnames35 = __toESM(require_classnames(), 1);

// ../../node_modules/@radix-ui/react-collapsible/dist/index.mjs
init_extends();
var import_react89 = __toESM(require_react(), 1);
var $409067139f391064$var$COLLAPSIBLE_NAME = "Collapsible";
var [$409067139f391064$var$createCollapsibleContext, $409067139f391064$export$952b32dcbe73087a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($409067139f391064$var$COLLAPSIBLE_NAME);
var [$409067139f391064$var$CollapsibleProvider, $409067139f391064$var$useCollapsibleContext] = $409067139f391064$var$createCollapsibleContext($409067139f391064$var$COLLAPSIBLE_NAME);
var $409067139f391064$export$6eb0f7ddcda6131f = /* @__PURE__ */ (0, import_react89.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, open: openProp, defaultOpen, disabled, onOpenChange, ...collapsibleProps } = props;
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react89.createElement)($409067139f391064$var$CollapsibleProvider, {
    scope: __scopeCollapsible,
    disabled,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenToggle: (0, import_react89.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    )
  }, /* @__PURE__ */ (0, import_react89.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-state": $409067139f391064$var$getState(open),
    "data-disabled": disabled ? "" : void 0
  }, collapsibleProps, {
    ref: forwardedRef
  })));
});
var $409067139f391064$var$TRIGGER_NAME = "CollapsibleTrigger";
var $409067139f391064$export$c135dce7b15bbbdc = /* @__PURE__ */ (0, import_react89.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, ...triggerProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$TRIGGER_NAME, __scopeCollapsible);
  return /* @__PURE__ */ (0, import_react89.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-controls": context.contentId,
    "aria-expanded": context.open || false,
    "data-state": $409067139f391064$var$getState(context.open),
    "data-disabled": context.disabled ? "" : void 0,
    disabled: context.disabled
  }, triggerProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
});
var $409067139f391064$var$CONTENT_NAME = "CollapsibleContent";
var $409067139f391064$export$aadde00976f34151 = /* @__PURE__ */ (0, import_react89.forwardRef)((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, props.__scopeCollapsible);
  return /* @__PURE__ */ (0, import_react89.createElement)(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || context.open
    },
    ({ present }) => /* @__PURE__ */ (0, import_react89.createElement)($409067139f391064$var$CollapsibleContentImpl, _extends({}, contentProps, {
      ref: forwardedRef,
      present
    }))
  );
});
var $409067139f391064$var$CollapsibleContentImpl = /* @__PURE__ */ (0, import_react89.forwardRef)((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, __scopeCollapsible);
  const [isPresent, setIsPresent] = (0, import_react89.useState)(present);
  const ref = (0, import_react89.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const heightRef = (0, import_react89.useRef)(0);
  const height = heightRef.current;
  const widthRef = (0, import_react89.useRef)(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = (0, import_react89.useRef)(isOpen);
  const originalStylesRef = (0, import_react89.useRef)();
  (0, import_react89.useEffect)(() => {
    const rAF2 = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF2);
  }, []);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [
    context.open,
    present
  ]);
  return /* @__PURE__ */ (0, import_react89.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-state": $409067139f391064$var$getState(context.open),
    "data-disabled": context.disabled ? "" : void 0,
    id: context.contentId,
    hidden: !isOpen
  }, contentProps, {
    ref: composedRefs,
    style: {
      [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
      [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
      ...props.style
    }
  }), isOpen && children);
});
function $409067139f391064$var$getState(open) {
  return open ? "open" : "closed";
}
var $409067139f391064$export$be92b6f5f03c0fe9 = $409067139f391064$export$6eb0f7ddcda6131f;
var $409067139f391064$export$41fb9f06171c75f4 = $409067139f391064$export$c135dce7b15bbbdc;
var $409067139f391064$export$7c6e2c02157bb7d2 = $409067139f391064$export$aadde00976f34151;

// ../../packages/site/src/components/Navigation/TableOfContentsItems.tsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime(), 1);
function nestToc(toc) {
  const items = [];
  const stack = [];
  toc.forEach((tocItem, id) => {
    const item = tocItem;
    item.children = [];
    item.id = String(id);
    if (item.level === "index") {
      while (stack.length)
        stack.pop();
      items.push(item);
      return;
    }
    while (stack.length && stack[stack.length - 1].level >= item.level) {
      stack.pop();
    }
    const top = stack[stack.length - 1];
    if (top) {
      top.children.push(item);
    } else {
      items.push(item);
    }
    stack.push(item);
  });
  return items;
}
function childrenOpen(headings, pathname, baseurl) {
  return headings.map((heading) => {
    if (withBaseurl(heading.path, baseurl) === pathname)
      return [heading.id];
    const open = childrenOpen(heading.children, pathname, baseurl);
    if (open.length === 0)
      return [];
    return [heading.id, ...open];
  }).flat();
}
var Toc = ({ headings }) => {
  const nested = nestToc(headings);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "w-full px-1 dark:text-white", children: nested.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 54,
    columnNumber: 9
  }, this)) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 52,
    columnNumber: 5
  }, this);
};
function LinkItem({
  className,
  heading,
  onClick
}) {
  const NavLink2 = useNavLinkProvider();
  const baseurl = useBaseurl();
  const [, setOpen] = useNavOpen();
  if (!heading.path) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
      "div",
      {
        title: heading.title,
        className: (0, import_classnames35.default)("block break-words rounded", className),
        onClick: () => {
          onClick == null ? void 0 : onClick();
        },
        children: heading.short_title || heading.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 74,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
    NavLink2,
    {
      prefetch: "intent",
      title: heading.title,
      className: (0, import_classnames35.default)(
        "block break-words focus:outline outline-blue-200 outline-2 rounded",
        className
      ),
      to: withBaseurl(heading.path, baseurl),
      onClick: () => {
        onClick == null ? void 0 : onClick();
        setOpen(false);
      },
      children: heading.short_title || heading.title
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 86,
      columnNumber: 5
    },
    this
  );
}
var NestedToc = ({ heading }) => {
  const { pathname } = useLocation();
  const baseurl = useBaseurl();
  const startOpen = childrenOpen([heading], pathname, baseurl).includes(heading.id);
  const nav = useNavigation();
  const [open, setOpen] = import_react90.default.useState(startOpen);
  (0, import_react90.useEffect)(() => {
    if (nav.state === "idle")
      setOpen(startOpen);
  }, [nav.state]);
  const exact = pathname === withBaseurl(heading.path, baseurl);
  if (!heading.children || heading.children.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
      LinkItem,
      {
        className: (0, import_classnames35.default)("p-2 my-1 rounded-lg", {
          "bg-blue-300/30": exact,
          "hover:bg-slate-300/30": !exact,
          "font-bold": heading.level === "index"
        }),
        heading
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 116,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)($409067139f391064$export$be92b6f5f03c0fe9, { className: "w-full", open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
      "div",
      {
        className: (0, import_classnames35.default)(
          "flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none",
          {
            "bg-blue-300/30": exact,
            "hover:bg-slate-300/30": !exact
          }
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
            LinkItem,
            {
              className: (0, import_classnames35.default)("py-2 grow", {
                "font-semibold text-blue-800 dark:text-blue-200": startOpen,
                "cursor-pointer": !heading.path
              }),
              heading,
              onClick: () => setOpen(heading.path ? true : !open)
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 137,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)($409067139f391064$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
            "button",
            {
              className: "self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2",
              "aria-label": "Open Folder",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
                ChevronRightIcon_default,
                {
                  className: "transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100",
                  height: "1.5rem",
                  width: "1.5rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
                  lineNumber: 150,
                  columnNumber: 13
                },
                this
              )
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 146,
              columnNumber: 11
            },
            this
          ) }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 145,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 128,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)($409067139f391064$export$7c6e2c02157bb7d2, { className: "pl-3 pr-[2px] collapsible-content", children: heading.children.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 160,
      columnNumber: 11
    }, this)) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 158,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 127,
    columnNumber: 5
  }, this);
};

// ../../packages/site/src/components/Navigation/TableOfContents.tsx
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime(), 1);
function useTocHeight(top = 0, inset = 0) {
  const container = (0, import_react92.useRef)(null);
  const toc = (0, import_react92.useRef)(null);
  const transitionState = useNavigation().state;
  const setHeight = () => {
    if (!container.current || !toc.current)
      return;
    const height = container.current.offsetHeight - window.scrollY;
    const div = toc.current.firstChild;
    if (div)
      div.style.height = `min(calc(100vh - ${top}px), ${height + inset}px)`;
    const nav = toc.current.querySelector("nav");
    if (nav)
      nav.style.opacity = height > 150 ? "1" : "0";
  };
  (0, import_react92.useEffect)(() => {
    setHeight();
    setTimeout(setHeight, 100);
    const handleScroll2 = () => setHeight();
    window.addEventListener("scroll", handleScroll2);
    return () => {
      window.removeEventListener("scroll", handleScroll2);
    };
  }, [container, toc, transitionState]);
  return { container, toc };
}
var TableOfContents = ({
  projectSlug,
  tocRef,
  footer
}) => {
  const top = useThemeTop();
  const grid = useGridSystemProvider();
  const footerRef = (0, import_react92.useRef)(null);
  const [open] = useNavOpen();
  const config = useSiteManifest();
  (0, import_react92.useEffect)(() => {
    setTimeout(() => {
      if (!footerRef.current)
        return;
      footerRef.current.style.opacity = "1";
      footerRef.current.style.transform = "none";
    }, 500);
  }, [footerRef]);
  if (!config)
    return null;
  const headings = getProjectHeadings(config, projectSlug, {
    addGroups: false
  });
  if (!headings)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
    "div",
    {
      ref: tocRef,
      className: (0, import_classnames36.default)(
        "fixed",
        `xl:${grid}`,
        // for example, xl:article-grid
        "grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px]",
        { hidden: !open, "z-30": open, "z-10": !open }
      ),
      style: { top },
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
        "div",
        {
          className: (0, import_classnames36.default)(
            "pointer-events-auto",
            "xl:col-margin-left flex-col",
            "overflow-hidden",
            // 'border-r border-stone-200 dark:border-stone-700',
            {
              flex: open,
              "bg-white dark:bg-stone-900": open,
              // just apply when open, so that theme can transition
              "hidden xl:flex": !open
            }
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
              "nav",
              {
                "aria-label": "Table of Contents",
                className: "flex-grow overflow-y-auto transition-opacity mt-6 pb-3 ml-3 xl:ml-0 mr-3 max-w-[350px]",
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Toc, { headings }, void 0, false, {
                  fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                  lineNumber: 91,
                  columnNumber: 11
                }, this)
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                lineNumber: 87,
                columnNumber: 9
              },
              this
            ),
            footer && /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
              "div",
              {
                className: "flex-none py-4 transition-all duration-700 translate-y-6 opacity-0",
                ref: footerRef,
                children: footer
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
                lineNumber: 94,
                columnNumber: 11
              },
              this
            )
          ]
        },
        void 0,
        true,
        {
          fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
          lineNumber: 74,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/TableOfContents.tsx",
      lineNumber: 64,
      columnNumber: 5
    },
    this
  );
};

// ../../packages/site/src/components/Navigation/Navigation.tsx
var import_jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime(), 1);
function Navigation({
  children,
  projectSlug,
  tocRef,
  hide_toc,
  footer
}) {
  const [open, setOpen] = useNavOpen();
  const top = useThemeTop();
  if (children)
    console.warn(
      `Including children in Navigation can break keyboard accessbility and is deprecated. Please move children to the page component.`
    );
  if (hide_toc)
    return children ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(import_jsx_dev_runtime12.Fragment, { children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 23,
      columnNumber: 42
    }, this);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(import_jsx_dev_runtime12.Fragment, { children: [
    open && /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "div",
      {
        className: "fixed inset-0 z-30 bg-black opacity-50",
        style: { marginTop: top },
        onClick: () => setOpen(false)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
        lineNumber: 27,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(TableOfContents, { tocRef, projectSlug, footer }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 33,
      columnNumber: 7
    }, this),
    children
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Abstract.tsx
var import_jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime(), 1);
function Abstract({
  content,
  title = "Abstract",
  id = "abstract",
  className
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { className, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("h2", { id, className: "mb-3 text-base font-semibold group", children: [
      title,
      /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
        fileName: "../../packages/site/src/components/Abstract.tsx",
        lineNumber: 21,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 19,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { className: "px-6 py-1 mb-3 rounded-sm bg-slate-50 dark:bg-slate-800", children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(ContentBlocks, { mdast: content, className: "col-body" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 24,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 23,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Abstract.tsx",
    lineNumber: 18,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Keywords.tsx
var import_classnames37 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime(), 1);
function Keywords({
  keywords,
  hideKeywords,
  className
}) {
  if (hideKeywords || !keywords || keywords.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { className: (0, import_classnames37.default)("mb-10 group", className), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("span", { className: "mr-2 font-semibold", children: "Keywords:" }, void 0, false, {
      fileName: "../../packages/site/src/components/Keywords.tsx",
      lineNumber: 16,
      columnNumber: 7
    }, this),
    keywords.map((k, i5) => /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
      "span",
      {
        className: (0, import_classnames37.default)({
          "after:content-[','] after:mr-1": i5 < keywords.length - 1
        }),
        children: k
      },
      k,
      false,
      {
        fileName: "../../packages/site/src/components/Keywords.tsx",
        lineNumber: 18,
        columnNumber: 9
      },
      this
    )),
    /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(HashLink, { id: "keywords", title: "Link to Keywords", hover: true, className: "ml-2" }, void 0, false, {
      fileName: "../../packages/site/src/components/Keywords.tsx",
      lineNumber: 27,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Keywords.tsx",
    lineNumber: 15,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/FrontmatterParts.tsx
var import_jsx_dev_runtime15 = __toESM(require_jsx_dev_runtime(), 1);
function FrontmatterParts({
  parts,
  keywords,
  hideKeywords,
  containerClassName,
  innerClassName
}) {
  if (!parts.abstract && !parts.keypoints && !parts.summary)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("div", { className: containerClassName, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(Abstract, { className: innerClassName, content: parts.abstract }, void 0, false, {
      fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
      lineNumber: 21,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(
      Abstract,
      {
        className: innerClassName,
        content: parts.keypoints,
        title: "Key Points",
        id: "keypoints"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 22,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(
      Abstract,
      {
        className: innerClassName,
        content: parts.summary,
        title: "Plain Language Summary",
        id: "summary"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 28,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(Keywords, { className: innerClassName, keywords, hideKeywords }, void 0, false, {
      fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
      lineNumber: 34,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
    lineNumber: 20,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Backmatter.tsx
var import_classnames38 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime16 = __toESM(require_jsx_dev_runtime(), 1);
function BackmatterParts({
  parts,
  containerClassName,
  innerClassName
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("div", { className: containerClassName, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
      Backmatter,
      {
        className: innerClassName,
        title: "Acknowledgments",
        id: "acknowledgments",
        content: parts.acknowledgments
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 17,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
      Backmatter,
      {
        className: innerClassName,
        title: "Data Availability",
        id: "data-availability",
        content: parts.data_availability
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 23,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Backmatter.tsx",
    lineNumber: 16,
    columnNumber: 5
  }, this);
}
function Backmatter({
  title,
  id,
  content,
  className
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("div", { className: (0, import_classnames38.default)("flex flex-col w-full md:flex-row group/backmatter", className), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
      "h2",
      {
        id,
        className: "mt-5 text-base font-semibold group md:w-[200px] self-start md:flex-none opacity-90 group-hover/backmatter:opacity-100",
        children: [
          title,
          /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
            fileName: "../../packages/site/src/components/Backmatter.tsx",
            lineNumber: 52,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 47,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("div", { className: "grow opacity-90 group-hover/backmatter:opacity-100 col-screen", children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(MyST, { ast: getChildren(content) }, void 0, false, {
      fileName: "../../packages/site/src/components/Backmatter.tsx",
      lineNumber: 55,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Backmatter.tsx",
      lineNumber: 54,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Backmatter.tsx",
    lineNumber: 46,
    columnNumber: 5
  }, this);
}

// ../../packages/myst-demo/dist/index.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-demo/node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all);
  function all(node) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node) {
    return node && node.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// ../../packages/myst-demo/node_modules/unist-util-remove/lib/index.js
function remove(tree, options, test) {
  const is2 = convert(test || options);
  let cascade = true;
  if (options && typeof options === "object" && "cascade" in options && typeof options.cascade === "boolean") {
    cascade = options.cascade;
  }
  preorder(tree);
  function preorder(node, index2, parent) {
    if (node !== tree && is2(node, index2, parent)) {
      return false;
    }
    if ("children" in node && Array.isArray(node.children)) {
      const nodeAsParent = (
        /** @type {Parent} */
        node
      );
      const children = nodeAsParent.children;
      let oldChildIndex = -1;
      let newChildIndex = 0;
      if (children.length > 0) {
        while (++oldChildIndex < children.length) {
          if (preorder(children[oldChildIndex], oldChildIndex, nodeAsParent)) {
            children[newChildIndex++] = children[oldChildIndex];
          }
        }
        if (node !== tree && cascade && !newChildIndex) {
          return false;
        }
        children.length = newChildIndex;
      }
    }
    return true;
  }
}

// ../../packages/myst-demo/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject4(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray2(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result2 = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result2 += string;
  }
  return result2;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject4;
var toArray_1 = toArray2;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact2) {
  var where2 = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where2 += 'in "' + exception2.mark.name + '" ';
  }
  where2 += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact2 && exception2.mark.snippet) {
    where2 += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where2;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact2) {
  return this.name + ": " + formatError(this, compact2);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max3) {
  return common.repeat(" ", max3 - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result2 = "", i5, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i5 = 1; i5 <= options.linesBefore; i5++) {
    if (foundLineNo - i5 < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i5],
      lineEnds[foundLineNo - i5],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i5]),
      maxLineLength
    );
    result2 = common.repeat(" ", options.indent) + padStart((mark.line - i5 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result2;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result2 += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result2 += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i5 = 1; i5 <= options.linesAfter; i5++) {
    if (foundLineNo + i5 >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i5],
      lineEnds[foundLineNo + i5],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i5]),
      maxLineLength
    );
    result2 += common.repeat(" ", options.indent) + padStart((mark.line + i5 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result2.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result2 = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result2[String(alias)] = style;
      });
    });
  }
  return result2;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result2 = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result2.length;
    result2.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result2[newIndex] = currentType;
  });
  return result2;
}
function compileMap() {
  var result2 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result2.multi[type2.kind].push(type2);
      result2.multi["fallback"].push(type2);
    } else {
      result2[type2.kind][type2.tag] = result2["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result2;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result2 = Object.create(Schema$1.prototype);
  result2.implicit = (this.implicit || []).concat(implicit);
  result2.explicit = (this.explicit || []).concat(explicit);
  result2.compiledImplicit = compileList(result2, "implicit");
  result2.compiledExplicit = compileList(result2, "explicit");
  result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit);
  return result2;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map3 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map3
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max3 = data.length;
  return max3 === 1 && data === "~" || max3 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull2(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull2,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max3 = data.length;
  return max3 === 4 && (data === "true" || data === "True" || data === "TRUE") || max3 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean2(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean2,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c6) {
  return 48 <= c6 && c6 <= 57 || 65 <= c6 && c6 <= 70 || 97 <= c6 && c6 <= 102;
}
function isOctCode(c6) {
  return 48 <= c6 && c6 <= 55;
}
function isDecCode(c6) {
  return 48 <= c6 && c6 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max3 = data.length, index2 = 0, hasDigits = false, ch;
  if (!max3)
    return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max3)
      return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max3; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index2 < max3; index2++) {
    ch = data[index2];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code3, idx, bitlen = 0, max3 = data.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    code3 = map4.indexOf(data.charAt(idx));
    if (code3 > 64)
      continue;
    if (code3 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max3 = input.length, map4 = BASE64_MAP, bits = 0, result2 = [];
  for (idx = 0; idx < max3; idx++) {
    if (idx % 4 === 0 && idx) {
      result2.push(bits >> 16 & 255);
      result2.push(bits >> 8 & 255);
      result2.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max3 % 4 * 6;
  if (tailbits === 0) {
    result2.push(bits >> 16 & 255);
    result2.push(bits >> 8 & 255);
    result2.push(bits & 255);
  } else if (tailbits === 18) {
    result2.push(bits >> 10 & 255);
    result2.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result2.push(bits >> 4 & 255);
  }
  return new Uint8Array(result2);
}
function representYamlBinary(object2) {
  var result2 = "", bits = 0, idx, tail, max3 = object2.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    if (idx % 3 === 0 && idx) {
      result2 += map4[bits >> 18 & 63];
      result2 += map4[bits >> 12 & 63];
      result2 += map4[bits >> 6 & 63];
      result2 += map4[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max3 % 3;
  if (tail === 0) {
    result2 += map4[bits >> 18 & 63];
    result2 += map4[bits >> 12 & 63];
    result2 += map4[bits >> 6 & 63];
    result2 += map4[bits & 63];
  } else if (tail === 2) {
    result2 += map4[bits >> 10 & 63];
    result2 += map4[bits >> 4 & 63];
    result2 += map4[bits << 2 & 63];
    result2 += map4[64];
  } else if (tail === 1) {
    result2 += map4[bits >> 2 & 63];
    result2 += map4[bits << 4 & 63];
    result2 += map4[64];
    result2 += map4[64];
  }
  return result2;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object2 = data;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index2, length, pair, keys2, result2, object2 = data;
  result2 = new Array(object2.length);
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1)
      return false;
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index2, length, pair, keys2, result2, object2 = data;
  result2 = new Array(object2.length);
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    pair = object2[index2];
    keys2 = Object.keys(pair);
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return result2;
}
var pairs2 = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs2,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c6) {
  return c6 === 10 || c6 === 13;
}
function is_WHITE_SPACE(c6) {
  return c6 === 9 || c6 === 32;
}
function is_WS_OR_EOL(c6) {
  return c6 === 9 || c6 === 32 || c6 === 10 || c6 === 13;
}
function is_FLOW_INDICATOR(c6) {
  return c6 === 44 || c6 === 91 || c6 === 93 || c6 === 123 || c6 === 125;
}
function fromHexCode(c6) {
  var lc;
  if (48 <= c6 && c6 <= 57) {
    return c6 - 48;
  }
  lc = c6 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c6) {
  if (c6 === 120) {
    return 2;
  }
  if (c6 === 117) {
    return 4;
  }
  if (c6 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c6) {
  if (48 <= c6 && c6 <= 57) {
    return c6 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c6) {
  return c6 === 48 ? "\0" : c6 === 97 ? "\x07" : c6 === 98 ? "\b" : c6 === 116 ? "	" : c6 === 9 ? "	" : c6 === 110 ? "\n" : c6 === 118 ? "\v" : c6 === 102 ? "\f" : c6 === 114 ? "\r" : c6 === 101 ? "\x1B" : c6 === 32 ? " " : c6 === 34 ? '"' : c6 === 47 ? "/" : c6 === 92 ? "\\" : c6 === 78 ? "\x85" : c6 === 95 ? "\xA0" : c6 === 76 ? "\u2028" : c6 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c6) {
  if (c6 <= 65535) {
    return String.fromCharCode(c6);
  }
  return String.fromCharCode(
    (c6 - 65536 >> 10) + 55296,
    (c6 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i5 = 0; i5 < 256; i5++) {
  simpleEscapeCheck[i5] = simpleEscapeSequence(i5) ? 1 : 0;
  simpleEscapeMap[i5] = simpleEscapeSequence(i5);
}
var i5;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader2 = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map4) {
  var result2, keys2, index2, length, tag, style, type2;
  if (map4 === null)
    return {};
  result2 = {};
  keys2 = Object.keys(map4);
  for (index2 = 0, length = keys2.length; index2 < length; index2 += 1) {
    tag = keys2[index2];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result2[tag] = style;
  }
  return result2;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result2 = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result2 += ind;
    result2 += line;
  }
  return result2;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c6) {
  return c6 === CHAR_SPACE || c6 === CHAR_TAB;
}
function isPrintable(c6) {
  return 32 <= c6 && c6 <= 126 || 161 <= c6 && c6 <= 55295 && c6 !== 8232 && c6 !== 8233 || 57344 <= c6 && c6 <= 65533 && c6 !== CHAR_BOM || 65536 <= c6 && c6 <= 1114111;
}
function isNsCharOrWhitespace(c6) {
  return isPrintable(c6) && c6 !== CHAR_BOM && c6 !== CHAR_CARRIAGE_RETURN && c6 !== CHAR_LINE_FEED;
}
function isPlainSafe(c6, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c6);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c6);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c6 !== CHAR_COMMA && c6 !== CHAR_LEFT_SQUARE_BRACKET && c6 !== CHAR_RIGHT_SQUARE_BRACKET && c6 !== CHAR_LEFT_CURLY_BRACKET && c6 !== CHAR_RIGHT_CURLY_BRACKET) && c6 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c6 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c6) {
  return isPrintable(c6) && c6 !== CHAR_BOM && !isWhitespace(c6) && c6 !== CHAR_MINUS && c6 !== CHAR_QUESTION && c6 !== CHAR_COLON && c6 !== CHAR_COMMA && c6 !== CHAR_LEFT_SQUARE_BRACKET && c6 !== CHAR_RIGHT_SQUARE_BRACKET && c6 !== CHAR_LEFT_CURLY_BRACKET && c6 !== CHAR_RIGHT_CURLY_BRACKET && c6 !== CHAR_SHARP && c6 !== CHAR_AMPERSAND && c6 !== CHAR_ASTERISK && c6 !== CHAR_EXCLAMATION && c6 !== CHAR_VERTICAL_LINE && c6 !== CHAR_EQUALS && c6 !== CHAR_GREATER_THAN && c6 !== CHAR_SINGLE_QUOTE && c6 !== CHAR_DOUBLE_QUOTE && c6 !== CHAR_PERCENT && c6 !== CHAR_COMMERCIAL_AT && c6 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c6) {
  return !isWhitespace(c6) && c6 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first2 = string.charCodeAt(pos), second;
  if (first2 >= 55296 && first2 <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first2 - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first2;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i5;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
      char = codePointAt(string, i5);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
      char = codePointAt(string, i5);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i5 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i5;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i5 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result2 = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result2 += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result2;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result2 = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result2 += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result2 += "\n";
  if (line.length - start > width && curr > start) {
    result2 += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result2 += line.slice(start);
  }
  return result2.slice(1);
}
function escapeString(string) {
  var result2 = "";
  var char = 0;
  var escapeSeq;
  for (var i5 = 0; i5 < string.length; char >= 65536 ? i5 += 2 : i5++) {
    char = codePointAt(string, i5);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result2 += string[i5];
      if (char >= 65536)
        result2 += string[i5 + 1];
    } else {
      result2 += escapeSeq || encodeHex(char);
    }
  }
  return result2;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    value = object2[index2];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index2), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact2) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
    value = object2[index2];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index2), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact2 || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact2 || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact2, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact2 = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact2);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact2);
        } else {
          writeBlockSequence(state, level, state.dump, compact2);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object2 !== null && typeof object2 === "object") {
    index2 = objects.indexOf(object2);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index2 = 0, length = object2.length; index2 < length; index2 += 1) {
          inspectNode(object2[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object2[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader2.load;
var loadAll = loader2.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map: map3,
  null: _null,
  pairs: pairs2,
  set: set2,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// ../../packages/myst-demo/dist/index.js
var import_react94 = __toESM(require_react(), 1);
var import_classnames39 = __toESM(require_classnames(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function downloadBlob(filename, blob) {
  const a4 = document.createElement("a");
  const url = URL.createObjectURL(blob);
  a4.href = url;
  a4.download = filename;
  a4.click();
}
function saveDocxFile(filename, mdast) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { unified } = yield import("/myst_assets_folder/_shared/unified-YRUTPRKB.js");
    const { mystToDocx, fetchImagesAsBuffers } = yield import("/myst_assets_folder/_shared/dist-UJQJ2NU4.js");
    const tree = JSON.parse(JSON.stringify(mdast));
    const opts = yield fetchImagesAsBuffers(tree);
    const docxBlob = yield unified().use(mystToDocx, opts).stringify(tree).result;
    downloadBlob(filename, docxBlob);
  });
}
function getFrontmatter(vfile, tree) {
  var _a, _b;
  const firstParent = ((_a = tree.children[0]) === null || _a === void 0 ? void 0 : _a.type) === "block" ? tree.children[0] : tree;
  const firstNode = (_b = firstParent.children) === null || _b === void 0 ? void 0 : _b[0];
  let frontmatter = {};
  const firstIsYaml = (firstNode === null || firstNode === void 0 ? void 0 : firstNode.type) === "code" && (firstNode === null || firstNode === void 0 ? void 0 : firstNode.lang) === "yaml";
  if (firstIsYaml) {
    try {
      frontmatter = js_yaml_default.load(firstNode.value) || {};
      firstNode.type = "__delete__";
    } catch (err) {
      fileError(vfile, "Invalid YAML frontmatter", {
        note: err.message,
        ruleId: RuleId.frontmatterIsYaml
      });
    }
  }
  const possibleNull = remove(tree, "__delete__");
  if (possibleNull === null) {
    remove(tree, { cascade: false }, "__delete__");
  }
  return frontmatter;
}
function parse2(text, defaultFrontmatter, options) {
  var _a, _b, _c;
  return __awaiter6(this, void 0, void 0, function* () {
    const { visit } = yield import("/myst_assets_folder/_shared/unist-util-visit-E43QFDEC.js");
    const { unified } = yield import("/myst_assets_folder/_shared/unified-YRUTPRKB.js");
    const { mystParse } = yield import("/myst_assets_folder/_shared/dist-TBV5633H.js");
    const { mathPlugin, footnotesPlugin, keysPlugin, htmlPlugin, reconstructHtmlPlugin, basicTransformationsPlugin, enumerateTargetsPlugin, resolveReferencesPlugin, WikiTransformer, GithubTransformer, DOITransformer, RRIDTransformer, RORTransformer, linksPlugin, ReferenceState, abbreviationPlugin, glossaryPlugin, joinGatesPlugin } = yield import("/myst_assets_folder/_shared/dist-AFU7GCF7.js");
    const { default: mystToTex } = yield import("/myst_assets_folder/_shared/dist-DDPICHH4.js");
    const { default: mystToTypst } = yield import("/myst_assets_folder/_shared/dist-SRSGG4EM.js");
    const { default: mystToJats } = yield import("/myst_assets_folder/_shared/dist-4ZC46U3F.js").catch(() => ({ default: null }));
    const { mystToHtml } = yield import("/myst_assets_folder/_shared/dist-WNCAGVCZ.js");
    const { cardDirective } = yield import("/myst_assets_folder/_shared/dist-7MJX6IHI.js");
    const { gridDirective } = yield import("/myst_assets_folder/_shared/dist-B2GTWGXH.js");
    const { tabDirectives } = yield import("/myst_assets_folder/_shared/dist-ZF7GJYCI.js");
    const { proofDirective } = yield import("/myst_assets_folder/_shared/dist-T5SKRHXN.js");
    const { exerciseDirectives } = yield import("/myst_assets_folder/_shared/dist-6R2JNVRJ.js");
    const vfile = new VFile();
    const parseMyst = (content) => mystParse(content, {
      markdownit: { linkify: true },
      directives: [
        cardDirective,
        gridDirective,
        ...tabDirectives,
        proofDirective,
        ...exerciseDirectives
      ],
      // roles: [reactiveRole],
      vfile
    });
    const mdast = parseMyst(text);
    const linkTransforms = [
      new WikiTransformer(),
      new GithubTransformer(),
      new DOITransformer(),
      new RRIDTransformer(),
      new RORTransformer()
    ];
    const mdastPre = JSON.parse(JSON.stringify(mdast));
    visit(mdastPre, (n4) => delete n4.position);
    const htmlString = mystToHtml(JSON.parse(JSON.stringify(mdast)));
    const references = {
      cite: { order: [], data: {} },
      footnotes: {}
    };
    const frontmatterRaw = getFrontmatter(vfile, mdast);
    const frontmatter = validatePageFrontmatter(frontmatterRaw, {
      property: "frontmatter",
      messages: {}
    });
    const state = new ReferenceState("", {
      numbering: (_a = frontmatter.numbering) !== null && _a !== void 0 ? _a : defaultFrontmatter === null || defaultFrontmatter === void 0 ? void 0 : defaultFrontmatter.numbering,
      vfile
    });
    visit(mdast, (n4) => {
      if (n4.type === "cite") {
        n4.error = true;
      }
    });
    unified().use(reconstructHtmlPlugin).use(htmlPlugin).use(basicTransformationsPlugin, { parser: parseMyst }).use(mathPlugin, { macros: (_b = frontmatter === null || frontmatter === void 0 ? void 0 : frontmatter.math) !== null && _b !== void 0 ? _b : {} }).use(glossaryPlugin).use(abbreviationPlugin, { abbreviations: frontmatter.abbreviations }).use(enumerateTargetsPlugin, { state }).use(linksPlugin, { transformers: linkTransforms }).use(footnotesPlugin).use(joinGatesPlugin).use(resolveReferencesPlugin, { state }).use(keysPlugin).runSync(mdast, vfile);
    const mdastPost = JSON.parse(JSON.stringify(mdast));
    visit(mdastPost, (n4) => {
      delete n4.position;
      delete n4.key;
    });
    const texFile = new VFile();
    const tex = unified().use(mystToTex, { references }).stringify(mdast, texFile).result;
    const typstFile = new VFile();
    let typst;
    try {
      typst = unified().use(mystToTypst).stringify(mdast, typstFile).result;
    } catch (error) {
      console.error(error);
      typst = {
        value: `Problem with typst conversion: ${error.message || "Unknown Error"}`,
        macros: [],
        commands: {}
      };
    }
    const jatsFile = new VFile();
    const jats = mystToJats ? unified().use(mystToJats, SourceFileKind.Article, frontmatter, void 0, "", {
      format: 2,
      writeFullArticle: (_c = options === null || options === void 0 ? void 0 : options.jats) === null || _c === void 0 ? void 0 : _c.fullArticle
    }).stringify(mdast, jatsFile).result : "Problem loading myst-to-jats";
    return {
      frontmatter,
      mdastPre,
      mdastPost,
      references: Object.assign(Object.assign({}, references), { article: mdast }),
      html: htmlString,
      tex: tex.value,
      texWarnings: texFile.messages,
      typst: typst.value,
      typstWarnings: typstFile.messages,
      jats,
      jatsWarnings: jatsFile.messages,
      warnings: vfile.messages
    };
  });
}
function MySTRenderer({ value, column, fullscreen, numbering, TitleBlock, captureTab, className }) {
  var _a;
  const area = (0, import_react94.useRef)(null);
  const [text, setText] = (0, import_react94.useState)(value.trim());
  const [references, setReferences] = (0, import_react94.useState)({});
  const [frontmatter, setFrontmatter] = (0, import_react94.useState)({});
  const [mdastPre, setMdastPre] = (0, import_react94.useState)("Loading...");
  const [mdastPost, setMdastPost] = (0, import_react94.useState)("Loading...");
  const [html, setHtml] = (0, import_react94.useState)("Loading...");
  const [tex, setTex] = (0, import_react94.useState)("Loading...");
  const [texWarnings, setTexWarnings] = (0, import_react94.useState)([]);
  const [typst, setTypst] = (0, import_react94.useState)("Loading...");
  const [typstWarnings, setTypstWarnings] = (0, import_react94.useState)([]);
  const [jats, setJats] = (0, import_react94.useState)("Loading...");
  const [jatsWarnings, setJatsWarnings] = (0, import_react94.useState)([]);
  const [warnings, setWarnings] = (0, import_react94.useState)([]);
  const [previewType, setPreviewType] = (0, import_react94.useState)("DEMO");
  const [astLang, setAstLang] = (0, import_react94.useState)("yaml");
  const [astStage, setAstStage] = (0, import_react94.useState)("pre");
  (0, import_react94.useEffect)(() => {
    const ref = { current: true };
    parse2(text, { numbering }, { removeHeading: !!TitleBlock, jats: { fullArticle: !!TitleBlock } }).then((result2) => {
      if (!ref.current)
        return;
      setFrontmatter(result2.frontmatter);
      setMdastPre(result2.mdastPre);
      setMdastPost(result2.mdastPost);
      setReferences(result2.references);
      setHtml(result2.html);
      setTex(result2.tex);
      setTexWarnings(result2.texWarnings);
      setTypst(result2.typst);
      setTypstWarnings(result2.typstWarnings);
      setJats(result2.jats);
      setJatsWarnings(result2.jatsWarnings);
      setWarnings(result2.warnings);
    });
    return () => {
      ref.current = false;
    };
  }, [text]);
  (0, import_react94.useEffect)(() => {
    if (!area.current)
      return;
    if (column) {
      area.current.style.height = "";
      return;
    }
    area.current.style.height = "auto";
    area.current.style.height = `${area.current.scrollHeight}px`;
  }, [text, column]);
  (0, import_react94.useEffect)(() => {
    if (!area.current || !captureTab)
      return;
    area.current.addEventListener("keydown", (ev) => {
      if (ev.key !== "Tab")
        return;
      ev.preventDefault();
      ev.stopPropagation();
    });
  }, [area, captureTab]);
  let currentWarnings = [];
  switch (previewType) {
    case "DEMO":
      currentWarnings = warnings;
      break;
    case "LaTeX":
      currentWarnings = texWarnings;
      break;
    case "Typst":
      currentWarnings = typstWarnings;
      break;
    case "JATS":
      currentWarnings = jatsWarnings;
      break;
    default:
      break;
  }
  const demoMenu = (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, { children: [(0, import_jsx_runtime69.jsx)("div", { className: "self-center text-sm border cursor-pointer dark:border-slate-600", children: ["DEMO", "AST", "HTML", "LaTeX", "Typst", "JATS", "DOCX"].map((show) => (0, import_jsx_runtime69.jsx)("button", { className: (0, import_classnames39.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": previewType !== show,
    "bg-blue-800 text-white": previewType === show
  }), title: `Show the ${show}`, "aria-label": `Show the ${show}`, "aria-pressed": previewType === show ? "true" : "false", onClick: () => setPreviewType(show), children: show }, show)) }), previewType === "AST" && (0, import_jsx_runtime69.jsxs)("div", { className: "self-center text-sm border cursor-pointer w-fit dark:border-slate-600", children: [["yaml", "json"].map((show) => (0, import_jsx_runtime69.jsx)("button", { className: (0, import_classnames39.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astLang !== show,
    "bg-blue-800 text-white": astLang === show
  }), title: `Show the AST as ${show.toUpperCase()}`, "aria-pressed": astLang === show ? "true" : "false", onClick: () => setAstLang(show), children: show.toUpperCase() }, show)), ["pre", "post"].map((show) => (0, import_jsx_runtime69.jsx)("button", { className: (0, import_classnames39.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astStage !== show,
    "bg-blue-800 text-white": astStage === show
  }), title: `Show the AST Stage ${show.toUpperCase()}`, "aria-pressed": astStage === show ? "true" : "false", onClick: () => setAstStage(show), children: show.toUpperCase() }, show))] })] });
  const mdastStage = astStage === "pre" ? mdastPre : mdastPost;
  return (0, import_jsx_runtime69.jsxs)("figure", { className: (0, import_classnames39.default)("relative", {
    "grid grid-cols-2 gap-0 grid-rows-[3rem_1fr]": column,
    "shadow-lg rounded": !fullscreen,
    "m-0": fullscreen
  }, className), children: [column && (0, import_jsx_runtime69.jsxs)("div", { className: "flex flex-row items-stretch h-full col-span-2 px-2 border dark:border-slate-600", children: [(0, import_jsx_runtime69.jsx)("div", { className: "flex-grow" }), demoMenu] }), (0, import_jsx_runtime69.jsxs)("div", { className: (0, import_classnames39.default)("myst relative", { "overflow-auto": column }), children: [(0, import_jsx_runtime69.jsx)(CopyIcon, { text, className: "absolute right-0 p-1" }), (0, import_jsx_runtime69.jsxs)("label", { children: [(0, import_jsx_runtime69.jsx)("span", { className: "sr-only", children: "Edit the MyST Markdown text" }), (0, import_jsx_runtime69.jsx)("textarea", { ref: area, value: text, className: (0, import_classnames39.default)("block p-6 shadow-inner resize-none w-full font-mono bg-slate-50/50 dark:bg-slate-800/50 outline-none", { "text-sm": !column }, { "h-full": column }), onChange: (e4) => setText(e4.target.value) })] })] }), (0, import_jsx_runtime69.jsxs)("div", { className: (0, import_classnames39.default)("exclude-from-outline relative min-h-1 dark:bg-slate-900", {
    "overflow-auto": column
  }), children: [!column && (0, import_jsx_runtime69.jsx)("div", { className: "absolute top-0 left-0", children: demoMenu }), (0, import_jsx_runtime69.jsxs)("div", { className: (0, import_classnames39.default)("px-6 pb-6", {
    "pt-[40px]": !column && previewType !== "AST",
    "pt-[80px]": !column && previewType === "AST",
    "pt-4": column
  }), children: [previewType === "DEMO" && (0, import_jsx_runtime69.jsx)(import_jsx_runtime69.Fragment, { children: (0, import_jsx_runtime69.jsxs)(ReferencesProvider, { references, frontmatter, children: [TitleBlock && (0, import_jsx_runtime69.jsx)(TitleBlock, { frontmatter }), (0, import_jsx_runtime69.jsx)(MyST, { ast: (_a = references.article) === null || _a === void 0 ? void 0 : _a.children })] }) }), previewType === "AST" && (0, import_jsx_runtime69.jsx)(import_jsx_runtime69.Fragment, { children: (0, import_jsx_runtime69.jsx)(CodeBlock, { lang: astLang, value: astLang === "yaml" ? js_yaml_default.dump(mdastStage) : JSON.stringify(mdastStage, null, 2) }) }), previewType === "HTML" && (0, import_jsx_runtime69.jsx)(CodeBlock, { lang: "xml", value: html, showCopy: false }), previewType === "LaTeX" && (0, import_jsx_runtime69.jsx)(CodeBlock, { lang: "latex", value: tex, showCopy: false }), previewType === "Typst" && (0, import_jsx_runtime69.jsx)(CodeBlock, { lang: "typst", value: typst, showCopy: false }), previewType === "JATS" && (0, import_jsx_runtime69.jsx)(CodeBlock, { lang: "xml", value: jats, showCopy: false }), previewType === "DOCX" && (0, import_jsx_runtime69.jsx)("div", { children: (0, import_jsx_runtime69.jsxs)("button", { className: "p-3 border rounded", onClick: () => saveDocxFile("demo.docx", references.article), title: `Download Micorsoft Word`, "aria-label": `Download Micorsoft Word`, children: [(0, import_jsx_runtime69.jsx)(ArrowDownTrayIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), " ", "Download as Microsoft Word"] }) })] }), currentWarnings.length > 0 && (0, import_jsx_runtime69.jsx)("div", { className: (0, import_classnames39.default)("w-full", { "absolute bottom-0": column }), children: currentWarnings.map((m4, i5) => (0, import_jsx_runtime69.jsxs)("div", { className: (0, import_classnames39.default)("p-1 shadow-inner text-white not-prose", {
    "bg-red-500 dark:bg-red-800": m4.fatal === true,
    "bg-orange-500 dark:bg-orange-700": m4.fatal === false,
    "bg-slate-500 dark:bg-slate-800": m4.fatal === null
  }), children: [m4.fatal === true && (0, import_jsx_runtime69.jsx)(ExclamationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m4.fatal === false && (0, import_jsx_runtime69.jsx)(ExclamationTriangleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m4.fatal === null && (0, import_jsx_runtime69.jsx)(InformationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), (0, import_jsx_runtime69.jsx)("code", { children: m4.ruleId || m4.source }), ": ", m4.message] }, i5)) })] })] });
}
var MystDemoRenderer = ({ node }) => {
  return (0, import_jsx_runtime69.jsx)(MySTRenderer, { value: node.value, numbering: node.numbering });
};

// ../../packages/diagrams/dist/index.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject4(e4);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parse3(id, text) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { default: mermaid } = yield import("/myst_assets_folder/_shared/mermaid.core-WXZWRUQK.js");
    return yield new Promise((resolve) => {
      mermaid.render(id, text, (code3) => {
        resolve(code3);
      });
    });
  });
}
function MermaidRenderer({ id, value }) {
  const key = (0, import_react95.useId)();
  const [graph, setGraph] = (0, import_react95.useState)();
  const [error, setError] = (0, import_react95.useState)();
  (0, import_react95.useEffect)(() => {
    parse3(`mermaid-${key.replace(/:/g, "")}`, value).then((svg) => {
      setGraph(svg);
      setError(void 0);
    }).catch((err) => {
      setGraph(void 0);
      setError(err);
    });
  }, []);
  return (0, import_jsx_runtime70.jsxs)("figure", { id, children: [graph && (0, import_jsx_runtime70.jsx)("div", { dangerouslySetInnerHTML: { __html: graph } }), error && (0, import_jsx_runtime70.jsxs)("pre", { children: ["Error parsing mermaid graph.", "\n\n", error.message, "\n\n", value] })] });
}
var MermaidNodeRenderer = ({ node }) => {
  return (0, import_jsx_runtime70.jsx)(MermaidRenderer, { id: node.html_id || node.identifier, value: node.value });
};

// ../../packages/site/src/components/renderers.ts
var renderers = {
  ...DEFAULT_RENDERERS,
  myst: MystDemoRenderer,
  mermaid: MermaidNodeRenderer,
  ...dist_default
};

// ../../packages/site/src/components/SkipToArticle.tsx
var import_react96 = __toESM(require_react(), 1);
var import_jsx_dev_runtime17 = __toESM(require_jsx_dev_runtime(), 1);
function makeSkipClickHandler(hash) {
  return (e4) => {
    e4.preventDefault();
    const el = document.querySelector(`#${hash}`);
    if (!el)
      return;
    el.nextSibling.focus();
    history.replaceState(void 0, "", `#${hash}`);
  };
}
var SkipTo = import_react96.default.memo(({ targets }) => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
    "div",
    {
      className: "fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1",
      "aria-label": "skip to content options",
      children: targets.map(({ id, title }) => /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
        "a",
        {
          href: `#${id}`,
          className: "block px-2 py-1 text-black underline",
          onClick: makeSkipClickHandler(id),
          children: title
        },
        id,
        false,
        {
          fileName: "../../packages/site/src/components/SkipToArticle.tsx",
          lineNumber: 66,
          columnNumber: 9
        },
        this
      ))
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/SkipToArticle.tsx",
      lineNumber: 61,
      columnNumber: 5
    },
    this
  );
});

// ../../packages/site/src/seo/analytics.tsx
var import_jsx_dev_runtime18 = __toESM(require_jsx_dev_runtime(), 1);
var getGoogleAnalyticsScript = (tag) => `window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', '${tag}');`;
function Analytics({ analytics_google, analytics_plausible }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(import_jsx_dev_runtime18.Fragment, { children: [
    analytics_plausible && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
      "script",
      {
        defer: true,
        "data-domain": analytics_plausible,
        src: "https://plausible.io/js/plausible.js"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/seo/analytics.tsx",
        lineNumber: 13,
        columnNumber: 9
      },
      this
    ),
    analytics_google && /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(import_jsx_dev_runtime18.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
        "script",
        {
          async: true,
          src: `https://www.googletagmanager.com/gtag/js?id=${analytics_google}`
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 21,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
        "script",
        {
          dangerouslySetInnerHTML: {
            __html: getGoogleAnalyticsScript(analytics_google)
          }
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 25,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/seo/analytics.tsx",
      lineNumber: 20,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/seo/analytics.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/seo/meta.ts
function getMetaTagsForSite({
  title,
  description,
  twitter
}) {
  const meta = [
    { title },
    { property: "og:title", content: title },
    { name: "generator", content: "mystmd" }
  ];
  if (description) {
    meta.push({ name: "description", content: description });
    meta.push({ property: "og:description", content: description });
  }
  if (twitter)
    meta.push({ name: "twitter:site", content: `@${twitter.replace("@", "")}` });
  return meta;
}
function getMetaTagsForArticle({
  origin,
  url,
  title,
  description,
  image,
  twitter,
  keywords
}) {
  const meta = [
    { title },
    { property: "og:title", content: title },
    { name: "generator", content: "mystmd" }
  ];
  if (description) {
    meta.push({ name: "description", content: description });
    meta.push({ property: "og:description", content: description });
  }
  if (keywords)
    meta.push({ name: "keywords", content: keywords.join(", ") });
  if (origin && url)
    meta.push({ property: "og:url", content: `${origin}${url}` });
  if (image) {
    meta.push({ name: "image", content: image });
    meta.push({ property: "og:image", content: image });
  }
  if (twitter) {
    meta.push({ name: "twitter:card", content: image ? "summary_large_image" : "summary" });
    meta.push({ name: "twitter:creator", content: `@${twitter.replace("@", "")}` });
    meta.push({ name: "twitter:title", content: title });
    if (description)
      meta.push({ name: "twitter:description", content: description });
    if (image)
      meta.push({ name: "twitter:image", content: image });
    meta.push({ name: "twitter:alt", content: title });
  }
  return meta;
}

// ../../packages/site/src/pages/Error404.tsx
var import_jsx_dev_runtime19 = __toESM(require_jsx_dev_runtime(), 1);
function Error404() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_jsx_dev_runtime19.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("h1", { children: "No Site Found - 404" }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("p", { children: "No website is available at this url, or an error occurred. Please double check the url." }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Error404.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/Root.tsx
var import_classnames40 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime20 = __toESM(require_jsx_dev_runtime(), 1);
function Document({
  children,
  scripts,
  theme,
  config,
  title,
  staticBuild,
  baseurl,
  top = DEFAULT_NAV_HEIGHT,
  renderers: renderers2 = renderers
}) {
  var _a, _b;
  const links = staticBuild ? {
    Link: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Link, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 44,
      columnNumber: 31
    }, this),
    NavLink: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(NavLink, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 45,
      columnNumber: 34
    }, this)
  } : {
    Link,
    NavLink
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("html", { lang: "en", className: (0, import_classnames40.default)(theme), style: { scrollPadding: top }, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("meta", { charSet: "utf-8" }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 55,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 56,
        columnNumber: 9
      }, this),
      title && /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("title", { children: title }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 57,
        columnNumber: 19
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Meta, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 58,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Links, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 59,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
        Analytics,
        {
          analytics_google: (_a = config == null ? void 0 : config.options) == null ? void 0 : _a.analytics_google,
          analytics_plausible: (_b = config == null ? void 0 : config.options) == null ? void 0 : _b.analytics_plausible
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 60,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 54,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("body", { className: "m-0 transition-colors duration-500 bg-white dark:bg-stone-900", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(ThemeProvider, { theme, renderers: renderers2, ...links, top, children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(BaseUrlProvider, { baseurl, children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(SiteProvider, { config, children }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 68,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 67,
        columnNumber: 11
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 66,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(ScrollRestoration, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 71,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Scripts, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 72,
        columnNumber: 9
      }, this),
      !staticBuild && /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(LiveReload, {}, void 0, false, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 73,
        columnNumber: 26
      }, this),
      scripts
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 65,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 53,
    columnNumber: 5
  }, this);
}
function AppCatchBoundary() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Document, { theme: Theme.light, children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("article", { className: "article", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("main", { className: "article-grid subgrid-gap col-screen", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(Error404, {}, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 94,
    columnNumber: 11
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 93,
    columnNumber: 9
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 92,
    columnNumber: 7
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 91,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/ErrorDocumentNotFound.tsx
var import_jsx_dev_runtime21 = __toESM(require_jsx_dev_runtime(), 1);
function ErrorDocumentNotFound() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(import_jsx_dev_runtime21.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("h1", { children: "Document Not Found" }, void 0, false, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("p", { children: [
      "Take me ",
      /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("a", { href: "/", children: "home" }, void 0, false, {
        fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
        lineNumber: 6,
        columnNumber: 17
      }, this),
      "."
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/Article.tsx
var import_react98 = __toESM(require_react(), 1);
var import_jsx_dev_runtime22 = __toESM(require_jsx_dev_runtime(), 1);
var ArticlePage = import_react98.default.memo(function({
  article,
  hide_all_footer_links,
  hideKeywords
}) {
  var _a, _b, _c, _d, _e;
  const manifest = useProjectManifest();
  const compute = useComputeOptions();
  const { hide_title_block, hide_footer_links } = (_b = (_a = article.frontmatter) == null ? void 0 : _a.options) != null ? _b : {};
  const downloads = combineDownloads(manifest == null ? void 0 : manifest.downloads, article.frontmatter);
  const tree = copyNode(article.mdast);
  const keywords = (_d = (_c = article.frontmatter) == null ? void 0 : _c.keywords) != null ? _d : [];
  const parts = extractKnownParts(tree);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(
    ReferencesProvider,
    {
      references: { ...article.references, article: article.mdast },
      frontmatter: article.frontmatter,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(BusyScopeProvider, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(ExecuteScopeProvider, { enable: (_e = compute == null ? void 0 : compute.enabled) != null ? _e : false, contents: article, children: [
        !hide_title_block && /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(
          FrontmatterBlock,
          {
            kind: article.kind,
            frontmatter: { ...article.frontmatter, downloads },
            className: "pt-5 mb-8"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/pages/Article.tsx",
            lineNumber: 57,
            columnNumber: 13
          },
          this
        ),
        (compute == null ? void 0 : compute.enabled) && compute.features.notebookCompute && article.kind === SourceFileKind.Notebook && /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(NotebookToolbar, { showLaunch: true }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 65,
          columnNumber: 57
        }, this),
        (compute == null ? void 0 : compute.enabled) && article.kind === SourceFileKind.Article && /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(ErrorTray, { pageSlug: article.slug }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 67,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)("div", { id: "skip-to-article" }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 69,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(FrontmatterParts, { parts, keywords, hideKeywords }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 70,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(ContentBlocks, { pageKind: article.kind, mdast: tree }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 71,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(BackmatterParts, { parts }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 72,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Bibliography, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 73,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(ConnectionStatusTray, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 74,
          columnNumber: 11
        }, this),
        !hide_footer_links && !hide_all_footer_links && /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(FooterLinksBlock, { links: article.footer }, void 0, false, {
          fileName: "../../packages/site/src/pages/Article.tsx",
          lineNumber: 76,
          columnNumber: 13
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/pages/Article.tsx",
        lineNumber: 55,
        columnNumber: 9
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/pages/Article.tsx",
        lineNumber: 54,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/pages/Article.tsx",
      lineNumber: 50,
      columnNumber: 5
    },
    this
  );
});
function ArticlePageCatchBoundary() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(ErrorDocumentNotFound, {}, void 0, false, {
    fileName: "../../packages/site/src/pages/Article.tsx",
    lineNumber: 89,
    columnNumber: 10
  }, this);
}

export {
  require_loaders,
  useThemeTop,
  GridSystemProvider,
  ReferencesProvider,
  useBaseurl,
  UiStateProvider,
  useSiteManifest,
  TabStateProvider,
  ProjectProvider,
  useProjectManifest,
  MyST,
  ExecuteScopeProvider,
  BusyScopeProvider,
  ComputeOptionsProvider,
  useComputeOptions,
  ThebeLoaderAndServer,
  ErrorTray,
  ConnectionStatusTray,
  NotebookToolbar,
  extractKnownParts,
  ContentBlocks,
  FooterLinksBlock,
  ContentReload,
  Bibliography,
  Footnotes,
  FrontmatterBlock,
  TopNav,
  useTocHeight,
  TableOfContents,
  Navigation,
  FrontmatterParts,
  BackmatterParts,
  SkipTo,
  ArticlePageCatchBoundary,
  getMetaTagsForSite,
  getMetaTagsForArticle,
  Document,
  AppCatchBoundary
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-plain-object/dist/is-plain-object.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=/myst_assets_folder/_shared/chunk-A7NUFDB7.js.map
