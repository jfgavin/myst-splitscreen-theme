import {
  require_client,
  require_react
} from "/myst_assets_folder/_shared/chunk-SMG2HPMX.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "/myst_assets_folder/_shared/chunk-D5NAPBYJ.js";

// ../../node_modules/@lumino/coreutils/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@lumino/coreutils/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_coreutils = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.JSONExt = void 0;
      (function(JSONExt7) {
        JSONExt7.emptyObject = Object.freeze({});
        JSONExt7.emptyArray = Object.freeze([]);
        function isPrimitive(value) {
          return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
        }
        JSONExt7.isPrimitive = isPrimitive;
        function isArray(value) {
          return Array.isArray(value);
        }
        JSONExt7.isArray = isArray;
        function isObject8(value) {
          return !isPrimitive(value) && !isArray(value);
        }
        JSONExt7.isObject = isObject8;
        function deepEqual(first, second) {
          if (first === second) {
            return true;
          }
          if (isPrimitive(first) || isPrimitive(second)) {
            return false;
          }
          let a1 = isArray(first);
          let a2 = isArray(second);
          if (a1 !== a2) {
            return false;
          }
          if (a1 && a2) {
            return deepArrayEqual(first, second);
          }
          return deepObjectEqual(first, second);
        }
        JSONExt7.deepEqual = deepEqual;
        function deepCopy(value) {
          if (isPrimitive(value)) {
            return value;
          }
          if (isArray(value)) {
            return deepArrayCopy(value);
          }
          return deepObjectCopy(value);
        }
        JSONExt7.deepCopy = deepCopy;
        function deepArrayEqual(first, second) {
          if (first === second) {
            return true;
          }
          if (first.length !== second.length) {
            return false;
          }
          for (let i2 = 0, n = first.length; i2 < n; ++i2) {
            if (!deepEqual(first[i2], second[i2])) {
              return false;
            }
          }
          return true;
        }
        function deepObjectEqual(first, second) {
          if (first === second) {
            return true;
          }
          for (let key2 in first) {
            if (first[key2] !== void 0 && !(key2 in second)) {
              return false;
            }
          }
          for (let key2 in second) {
            if (second[key2] !== void 0 && !(key2 in first)) {
              return false;
            }
          }
          for (let key2 in first) {
            let firstValue = first[key2];
            let secondValue = second[key2];
            if (firstValue === void 0 && secondValue === void 0) {
              continue;
            }
            if (firstValue === void 0 || secondValue === void 0) {
              return false;
            }
            if (!deepEqual(firstValue, secondValue)) {
              return false;
            }
          }
          return true;
        }
        function deepArrayCopy(value) {
          let result = new Array(value.length);
          for (let i2 = 0, n = value.length; i2 < n; ++i2) {
            result[i2] = deepCopy(value[i2]);
          }
          return result;
        }
        function deepObjectCopy(value) {
          let result = {};
          for (let key2 in value) {
            let subvalue = value[key2];
            if (subvalue === void 0) {
              continue;
            }
            result[key2] = deepCopy(subvalue);
          }
          return result;
        }
      })(exports3.JSONExt || (exports3.JSONExt = {}));
      class MimeData2 {
        constructor() {
          this._types = [];
          this._values = [];
        }
        /**
         * Get an array of the MIME types contained within the dataset.
         *
         * @returns A new array of the MIME types, in order of insertion.
         */
        types() {
          return this._types.slice();
        }
        /**
         * Test whether the dataset has an entry for the given type.
         *
         * @param mime - The MIME type of interest.
         *
         * @returns `true` if the dataset contains a value for the given
         *   MIME type, `false` otherwise.
         */
        hasData(mime) {
          return this._types.indexOf(mime) !== -1;
        }
        /**
         * Get the data value for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * @returns The value for the given MIME type, or `undefined` if
         *   the dataset does not contain a value for the type.
         */
        getData(mime) {
          let i2 = this._types.indexOf(mime);
          return i2 !== -1 ? this._values[i2] : void 0;
        }
        /**
         * Set the data value for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * @param data - The data value for the given MIME type.
         *
         * #### Notes
         * This will overwrite any previous entry for the MIME type.
         */
        setData(mime, data) {
          this.clearData(mime);
          this._types.push(mime);
          this._values.push(data);
        }
        /**
         * Remove the data entry for the given MIME type.
         *
         * @param mime - The MIME type of interest.
         *
         * #### Notes
         * This is a no-op if there is no entry for the given MIME type.
         */
        clearData(mime) {
          let i2 = this._types.indexOf(mime);
          if (i2 !== -1) {
            this._types.splice(i2, 1);
            this._values.splice(i2, 1);
          }
        }
        /**
         * Remove all data entries from the dataset.
         */
        clear() {
          this._types.length = 0;
          this._values.length = 0;
        }
      }
      class PromiseDelegate4 {
        /**
         * Construct a new promise delegate.
         */
        constructor() {
          this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        }
        /**
         * Resolve the wrapped promise with the given value.
         *
         * @param value - The value to use for resolving the promise.
         */
        resolve(value) {
          let resolve = this._resolve;
          resolve(value);
        }
        /**
         * Reject the wrapped promise with the given value.
         *
         * @reason - The reason for rejecting the promise.
         */
        reject(reason) {
          let reject = this._reject;
          reject(reason);
        }
      }
      class Token4 {
        /**
         * Construct a new token.
         *
         * @param name - A human readable name for the token.
         * @param description - Token purpose description for documentation.
         */
        constructor(name2, description) {
          this.name = name2;
          this.description = description !== null && description !== void 0 ? description : "";
          this._tokenStructuralPropertyT = null;
        }
      }
      function fallbackRandomValues(buffer) {
        let value = 0;
        for (let i2 = 0, n = buffer.length; i2 < n; ++i2) {
          if (i2 % 4 === 0) {
            value = Math.random() * 4294967295 >>> 0;
          }
          buffer[i2] = value & 255;
          value >>>= 8;
        }
      }
      exports3.Random = void 0;
      (function(Random) {
        Random.getRandomValues = (() => {
          const crypto = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
          if (crypto && typeof crypto.getRandomValues === "function") {
            return function getRandomValues(buffer) {
              return crypto.getRandomValues(buffer);
            };
          }
          return fallbackRandomValues;
        })();
      })(exports3.Random || (exports3.Random = {}));
      function uuid4Factory(getRandomValues) {
        const bytes = new Uint8Array(16);
        const lut = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          lut[i2] = "0" + i2.toString(16);
        }
        for (let i2 = 16; i2 < 256; ++i2) {
          lut[i2] = i2.toString(16);
        }
        return function uuid4() {
          getRandomValues(bytes);
          bytes[6] = 64 | bytes[6] & 15;
          bytes[8] = 128 | bytes[8] & 63;
          return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
        };
      }
      exports3.UUID = void 0;
      (function(UUID3) {
        UUID3.uuid4 = uuid4Factory(exports3.Random.getRandomValues);
      })(exports3.UUID || (exports3.UUID = {}));
      exports3.MimeData = MimeData2;
      exports3.PromiseDelegate = PromiseDelegate4;
      exports3.Token = Token4;
    });
  }
});

// ../../node_modules/@jupyterlab/translation/lib/utils.js
function normalizeDomain(domain) {
  return domain.replace("-", "_");
}
var init_utils = __esm({
  "../../node_modules/@jupyterlab/translation/lib/utils.js"() {
  }
});

// ../../node_modules/@jupyterlab/translation/lib/gettext.js
var Gettext;
var init_gettext = __esm({
  "../../node_modules/@jupyterlab/translation/lib/gettext.js"() {
    init_utils();
    Gettext = class {
      constructor(options) {
        options = options || {};
        this._defaults = {
          domain: "messages",
          locale: document.documentElement.getAttribute("lang") || "en",
          pluralFunc: function(n) {
            return { nplurals: 2, plural: n != 1 ? 1 : 0 };
          },
          contextDelimiter: String.fromCharCode(4),
          stringsPrefix: ""
        };
        this._locale = (options.locale || this._defaults.locale).replace("_", "-");
        this._domain = normalizeDomain(options.domain || this._defaults.domain);
        this._contextDelimiter = options.contextDelimiter || this._defaults.contextDelimiter;
        this._stringsPrefix = options.stringsPrefix || this._defaults.stringsPrefix;
        this._pluralFuncs = {};
        this._dictionary = {};
        this._pluralForms = {};
        if (options.messages) {
          this._dictionary[this._domain] = {};
          this._dictionary[this._domain][this._locale] = options.messages;
        }
        if (options.pluralForms) {
          this._pluralForms[this._locale] = options.pluralForms;
        }
      }
      /**
       * Set current context delimiter.
       *
       * @param delimiter - The delimiter to set.
       */
      setContextDelimiter(delimiter) {
        this._contextDelimiter = delimiter;
      }
      /**
       * Get current context delimiter.
       *
       * @returns The current delimiter.
       */
      getContextDelimiter() {
        return this._contextDelimiter;
      }
      /**
       * Set current locale.
       *
       * @param locale - The locale to set.
       */
      setLocale(locale) {
        this._locale = locale.replace("_", "-");
      }
      /**
       * Get current locale.
       *
       * @returns The current locale.
       */
      getLocale() {
        return this._locale;
      }
      /**
       * Set current domain.
       *
       * @param domain - The domain to set.
       */
      setDomain(domain) {
        this._domain = normalizeDomain(domain);
      }
      /**
       * Get current domain.
       *
       * @returns The current domain string.
       */
      getDomain() {
        return this._domain;
      }
      /**
       * Set current strings prefix.
       *
       * @param prefix - The string prefix to set.
       */
      setStringsPrefix(prefix) {
        this._stringsPrefix = prefix;
      }
      /**
       * Get current strings prefix.
       *
       * @returns The strings prefix.
       */
      getStringsPrefix() {
        return this._stringsPrefix;
      }
      /**
       * `sprintf` equivalent, takes a string and some arguments to make a
       * computed string.
       *
       * @param fmt - The string to interpolate.
       * @param args - The variables to use in interpolation.
       *
       * ### Examples
       * strfmt("%1 dogs are in %2", 7, "the kitchen"); => "7 dogs are in the kitchen"
       * strfmt("I like %1, bananas and %1", "apples"); => "I like apples, bananas and apples"
       */
      static strfmt(fmt, ...args) {
        return fmt.replace(/%%/g, "%% ").replace(/%(\d+)/g, function(str, p1) {
          return args[p1 - 1];
        }).replace(/%% /g, "%");
      }
      /**
       * Load json translations strings (In Jed 2.x format).
       *
       * @param jsonData - The translation strings plus metadata.
       * @param domain - The translation domain, e.g. "jupyterlab".
       */
      loadJSON(jsonData, domain) {
        if (!jsonData[""] || !jsonData[""]["language"] || !jsonData[""]["pluralForms"]) {
          throw new Error(`Wrong jsonData, it must have an empty key ("") with "language" and "pluralForms" information: ${jsonData}`);
        }
        domain = normalizeDomain(domain);
        let headers = jsonData[""];
        let jsonDataCopy = JSON.parse(JSON.stringify(jsonData));
        delete jsonDataCopy[""];
        this.setMessages(domain || this._defaults.domain, headers["language"], jsonDataCopy, headers["pluralForms"]);
      }
      /**
       * Shorthand for gettext.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      __(msgid, ...args) {
        return this.gettext(msgid, ...args);
      }
      /**
       * Shorthand for ngettext.
       *
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _n(msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      /**
       * Shorthand for pgettext.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _p(msgctxt, msgid, ...args) {
        return this.pgettext(msgctxt, msgid, ...args);
      }
      /**
       * Shorthand for npgettext.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      _np(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a singular string with extra interpolation values.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       */
      gettext(msgid, ...args) {
        return this.dcnpgettext("", "", msgid, "", 0, ...args);
      }
      /**
       * Translate a plural string with extra interpolation values.
       *
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       */
      ngettext(msgid, msgid_plural, n, ...args) {
        return this.dcnpgettext("", "", msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a contextualized singular string with extra interpolation values.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param args - Any additional values to use with interpolation.
       *
       * @returns A translated string if found, or the original string.
       *
       * ### Notes
       * This is not a private method (starts with an underscore) it is just
       * a shorter and standard way to call these methods.
       */
      pgettext(msgctxt, msgid, ...args) {
        return this.dcnpgettext("", msgctxt, msgid, "", 0, ...args);
      }
      /**
       * Translate a contextualized plural string with extra interpolation values.
       *
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation
       *
       * @returns A translated string if found, or the original string.
       */
      npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.dcnpgettext("", msgctxt, msgid, msgid_plural, n, ...args);
      }
      /**
       * Translate a singular string with extra interpolation values.
       *
       * @param domain - The translations domain.
       * @param msgctxt - The message context.
       * @param msgid - The singular string to translate.
       * @param msgid_plural - The plural string to translate.
       * @param n - The number for pluralization.
       * @param args - Any additional values to use with interpolation
       *
       * @returns A translated string if found, or the original string.
       */
      dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
        domain = normalizeDomain(domain) || this._domain;
        let translation;
        let key2 = msgctxt ? msgctxt + this._contextDelimiter + msgid : msgid;
        let options = { pluralForm: false };
        let exist = false;
        let locale = this._locale;
        let locales = this.expandLocale(this._locale);
        for (let i2 in locales) {
          locale = locales[i2];
          exist = this._dictionary[domain] && this._dictionary[domain][locale] && this._dictionary[domain][locale][key2];
          if (msgid_plural) {
            exist = exist && this._dictionary[domain][locale][key2].length > 1;
          } else {
            exist = exist && this._dictionary[domain][locale][key2].length == 1;
          }
          if (exist) {
            options.locale = locale;
            break;
          }
        }
        if (!exist) {
          translation = [msgid];
          options.pluralFunc = this._defaults.pluralFunc;
        } else {
          translation = this._dictionary[domain][locale][key2];
        }
        if (!msgid_plural) {
          return this.t(translation, n, options, ...args);
        }
        options.pluralForm = true;
        let value = exist ? translation : [msgid, msgid_plural];
        return this.t(value, n, options, ...args);
      }
      /**
       * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
       *
       * @param locale - The locale string.
       *
       * @returns An array of locales.
       */
      expandLocale(locale) {
        let locales = [locale];
        let i2 = locale.lastIndexOf("-");
        while (i2 > 0) {
          locale = locale.slice(0, i2);
          locales.push(locale);
          i2 = locale.lastIndexOf("-");
        }
        return locales;
      }
      /**
       * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
       *
       * @param pluralForm - Plural form string..
       * @returns An function to compute plural forms.
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      getPluralFunc(pluralForm) {
        let pf_re = new RegExp("^\\s*nplurals\\s*=\\s*[0-9]+\\s*;\\s*plural\\s*=\\s*(?:\\s|[-\\?\\|&=!<>+*/%:;n0-9_()])+");
        if (!pf_re.test(pluralForm))
          throw new Error(Gettext.strfmt('The plural form "%1" is not valid', pluralForm));
        return new Function("n", "let plural, nplurals; " + pluralForm + " return { nplurals: nplurals, plural: (plural === true ? 1 : (plural ? plural : 0)) };");
      }
      /**
       * Remove the context delimiter from string.
       *
       * @param str - Translation string.
       * @returns A translation string without context.
       */
      removeContext(str) {
        if (str.indexOf(this._contextDelimiter) !== -1) {
          let parts = str.split(this._contextDelimiter);
          return parts[1];
        }
        return str;
      }
      /**
       * Proper translation function that handle plurals and directives.
       *
       * @param messages - List of translation strings.
       * @param n - The number for pluralization.
       * @param options - Translation options.
       * @param args - Any variables to interpolate.
       *
       * @returns A translation string without context.
       *
       * ### Notes
       * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
       */
      t(messages, n, options, ...args) {
        if (!options.pluralForm)
          return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages[0]), ...args);
        let plural;
        if (options.pluralFunc) {
          plural = options.pluralFunc(n);
        } else if (!this._pluralFuncs[options.locale || ""]) {
          this._pluralFuncs[options.locale || ""] = this.getPluralFunc(this._pluralForms[options.locale || ""]);
          plural = this._pluralFuncs[options.locale || ""](n);
        } else {
          plural = this._pluralFuncs[options.locale || ""](n);
        }
        if ("undefined" === typeof !plural.plural || plural.plural > plural.nplurals || messages.length <= plural.plural)
          plural.plural = 0;
        return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages[plural.plural]), ...[n].concat(args));
      }
      /**
       * Set messages after loading them.
       *
       * @param domain - The translation domain.
       * @param locale - The translation locale.
       * @param messages - List of translation strings.
       * @param pluralForms - Plural form string.
       *
       * ### Notes
       * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
       */
      setMessages(domain, locale, messages, pluralForms) {
        domain = normalizeDomain(domain);
        if (pluralForms)
          this._pluralForms[locale] = pluralForms;
        if (!this._dictionary[domain])
          this._dictionary[domain] = {};
        this._dictionary[domain][locale] = messages;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/translation/lib/base.js
var NullTranslator, NullLanguageBundle, nullTranslator;
var init_base = __esm({
  "../../node_modules/@jupyterlab/translation/lib/base.js"() {
    init_gettext();
    NullTranslator = class {
      constructor(bundle) {
        this.languageCode = "en";
        this._languageBundle = bundle;
      }
      load(domain) {
        return this._languageBundle;
      }
    };
    NullLanguageBundle = class {
      __(msgid, ...args) {
        return this.gettext(msgid, ...args);
      }
      _n(msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      _p(msgctxt, msgid, ...args) {
        return this.pgettext(msgctxt, msgid, ...args);
      }
      _np(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
      }
      gettext(msgid, ...args) {
        return Gettext.strfmt(msgid, ...args);
      }
      ngettext(msgid, msgid_plural, n, ...args) {
        return Gettext.strfmt(n == 1 ? msgid : msgid_plural, ...[n].concat(args));
      }
      pgettext(msgctxt, msgid, ...args) {
        return Gettext.strfmt(msgid, ...args);
      }
      npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
      dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
        return this.ngettext(msgid, msgid_plural, n, ...args);
      }
    };
    nullTranslator = new NullTranslator(new NullLanguageBundle());
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/statedb/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports = {};
__export(index_es6_exports, {
  AttachedProperty: () => AttachedProperty
});
var AttachedProperty, Private;
var init_index_es6 = __esm({
  "../../node_modules/@jupyterlab/statedb/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty || (AttachedProperty = {}));
    (function(Private31) {
      Private31.ownerData = /* @__PURE__ */ new WeakMap();
      Private31.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private31.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private31.ownerData.set(owner, map2);
        return map2;
      }
      Private31.ensureMap = ensureMap;
    })(Private || (Private = {}));
  }
});

// ../../node_modules/@lumino/signaling/node_modules/@lumino/algorithm/dist/index.es6.js
function find(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
var ArrayExt, Private2, StringExt;
var init_index_es62 = __esm({
  "../../node_modules/@lumino/signaling/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt || (ArrayExt = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private2 || (Private2 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt || (StringExt = {}));
  }
});

// ../../node_modules/@lumino/signaling/dist/index.es6.js
var index_es6_exports2 = {};
__export(index_es6_exports2, {
  Signal: () => Signal,
  Stream: () => Stream
});
var import_coreutils, Signal, Stream, Private3;
var init_index_es63 = __esm({
  "../../node_modules/@lumino/signaling/dist/index.es6.js"() {
    init_index_es62();
    import_coreutils = __toESM(require_dist());
    Signal = class {
      /**
       * Construct a new signal.
       *
       * @param sender - The sender which owns the signal.
       */
      constructor(sender) {
        this.sender = sender;
      }
      /**
       * Connect a slot to the signal.
       *
       * @param slot - The slot to invoke when the signal is emitted.
       *
       * @param thisArg - The `this` context for the slot. If provided,
       *   this must be a non-primitive object.
       *
       * @returns `true` if the connection succeeds, `false` otherwise.
       */
      connect(slot, thisArg) {
        return Private3.connect(this, slot, thisArg);
      }
      /**
       * Disconnect a slot from the signal.
       *
       * @param slot - The slot to disconnect from the signal.
       *
       * @param thisArg - The `this` context for the slot. If provided,
       *   this must be a non-primitive object.
       *
       * @returns `true` if the connection is removed, `false` otherwise.
       */
      disconnect(slot, thisArg) {
        return Private3.disconnect(this, slot, thisArg);
      }
      /**
       * Emit the signal and invoke the connected slots.
       *
       * @param args - The args to pass to the connected slots.
       *
       * #### Notes
       * Slots are invoked synchronously in connection order.
       *
       * Exceptions thrown by connected slots will be caught and logged.
       */
      emit(args) {
        Private3.emit(this, args);
      }
    };
    (function(Signal2) {
      function disconnectBetween(sender, receiver) {
        Private3.disconnectBetween(sender, receiver);
      }
      Signal2.disconnectBetween = disconnectBetween;
      function disconnectSender(sender) {
        Private3.disconnectSender(sender);
      }
      Signal2.disconnectSender = disconnectSender;
      function disconnectReceiver(receiver) {
        Private3.disconnectReceiver(receiver);
      }
      Signal2.disconnectReceiver = disconnectReceiver;
      function disconnectAll(object) {
        Private3.disconnectAll(object);
      }
      Signal2.disconnectAll = disconnectAll;
      function clearData(object) {
        Private3.disconnectAll(object);
      }
      Signal2.clearData = clearData;
      function getExceptionHandler() {
        return Private3.exceptionHandler;
      }
      Signal2.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = Private3.exceptionHandler;
        Private3.exceptionHandler = handler;
        return old;
      }
      Signal2.setExceptionHandler = setExceptionHandler;
    })(Signal || (Signal = {}));
    Stream = class extends Signal {
      constructor() {
        super(...arguments);
        this._pending = new import_coreutils.PromiseDelegate();
      }
      /**
       * Return an async iterator that yields every emission.
       */
      async *[Symbol.asyncIterator]() {
        let pending = this._pending;
        while (true) {
          try {
            const { args, next } = await pending.promise;
            pending = next;
            yield args;
          } catch (_) {
            return;
          }
        }
      }
      /**
       * Emit the signal, invoke the connected slots, and yield the emission.
       *
       * @param args - The args to pass to the connected slots.
       */
      emit(args) {
        const pending = this._pending;
        const next = this._pending = new import_coreutils.PromiseDelegate();
        pending.resolve({ args, next });
        super.emit(args);
      }
      /**
       * Stop the stream's async iteration.
       */
      stop() {
        this._pending.promise.catch(() => void 0);
        this._pending.reject("stop");
        this._pending = new import_coreutils.PromiseDelegate();
      }
    };
    (function(Private31) {
      Private31.exceptionHandler = (err) => {
        console.error(err);
      };
      function connect(signal, slot, thisArg) {
        thisArg = thisArg || void 0;
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers) {
          receivers = [];
          receiversForSender.set(signal.sender, receivers);
        }
        if (findConnection(receivers, signal, slot, thisArg)) {
          return false;
        }
        let receiver = thisArg || slot;
        let senders = sendersForReceiver.get(receiver);
        if (!senders) {
          senders = [];
          sendersForReceiver.set(receiver, senders);
        }
        let connection = { signal, slot, thisArg };
        receivers.push(connection);
        senders.push(connection);
        return true;
      }
      Private31.connect = connect;
      function disconnect(signal, slot, thisArg) {
        thisArg = thisArg || void 0;
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers || receivers.length === 0) {
          return false;
        }
        let connection = findConnection(receivers, signal, slot, thisArg);
        if (!connection) {
          return false;
        }
        let receiver = thisArg || slot;
        let senders = sendersForReceiver.get(receiver);
        connection.signal = null;
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
        return true;
      }
      Private31.disconnect = disconnect;
      function disconnectBetween(sender, receiver) {
        let receivers = receiversForSender.get(sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        let senders = sendersForReceiver.get(receiver);
        if (!senders || senders.length === 0) {
          return;
        }
        for (const connection of senders) {
          if (!connection.signal) {
            continue;
          }
          if (connection.signal.sender === sender) {
            connection.signal = null;
          }
        }
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
      }
      Private31.disconnectBetween = disconnectBetween;
      function disconnectSender(sender) {
        let receivers = receiversForSender.get(sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        for (const connection of receivers) {
          if (!connection.signal) {
            continue;
          }
          let receiver = connection.thisArg || connection.slot;
          connection.signal = null;
          scheduleCleanup(sendersForReceiver.get(receiver));
        }
        scheduleCleanup(receivers);
      }
      Private31.disconnectSender = disconnectSender;
      function disconnectReceiver(receiver) {
        let senders = sendersForReceiver.get(receiver);
        if (!senders || senders.length === 0) {
          return;
        }
        for (const connection of senders) {
          if (!connection.signal) {
            continue;
          }
          let sender = connection.signal.sender;
          connection.signal = null;
          scheduleCleanup(receiversForSender.get(sender));
        }
        scheduleCleanup(senders);
      }
      Private31.disconnectReceiver = disconnectReceiver;
      function disconnectAll(object) {
        disconnectSender(object);
        disconnectReceiver(object);
      }
      Private31.disconnectAll = disconnectAll;
      function emit(signal, args) {
        let receivers = receiversForSender.get(signal.sender);
        if (!receivers || receivers.length === 0) {
          return;
        }
        for (let i2 = 0, n = receivers.length; i2 < n; ++i2) {
          let connection = receivers[i2];
          if (connection.signal === signal) {
            invokeSlot(connection, args);
          }
        }
      }
      Private31.emit = emit;
      const receiversForSender = /* @__PURE__ */ new WeakMap();
      const sendersForReceiver = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      const schedule = (() => {
        let ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      function findConnection(connections, signal, slot, thisArg) {
        return find(connections, (connection) => connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg);
      }
      function invokeSlot(connection, args) {
        let { signal, slot, thisArg } = connection;
        try {
          slot.call(thisArg, signal.sender, args);
        } catch (err) {
          Private31.exceptionHandler(err);
        }
      }
      function scheduleCleanup(array) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(array);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupConnections);
        dirtySet.clear();
      }
      function cleanupConnections(connections) {
        ArrayExt.removeAllWhere(connections, isDeadConnection);
      }
      function isDeadConnection(connection) {
        return connection.signal === null;
      }
    })(Private3 || (Private3 = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es6(), __toCommonJS(index_es6_exports));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var RestorablePool = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private31.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private31.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param - fn The filter function to call on each object.
       */
      find(fn) {
        const values = this._objects.values();
        for (const value of values) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private31.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when } = options;
        const namespace = this.namespace;
        const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values = await Promise.all(saved.ids.map(async (id, index) => {
          const value = saved.values[index];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private31.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private31.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private31.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private31.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private31.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool;
    var Private31;
    (function(Private32) {
      Private32.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private32.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform: transform2 } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform2) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform2.then((transformation) => {
            const { contents, type } = transformation;
            switch (type) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param filter - The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values } = await this._list();
        return values.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values } = await this._connector.list(namespace);
        return {
          ids,
          values: values.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key2) => contents[key2] && this._save(key2, contents[key2])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/statedb/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_dataconnector(), exports2);
    __exportStar2(require_interfaces(), exports2);
    __exportStar2(require_restorablepool(), exports2);
    __exportStar2(require_statedb(), exports2);
    __exportStar2(require_tokens(), exports2);
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces2 = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key2) {
        const item = this._map.get(key2) || null;
        if (item != null) {
          this._map.delete(key2);
          this._map.set(key2, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key2, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key2, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/minimist/index.js"(exports2, module2) {
    "use strict";
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key3) {
        o = o[key3] || {};
      });
      var key2 = keys[keys.length - 1];
      return key2 in o;
    }
    function isNumber3(x) {
      if (typeof x === "number") {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(x)) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key2) {
      return key2 === "constructor" && typeof obj[key2] === "function" || key2 === "__proto__";
    }
    module2.exports = function(args, opts) {
      if (!opts) {
        opts = {};
      }
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      if (typeof opts.unknown === "function") {
        flags.unknownFn = opts.unknown;
      }
      if (typeof opts.boolean === "boolean" && opts.boolean) {
        flags.allBools = true;
      } else {
        [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
          flags.bools[key3] = true;
        });
      }
      var aliases = {};
      function aliasIsBoolean(key3) {
        return aliases[key3].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key3) {
        aliases[key3] = [].concat(opts.alias[key3]);
        aliases[key3].forEach(function(x) {
          aliases[x] = [key3].concat(aliases[key3].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key3) {
        flags.strings[key3] = true;
        if (aliases[key3]) {
          [].concat(aliases[key3]).forEach(function(k) {
            flags.strings[k] = true;
          });
        }
      });
      var defaults = opts.default || {};
      var argv = { _: [] };
      function argDefined(key3, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases[key3];
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i3 = 0; i3 < keys.length - 1; i3++) {
          var key3 = keys[i3];
          if (isConstructorOrProto(o, key3)) {
            return;
          }
          if (o[key3] === void 0) {
            o[key3] = {};
          }
          if (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) {
            o[key3] = {};
          }
          if (o[key3] === Array.prototype) {
            o[key3] = [];
          }
          o = o[key3];
        }
        var lastKey = keys[keys.length - 1];
        if (isConstructorOrProto(o, lastKey)) {
          return;
        }
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
          o = {};
        }
        if (o === Array.prototype) {
          o = [];
        }
        if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === "boolean") {
          o[lastKey] = value2;
        } else if (Array.isArray(o[lastKey])) {
          o[lastKey].push(value2);
        } else {
          o[lastKey] = [o[lastKey], value2];
        }
      }
      function setArg(key3, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key3, arg2)) {
          if (flags.unknownFn(arg2) === false) {
            return;
          }
        }
        var value2 = !flags.strings[key3] && isNumber3(val) ? Number(val) : val;
        setKey(argv, key3.split("."), value2);
        (aliases[key3] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      Object.keys(flags.bools).forEach(function(key3) {
        setArg(key3, defaults[key3] === void 0 ? false : defaults[key3]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      for (var i2 = 0; i2 < args.length; i2++) {
        var arg = args[i2];
        var key2;
        var next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key2 = m[1];
          var value = m[2];
          if (flags.bools[key2]) {
            value = value !== "false";
          }
          setArg(key2, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          key2 = arg.match(/^--no-(.+)/)[1];
          setArg(key2, false, arg);
        } else if (/^--.+/.test(arg)) {
          key2 = arg.match(/^--(.+)/)[1];
          next = args[i2 + 1];
          if (next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
            setArg(key2, next, arg);
            i2 += 1;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key2, next === "true", arg);
            i2 += 1;
          } else {
            setArg(key2, flags.strings[key2] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          key2 = arg.slice(-1)[0];
          if (!broken && key2 !== "-") {
            if (args[i2 + 1] && !/^(-|--)[^-]/.test(args[i2 + 1]) && !flags.bools[key2] && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
              setArg(key2, args[i2 + 1], arg);
              i2 += 1;
            } else if (args[i2 + 1] && /^(true|false)$/.test(args[i2 + 1])) {
              setArg(key2, args[i2 + 1] === "true", arg);
              i2 += 1;
            } else {
              setArg(key2, flags.strings[key2] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings._ || !isNumber3(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i2 + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(k) {
        if (!hasKey(argv, k.split("."))) {
          setKey(argv, k.split("."), defaults[k]);
          (aliases[k] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[k]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = notFlags.slice();
      } else {
        notFlags.forEach(function(k) {
          argv._.push(k);
        });
      }
      return argv;
    };
  }
});

// ../../node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "../../node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// ../../node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "../../node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has5 = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key2 = decode(part[1]), value = decode(part[2]);
        if (key2 === null || value === null || key2 in result)
          continue;
        result[key2] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key2;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key2 in obj) {
        if (has5.call(obj, key2)) {
          value = obj[key2];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key2 = encode(key2);
          value = encode(value);
          if (key2 === null || value === null)
            continue;
          pairs.push(key2 + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// ../../node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "../../node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof globalThis !== "undefined")
        globalVar = globalThis;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key2;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key2 in ignore)
          delete finaldestination[key2];
      } else if ("object" === type) {
        for (key2 in loc) {
          if (key2 in ignore)
            continue;
          finaldestination[key2] = loc[key2];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path2.length, last = path2[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path2[i2] === ".") {
          path2.splice(i2, 1);
        } else if (path2[i2] === "..") {
          path2.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0)
            unshift = true;
          path2.splice(i2, 1);
          up--;
        }
      }
      if (unshift)
        path2.unshift("");
      if (last === "." || last === "..")
        path2.push("");
      return path2.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key2, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key2 = instruction[1];
        if (parse !== parse) {
          url[key2] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key2] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key2] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key2] = index[1];
          address = address.slice(0, index.index);
        }
        url[key2] = url[key2] || (relative && instruction[3] ? location[key2] || "" : "");
        if (instruction[4])
          url[key2] = url[key2].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set7(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        var ins = rules[i2];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set: set7, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/url.js
var require_url = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault3(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName;
      function normalize(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize;
      function join2(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join2;
      function encodeParts(url) {
        return join2(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key2) => key2.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key2) => {
          const content = encodeURIComponent(String(value[key2]));
          return key2 + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key2, value2] = val.split("=");
          if (key2.length > 0) {
            acc[key2] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key2 in configData) {
            if (typeof configData[key2] !== "string") {
              configData[key2] = JSON.stringify(configData[key2]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key2) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key2];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key2) {
          try {
            const raw = getOption(key2);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key2}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/path.js
var require_path = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt;
    (function(PathExt2) {
      function join2(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt2.join = join2;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt2.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt2.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt2.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt2.extname = extname;
      function normalize(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt2.normalize = normalize;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt2.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt2.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt2.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt2.removeSlash = removeSlash;
    })(PathExt || (exports2.PathExt = PathExt = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/text.js
var require_text = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text2;
    (function(Text3) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i2 = 0; i2 + 1 < text.length && i2 < jsIdx; i2++) {
          const charCode = text.charCodeAt(i2);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i2 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i2++;
            }
          }
        }
        return charIdx;
      }
      Text3.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i2 = 0; i2 + 1 < text.length && i2 < jsIdx; i2++) {
          const charCode = text.charCodeAt(i2);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i2 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i2++;
            }
          }
        }
        return jsIdx;
      }
      Text3.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text3.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text3.titleCase = titleCase;
    })(Text2 || (exports2.Text = Text2 = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/time.js
var require_time = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_activitymonitor(), exports2);
    __exportStar2(require_interfaces2(), exports2);
    __exportStar2(require_lru(), exports2);
    __exportStar2(require_markdowncodeblocks(), exports2);
    __exportStar2(require_pageconfig(), exports2);
    __exportStar2(require_path(), exports2);
    __exportStar2(require_signal(), exports2);
    __exportStar2(require_text(), exports2);
    __exportStar2(require_time(), exports2);
    __exportStar2(require_url(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces3 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key2) {
        const item = this._map.get(key2) || null;
        if (item != null) {
          this._map.delete(key2);
          this._map.set(key2, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key2, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key2, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/url.js
var require_url2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = __require("path");
    var url_parse_1 = __importDefault3(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName;
      function normalize(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize;
      function join2(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join2;
      function encodeParts(url) {
        return join2(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key2) => key2.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key2) => {
          const content = encodeURIComponent(String(value[key2]));
          return key2 + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key2, value2] = val.split("=");
          if (key2.length > 0) {
            acc[key2] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_dist();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url2();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = __require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key2 in configData) {
            if (typeof configData[key2] !== "string") {
              configData[key2] = JSON.stringify(configData[key2]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key2) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key2];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key2) {
          try {
            const raw = getOption(key2);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key2}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/path.js
var require_path2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = __require("path");
    var PathExt;
    (function(PathExt2) {
      function join2(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt2.join = join2;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt2.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt2.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt2.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt2.extname = extname;
      function normalize(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt2.normalize = normalize;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt2.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt2.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt2.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt2.removeSlash = removeSlash;
    })(PathExt || (exports2.PathExt = PathExt = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_dist();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/text.js
var require_text2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text2;
    (function(Text3) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i2 = 0; i2 + 1 < text.length && i2 < jsIdx; i2++) {
          const charCode = text.charCodeAt(i2);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i2 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i2++;
            }
          }
        }
        return charIdx;
      }
      Text3.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i2 = 0; i2 + 1 < text.length && i2 < jsIdx; i2++) {
          const charCode = text.charCodeAt(i2);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i2 + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i2++;
            }
          }
        }
        return jsIdx;
      }
      Text3.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text3.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text3.titleCase = titleCase;
    })(Text2 || (exports2.Text = Text2 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/time.js
var require_time2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value, format2 = "long") {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, {
          numeric: "auto",
          style: format2
        });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_activitymonitor2(), exports2);
    __exportStar2(require_interfaces3(), exports2);
    __exportStar2(require_lru2(), exports2);
    __exportStar2(require_markdowncodeblocks2(), exports2);
    __exportStar2(require_pageconfig2(), exports2);
    __exportStar2(require_path2(), exports2);
    __exportStar2(require_signal2(), exports2);
    __exportStar2(require_text2(), exports2);
    __exportStar2(require_time2(), exports2);
    __exportStar2(require_url2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_dist();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage = __importStar2(require_messages());
    function serialize(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private31.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private31.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private31.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private31.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private31;
    (function(Private32) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i2 = 0; i2 < offsetNumber; i2++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i2 + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i2 = 5; i2 < offsets.length - 1; i2++) {
          buffers.push(new DataView(binMsg.slice(offsets[i2], offsets[i2 + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private32.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i2 = 0; i2 < offsets.length; i2++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i2]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i2 + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i2 = 0; i2 < buffers.length; i2++) {
          const buffer = buffers[i2];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i2]);
        }
        return binMsg.buffer;
      }
      Private32.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private32.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private32.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i2 = 1; i2 <= nbufs; i2++) {
          offsets.push(data.getUint32(i2 * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i2 = 1; i2 < nbufs; i2++) {
          const start = offsets[i2];
          const stop = offsets[i2 + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i2 = 0; i2 < origBuffers.length; i2++) {
          const b = origBuffers[i2];
          buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i2 = 0; i2 + 1 < buffers.length; i2++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i2].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i2 = 0; i2 < offsets.length; i2++) {
          view.setUint32(4 * (i2 + 1), offsets[i2]);
        }
        for (let i2 = 0; i2 < buffers.length; i2++) {
          msgBuf.set(new Uint8Array(buffers[i2]), offsets[i2]);
        }
        return msgBuf.buffer;
      }
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/shim/ws.js
var require_ws = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/shim/ws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = WebSocket;
  }
});

// ../../node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib3();
    var serialize_1 = require_serialize();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection2;
    (function(ServerConnection3) {
      function makeSettings(options) {
        return Private31.makeSettings(options);
      }
      ServerConnection3.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private31.handleRequest(url, init, settings);
      }
      ServerConnection3.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e) {
            console.debug(e);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection3.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection3.NetworkError = NetworkError;
    })(ServerConnection2 || (exports2.ServerConnection = ServerConnection2 = {}));
    var Private31;
    (function(Private32) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken: typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl),
          serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private32.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined") {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e) => {
          throw new ServerConnection2.NetworkError(e);
        });
      }
      Private32.handleRequest = handleRequest;
      function getCookie(name2) {
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
          return;
        }
        const matches = cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches === null || matches === void 0 ? void 0 : matches[1];
      }
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/config/index.js
var require_config = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib3();
    var __1 = require_lib5();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create2(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create2;
    })(ConfigSection || (exports2.ConfigSection = ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key2) {
        const data = this._classData();
        return key2 in data ? data[key2] : this._defaults[key2];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key2, value) {
        const d2 = {};
        d2[key2] = value;
        if (this._className) {
          const d22 = {};
          d22[this._className] = d2;
          return this._section.update(d22);
        } else {
          return this._section.update(d2);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// ../../node_modules/@jupyterlab/services/lib/validate.js
var require_validate = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object, name2, typeName, values = []) {
      if (!object.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object[name2];
      if (typeName !== void 0) {
        let valid = true;
        switch (typeName) {
          case "array":
            valid = Array.isArray(value);
            break;
          case "object":
            valid = typeof value !== "undefined";
            break;
          default:
            valid = typeof value === typeName;
        }
        if (!valid) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values.length > 0) {
          let valid2 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid2 = values.includes(value);
              break;
            default:
              valid2 = values.findIndex((v2) => v2 === value) >= 0;
              break;
          }
          if (!valid2) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// ../../node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// ../../node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib3();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var validate = __importStar2(require_validate2());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents || (exports2.Contents = Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path: the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path: the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root, path2) {
        const driveName = this.driveName(root);
        const localPath = this.localPath(root);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path: the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive: an `IDrive`.
       *
       * @param localPath: the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path: a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath: The path to the file.
       *
       * @param options: The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const hash = options.hash ? "1" : "0";
          const params = { ...options, content, hash };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
        }
        const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options: The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private31.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i2 = 0; i2 < data.length; i2++) {
          validate.validateCheckpointModel(data[i2]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private31;
    (function(Private32) {
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      Private32.normalizeExtension = normalizeExtension;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@lumino/polling/dist/index.es6.js
var index_es6_exports3 = {};
__export(index_es6_exports3, {
  Debouncer: () => Debouncer,
  Poll: () => Poll,
  RateLimiter: () => RateLimiter,
  Throttler: () => Throttler
});
var import_coreutils2, Poll, Private4, RateLimiter, Debouncer, Throttler;
var init_index_es64 = __esm({
  "../../node_modules/@lumino/polling/dist/index.es6.js"() {
    import_coreutils2 = __toESM(require_dist());
    init_index_es63();
    Poll = class {
      /**
       * Instantiate a new poll with exponential backoff in case of failure.
       *
       * @param options - The poll instantiation options.
       */
      constructor(options) {
        var _a;
        this._disposed = new Signal(this);
        this._lingered = 0;
        this._tick = new import_coreutils2.PromiseDelegate();
        this._ticked = new Signal(this);
        this._factory = options.factory;
        this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private4.DEFAULT_LINGER;
        this._standby = options.standby || Private4.DEFAULT_STANDBY;
        this._state = { ...Private4.DEFAULT_STATE, timestamp: (/* @__PURE__ */ new Date()).getTime() };
        const frequency = options.frequency || {};
        const max2 = Math.max(frequency.interval || 0, frequency.max || 0, Private4.DEFAULT_FREQUENCY.max);
        this.frequency = { ...Private4.DEFAULT_FREQUENCY, ...frequency, ...{ max: max2 } };
        this.name = options.name || Private4.DEFAULT_NAME;
        if ("auto" in options ? options.auto : true) {
          setTimeout(() => this.start());
        }
      }
      /**
       * A signal emitted when the poll is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * The polling frequency parameters.
       */
      get frequency() {
        return this._frequency;
      }
      set frequency(frequency) {
        if (this.isDisposed || import_coreutils2.JSONExt.deepEqual(frequency, this.frequency || {})) {
          return;
        }
        let { backoff, interval, max: max2 } = frequency;
        interval = Math.round(interval);
        max2 = Math.round(max2);
        if (typeof backoff === "number" && backoff < 1) {
          throw new Error("Poll backoff growth factor must be at least 1");
        }
        if ((interval < 0 || interval > max2) && interval !== Poll.NEVER) {
          throw new Error("Poll interval must be between 0 and max");
        }
        if (max2 > Poll.MAX_INTERVAL && max2 !== Poll.NEVER) {
          throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);
        }
        this._frequency = { backoff, interval, max: max2 };
      }
      /**
       * Whether the poll is disposed.
       */
      get isDisposed() {
        return this.state.phase === "disposed";
      }
      /**
       * Indicates when the poll switches to standby.
       */
      get standby() {
        return this._standby;
      }
      set standby(standby) {
        if (this.isDisposed || this.standby === standby) {
          return;
        }
        this._standby = standby;
      }
      /**
       * The poll state, which is the content of the current poll tick.
       */
      get state() {
        return this._state;
      }
      /**
       * A promise that resolves when the poll next ticks.
       */
      get tick() {
        return this._tick.promise;
      }
      /**
       * A signal emitted when the poll ticks and fires off a new request.
       */
      get ticked() {
        return this._ticked;
      }
      /**
       * Return an async iterator that yields every tick.
       */
      async *[Symbol.asyncIterator]() {
        while (!this.isDisposed) {
          yield this.state;
          await this.tick.catch(() => void 0);
        }
      }
      /**
       * Dispose the poll.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._state = {
          ...Private4.DISPOSED_STATE,
          timestamp: (/* @__PURE__ */ new Date()).getTime()
        };
        this._tick.promise.catch((_) => void 0);
        this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
      /**
       * Refreshes the poll. Schedules `refreshed` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       *
       * #### Notes
       * The returned promise resolves after the tick is scheduled, but before
       * the polling action is run. To wait until after the poll action executes,
       * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`
       */
      refresh() {
        return this.schedule({
          cancel: ({ phase }) => phase === "refreshed",
          interval: Poll.IMMEDIATE,
          phase: "refreshed"
        });
      }
      /**
       * Schedule the next poll tick.
       *
       * @param next - The next poll state data to schedule. Defaults to standby.
       *
       * @param next.cancel - Cancels state transition if function returns `true`.
       *
       * @returns A promise that resolves when the next poll state is active.
       *
       * #### Notes
       * This method is not meant to be invoked by user code typically. It is public
       * to allow poll instances to be composed into classes that schedule ticks.
       */
      async schedule(next = {}) {
        if (this.isDisposed) {
          return;
        }
        if (next.cancel && next.cancel(this.state)) {
          return;
        }
        const pending = this._tick;
        const scheduled = new import_coreutils2.PromiseDelegate();
        const state = {
          interval: this.frequency.interval,
          payload: null,
          phase: "standby",
          timestamp: (/* @__PURE__ */ new Date()).getTime(),
          ...next
        };
        this._state = state;
        this._tick = scheduled;
        clearTimeout(this._timeout);
        this._ticked.emit(this.state);
        pending.resolve(this);
        await pending.promise;
        if (state.interval === Poll.NEVER) {
          this._timeout = void 0;
          return;
        }
        const execute = () => {
          if (this.isDisposed || this.tick !== scheduled.promise) {
            return;
          }
          this._execute();
        };
        this._timeout = setTimeout(execute, state.interval);
      }
      /**
       * Starts the poll. Schedules `started` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       */
      start() {
        return this.schedule({
          cancel: ({ phase }) => phase !== "constructed" && phase !== "standby" && phase !== "stopped",
          interval: Poll.IMMEDIATE,
          phase: "started"
        });
      }
      /**
       * Stops the poll. Schedules `stopped` tick if necessary.
       *
       * @returns A promise that resolves after tick is scheduled and never rejects.
       */
      stop() {
        return this.schedule({
          cancel: ({ phase }) => phase === "stopped",
          interval: Poll.NEVER,
          phase: "stopped"
        });
      }
      /**
       * Whether the poll is hidden.
       *
       * #### Notes
       * This property is only relevant in a browser context.
       */
      get hidden() {
        return Private4.hidden;
      }
      /**
       * Execute a new poll factory promise or stand by if necessary.
       */
      _execute() {
        let standby = typeof this.standby === "function" ? this.standby() : this.standby;
        if (standby === "never") {
          standby = false;
        } else if (standby === "when-hidden") {
          if (this.hidden) {
            standby = ++this._lingered > this._linger;
          } else {
            this._lingered = 0;
            standby = false;
          }
        }
        if (standby) {
          void this.schedule();
          return;
        }
        const pending = this.tick;
        this._factory(this.state).then((resolved) => {
          if (this.isDisposed || this.tick !== pending) {
            return;
          }
          void this.schedule({
            payload: resolved,
            phase: this.state.phase === "rejected" ? "reconnected" : "resolved"
          });
        }).catch((rejected) => {
          if (this.isDisposed || this.tick !== pending) {
            return;
          }
          void this.schedule({
            interval: Private4.sleep(this.frequency, this.state),
            payload: rejected,
            phase: "rejected"
          });
        });
      }
    };
    (function(Poll2) {
      Poll2.IMMEDIATE = 0;
      Poll2.MAX_INTERVAL = 2147483647;
      Poll2.NEVER = Infinity;
    })(Poll || (Poll = {}));
    (function(Private31) {
      Private31.DEFAULT_BACKOFF = 3;
      Private31.DEFAULT_FREQUENCY = {
        backoff: true,
        interval: 1e3,
        max: 30 * 1e3
      };
      Private31.DEFAULT_LINGER = 1;
      Private31.DEFAULT_NAME = "unknown";
      Private31.DEFAULT_STANDBY = "when-hidden";
      Private31.DEFAULT_STATE = {
        interval: Poll.NEVER,
        payload: null,
        phase: "constructed",
        timestamp: (/* @__PURE__ */ new Date(0)).getTime()
      };
      Private31.DISPOSED_STATE = {
        interval: Poll.NEVER,
        payload: null,
        phase: "disposed",
        timestamp: (/* @__PURE__ */ new Date(0)).getTime()
      };
      function sleep(frequency, last) {
        const { backoff, interval, max: max2 } = frequency;
        if (interval === Poll.NEVER) {
          return interval;
        }
        const growth = backoff === true ? Private31.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;
        const random = getRandomIntInclusive(interval, last.interval * growth);
        return Math.min(max2, random);
      }
      Private31.sleep = sleep;
      Private31.hidden = (() => {
        if (typeof document === "undefined") {
          return false;
        }
        document.addEventListener("visibilitychange", () => {
          Private31.hidden = document.visibilityState === "hidden";
        });
        document.addEventListener("pagehide", () => {
          Private31.hidden = document.visibilityState === "hidden";
        });
        return document.visibilityState === "hidden";
      })();
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
    })(Private4 || (Private4 = {}));
    RateLimiter = class {
      /**
       * Instantiate a rate limiter.
       *
       * @param fn - The function to rate limit.
       *
       * @param limit - The rate limit; defaults to 500ms.
       */
      constructor(fn, limit = 500) {
        this.args = void 0;
        this.payload = null;
        this.limit = limit;
        this.poll = new Poll({
          auto: false,
          factory: async () => {
            const { args } = this;
            this.args = void 0;
            return fn(...args);
          },
          frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },
          standby: "never"
        });
        this.payload = new import_coreutils2.PromiseDelegate();
        this.poll.ticked.connect((_, state) => {
          const { payload } = this;
          if (state.phase === "resolved") {
            this.payload = new import_coreutils2.PromiseDelegate();
            payload.resolve(state.payload);
            return;
          }
          if (state.phase === "rejected" || state.phase === "stopped") {
            this.payload = new import_coreutils2.PromiseDelegate();
            payload.promise.catch((_2) => void 0);
            payload.reject(state.payload);
            return;
          }
        }, this);
      }
      /**
       * Whether the rate limiter is disposed.
       */
      get isDisposed() {
        return this.payload === null;
      }
      /**
       * Disposes the rate limiter.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.args = void 0;
        this.payload = null;
        this.poll.dispose();
      }
      /**
       * Stop the function if it is mid-flight.
       */
      async stop() {
        return this.poll.stop();
      }
    };
    Debouncer = class extends RateLimiter {
      /**
       * Invokes the function and only executes after rate limit has elapsed.
       * Each invocation resets the timer.
       */
      invoke(...args) {
        this.args = args;
        void this.poll.schedule({ interval: this.limit, phase: "invoked" });
        return this.payload.promise;
      }
    };
    Throttler = class extends RateLimiter {
      /**
       * Instantiate a throttler.
       *
       * @param fn - The function being throttled.
       *
       * @param options - Throttling configuration or throttling limit in ms.
       *
       * #### Notes
       * The `edge` defaults to `leading`; the `limit` defaults to `500`.
       */
      constructor(fn, options) {
        super(fn, typeof options === "number" ? options : options && options.limit);
        this._trailing = false;
        if (typeof options !== "number" && options && options.edge === "trailing") {
          this._trailing = true;
        }
        this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;
      }
      /**
       * Throttles function invocations if one is currently in flight.
       */
      invoke(...args) {
        const idle = this.poll.state.phase !== "invoked";
        if (idle || this._trailing) {
          this.args = args;
        }
        if (idle) {
          void this.poll.schedule({ interval: this._interval, phase: "invoked" });
        }
        return this.payload.promise;
      }
    };
  }
});

// ../../node_modules/@jupyterlab/services/lib/event/index.js
var require_event = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib3();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl, token } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL) + (token ? `?token=${token}` : "");
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_, reject) => {
          if (this.isDisposed) {
            return;
          }
          const { token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          const url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : "");
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i2 = 0; i2 < HEADER_FIELDS.length; i2++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i2], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i2 = 0; i2 < names.length; i2++) {
          let args = fields[names[i2]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i2], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d2) => validateModel(d2));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib3();
    var validate_1 = require_validate3();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// ../../node_modules/@lumino/disposable/dist/index.es6.js
var index_es6_exports4 = {};
__export(index_es6_exports4, {
  DisposableDelegate: () => DisposableDelegate,
  DisposableSet: () => DisposableSet,
  ObservableDisposableDelegate: () => ObservableDisposableDelegate,
  ObservableDisposableSet: () => ObservableDisposableSet
});
var DisposableDelegate, ObservableDisposableDelegate, DisposableSet, ObservableDisposableSet;
var init_index_es65 = __esm({
  "../../node_modules/@lumino/disposable/dist/index.es6.js"() {
    init_index_es63();
    DisposableDelegate = class {
      /**
       * Construct a new disposable delegate.
       *
       * @param fn - The callback function to invoke on dispose.
       */
      constructor(fn) {
        this._fn = fn;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return !this._fn;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (!this._fn) {
          return;
        }
        let fn = this._fn;
        this._fn = null;
        fn();
      }
    };
    ObservableDisposableDelegate = class extends DisposableDelegate {
      constructor() {
        super(...arguments);
        this._disposed = new Signal(this);
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
    };
    DisposableSet = class {
      constructor() {
        this._isDisposed = false;
        this._items = /* @__PURE__ */ new Set();
      }
      /**
       * Test whether the set has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the set and the items it contains.
       *
       * #### Notes
       * Items are disposed in the order they are added to the set.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._items.forEach((item) => {
          item.dispose();
        });
        this._items.clear();
      }
      /**
       * Test whether the set contains a specific item.
       *
       * @param item - The item of interest.
       *
       * @returns `true` if the set contains the item, `false` otherwise.
       */
      contains(item) {
        return this._items.has(item);
      }
      /**
       * Add a disposable item to the set.
       *
       * @param item - The item to add to the set.
       *
       * #### Notes
       * If the item is already contained in the set, this is a no-op.
       */
      add(item) {
        this._items.add(item);
      }
      /**
       * Remove a disposable item from the set.
       *
       * @param item - The item to remove from the set.
       *
       * #### Notes
       * If the item is not contained in the set, this is a no-op.
       */
      remove(item) {
        this._items.delete(item);
      }
      /**
       * Remove all items from the set.
       */
      clear() {
        this._items.clear();
      }
    };
    (function(DisposableSet2) {
      function from(items) {
        let set7 = new DisposableSet2();
        for (const item of items) {
          set7.add(item);
        }
        return set7;
      }
      DisposableSet2.from = from;
    })(DisposableSet || (DisposableSet = {}));
    ObservableDisposableSet = class extends DisposableSet {
      constructor() {
        super(...arguments);
        this._disposed = new Signal(this);
      }
      /**
       * A signal emitted when the set is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Dispose of the set and the items it contains.
       *
       * #### Notes
       * Items are disposed in the order they are added to the set.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._disposed.emit(void 0);
        Signal.clearData(this);
      }
    };
    (function(ObservableDisposableSet2) {
      function from(items) {
        let set7 = new ObservableDisposableSet2();
        for (const item of items) {
          set7.add(item);
        }
        return set7;
      }
      ObservableDisposableSet2.from = from;
    })(ObservableDisposableSet || (ObservableDisposableSet = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb) {
        this._onClose = cb;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb) {
        this._onMsg = cb;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_dist();
    var disposable_1 = (init_index_es65(), __toCommonJS(index_es6_exports4));
    var KernelMessage = __importStar2(require_messages());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb, msg, expectReply, disposeOnDone, kernel) {
        super(cb);
        this._status = 0;
        this._stdin = Private31.noOp;
        this._iopub = Private31.noOp;
        this._reply = Private31.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private31.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private31.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb) {
        this._reply = cb;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb) {
        this._iopub = cb;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb) {
        this._stdin = cb;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private31.noOp;
        this._iopub = Private31.noOp;
        this._reply = Private31.noOp;
        this._hooks = null;
        if (!this._testFlag(Private31.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private31.KernelFutureFlag.GotReply);
        if (this._testFlag(Private31.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private31.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private31.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private31.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private31.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private31;
    (function(Private32) {
      Private32.noOp = () => {
      };
      const defer = (() => {
        const ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index = this._hooks.indexOf(hook);
          if (index >= 0) {
            this._hooks[index] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i2 = this._hooks.length - 1; i2 >= 0; i2--) {
            const hook = this._hooks[i2];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i2 = 0, len = this._hooks.length; i2 < len; i2++) {
            const hook = this._hooks[i2];
            if (this._hooks[i2] === null) {
              numNulls++;
            } else {
              this._hooks[i2 - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private32.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private32.KernelFutureFlag || (Private32.KernelFutureFlag = {}));
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i2 = 0; i2 < keys.length; i2++) {
        const ks = data.kernelspecs[keys[i2]];
        try {
          kernelspecs[keys[i2]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys[i2]}`);
        }
      }
      keys = Object.keys(kernelspecs);
      if (!keys.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys[0];
        console.warn(`Default kernel not found, using '${keys[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection();
    var validate_1 = require_validate4();
    var coreutils_12 = require_lib3();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var restapi = __importStar2(require_restapi2());
    var basemanager_1 = require_basemanager();
    var KernelSpecManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_) => void 0).catch((_) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar2(require_kernelspec());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI = __importStar2(require_restapi2());
    exports2.KernelSpecAPI = KernelSpecAPI;
    __exportStar2(require_manager(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib3();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var comm_1 = require_comm();
    var KernelMessage = __importStar2(require_messages());
    var future_1 = require_future();
    var validate = __importStar2(require_validate3());
    var kernelspec_1 = require_kernelspec2();
    var restapi = __importStar2(require_restapi());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private31.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private31.handleShellMessage(this, msg);
        } catch (e) {
          if (this.isDisposed) {
            return;
          } else {
            throw e;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private31.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private31.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private31.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private31.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private31.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private31.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target = await Private31.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target(comm, msg);
        } catch (e) {
          comm.close();
          console.error("Exception opening new comm");
          throw e;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p2 = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p2.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private31.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private31;
    (function(Private32) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private32.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private32.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private32.loadObject = loadObject;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private32.getRandomIntInclusive = getRandomIntInclusive;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi();
    var default_1 = require_default();
    var KernelManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager;
    (function(KernelManager2) {
      class NoopManager extends KernelManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager2.NoopManager = NoopManager;
    })(KernelManager || (exports2.KernelManager = KernelManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar2(require_kernel());
    exports2.Kernel = Kernel;
    var KernelMessage = __importStar2(require_messages());
    exports2.KernelMessage = KernelMessage;
    var KernelAPI = __importStar2(require_restapi());
    exports2.KernelAPI = KernelAPI;
    var default_1 = require_default();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar2(require_manager2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib3();
    var serverconnection_1 = require_serverconnection();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib3();
    var serverconnection_1 = require_serverconnection();
    var coreutils_2 = require_dist();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys = Object.keys(data);
        keys.forEach(function(key2) {
          const mimeType = data[key2].output_mimetype;
          exportList[key2] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/session.js
var require_session = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate5 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate3();
    var validate_2 = require_validate();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d2) => validateModel(d2));
    }
    exports2.validateModels = validateModels;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib3();
    var validate_1 = require_validate5();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m) => {
        (0, validate_1.updateLegacySessionModel)(m);
        (0, validate_1.validateModel)(m);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      const servicesBase = coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL);
      const result = coreutils_12.URLExt.join(servicesBase, id);
      if (!result.startsWith(servicesBase)) {
        throw new Error("Can only be used for services requests");
      }
      return result;
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/default.js
var require_default2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var restapi_1 = require_restapi3();
    var coreutils_12 = require_dist();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var default_1 = require_default2();
    var restapi_1 = require_restapi3();
    var SessionManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches = sessions.filter((value) => value.path === path2);
          if (matches.length === 1) {
            const id = matches[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        await this.refreshRunning();
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager;
    (function(SessionManager2) {
      class NoopManager extends SessionManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager2.NoopManager = NoopManager;
    })(SessionManager || (exports2.SessionManager = SessionManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/session/index.js
var require_session2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar2(require_session());
    exports2.Session = Session;
    var SessionAPI = __importStar2(require_restapi3());
    exports2.SessionAPI = SessionAPI;
    __exportStar2(require_manager3(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces4 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@lumino/properties/dist/index.es6.js
var index_es6_exports5 = {};
__export(index_es6_exports5, {
  AttachedProperty: () => AttachedProperty2
});
var AttachedProperty2, Private5;
var init_index_es66 = __esm({
  "../../node_modules/@jupyterlab/services/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty2 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private5.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private5.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private5.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private5.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private5.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty2 || (AttachedProperty2 = {}));
    (function(Private31) {
      Private31.ownerData = /* @__PURE__ */ new WeakMap();
      Private31.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private31.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private31.ownerData.set(owner, map2);
        return map2;
      }
      Private31.ensureMap = ensureMap;
    })(Private5 || (Private5 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_dist();
    var properties_1 = (init_index_es66(), __toCommonJS(index_es6_exports5));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var RestorablePool = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private31.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private31.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param fn The filter function to call on each object.
       */
      find(fn) {
        const values = this._objects.values();
        for (const value of values) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private31.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when } = options;
        const namespace = this.namespace;
        const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values = await Promise.all(saved.ids.map(async (id, index) => {
          const value = saved.values[index];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private31.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private31.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private31.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private31.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private31.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool;
    var Private31;
    (function(Private32) {
      Private32.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private32.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var StateDB = class {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform: transform2 } = options;
        this._connector = connector || new StateDB.Connector();
        if (!transform2) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform2.then((transformation) => {
            const { contents, type } = transformation;
            switch (type) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param namespace The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values } = await this._list();
        return values.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values } = await this._connector.list(namespace);
        return {
          ids,
          values: values.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key2) => contents[key2] && this._save(key2, contents[key2])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens2 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_dist();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// ../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/@jupyterlab/services/node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_dataconnector2(), exports2);
    __exportStar2(require_interfaces4(), exports2);
    __exportStar2(require_restorablepool2(), exports2);
    __exportStar2(require_statedb2(), exports2);
    __exportStar2(require_tokens2(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib3();
    var statedb_1 = require_lib4();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json = await response.json();
        const ids = (_b = (_a = json === null || json === void 0 ? void 0 : json["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values = [];
        if (!query) {
          values = (_d = (_c = json === null || json === void 0 ? void 0 : json["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private31;
    (function(Private32) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        const settingsBase = coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL);
        const result = coreutils_12.URLExt.join(settingsBase, id);
        if (!result.startsWith(settingsBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return `${result}${idsOnlyParam}`;
      }
      Private32.url = url;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib3();
    var serverconnection_1 = require_serverconnection();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private31.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private31.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private31.errorIfNotAvailable();
      const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const url = coreutils_12.URLExt.join(workspacesBase, name2);
      if (!url.startsWith(workspacesBase)) {
        throw new Error("Can only be used for terminal requests");
      }
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private31;
    (function(Private32) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private32.errorIfNotAvailable = errorIfNotAvailable;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi4();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default3 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib3();
    var coreutils_2 = require_dist();
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var restapi_1 = require_restapi4();
    var TerminalConnection = class {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private31.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private31;
    (function(Private32) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private32.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min, max2) {
        min = Math.ceil(min);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min + 1)) + min;
      }
      Private32.getRandomIntInclusive = getRandomIntInclusive;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager4 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var __1 = require_lib5();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi4();
    var default_1 = require_default3();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager || (exports2.TerminalManager = TerminalManager = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal2 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar2(require_terminal());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar2(require_restapi4());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar2(require_manager4(), exports2);
  }
});

// ../../node_modules/@jupyterlab/services/lib/user/index.js
var require_user = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib3();
    var coreutils_2 = require_dist();
    var polling_1 = (init_index_es64(), __toCommonJS(index_es6_exports3));
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity = newUser.identity;
        const { localStorage } = window;
        const data = localStorage.getItem(SERVICE_ID);
        if (data && (!identity.initials || !identity.color)) {
          const localUser = JSON.parse(data);
          identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1);
          identity.color = identity.color || localUser.color || Private31.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity;
          this._permissions = newUser.permissions;
          localStorage.setItem(SERVICE_ID, JSON.stringify(identity));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private31;
    (function(Private32) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private32.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib3();
    var statedb_1 = require_lib4();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result = await response.json();
        return result.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private31.url(base, id);
        const init = { body: JSON.stringify(workspace), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private31;
    (function(Private32) {
      function url(base, id) {
        const workspacesBase = coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL);
        const result = coreutils_12.URLExt.join(workspacesBase, id);
        if (!result.startsWith(workspacesBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return result;
      }
      Private32.url = url;
    })(Private31 || (Private31 = {}));
  }
});

// ../../node_modules/@jupyterlab/services/lib/manager.js
var require_manager5 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = (init_index_es63(), __toCommonJS(index_es6_exports2));
    var builder_1 = require_builder();
    var contents_1 = require_contents();
    var event_1 = require_event();
    var kernel_1 = require_kernel2();
    var kernelspec_1 = require_kernelspec2();
    var nbconvert_1 = require_nbconvert();
    var serverconnection_1 = require_serverconnection();
    var session_1 = require_session2();
    var setting_1 = require_setting();
    var terminal_1 = require_terminal2();
    var user_1 = require_user();
    var workspace_1 = require_workspace();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// ../../node_modules/@jupyterlab/services/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_basemanager(), exports2);
    __exportStar2(require_config(), exports2);
    __exportStar2(require_contents(), exports2);
    __exportStar2(require_event(), exports2);
    __exportStar2(require_kernel2(), exports2);
    __exportStar2(require_kernelspec2(), exports2);
    __exportStar2(require_manager5(), exports2);
    __exportStar2(require_serverconnection(), exports2);
    __exportStar2(require_session2(), exports2);
    __exportStar2(require_setting(), exports2);
    __exportStar2(require_terminal2(), exports2);
    __exportStar2(require_user(), exports2);
    __exportStar2(require_workspace(), exports2);
    __exportStar2(require_nbconvert(), exports2);
  }
});

// ../../node_modules/@jupyterlab/translation/lib/server.js
var import_services;
var init_server = __esm({
  "../../node_modules/@jupyterlab/translation/lib/server.js"() {
    import_services = __toESM(require_lib5());
  }
});

// ../../node_modules/@jupyterlab/translation/lib/tokens.js
var import_coreutils3, ITranslatorConnector, ITranslator;
var init_tokens = __esm({
  "../../node_modules/@jupyterlab/translation/lib/tokens.js"() {
    import_coreutils3 = __toESM(require_dist());
    init_server();
    ITranslatorConnector = new import_coreutils3.Token("@jupyterlab/translation:ITranslatorConnector", "A service to connect to the server translation endpoint.");
    ITranslator = new import_coreutils3.Token("@jupyterlab/translation:ITranslator", "A service to translate strings.");
  }
});

// ../../node_modules/@jupyterlab/translation/lib/manager.js
var init_manager = __esm({
  "../../node_modules/@jupyterlab/translation/lib/manager.js"() {
    init_gettext();
    init_tokens();
    init_utils();
  }
});

// ../../node_modules/@jupyterlab/translation/lib/index.js
var init_lib = __esm({
  "../../node_modules/@jupyterlab/translation/lib/index.js"() {
    init_base();
    init_gettext();
    init_manager();
    init_server();
    init_tokens();
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/debug/bad.svg
var bad_default;
var init_bad = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/debug/bad.svg"() {
    bad_default = "/myst_assets_folder/_assets/bad-FQMIYYET.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/debug/blank.svg
var blank_default;
var init_blank = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/debug/blank.svg"() {
    blank_default = "/myst_assets_folder/_assets/blank-US55MPOI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/refresh.svg
var refresh_default;
var init_refresh = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/refresh.svg"() {
    refresh_default = "/myst_assets_folder/_assets/refresh-3LT7D5B7.svg";
  }
});

// ../../node_modules/free-style/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  Cache: () => Cache,
  FreeStyle: () => FreeStyle,
  Rule: () => Rule,
  Selector: () => Selector,
  Style: () => Style,
  create: () => create
});
function escape(str) {
  return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
function hyphenate(propertyName) {
  return propertyName.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).replace(/^ms-/, "-ms-");
}
function stringHash(str) {
  let value = 5381;
  let len = str.length;
  while (len--)
    value = value * 33 ^ str.charCodeAt(len);
  return (value >>> 0).toString(36);
}
function styleToString(key2, value) {
  if (value && typeof value === "number" && !CSS_NUMBER[key2]) {
    return `${key2}:${value}px`;
  }
  return `${key2}:${value}`;
}
function sortTuples(value) {
  return value.sort((a, b) => a[0] > b[0] ? 1 : -1);
}
function parseStyles(styles, hasNestedStyles) {
  const properties = [];
  const nestedStyles = [];
  for (const key2 of Object.keys(styles)) {
    const name2 = key2.trim();
    const value = styles[key2];
    if (name2.charCodeAt(0) !== 36 && value != null) {
      if (typeof value === "object" && !Array.isArray(value)) {
        nestedStyles.push([name2, value]);
      } else {
        properties.push([hyphenate(name2), value]);
      }
    }
  }
  return {
    style: stringifyProperties(sortTuples(properties)),
    nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
    isUnique: !!styles.$unique
  };
}
function stringifyProperties(properties) {
  return properties.map(([name2, value]) => {
    if (!Array.isArray(value))
      return styleToString(name2, value);
    return value.map((x) => styleToString(name2, x)).join(";");
  }).join(";");
}
function interpolate(selector, parent) {
  if (selector.indexOf("&") === -1)
    return `${parent} ${selector}`;
  return selector.replace(/&/g, parent);
}
function stylize(selector, styles, rulesList, stylesList, parent) {
  const { style, nested, isUnique } = parseStyles(styles, selector !== "");
  let pid = style;
  if (selector.charCodeAt(0) === 64) {
    const child = {
      selector,
      styles: [],
      rules: [],
      style: parent ? "" : style
    };
    rulesList.push(child);
    if (style && parent) {
      child.styles.push({ selector: parent, style, isUnique });
    }
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, child.rules, child.styles, parent);
    }
  } else {
    const key2 = parent ? interpolate(selector, parent) : selector;
    if (style)
      stylesList.push({ selector: key2, style, isUnique });
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, rulesList, stylesList, key2);
    }
  }
  return pid;
}
function composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {
  for (const { selector, style, isUnique } of stylesList) {
    const key2 = isStyle ? interpolate(selector, className) : selector;
    const id = isUnique ? `u\0${(++uniqueId).toString(36)}` : `s\0${pid}\0${style}`;
    const item = new Style(style, id);
    item.add(new Selector(key2, `k\0${pid}\0${key2}`));
    cache.add(item);
  }
  for (const { selector, style, rules, styles } of rulesList) {
    const item = new Rule(selector, style, `r\0${pid}\0${selector}\0${style}`);
    composeStylize(item, pid, rules, styles, className, isStyle);
    cache.add(item);
  }
}
function join(arr) {
  let res = "";
  for (let i2 = 0; i2 < arr.length; i2++)
    res += arr[i2];
  return res;
}
function key(pid, styles) {
  const key2 = `f${stringHash(pid)}`;
  if (!styles.$displayName)
    return key2;
  return `${styles.$displayName}_${key2}`;
}
function create(changes) {
  return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
}
var uniqueId, CSS_NUMBER, CSS_NUMBER_KEYS, noopChanges, Cache, Selector, Style, Rule, FreeStyle;
var init_dist = __esm({
  "../../node_modules/free-style/dist.es2015/index.js"() {
    uniqueId = 0;
    CSS_NUMBER = /* @__PURE__ */ Object.create(null);
    CSS_NUMBER_KEYS = [
      "animation-iteration-count",
      "border-image-outset",
      "border-image-slice",
      "border-image-width",
      "box-flex",
      "box-flex-group",
      "box-ordinal-group",
      "column-count",
      "columns",
      "counter-increment",
      "counter-reset",
      "flex",
      "flex-grow",
      "flex-positive",
      "flex-shrink",
      "flex-negative",
      "flex-order",
      "font-weight",
      "grid-area",
      "grid-column",
      "grid-column-end",
      "grid-column-span",
      "grid-column-start",
      "grid-row",
      "grid-row-end",
      "grid-row-span",
      "grid-row-start",
      "line-clamp",
      "line-height",
      "opacity",
      "order",
      "orphans",
      "tab-size",
      "widows",
      "z-index",
      "zoom",
      // SVG properties.
      "fill-opacity",
      "flood-opacity",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width"
    ];
    for (const property of CSS_NUMBER_KEYS) {
      for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
        CSS_NUMBER[prefix + property] = true;
      }
    }
    noopChanges = {
      add: () => void 0,
      change: () => void 0,
      remove: () => void 0
    };
    Cache = class {
      constructor(changes = noopChanges) {
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = /* @__PURE__ */ Object.create(null);
        this._counters = /* @__PURE__ */ Object.create(null);
      }
      add(style) {
        const count = this._counters[style.id] || 0;
        const item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
          this._children[item.id] = item;
          this._keys.push(item.id);
          this.sheet.push(item.getStyles());
          this.changeId++;
          this.changes.add(item, this._keys.length - 1);
        } else if (item instanceof Cache && style instanceof Cache) {
          const curIndex = this._keys.indexOf(style.id);
          const prevItemChangeId = item.changeId;
          item.merge(style);
          if (item.changeId !== prevItemChangeId) {
            this.sheet.splice(curIndex, 1, item.getStyles());
            this.changeId++;
            this.changes.change(item, curIndex, curIndex);
          }
        }
      }
      remove(style) {
        const count = this._counters[style.id];
        if (count) {
          this._counters[style.id] = count - 1;
          const item = this._children[style.id];
          const index = this._keys.indexOf(item.id);
          if (count === 1) {
            delete this._counters[style.id];
            delete this._children[style.id];
            this._keys.splice(index, 1);
            this.sheet.splice(index, 1);
            this.changeId++;
            this.changes.remove(item, index);
          } else if (item instanceof Cache && style instanceof Cache) {
            const prevChangeId = item.changeId;
            item.unmerge(style);
            if (item.changeId !== prevChangeId) {
              this.sheet.splice(index, 1, item.getStyles());
              this.changeId++;
              this.changes.change(item, index, index);
            }
          }
        }
      }
      values() {
        return this._keys.map((key2) => this._children[key2]);
      }
      merge(cache) {
        for (const item of cache.values())
          this.add(item);
        return this;
      }
      unmerge(cache) {
        for (const item of cache.values())
          this.remove(item);
        return this;
      }
      clone() {
        return new Cache().merge(this);
      }
    };
    Selector = class {
      constructor(selector, id) {
        this.selector = selector;
        this.id = id;
      }
      getStyles() {
        return this.selector;
      }
      clone() {
        return this;
      }
    };
    Style = class extends Cache {
      constructor(style, id) {
        super();
        this.style = style;
        this.id = id;
      }
      getStyles() {
        return `${this.sheet.join(",")}{${this.style}}`;
      }
      clone() {
        return new Style(this.style, this.id).merge(this);
      }
    };
    Rule = class extends Cache {
      constructor(rule, style, id) {
        super();
        this.rule = rule;
        this.style = style;
        this.id = id;
      }
      getStyles() {
        return `${this.rule}{${this.style}${join(this.sheet)}}`;
      }
      clone() {
        return new Rule(this.rule, this.style, this.id).merge(this);
      }
    };
    FreeStyle = class extends Cache {
      constructor(id, changes) {
        super(changes);
        this.id = id;
      }
      registerStyle(styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("&", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `.${false ? id : escape(id)}`;
        composeStylize(this, pid, rulesList, stylesList, selector, true);
        return id;
      }
      registerKeyframes(keyframes) {
        return this.registerHashRule("@keyframes", keyframes);
      }
      registerHashRule(prefix, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `${prefix} ${false ? id : escape(id)}`;
        const rule = new Rule(selector, "", `h\0${pid}\0${prefix}`);
        composeStylize(rule, pid, rulesList, stylesList, "", false);
        this.add(rule);
        return id;
      }
      registerRule(rule, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize(rule, styles, rulesList, stylesList);
        composeStylize(this, pid, rulesList, stylesList, "", false);
      }
      registerCss(styles) {
        return this.registerRule("", styles);
      }
      getStyles() {
        return join(this.sheet);
      }
      clone() {
        return new FreeStyle(this.id, this.changes).merge(this);
      }
    };
  }
});

// ../../node_modules/typestyle/lib/internal/formatting.js
var require_formatting = __commonJS({
  "../../node_modules/typestyle/lib/internal/formatting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function convertToStyles(object) {
      var styles = {};
      for (var key2 in object) {
        var val = object[key2];
        if (key2 === "$nest") {
          var nested = val;
          for (var selector in nested) {
            var subproperties = nested[selector];
            styles[selector] = convertToStyles(subproperties);
          }
        } else if (key2 === "$debugName") {
          styles.$displayName = val;
        } else {
          styles[key2] = val;
        }
      }
      return styles;
    }
    exports2.convertToStyles = convertToStyles;
    function convertToKeyframes(frames) {
      var result = {};
      for (var offset in frames) {
        if (offset !== "$debugName") {
          result[offset] = frames[offset];
        }
      }
      if (frames.$debugName) {
        result.$displayName = frames.$debugName;
      }
      return result;
    }
    exports2.convertToKeyframes = convertToKeyframes;
  }
});

// ../../node_modules/typestyle/lib/internal/utilities.js
var require_utilities = __commonJS({
  "../../node_modules/typestyle/lib/internal/utilities.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raf = typeof requestAnimationFrame === "undefined" ? function(cb) {
      return setTimeout(cb);
    } : typeof window === "undefined" ? requestAnimationFrame : requestAnimationFrame.bind(window);
    function classes2() {
      var classes3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        classes3[_i] = arguments[_i];
      }
      return classes3.map(function(c) {
        return c && typeof c === "object" ? Object.keys(c).map(function(key2) {
          return !!c[key2] && key2;
        }) : [c];
      }).reduce(function(flattened, c) {
        return flattened.concat(c);
      }, []).filter(function(c) {
        return !!c;
      }).join(" ");
    }
    exports2.classes = classes2;
    function extend() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result = {};
      for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        if (object == null || object === false) {
          continue;
        }
        for (var key2 in object) {
          var val = object[key2];
          if (!val && val !== 0) {
            continue;
          }
          if (key2 === "$nest" && val) {
            result[key2] = result["$nest"] ? extend(result["$nest"], val) : val;
          } else if (key2.indexOf("&") !== -1 || key2.indexOf("@media") === 0) {
            result[key2] = result[key2] ? extend(result[key2], val) : val;
          } else {
            result[key2] = val;
          }
        }
      }
      return result;
    }
    exports2.extend = extend;
    exports2.media = function(mediaQuery) {
      var _a;
      var objects = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
      }
      var mediaQuerySections = [];
      if (mediaQuery.type)
        mediaQuerySections.push(mediaQuery.type);
      if (mediaQuery.orientation)
        mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
      if (mediaQuery.minWidth)
        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
      if (mediaQuery.maxWidth)
        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
      if (mediaQuery.minHeight)
        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
      if (mediaQuery.maxHeight)
        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
      if (mediaQuery.prefersColorScheme)
        mediaQuerySections.push("(prefers-color-scheme: " + mediaQuery.prefersColorScheme + ")");
      var stringMediaQuery = "@media " + mediaQuerySections.join(" and ");
      var object = {
        $nest: (_a = {}, _a[stringMediaQuery] = extend.apply(void 0, objects), _a)
      };
      return object;
    };
    var mediaLength = function(value) {
      return typeof value === "string" ? value : value + "px";
    };
  }
});

// ../../node_modules/typestyle/lib/internal/typestyle.js
var require_typestyle = __commonJS({
  "../../node_modules/typestyle/lib/internal/typestyle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FreeStyle2 = (init_dist(), __toCommonJS(dist_exports));
    var formatting_1 = require_formatting();
    var utilities_1 = require_utilities();
    var createFreeStyle = function() {
      return FreeStyle2.create();
    };
    var TypeStyle = (
      /** @class */
      function() {
        function TypeStyle2(_a) {
          var _this = this;
          var autoGenerateTag = _a.autoGenerateTag;
          this.cssRaw = function(mustBeValidCSS) {
            if (!mustBeValidCSS) {
              return;
            }
            _this._raw += mustBeValidCSS || "";
            _this._pendingRawChange = true;
            _this._styleUpdated();
          };
          this.cssRule = function(selector) {
            var objects = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              objects[_i - 1] = arguments[_i];
            }
            var styles = formatting_1.convertToStyles(utilities_1.extend.apply(void 0, objects));
            _this._freeStyle.registerRule(selector, styles);
            _this._styleUpdated();
            return;
          };
          this.forceRenderStyles = function() {
            var target = _this._getTag();
            if (!target) {
              return;
            }
            target.textContent = _this.getStyles();
          };
          this.fontFace = function() {
            var fontFace = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              fontFace[_i] = arguments[_i];
            }
            var freeStyle2 = _this._freeStyle;
            for (var _a2 = 0, _b = fontFace; _a2 < _b.length; _a2++) {
              var face = _b[_a2];
              freeStyle2.registerRule("@font-face", face);
            }
            _this._styleUpdated();
            return;
          };
          this.getStyles = function() {
            return (_this._raw || "") + _this._freeStyle.getStyles();
          };
          this.keyframes = function(frames) {
            var keyframes = formatting_1.convertToKeyframes(frames);
            var animationName = _this._freeStyle.registerKeyframes(keyframes);
            _this._styleUpdated();
            return animationName;
          };
          this.reinit = function() {
            var freeStyle2 = createFreeStyle();
            _this._freeStyle = freeStyle2;
            _this._lastFreeStyleChangeId = freeStyle2.changeId;
            _this._raw = "";
            _this._pendingRawChange = false;
            var target = _this._getTag();
            if (target) {
              target.textContent = "";
            }
          };
          this.setStylesTarget = function(tag) {
            if (_this._tag) {
              _this._tag.textContent = "";
            }
            _this._tag = tag;
            _this.forceRenderStyles();
          };
          this.stylesheet = function(classes2) {
            var classNames = Object.getOwnPropertyNames(classes2);
            var result = {};
            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
              var className = classNames_1[_i];
              var classDef = classes2[className];
              if (classDef) {
                classDef.$debugName = className;
                result[className] = _this.style(classDef);
              }
            }
            return result;
          };
          var freeStyle = createFreeStyle();
          this._autoGenerateTag = autoGenerateTag;
          this._freeStyle = freeStyle;
          this._lastFreeStyleChangeId = freeStyle.changeId;
          this._pending = 0;
          this._pendingRawChange = false;
          this._raw = "";
          this._tag = void 0;
          this.style = this.style.bind(this);
        }
        TypeStyle2.prototype._afterAllSync = function(cb) {
          var _this = this;
          this._pending++;
          var pending = this._pending;
          utilities_1.raf(function() {
            if (pending !== _this._pending) {
              return;
            }
            cb();
          });
        };
        TypeStyle2.prototype._getTag = function() {
          if (this._tag) {
            return this._tag;
          }
          if (this._autoGenerateTag) {
            var tag = typeof window === "undefined" ? { textContent: "" } : document.createElement("style");
            if (typeof document !== "undefined") {
              document.head.appendChild(tag);
            }
            this._tag = tag;
            return tag;
          }
          return void 0;
        };
        TypeStyle2.prototype._styleUpdated = function() {
          var _this = this;
          var changeId = this._freeStyle.changeId;
          var lastChangeId = this._lastFreeStyleChangeId;
          if (!this._pendingRawChange && changeId === lastChangeId) {
            return;
          }
          this._lastFreeStyleChangeId = changeId;
          this._pendingRawChange = false;
          this._afterAllSync(function() {
            return _this.forceRenderStyles();
          });
        };
        TypeStyle2.prototype.style = function() {
          var className = this._freeStyle.registerStyle(formatting_1.convertToStyles(utilities_1.extend.apply(void 0, arguments)));
          this._styleUpdated();
          return className;
        };
        return TypeStyle2;
      }()
    );
    exports2.TypeStyle = TypeStyle;
  }
});

// ../../node_modules/typestyle/lib/types.js
var require_types = __commonJS({
  "../../node_modules/typestyle/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/typestyle/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/typestyle/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typestyle_1 = require_typestyle();
    exports2.TypeStyle = typestyle_1.TypeStyle;
    var types = require_types();
    exports2.types = types;
    var utilities_1 = require_utilities();
    exports2.extend = utilities_1.extend;
    exports2.classes = utilities_1.classes;
    exports2.media = utilities_1.media;
    var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });
    exports2.setStylesTarget = ts.setStylesTarget;
    exports2.cssRaw = ts.cssRaw;
    exports2.cssRule = ts.cssRule;
    exports2.forceRenderStyles = ts.forceRenderStyles;
    exports2.fontFace = ts.fontFace;
    exports2.getStyles = ts.getStyles;
    exports2.keyframes = ts.keyframes;
    exports2.reinit = ts.reinit;
    exports2.style = ts.style;
    exports2.stylesheet = ts.stylesheet;
    function createTypeStyle(target) {
      var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });
      if (target) {
        instance.setStylesTarget(target);
      }
      return instance;
    }
    exports2.createTypeStyle = createTypeStyle;
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/style/icon.js
var import_lib, LabIconStyle;
var init_icon = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/style/icon.js"() {
    import_lib = __toESM(require_lib6());
    (function(LabIconStyle2) {
      const builtinSheets = {
        breadCrumb: {
          container: {
            $nest: {
              // `&` will be substituted for the generated classname (interpolation)
              "&:first-child svg": {
                bottom: "1px",
                marginLeft: "0px",
                position: "relative"
              },
              "&:hover": {
                backgroundColor: "var(--jp-layout-color2)"
              },
              [".jp-mod-dropTarget&"]: {
                backgroundColor: "var(--jp-brand-color2)",
                opacity: 0.7
              }
            }
          },
          element: {
            borderRadius: "var(--jp-border-radius)",
            cursor: "pointer",
            margin: "0px 2px",
            padding: "0px 2px",
            height: "16px",
            width: "16px",
            verticalAlign: "middle"
          }
        },
        commandPaletteHeader: {
          container: {
            height: "14px",
            margin: "0 14px 0 auto"
          },
          element: {
            height: "14px",
            width: "14px"
          },
          options: {
            elementPosition: "center"
          }
        },
        commandPaletteItem: {
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        launcherCard: {
          container: {
            height: "52px",
            width: "52px"
          },
          element: {
            height: "52px",
            width: "52px"
          },
          options: {
            elementPosition: "center"
          }
        },
        launcherSection: {
          container: {
            boxSizing: "border-box",
            marginRight: "12px",
            height: "32px",
            width: "32px"
          },
          element: {
            height: "32px",
            width: "32px"
          },
          options: {
            elementPosition: "center"
          }
        },
        listing: {
          container: {
            flex: "0 0 20px",
            marginRight: "4px",
            position: "relative"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        listingHeaderItem: {
          container: {
            display: "inline",
            height: "16px",
            width: "16px"
          },
          element: {
            height: "auto",
            margin: "-2px 0 0 0",
            width: "20px"
          },
          options: {
            elementPosition: "center"
          }
        },
        mainAreaTab: {
          container: {
            $nest: {
              ".lm-DockPanel-tabBar &": {
                marginRight: "4px"
              }
            }
          },
          element: {
            $nest: {
              ".lm-DockPanel-tabBar &": {
                height: "14px",
                width: "14px"
              }
            }
          },
          options: {
            elementPosition: "center"
          }
        },
        menuItem: {
          container: {
            display: "inline-block",
            verticalAlign: "middle"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        runningItem: {
          container: {
            margin: "0px 4px 0px 4px"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        select: {
          container: {
            pointerEvents: "none"
          },
          element: {
            position: "absolute",
            height: "auto",
            width: "16px"
          }
        },
        settingsEditor: {
          container: {
            display: "flex",
            flex: "0 0 20px",
            margin: "0 3px 0 0",
            position: "relative",
            height: "20px",
            width: "20px"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        },
        sideBar: {
          element: {
            height: "auto",
            width: "20px"
          },
          options: {
            elementPosition: "center"
          }
        },
        splash: {
          container: {
            animation: "0.3s fade-in linear forwards",
            height: "100%",
            width: "100%",
            zIndex: 1
          },
          element: {
            // width no height
            width: "100px"
          },
          options: {
            elementPosition: "center"
          }
        },
        statusBar: {
          element: {
            left: "0px",
            top: "0px",
            height: "18px",
            width: "20px",
            position: "relative"
          }
        },
        toolbarButton: {
          container: {
            display: "inline-block",
            verticalAlign: "middle"
          },
          element: {
            height: "16px",
            width: "16px"
          },
          options: {
            elementPosition: "center"
          }
        }
      };
      function _elementPositionFactory(extra) {
        return {
          container: {
            alignItems: "center",
            display: "flex"
          },
          element: {
            display: "block",
            ...extra
          }
        };
      }
      const positionSheets = {
        center: _elementPositionFactory({ margin: "0 auto", width: "100%" }),
        top: _elementPositionFactory({ margin: "0 0 auto 0" }),
        right: _elementPositionFactory({ margin: "0 0 0 auto" }),
        bottom: _elementPositionFactory({ margin: "auto 0 0 0" }),
        left: _elementPositionFactory({ margin: "0 auto 0 0" }),
        "top right": _elementPositionFactory({ margin: "0 0 auto auto" }),
        "bottom right": _elementPositionFactory({ margin: "auto 0 0 auto" }),
        "bottom left": _elementPositionFactory({ margin: "auto auto 0 0" }),
        "top left": _elementPositionFactory({ margin: "0 auto 0 auto" })
      };
      function _elementSizeFactory(size) {
        return {
          element: {
            height: size,
            width: size
          }
        };
      }
      const sizeSheets = {
        small: _elementSizeFactory("14px"),
        normal: _elementSizeFactory("16px"),
        large: _elementSizeFactory("20px"),
        xlarge: _elementSizeFactory("24px")
      };
      function mergeSheets(sheets) {
        return {
          container: Object.assign({}, ...sheets.map((s) => s.container)),
          element: Object.assign({}, ...sheets.map((s) => s.element))
        };
      }
      function resolveSheet(stylesheet) {
        if (!stylesheet) {
          return [];
        }
        if (!Array.isArray(stylesheet)) {
          stylesheet = [stylesheet];
        }
        return stylesheet.map((k) => typeof k === "string" ? builtinSheets[k] : k);
      }
      function applySheetOptions(sheets) {
        const options = Object.assign({}, ...sheets.map((s) => s.options));
        if (options.elementPosition) {
          sheets.unshift(positionSheets[options.elementPosition]);
        }
        if (options.elementSize) {
          sheets.unshift(sizeSheets[options.elementSize]);
        }
        return mergeSheets(sheets);
      }
      function resolveStyleClass(stylesheet) {
        var _a;
        return (0, import_lib.style)({
          ...stylesheet.container,
          $nest: {
            ...(_a = stylesheet.container) === null || _a === void 0 ? void 0 : _a.$nest,
            ["svg"]: stylesheet.element
          }
        });
      }
      const _styleClassCache = /* @__PURE__ */ new Map();
      function styleClass(props) {
        if (!props || Object.keys(props).length === 0) {
          return "";
        }
        let { elementPosition, elementSize, stylesheet, ...elementCSS } = props;
        const options = {
          ...elementPosition && { elementPosition },
          ...elementSize && { elementSize }
        };
        const cacheable = typeof stylesheet === "string" && Object.keys(elementCSS).length === 0;
        const cacheKey = cacheable ? [stylesheet, elementPosition, elementSize].join(",") : "";
        if (cacheable && _styleClassCache.has(cacheKey)) {
          return _styleClassCache.get(cacheKey);
        }
        const sheets = resolveSheet(stylesheet);
        sheets.push({ element: elementCSS, options });
        const cls = resolveStyleClass(applySheetOptions(sheets));
        if (cacheable) {
          _styleClassCache.set(cacheKey, cls);
        }
        return cls;
      }
      LabIconStyle2.styleClass = styleClass;
    })(LabIconStyle || (LabIconStyle = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/style/index.js
var init_style = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/style/index.js"() {
    init_icon();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/utils.js
function _classes(classes2) {
  return classes2.map((c) => c && typeof c === "object" ? Object.keys(c).map((key2) => !!c[key2] && key2) : typeof c === "string" ? c.split(/\s+/) : []).reduce((flattened, c) => flattened.concat(c), []).filter((c) => !!c);
}
function classes(...classes2) {
  return _classes(classes2).join(" ");
}
function getReactAttrs(elem, { ignore = [] } = {}) {
  return elem.getAttributeNames().reduce((d2, name2) => {
    if (name2 === "style" || ignore.includes(name2)) {
    } else if (name2.startsWith("data")) {
      d2[name2] = elem.getAttribute(name2);
    } else {
      d2[import_coreutils4.Text.camelCase(name2)] = elem.getAttribute(name2);
    }
    return d2;
  }, {});
}
var import_coreutils4;
var init_utils2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/utils.js"() {
    import_coreutils4 = __toESM(require_lib2());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js
var import_coreutils5, import_react, import_client, LabIcon, Private6, badIcon, blankIcon;
var init_labicon = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js"() {
    import_coreutils5 = __toESM(require_dist());
    init_index_es63();
    import_react = __toESM(require_react());
    import_client = __toESM(require_client());
    init_bad();
    init_blank();
    init_refresh();
    init_style();
    init_utils2();
    LabIcon = class {
      /** *********
       * statics *
       ***********/
      /**
       * Remove any rendered icon from the element that contains it
       *
       * @param container - a DOM node into which an icon was
       * previously rendered
       *
       * @returns the cleaned container
       */
      static remove(container) {
        while (container.firstChild) {
          container.firstChild.remove();
        }
        container.className = "";
        return container;
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into an
       * actual LabIcon.
       *
       * @param icon - either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields.
       *
       * @returns a LabIcon instance
       */
      static resolve({ icon }) {
        if (icon instanceof LabIcon) {
          return icon;
        }
        if (typeof icon === "string") {
          const resolved = LabIcon._instances.get(icon);
          if (resolved) {
            return resolved;
          }
          if (LabIcon._debug) {
            console.warn(`Lookup failed for icon, creating loading icon. icon: ${icon}`);
          }
          return new LabIcon({ name: icon, svgstr: refresh_default, _loading: true });
        }
        return new LabIcon(icon);
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into a DOM element.
       * If icon arg is undefined, the function will fall back to trying to render
       * the icon as a CSS background image, via the iconClass arg.
       * If both icon and iconClass are undefined, this function will return
       * an empty div.
       *
       * @param icon - optional, either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields
       *
       * @param iconClass - optional, if the icon arg is not set, the iconClass arg
       * should be a CSS class associated with an existing CSS background-image
       *
       * @param fallback - DEPRECATED, optional, a LabIcon instance that will
       * be used if neither icon nor iconClass are defined
       *
       * @param props - any additional args are passed though to the element method
       * of the resolved icon on render
       *
       * @returns a DOM node with the resolved icon rendered into it
       */
      static resolveElement({ icon, iconClass, fallback, ...props }) {
        if (!Private6.isResolvable(icon)) {
          if (!iconClass && fallback) {
            return fallback.element(props);
          }
          props.className = classes(iconClass, props.className);
          return Private6.blankElement(props);
        }
        return LabIcon.resolve({ icon }).element(props);
      }
      /**
       * Resolve an icon name or a \{name, svgstr\} pair into a React component.
       * If icon arg is undefined, the function will fall back to trying to render
       * the icon as a CSS background image, via the iconClass arg.
       * If both icon and iconClass are undefined, the returned component
       * will simply render an empty div.
       *
       * @param icon - optional, either a string with the name of an existing icon
       * or an object with \{name: string, svgstr: string\} fields
       *
       * @param iconClass - optional, if the icon arg is not set, the iconClass arg
       * should be a CSS class associated with an existing CSS background-image
       *
       * @param fallback - DEPRECATED, optional, a LabIcon instance that will
       * be used if neither icon nor iconClass are defined
       *
       * @param props - any additional args are passed though to the React component
       * of the resolved icon on render
       *
       * @returns a React component that will render the resolved icon
       */
      static resolveReact({ icon, iconClass, fallback, ...props }) {
        if (!Private6.isResolvable(icon)) {
          if (!iconClass && fallback) {
            return import_react.default.createElement(fallback.react, { ...props });
          }
          props.className = classes(iconClass, props.className);
          return import_react.default.createElement(Private6.blankReact, { ...props });
        }
        const resolved = LabIcon.resolve({ icon });
        return import_react.default.createElement(resolved.react, { ...props });
      }
      /**
       * Resolve a \{name, svgstr\} pair into an actual svg node.
       */
      static resolveSvg({ name: name2, svgstr }) {
        const svgDoc = new DOMParser().parseFromString(Private6.svgstrShim(svgstr), "image/svg+xml");
        const svgError = svgDoc.querySelector("parsererror");
        if (svgError) {
          const errmsg = `SVG HTML was malformed for LabIcon instance.
name: ${name2}, svgstr: ${svgstr}`;
          if (LabIcon._debug) {
            console.error(errmsg);
            return svgError;
          } else {
            console.warn(errmsg);
            return null;
          }
        } else {
          return svgDoc.documentElement;
        }
      }
      /**
       * Toggle icon debug from off-to-on, or vice-versa.
       *
       * @param debug - optional boolean to force debug on or off
       */
      static toggleDebug(debug) {
        LabIcon._debug = debug !== null && debug !== void 0 ? debug : !LabIcon._debug;
      }
      /** *********
       * members *
       ***********/
      constructor({ name: name2, svgstr, render, unrender, _loading = false }) {
        this._props = {};
        this._svgReplaced = new Signal(this);
        this._svgElement = void 0;
        this._svgInnerHTML = void 0;
        this._svgReactAttrs = void 0;
        if (!(name2 && svgstr)) {
          console.error(`When defining a new LabIcon, name and svgstr must both be non-empty strings. name: ${name2}, svgstr: ${svgstr}`);
          return badIcon;
        }
        this._loading = _loading;
        if (LabIcon._instances.has(name2)) {
          const icon = LabIcon._instances.get(name2);
          if (this._loading) {
            icon.svgstr = svgstr;
            this._loading = false;
            return icon;
          } else {
            if (LabIcon._debug) {
              console.warn(`Redefining previously loaded icon svgstr. name: ${name2}, svgstrOld: ${icon.svgstr}, svgstr: ${svgstr}`);
            }
            icon.svgstr = svgstr;
            return icon;
          }
        }
        this.name = name2;
        this.react = this._initReact(name2);
        this.svgstr = svgstr;
        this._initRender({ render, unrender });
        LabIcon._instances.set(this.name, this);
      }
      /**
       * Get a view of this icon that is bound to the specified icon/style props
       *
       * @param optional icon/style props (same as args for .element
       * and .react methods). These will be bound to the resulting view
       *
       * @returns a view of this LabIcon instance
       */
      bindprops(props) {
        const view = Object.create(this);
        view._props = props;
        view.react = view._initReact(view.name + "_bind");
        return view;
      }
      /**
       * Create an icon as a DOM element
       *
       * @param className - a string that will be used as the class
       * of the container element. Overrides any existing class
       *
       * @param container - a preexisting DOM element that
       * will be used as the container for the svg element
       *
       * @param label - text that will be displayed adjacent
       * to the icon
       *
       * @param title - a tooltip for the icon
       *
       * @param tag - if container is not explicitly
       * provided, this tag will be used when creating the container
       *
       * @param stylesheet - optional string naming a builtin icon
       * stylesheet, for example 'menuItem' or `statusBar`. Can also be an
       * object defining a custom icon stylesheet, or a list of builtin
       * stylesheet names and/or custom stylesheet objects. If array,
       * the given stylesheets will be merged.
       *
       *   See @jupyterlab/ui-components/src/style/icon.ts for details
       *
       * @param elementPosition - optional position for the inner svg element
       *
       * @param elementSize - optional size for the inner svg element.
       * Set to 'normal' to get a standard 16px x 16px icon
       *
       * @param ...elementCSS - all additional args are treated as
       * overrides for the CSS props applied to the inner svg element
       *
       * @returns A DOM element that contains an (inline) svg element
       * that displays an icon
       */
      element(props = {}) {
        var _a;
        let { className, container, label, title, tag = "div", ...styleProps } = { ...this._props, ...props };
        const maybeSvgElement = container === null || container === void 0 ? void 0 : container.firstChild;
        if (((_a = maybeSvgElement === null || maybeSvgElement === void 0 ? void 0 : maybeSvgElement.dataset) === null || _a === void 0 ? void 0 : _a.iconId) === this._uuid) {
          return maybeSvgElement;
        }
        if (!this.svgElement) {
          return document.createElement("div");
        }
        let returnSvgElement = true;
        if (container) {
          while (container.firstChild) {
            container.firstChild.remove();
          }
        } else {
          container = document.createElement(tag);
          returnSvgElement = false;
        }
        if (label != null) {
          container.textContent = label;
        }
        Private6.initContainer({ container, className, styleProps, title });
        const svgElement = this.svgElement.cloneNode(true);
        container.appendChild(svgElement);
        return returnSvgElement ? svgElement : container;
      }
      render(container, options) {
        var _a;
        let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
        if (typeof label !== "string") {
          label = void 0;
        }
        this.element({
          container,
          label,
          ...options === null || options === void 0 ? void 0 : options.props
        });
      }
      get svgElement() {
        if (this._svgElement === void 0) {
          this._svgElement = this._initSvg({ uuid: this._uuid });
        }
        return this._svgElement;
      }
      get svgInnerHTML() {
        if (this._svgInnerHTML === void 0) {
          if (this.svgElement === null) {
            this._svgInnerHTML = null;
          } else {
            this._svgInnerHTML = this.svgElement.innerHTML;
          }
        }
        return this._svgInnerHTML;
      }
      get svgReactAttrs() {
        if (this._svgReactAttrs === void 0) {
          if (this.svgElement === null) {
            this._svgReactAttrs = null;
          } else {
            this._svgReactAttrs = getReactAttrs(this.svgElement, {
              ignore: ["data-icon-id"]
            });
          }
        }
        return this._svgReactAttrs;
      }
      get svgstr() {
        return this._svgstr;
      }
      set svgstr(svgstr) {
        this._svgstr = svgstr;
        const uuid = import_coreutils5.UUID.uuid4();
        const uuidOld = this._uuid;
        this._uuid = uuid;
        this._svgElement = void 0;
        this._svgInnerHTML = void 0;
        this._svgReactAttrs = void 0;
        document.querySelectorAll(`[data-icon-id="${uuidOld}"]`).forEach((oldSvgElement) => {
          if (this.svgElement) {
            oldSvgElement.replaceWith(this.svgElement.cloneNode(true));
          }
        });
        this._svgReplaced.emit();
      }
      _initReact(displayName) {
        const component = import_react.default.forwardRef((props = {}, ref) => {
          const { className, container, label, title, tag = "div", ...styleProps } = { ...this._props, ...props };
          const [, setId] = import_react.default.useState(this._uuid);
          import_react.default.useEffect(() => {
            const onSvgReplaced = () => {
              setId(this._uuid);
            };
            this._svgReplaced.connect(onSvgReplaced);
            return () => {
              this._svgReplaced.disconnect(onSvgReplaced);
            };
          });
          const Tag = tag;
          if (!(this.svgInnerHTML && this.svgReactAttrs)) {
            return import_react.default.createElement(import_react.default.Fragment, null);
          }
          const svgComponent = import_react.default.createElement("svg", { ...this.svgReactAttrs, dangerouslySetInnerHTML: { __html: this.svgInnerHTML }, ref });
          if (container) {
            Private6.initContainer({ container, className, styleProps, title });
            return import_react.default.createElement(
              import_react.default.Fragment,
              null,
              svgComponent,
              label
            );
          } else {
            return import_react.default.createElement(
              Tag,
              { className: className || styleProps ? classes(className, LabIconStyle.styleClass(styleProps)) : void 0, title },
              svgComponent,
              label
            );
          }
        });
        component.displayName = `LabIcon_${displayName}`;
        return component;
      }
      _initRender({ render, unrender }) {
        if (render) {
          this.render = render;
          if (unrender) {
            this.unrender = unrender;
          }
        } else if (unrender) {
          console.warn("In _initRender, ignoring unrender arg since render is undefined");
        }
      }
      _initSvg({ title, uuid } = {}) {
        const svgElement = LabIcon.resolveSvg(this);
        if (!svgElement) {
          return svgElement;
        }
        if (svgElement.tagName !== "parsererror") {
          svgElement.dataset.icon = this.name;
          if (uuid) {
            svgElement.dataset.iconId = uuid;
          }
          if (title) {
            Private6.setTitleSvg(svgElement, title);
          }
        }
        return svgElement;
      }
    };
    LabIcon._debug = false;
    LabIcon._instances = /* @__PURE__ */ new Map();
    (function(Private31) {
      function blankElement({ className = "", container, label, title, tag = "div", ...styleProps }) {
        if ((container === null || container === void 0 ? void 0 : container.className) === className) {
          return container;
        }
        if (container) {
          while (container.firstChild) {
            container.firstChild.remove();
          }
        } else {
          container = document.createElement(tag);
        }
        if (label != null) {
          container.textContent = label;
        }
        Private31.initContainer({ container, className, styleProps, title });
        return container;
      }
      Private31.blankElement = blankElement;
      Private31.blankReact = import_react.default.forwardRef(({ className = "", container, label, title, tag = "div", ...styleProps }, ref) => {
        const Tag = tag;
        if (container) {
          initContainer({ container, className, styleProps, title });
          return import_react.default.createElement(import_react.default.Fragment, null);
        } else {
          return import_react.default.createElement(
            Tag,
            { className: classes(className, LabIconStyle.styleClass(styleProps)) },
            ref && blankIcon.react({ ref }),
            label
          );
        }
      });
      Private31.blankReact.displayName = "BlankReact";
      function initContainer({ container, className, styleProps, title }) {
        if (title != null) {
          container.title = title;
        }
        const styleClass = LabIconStyle.styleClass(styleProps);
        if (className != null) {
          const classResolved = classes(className, styleClass);
          container.className = classResolved;
          return classResolved;
        } else if (styleClass) {
          container.classList.add(styleClass);
          return styleClass;
        } else {
          return "";
        }
      }
      Private31.initContainer = initContainer;
      function isResolvable(icon) {
        return !!(icon && (typeof icon === "string" || icon.name && icon.svgstr));
      }
      Private31.isResolvable = isResolvable;
      function setTitleSvg(svgNode, title) {
        const titleNodes = svgNode.getElementsByTagName("title");
        if (titleNodes.length) {
          titleNodes[0].textContent = title;
        } else {
          const titleNode = document.createElement("title");
          titleNode.textContent = title;
          svgNode.appendChild(titleNode);
        }
      }
      Private31.setTitleSvg = setTitleSvg;
      function svgstrShim(svgstr, strict = true) {
        const [, base64, raw] = decodeURIComponent(svgstr).replace(/>\s*\n\s*</g, "><").replace(/\s*\n\s*/g, " ").match(strict ? (
          // match based on data url schema
          /^(?:data:.*?(;base64)?,)?(.*)/
        ) : (
          // match based on open of svg tag
          /(?:(base64).*)?(<svg.*)/
        ));
        return base64 ? atob(raw) : raw;
      }
      Private31.svgstrShim = svgstrShim;
      class Renderer {
        constructor(_icon, _rendererOptions) {
          this._icon = _icon;
          this._rendererOptions = _rendererOptions;
        }
        // eslint-disable-next-line
        render(container, options) {
        }
      }
      Private31.Renderer = Renderer;
      class ElementRenderer extends Renderer {
        render(container, options) {
          var _a, _b;
          let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
          if (typeof label !== "string") {
            label = void 0;
          }
          this._icon.element({
            container,
            label,
            ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props,
            ...options === null || options === void 0 ? void 0 : options.props
          });
        }
      }
      Private31.ElementRenderer = ElementRenderer;
      class ReactRenderer extends Renderer {
        constructor() {
          super(...arguments);
          this._rootDOM = null;
        }
        render(container, options) {
          var _a, _b;
          let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
          if (typeof label !== "string") {
            label = void 0;
          }
          const icon = this._icon;
          if (this._rootDOM !== null) {
            this._rootDOM.unmount();
          }
          this._rootDOM = (0, import_client.createRoot)(container);
          this._rootDOM.render(import_react.default.createElement(icon.react, { container, label, ...{ ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props, ...options === null || options === void 0 ? void 0 : options.props } }));
        }
        unrender(container) {
          if (this._rootDOM !== null) {
            this._rootDOM.unmount();
            this._rootDOM = null;
          }
        }
      }
      Private31.ReactRenderer = ReactRenderer;
    })(Private6 || (Private6 = {}));
    badIcon = new LabIcon({
      name: "ui-components:bad",
      svgstr: bad_default
    });
    blankIcon = new LabIcon({
      name: "ui-components:blank",
      svgstr: blank_default
    });
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-above.svg
var add_above_default;
var init_add_above = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-above.svg"() {
    add_above_default = "/myst_assets_folder/_assets/add-above-5YUGWHEL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-below.svg
var add_below_default;
var init_add_below = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add-below.svg"() {
    add_below_default = "/myst_assets_folder/_assets/add-below-XTZUELQC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add.svg
var add_default;
var init_add = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/add.svg"() {
    add_default = "/myst_assets_folder/_assets/add-R4QSNJUY.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/bell.svg
var bell_default;
var init_bell = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/bell.svg"() {
    bell_default = "/myst_assets_folder/_assets/bell-XTFPCACC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug-dot.svg
var bug_dot_default;
var init_bug_dot = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug-dot.svg"() {
    bug_dot_default = "/myst_assets_folder/_assets/bug-dot-GJV4IWQD.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug.svg
var bug_default;
var init_bug = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/bug.svg"() {
    bug_default = "/myst_assets_folder/_assets/bug-4MAGJLKH.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/build.svg
var build_default;
var init_build = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/build.svg"() {
    build_default = "/myst_assets_folder/_assets/build-4P67M2HU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty.svg
var caret_down_empty_default;
var init_caret_down_empty = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty.svg"() {
    caret_down_empty_default = "/myst_assets_folder/_assets/caret-down-empty-C224CN6A.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty-thin.svg
var caret_down_empty_thin_default;
var init_caret_down_empty_thin = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down-empty-thin.svg"() {
    caret_down_empty_thin_default = "/myst_assets_folder/_assets/caret-down-empty-thin-62EUTBPL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down.svg
var caret_down_default;
var init_caret_down = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-down.svg"() {
    caret_down_default = "/myst_assets_folder/_assets/caret-down-CYALMSQQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-left.svg
var caret_left_default;
var init_caret_left = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-left.svg"() {
    caret_left_default = "/myst_assets_folder/_assets/caret-left-2YD4AJB4.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-right.svg
var caret_right_default;
var init_caret_right = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-right.svg"() {
    caret_right_default = "/myst_assets_folder/_assets/caret-right-IW4L2CPJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up-empty-thin.svg
var caret_up_empty_thin_default;
var init_caret_up_empty_thin = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up-empty-thin.svg"() {
    caret_up_empty_thin_default = "/myst_assets_folder/_assets/caret-up-empty-thin-SETVTKOF.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up.svg
var caret_up_default;
var init_caret_up = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/arrow/caret-up.svg"() {
    caret_up_default = "/myst_assets_folder/_assets/caret-up-TOMNEAKL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/case-sensitive.svg
var case_sensitive_default;
var init_case_sensitive = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/case-sensitive.svg"() {
    case_sensitive_default = "/myst_assets_folder/_assets/case-sensitive-5LX6IVLO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/check.svg
var check_default;
var init_check = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/check.svg"() {
    check_default = "/myst_assets_folder/_assets/check-BGI5YJWW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle-empty.svg
var circle_empty_default;
var init_circle_empty = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle-empty.svg"() {
    circle_empty_default = "/myst_assets_folder/_assets/circle-empty-JWWVJYTX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle.svg
var circle_default;
var init_circle = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/circle.svg"() {
    circle_default = "/myst_assets_folder/_assets/circle-CFDAPZA5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/clear.svg
var clear_default;
var init_clear = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/clear.svg"() {
    clear_default = "/myst_assets_folder/_assets/clear-6JK5E7JJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/close.svg
var close_default;
var init_close = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/close.svg"() {
    close_default = "/myst_assets_folder/_assets/close-KY5U6SOK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/lsp/code-check.svg
var code_check_default;
var init_code_check = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/lsp/code-check.svg"() {
    code_check_default = "/myst_assets_folder/_assets/code-check-THKPADVL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/code.svg
var code_default;
var init_code = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/code.svg"() {
    code_default = "/myst_assets_folder/_assets/code-7PPO5FGB.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/collapse-all.svg
var collapse_all_default;
var init_collapse_all = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/collapse-all.svg"() {
    collapse_all_default = "/myst_assets_folder/_assets/collapse-all-IGZNY6Q5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/console.svg
var console_default;
var init_console = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/console.svg"() {
    console_default = "/myst_assets_folder/_assets/console-K43B5JT7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/copy.svg
var copy_default;
var init_copy = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/copy.svg"() {
    copy_default = "/myst_assets_folder/_assets/copy-FP6F2OIW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/licenses/copyright.svg
var copyright_default;
var init_copyright = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/licenses/copyright.svg"() {
    copyright_default = "/myst_assets_folder/_assets/copyright-6OHU5QAV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/cut.svg
var cut_default;
var init_cut = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/cut.svg"() {
    cut_default = "/myst_assets_folder/_assets/cut-DDW54OJN.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/delete.svg
var delete_default;
var init_delete = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/delete.svg"() {
    delete_default = "/myst_assets_folder/_assets/delete-U532KYVM.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/download.svg
var download_default;
var init_download = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/download.svg"() {
    download_default = "/myst_assets_folder/_assets/download-4ASFXPY5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/duplicate.svg
var duplicate_default;
var init_duplicate = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/duplicate.svg"() {
    duplicate_default = "/myst_assets_folder/_assets/duplicate-RAKUKHXI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/edit.svg
var edit_default;
var init_edit = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/edit.svg"() {
    edit_default = "/myst_assets_folder/_assets/edit-P66G3NF6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/ellipses.svg
var ellipses_default;
var init_ellipses = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/ellipses.svg"() {
    ellipses_default = "/myst_assets_folder/_assets/ellipses-3ORICEZC.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/error.svg
var error_default;
var init_error = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/error.svg"() {
    error_default = "/myst_assets_folder/_assets/error-BSXZ5JTK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/expand-all.svg
var expand_all_default;
var init_expand_all = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/expand-all.svg"() {
    expand_all_default = "/myst_assets_folder/_assets/expand-all-QG3DD7QQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/extension.svg
var extension_default;
var init_extension = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/extension.svg"() {
    extension_default = "/myst_assets_folder/_assets/extension-KA4GVHFP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/fast-forward.svg
var fast_forward_default;
var init_fast_forward = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/fast-forward.svg"() {
    fast_forward_default = "/myst_assets_folder/_assets/fast-forward-7ARDBRH6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/file.svg
var file_default;
var init_file = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/file.svg"() {
    file_default = "/myst_assets_folder/_assets/file-QCU7GBDL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/file-upload.svg
var file_upload_default;
var init_file_upload = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/file-upload.svg"() {
    file_upload_default = "/myst_assets_folder/_assets/file-upload-IT6YG7XR.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/filter-dot.svg
var filter_dot_default;
var init_filter_dot = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/filter-dot.svg"() {
    filter_dot_default = "/myst_assets_folder/_assets/filter-dot-I75JHRGQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/filter-list.svg
var filter_list_default;
var init_filter_list = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/filter-list.svg"() {
    filter_list_default = "/myst_assets_folder/_assets/filter-list-TZYMSOVE.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/filter.svg
var filter_default;
var init_filter = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/filter.svg"() {
    filter_default = "/myst_assets_folder/_assets/filter-KOH6RC3B.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder-favorite.svg
var folder_favorite_default;
var init_folder_favorite = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder-favorite.svg"() {
    folder_favorite_default = "/myst_assets_folder/_assets/folder-favorite-P6GJXVI6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder.svg
var folder_default;
var init_folder = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/folder.svg"() {
    folder_default = "/myst_assets_folder/_assets/folder-BURVVL75.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/home.svg
var home_default;
var init_home = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/home.svg"() {
    home_default = "/myst_assets_folder/_assets/home-GKXJSXEV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/html5.svg
var html5_default;
var init_html5 = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/html5.svg"() {
    html5_default = "/myst_assets_folder/_assets/html5-5JBVHEQW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/image.svg
var image_default;
var init_image = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/image.svg"() {
    image_default = "/myst_assets_folder/_assets/image-QI2XIR4Y.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/info.svg
var info_default;
var init_info = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/info.svg"() {
    info_default = "/myst_assets_folder/_assets/info-JWBOWQKJ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/inspector.svg
var inspector_default;
var init_inspector = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/inspector.svg"() {
    inspector_default = "/myst_assets_folder/_assets/inspector-PEOMAXL2.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/json.svg
var json_default;
var init_json = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/json.svg"() {
    json_default = "/myst_assets_folder/_assets/json-ULBJNO2U.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/julia.svg
var julia_default;
var init_julia = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/julia.svg"() {
    julia_default = "/myst_assets_folder/_assets/julia-JGNMOTXV.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter-favicon.svg
var jupyter_favicon_default;
var init_jupyter_favicon = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter-favicon.svg"() {
    jupyter_favicon_default = "/myst_assets_folder/_assets/jupyter-favicon-WGOYKUNP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter.svg
var jupyter_default;
var init_jupyter = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyter.svg"() {
    jupyter_default = "/myst_assets_folder/_assets/jupyter-USEHDJ5T.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyterlab-wordmark.svg
var jupyterlab_wordmark_default;
var init_jupyterlab_wordmark = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/jupyter/jupyterlab-wordmark.svg"() {
    jupyterlab_wordmark_default = "/myst_assets_folder/_assets/jupyterlab-wordmark-MKAFM6T5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/kernel.svg
var kernel_default;
var init_kernel = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/kernel.svg"() {
    kernel_default = "/myst_assets_folder/_assets/kernel-E46TPADG.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/keyboard.svg
var keyboard_default;
var init_keyboard = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/keyboard.svg"() {
    keyboard_default = "/myst_assets_folder/_assets/keyboard-HMYUYZPR.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/launch.svg
var launch_default;
var init_launch = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/launch.svg"() {
    launch_default = "/myst_assets_folder/_assets/launch-MQLWQPN7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/launcher.svg
var launcher_default;
var init_launcher = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/launcher.svg"() {
    launcher_default = "/myst_assets_folder/_assets/launcher-ARJ62GM7.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/line-form.svg
var line_form_default;
var init_line_form = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/line-form.svg"() {
    line_form_default = "/myst_assets_folder/_assets/line-form-HY4KWCNU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/link.svg
var link_default;
var init_link = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/link.svg"() {
    link_default = "/myst_assets_folder/_assets/link-C4HM3C65.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/list.svg
var list_default;
var init_list = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/list.svg"() {
    list_default = "/myst_assets_folder/_assets/list-YSFA3VHH.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/markdown.svg
var markdown_default;
var init_markdown = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/markdown.svg"() {
    markdown_default = "/myst_assets_folder/_assets/markdown-MCLUEZEQ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-down.svg
var move_down_default;
var init_move_down = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-down.svg"() {
    move_down_default = "/myst_assets_folder/_assets/move-down-LZFDSSAO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-up.svg
var move_up_default;
var init_move_up = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/move-up.svg"() {
    move_up_default = "/myst_assets_folder/_assets/move-up-7KAUBHLO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/new-folder.svg
var new_folder_default;
var init_new_folder = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/new-folder.svg"() {
    new_folder_default = "/myst_assets_folder/_assets/new-folder-4POV3OI6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/not-trusted.svg
var not_trusted_default;
var init_not_trusted = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/not-trusted.svg"() {
    not_trusted_default = "/myst_assets_folder/_assets/not-trusted-RPAXQIYX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/notebook.svg
var notebook_default;
var init_notebook = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/notebook.svg"() {
    notebook_default = "/myst_assets_folder/_assets/notebook-TNDUP2XK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/numbering.svg
var numbering_default;
var init_numbering = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/numbering.svg"() {
    numbering_default = "/myst_assets_folder/_assets/numbering-MCTHQ3MW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/offline-bolt.svg
var offline_bolt_default;
var init_offline_bolt = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/offline-bolt.svg"() {
    offline_bolt_default = "/myst_assets_folder/_assets/offline-bolt-RWKC3GUI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/palette.svg
var palette_default;
var init_palette = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/palette.svg"() {
    palette_default = "/myst_assets_folder/_assets/palette-CTCHBG7A.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/paste.svg
var paste_default;
var init_paste = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/paste.svg"() {
    paste_default = "/myst_assets_folder/_assets/paste-HU6K3T27.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/pdf.svg
var pdf_default;
var init_pdf = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/pdf.svg"() {
    pdf_default = "/myst_assets_folder/_assets/pdf-62Q5YWM4.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/python.svg
var python_default;
var init_python = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/python.svg"() {
    python_default = "/myst_assets_folder/_assets/python-B77NBISZ.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/r-kernel.svg
var r_kernel_default;
var init_r_kernel = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/r-kernel.svg"() {
    r_kernel_default = "/myst_assets_folder/_assets/r-kernel-ZNBGLYKY.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/react.svg
var react_default;
var init_react = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/react.svg"() {
    react_default = "/myst_assets_folder/_assets/react-ZAPRXB2F.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/redo.svg
var redo_default;
var init_redo = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/redo.svg"() {
    redo_default = "/myst_assets_folder/_assets/redo-5TXV6DBU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/regex.svg
var regex_default;
var init_regex = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/regex.svg"() {
    regex_default = "/myst_assets_folder/_assets/regex-7KC5URCX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/run.svg
var run_default;
var init_run = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/run.svg"() {
    run_default = "/myst_assets_folder/_assets/run-ZPPLPQFU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/running.svg
var running_default;
var init_running = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/running.svg"() {
    running_default = "/myst_assets_folder/_assets/running-TCIMS2WE.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/save.svg
var save_default;
var init_save = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/save.svg"() {
    save_default = "/myst_assets_folder/_assets/save-FSPSDJ5V.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/search.svg
var search_default;
var init_search = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/search.svg"() {
    search_default = "/myst_assets_folder/_assets/search-O43R74CO.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/settings.svg
var settings_default;
var init_settings = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/settings.svg"() {
    settings_default = "/myst_assets_folder/_assets/settings-IVH6KP2C.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/share.svg
var share_default;
var init_share = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/share.svg"() {
    share_default = "/myst_assets_folder/_assets/share-ZS7CIGX5.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/spreadsheet.svg
var spreadsheet_default;
var init_spreadsheet = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/spreadsheet.svg"() {
    spreadsheet_default = "/myst_assets_folder/_assets/spreadsheet-JBVNHDBW.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/stop.svg
var stop_default;
var init_stop = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/stop.svg"() {
    stop_default = "/myst_assets_folder/_assets/stop-RBUW2A4K.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/tab.svg
var tab_default;
var init_tab = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/tab.svg"() {
    tab_default = "/myst_assets_folder/_assets/tab-M5UDZMG6.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/table-rows.svg
var table_rows_default;
var init_table_rows = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/table-rows.svg"() {
    table_rows_default = "/myst_assets_folder/_assets/table-rows-CBJWS37D.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tag.svg
var tag_default;
var init_tag = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tag.svg"() {
    tag_default = "/myst_assets_folder/_assets/tag-RCD4RZM3.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/terminal.svg
var terminal_default;
var init_terminal = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/terminal.svg"() {
    terminal_default = "/myst_assets_folder/_assets/terminal-BKHLQYWP.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/text-editor.svg
var text_editor_default;
var init_text_editor = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/text-editor.svg"() {
    text_editor_default = "/myst_assets_folder/_assets/text-editor-KKUF4F2Y.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/toc.svg
var toc_default;
var init_toc = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/toc.svg"() {
    toc_default = "/myst_assets_folder/_assets/toc-AVEQ4F4P.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tree-view.svg
var tree_view_default;
var init_tree_view = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/tree-view.svg"() {
    tree_view_default = "/myst_assets_folder/_assets/tree-view-BKKNCOY2.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/trusted.svg
var trusted_default;
var init_trusted = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/statusbar/trusted.svg"() {
    trusted_default = "/myst_assets_folder/_assets/trusted-HLBBEL7Z.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/undo.svg
var undo_default;
var init_undo = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/toolbar/undo.svg"() {
    undo_default = "/myst_assets_folder/_assets/undo-BRNP5XMB.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/user.svg
var user_default;
var init_user = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/user.svg"() {
    user_default = "/myst_assets_folder/_assets/user-UEYWBMNL.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/users.svg
var users_default;
var init_users = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/sidebar/users.svg"() {
    users_default = "/myst_assets_folder/_assets/users-ZOUO3MZX.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/vega.svg
var vega_default;
var init_vega = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/vega.svg"() {
    vega_default = "/myst_assets_folder/_assets/vega-YCXHCRWI.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/search/word.svg
var word_default;
var init_word = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/search/word.svg"() {
    word_default = "/myst_assets_folder/_assets/word-ZGJUELHU.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/style/icons/filetype/yaml.svg
var yaml_default;
var init_yaml = __esm({
  "../../node_modules/@jupyterlab/ui-components/style/icons/filetype/yaml.svg"() {
    yaml_default = "/myst_assets_folder/_assets/yaml-EZ7PS4QK.svg";
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/iconimports.js
var addAboveIcon, addBelowIcon, addIcon, bellIcon, bugDotIcon, bugIcon, buildIcon, caretDownEmptyIcon, caretDownEmptyThinIcon, caretDownIcon, caretLeftIcon, caretRightIcon, caretUpEmptyThinIcon, caretUpIcon, caseSensitiveIcon, checkIcon, circleEmptyIcon, circleIcon, clearIcon, closeIcon, codeCheckIcon, codeIcon, collapseAllIcon, consoleIcon, copyIcon, copyrightIcon, cutIcon, deleteIcon, downloadIcon, duplicateIcon, editIcon, ellipsesIcon, errorIcon, expandAllIcon, extensionIcon, fastForwardIcon, fileIcon, fileUploadIcon, filterDotIcon, filterIcon, filterListIcon, folderFavoriteIcon, folderIcon, homeIcon, html5Icon, imageIcon, infoIcon, inspectorIcon, jsonIcon, juliaIcon, jupyterFaviconIcon, jupyterIcon, jupyterlabWordmarkIcon, kernelIcon, keyboardIcon, launchIcon, launcherIcon, lineFormIcon, linkIcon, listIcon, markdownIcon, moveDownIcon, moveUpIcon, newFolderIcon, notTrustedIcon, notebookIcon, numberingIcon, offlineBoltIcon, paletteIcon, pasteIcon, pdfIcon, pythonIcon, rKernelIcon, reactIcon, redoIcon, refreshIcon, regexIcon, runIcon, runningIcon, saveIcon, searchIcon, settingsIcon, shareIcon, spreadsheetIcon, stopIcon, tabIcon, tableRowsIcon, tagIcon, terminalIcon, textEditorIcon, tocIcon, treeViewIcon, trustedIcon, undoIcon, userIcon, usersIcon, vegaIcon, wordIcon, yamlIcon;
var init_iconimports = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/iconimports.js"() {
    init_labicon();
    init_add_above();
    init_add_below();
    init_add();
    init_bell();
    init_bug_dot();
    init_bug();
    init_build();
    init_caret_down_empty();
    init_caret_down_empty_thin();
    init_caret_down();
    init_caret_left();
    init_caret_right();
    init_caret_up_empty_thin();
    init_caret_up();
    init_case_sensitive();
    init_check();
    init_circle_empty();
    init_circle();
    init_clear();
    init_close();
    init_code_check();
    init_code();
    init_collapse_all();
    init_console();
    init_copy();
    init_copyright();
    init_cut();
    init_delete();
    init_download();
    init_duplicate();
    init_edit();
    init_ellipses();
    init_error();
    init_expand_all();
    init_extension();
    init_fast_forward();
    init_file();
    init_file_upload();
    init_filter_dot();
    init_filter_list();
    init_filter();
    init_folder_favorite();
    init_folder();
    init_home();
    init_html5();
    init_image();
    init_info();
    init_inspector();
    init_json();
    init_julia();
    init_jupyter_favicon();
    init_jupyter();
    init_jupyterlab_wordmark();
    init_kernel();
    init_keyboard();
    init_launch();
    init_launcher();
    init_line_form();
    init_link();
    init_list();
    init_markdown();
    init_move_down();
    init_move_up();
    init_new_folder();
    init_not_trusted();
    init_notebook();
    init_numbering();
    init_offline_bolt();
    init_palette();
    init_paste();
    init_pdf();
    init_python();
    init_r_kernel();
    init_react();
    init_redo();
    init_refresh();
    init_regex();
    init_run();
    init_running();
    init_save();
    init_search();
    init_settings();
    init_share();
    init_spreadsheet();
    init_stop();
    init_tab();
    init_table_rows();
    init_tag();
    init_terminal();
    init_text_editor();
    init_toc();
    init_tree_view();
    init_trusted();
    init_undo();
    init_user();
    init_users();
    init_vega();
    init_word();
    init_yaml();
    addAboveIcon = new LabIcon({ name: "ui-components:add-above", svgstr: add_above_default });
    addBelowIcon = new LabIcon({ name: "ui-components:add-below", svgstr: add_below_default });
    addIcon = new LabIcon({ name: "ui-components:add", svgstr: add_default });
    bellIcon = new LabIcon({ name: "ui-components:bell", svgstr: bell_default });
    bugDotIcon = new LabIcon({ name: "ui-components:bug-dot", svgstr: bug_dot_default });
    bugIcon = new LabIcon({ name: "ui-components:bug", svgstr: bug_default });
    buildIcon = new LabIcon({ name: "ui-components:build", svgstr: build_default });
    caretDownEmptyIcon = new LabIcon({ name: "ui-components:caret-down-empty", svgstr: caret_down_empty_default });
    caretDownEmptyThinIcon = new LabIcon({ name: "ui-components:caret-down-empty-thin", svgstr: caret_down_empty_thin_default });
    caretDownIcon = new LabIcon({ name: "ui-components:caret-down", svgstr: caret_down_default });
    caretLeftIcon = new LabIcon({ name: "ui-components:caret-left", svgstr: caret_left_default });
    caretRightIcon = new LabIcon({ name: "ui-components:caret-right", svgstr: caret_right_default });
    caretUpEmptyThinIcon = new LabIcon({ name: "ui-components:caret-up-empty-thin", svgstr: caret_up_empty_thin_default });
    caretUpIcon = new LabIcon({ name: "ui-components:caret-up", svgstr: caret_up_default });
    caseSensitiveIcon = new LabIcon({ name: "ui-components:case-sensitive", svgstr: case_sensitive_default });
    checkIcon = new LabIcon({ name: "ui-components:check", svgstr: check_default });
    circleEmptyIcon = new LabIcon({ name: "ui-components:circle-empty", svgstr: circle_empty_default });
    circleIcon = new LabIcon({ name: "ui-components:circle", svgstr: circle_default });
    clearIcon = new LabIcon({ name: "ui-components:clear", svgstr: clear_default });
    closeIcon = new LabIcon({ name: "ui-components:close", svgstr: close_default });
    codeCheckIcon = new LabIcon({ name: "ui-components:code-check", svgstr: code_check_default });
    codeIcon = new LabIcon({ name: "ui-components:code", svgstr: code_default });
    collapseAllIcon = new LabIcon({ name: "ui-components:collapse-all", svgstr: collapse_all_default });
    consoleIcon = new LabIcon({ name: "ui-components:console", svgstr: console_default });
    copyIcon = new LabIcon({ name: "ui-components:copy", svgstr: copy_default });
    copyrightIcon = new LabIcon({ name: "ui-components:copyright", svgstr: copyright_default });
    cutIcon = new LabIcon({ name: "ui-components:cut", svgstr: cut_default });
    deleteIcon = new LabIcon({ name: "ui-components:delete", svgstr: delete_default });
    downloadIcon = new LabIcon({ name: "ui-components:download", svgstr: download_default });
    duplicateIcon = new LabIcon({ name: "ui-components:duplicate", svgstr: duplicate_default });
    editIcon = new LabIcon({ name: "ui-components:edit", svgstr: edit_default });
    ellipsesIcon = new LabIcon({ name: "ui-components:ellipses", svgstr: ellipses_default });
    errorIcon = new LabIcon({ name: "ui-components:error", svgstr: error_default });
    expandAllIcon = new LabIcon({ name: "ui-components:expand-all", svgstr: expand_all_default });
    extensionIcon = new LabIcon({ name: "ui-components:extension", svgstr: extension_default });
    fastForwardIcon = new LabIcon({ name: "ui-components:fast-forward", svgstr: fast_forward_default });
    fileIcon = new LabIcon({ name: "ui-components:file", svgstr: file_default });
    fileUploadIcon = new LabIcon({ name: "ui-components:file-upload", svgstr: file_upload_default });
    filterDotIcon = new LabIcon({ name: "ui-components:filter-dot", svgstr: filter_dot_default });
    filterIcon = new LabIcon({ name: "ui-components:filter", svgstr: filter_default });
    filterListIcon = new LabIcon({ name: "ui-components:filter-list", svgstr: filter_list_default });
    folderFavoriteIcon = new LabIcon({ name: "ui-components:folder-favorite", svgstr: folder_favorite_default });
    folderIcon = new LabIcon({ name: "ui-components:folder", svgstr: folder_default });
    homeIcon = new LabIcon({ name: "ui-components:home", svgstr: home_default });
    html5Icon = new LabIcon({ name: "ui-components:html5", svgstr: html5_default });
    imageIcon = new LabIcon({ name: "ui-components:image", svgstr: image_default });
    infoIcon = new LabIcon({ name: "ui-components:info", svgstr: info_default });
    inspectorIcon = new LabIcon({ name: "ui-components:inspector", svgstr: inspector_default });
    jsonIcon = new LabIcon({ name: "ui-components:json", svgstr: json_default });
    juliaIcon = new LabIcon({ name: "ui-components:julia", svgstr: julia_default });
    jupyterFaviconIcon = new LabIcon({ name: "ui-components:jupyter-favicon", svgstr: jupyter_favicon_default });
    jupyterIcon = new LabIcon({ name: "ui-components:jupyter", svgstr: jupyter_default });
    jupyterlabWordmarkIcon = new LabIcon({ name: "ui-components:jupyterlab-wordmark", svgstr: jupyterlab_wordmark_default });
    kernelIcon = new LabIcon({ name: "ui-components:kernel", svgstr: kernel_default });
    keyboardIcon = new LabIcon({ name: "ui-components:keyboard", svgstr: keyboard_default });
    launchIcon = new LabIcon({ name: "ui-components:launch", svgstr: launch_default });
    launcherIcon = new LabIcon({ name: "ui-components:launcher", svgstr: launcher_default });
    lineFormIcon = new LabIcon({ name: "ui-components:line-form", svgstr: line_form_default });
    linkIcon = new LabIcon({ name: "ui-components:link", svgstr: link_default });
    listIcon = new LabIcon({ name: "ui-components:list", svgstr: list_default });
    markdownIcon = new LabIcon({ name: "ui-components:markdown", svgstr: markdown_default });
    moveDownIcon = new LabIcon({ name: "ui-components:move-down", svgstr: move_down_default });
    moveUpIcon = new LabIcon({ name: "ui-components:move-up", svgstr: move_up_default });
    newFolderIcon = new LabIcon({ name: "ui-components:new-folder", svgstr: new_folder_default });
    notTrustedIcon = new LabIcon({ name: "ui-components:not-trusted", svgstr: not_trusted_default });
    notebookIcon = new LabIcon({ name: "ui-components:notebook", svgstr: notebook_default });
    numberingIcon = new LabIcon({ name: "ui-components:numbering", svgstr: numbering_default });
    offlineBoltIcon = new LabIcon({ name: "ui-components:offline-bolt", svgstr: offline_bolt_default });
    paletteIcon = new LabIcon({ name: "ui-components:palette", svgstr: palette_default });
    pasteIcon = new LabIcon({ name: "ui-components:paste", svgstr: paste_default });
    pdfIcon = new LabIcon({ name: "ui-components:pdf", svgstr: pdf_default });
    pythonIcon = new LabIcon({ name: "ui-components:python", svgstr: python_default });
    rKernelIcon = new LabIcon({ name: "ui-components:r-kernel", svgstr: r_kernel_default });
    reactIcon = new LabIcon({ name: "ui-components:react", svgstr: react_default });
    redoIcon = new LabIcon({ name: "ui-components:redo", svgstr: redo_default });
    refreshIcon = new LabIcon({ name: "ui-components:refresh", svgstr: refresh_default });
    regexIcon = new LabIcon({ name: "ui-components:regex", svgstr: regex_default });
    runIcon = new LabIcon({ name: "ui-components:run", svgstr: run_default });
    runningIcon = new LabIcon({ name: "ui-components:running", svgstr: running_default });
    saveIcon = new LabIcon({ name: "ui-components:save", svgstr: save_default });
    searchIcon = new LabIcon({ name: "ui-components:search", svgstr: search_default });
    settingsIcon = new LabIcon({ name: "ui-components:settings", svgstr: settings_default });
    shareIcon = new LabIcon({ name: "ui-components:share", svgstr: share_default });
    spreadsheetIcon = new LabIcon({ name: "ui-components:spreadsheet", svgstr: spreadsheet_default });
    stopIcon = new LabIcon({ name: "ui-components:stop", svgstr: stop_default });
    tabIcon = new LabIcon({ name: "ui-components:tab", svgstr: tab_default });
    tableRowsIcon = new LabIcon({ name: "ui-components:table-rows", svgstr: table_rows_default });
    tagIcon = new LabIcon({ name: "ui-components:tag", svgstr: tag_default });
    terminalIcon = new LabIcon({ name: "ui-components:terminal", svgstr: terminal_default });
    textEditorIcon = new LabIcon({ name: "ui-components:text-editor", svgstr: text_editor_default });
    tocIcon = new LabIcon({ name: "ui-components:toc", svgstr: toc_default });
    treeViewIcon = new LabIcon({ name: "ui-components:tree-view", svgstr: tree_view_default });
    trustedIcon = new LabIcon({ name: "ui-components:trusted", svgstr: trusted_default });
    undoIcon = new LabIcon({ name: "ui-components:undo", svgstr: undo_default });
    userIcon = new LabIcon({ name: "ui-components:user", svgstr: user_default });
    usersIcon = new LabIcon({ name: "ui-components:users", svgstr: users_default });
    vegaIcon = new LabIcon({ name: "ui-components:vega", svgstr: vega_default });
    wordIcon = new LabIcon({ name: "ui-components:word", svgstr: word_default });
    yamlIcon = new LabIcon({ name: "ui-components:yaml", svgstr: yaml_default });
  }
});

// ../../node_modules/@lumino/virtualdom/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt2, Private7, StringExt2;
var init_index_es67 = __esm({
  "../../node_modules/@lumino/virtualdom/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt2 || (ArrayExt2 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private7 || (Private7 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt2 || (StringExt2 = {}));
  }
});

// ../../node_modules/@lumino/virtualdom/dist/index.es6.js
function h(tag) {
  let attrs = {};
  let renderer;
  let children = [];
  for (let i2 = 1, n = arguments.length; i2 < n; ++i2) {
    let arg = arguments[i2];
    if (typeof arg === "string") {
      children.push(new VirtualText(arg));
    } else if (arg instanceof VirtualText) {
      children.push(arg);
    } else if (arg instanceof VirtualElement) {
      children.push(arg);
    } else if (arg instanceof Array) {
      extend(children, arg);
    } else if ((i2 === 1 || i2 === 2) && arg && typeof arg === "object") {
      if ("render" in arg) {
        renderer = arg;
      } else {
        attrs = arg;
      }
    }
  }
  return new VirtualElement(tag, attrs, children, renderer);
  function extend(array, values) {
    for (let child of values) {
      if (typeof child === "string") {
        array.push(new VirtualText(child));
      } else if (child instanceof VirtualText) {
        array.push(child);
      } else if (child instanceof VirtualElement) {
        array.push(child);
      }
    }
  }
}
function hpass(tag) {
  let attrs = {};
  let renderer = null;
  if (arguments.length === 2) {
    const arg = arguments[1];
    if ("render" in arg) {
      renderer = arg;
    } else {
      attrs = arg;
    }
  } else if (arguments.length === 3) {
    attrs = arguments[1];
    renderer = arguments[2];
  } else if (arguments.length > 3) {
    throw new Error("hpass() should be called with 1, 2, or 3 arguments");
  }
  return new VirtualElementPass(tag, attrs, renderer);
}
var VirtualText, VirtualElement, VirtualElementPass, VirtualDOM, Private8;
var init_index_es68 = __esm({
  "../../node_modules/@lumino/virtualdom/dist/index.es6.js"() {
    init_index_es67();
    VirtualText = class {
      /**
       * Construct a new virtual text node.
       *
       * @param content - The text content for the node.
       */
      constructor(content) {
        this.type = "text";
        this.content = content;
      }
    };
    VirtualElement = class {
      /**
       * Construct a new virtual element node.
       *
       * @param tag - The element tag name.
       *
       * @param attrs - The element attributes.
       *
       * @param children - The element children.
       *
       * @param renderer - An optional custom renderer for the element.
       */
      constructor(tag, attrs, children, renderer) {
        this.type = "element";
        this.tag = tag;
        this.attrs = attrs;
        this.children = children;
        this.renderer = renderer;
      }
    };
    VirtualElementPass = class extends VirtualElement {
      /**
       * DEPRECATED - use VirtualElement with a defined renderer param instead
       *
       * Construct a new virtual element pass thru node.
       *
       * @param tag - the tag of the parent element of this node. Once the parent
       * element is rendered, it will be passed as an argument to
       * renderer.render
       *
       * @param attrs - attributes that will assigned to the
       * parent element
       *
       * @param renderer - an object with render and unrender
       * functions, each of which should take a single argument of type
       * HTMLElement and return nothing. If null, the parent element
       * will be rendered barren without any children.
       */
      constructor(tag, attrs, renderer) {
        super(tag, attrs, [], renderer || void 0);
      }
    };
    (function(h2) {
      h2.a = h2.bind(void 0, "a");
      h2.abbr = h2.bind(void 0, "abbr");
      h2.address = h2.bind(void 0, "address");
      h2.area = h2.bind(void 0, "area");
      h2.article = h2.bind(void 0, "article");
      h2.aside = h2.bind(void 0, "aside");
      h2.audio = h2.bind(void 0, "audio");
      h2.b = h2.bind(void 0, "b");
      h2.bdi = h2.bind(void 0, "bdi");
      h2.bdo = h2.bind(void 0, "bdo");
      h2.blockquote = h2.bind(void 0, "blockquote");
      h2.br = h2.bind(void 0, "br");
      h2.button = h2.bind(void 0, "button");
      h2.canvas = h2.bind(void 0, "canvas");
      h2.caption = h2.bind(void 0, "caption");
      h2.cite = h2.bind(void 0, "cite");
      h2.code = h2.bind(void 0, "code");
      h2.col = h2.bind(void 0, "col");
      h2.colgroup = h2.bind(void 0, "colgroup");
      h2.data = h2.bind(void 0, "data");
      h2.datalist = h2.bind(void 0, "datalist");
      h2.dd = h2.bind(void 0, "dd");
      h2.del = h2.bind(void 0, "del");
      h2.dfn = h2.bind(void 0, "dfn");
      h2.div = h2.bind(void 0, "div");
      h2.dl = h2.bind(void 0, "dl");
      h2.dt = h2.bind(void 0, "dt");
      h2.em = h2.bind(void 0, "em");
      h2.embed = h2.bind(void 0, "embed");
      h2.fieldset = h2.bind(void 0, "fieldset");
      h2.figcaption = h2.bind(void 0, "figcaption");
      h2.figure = h2.bind(void 0, "figure");
      h2.footer = h2.bind(void 0, "footer");
      h2.form = h2.bind(void 0, "form");
      h2.h1 = h2.bind(void 0, "h1");
      h2.h2 = h2.bind(void 0, "h2");
      h2.h3 = h2.bind(void 0, "h3");
      h2.h4 = h2.bind(void 0, "h4");
      h2.h5 = h2.bind(void 0, "h5");
      h2.h6 = h2.bind(void 0, "h6");
      h2.header = h2.bind(void 0, "header");
      h2.hr = h2.bind(void 0, "hr");
      h2.i = h2.bind(void 0, "i");
      h2.iframe = h2.bind(void 0, "iframe");
      h2.img = h2.bind(void 0, "img");
      h2.input = h2.bind(void 0, "input");
      h2.ins = h2.bind(void 0, "ins");
      h2.kbd = h2.bind(void 0, "kbd");
      h2.label = h2.bind(void 0, "label");
      h2.legend = h2.bind(void 0, "legend");
      h2.li = h2.bind(void 0, "li");
      h2.main = h2.bind(void 0, "main");
      h2.map = h2.bind(void 0, "map");
      h2.mark = h2.bind(void 0, "mark");
      h2.meter = h2.bind(void 0, "meter");
      h2.nav = h2.bind(void 0, "nav");
      h2.noscript = h2.bind(void 0, "noscript");
      h2.object = h2.bind(void 0, "object");
      h2.ol = h2.bind(void 0, "ol");
      h2.optgroup = h2.bind(void 0, "optgroup");
      h2.option = h2.bind(void 0, "option");
      h2.output = h2.bind(void 0, "output");
      h2.p = h2.bind(void 0, "p");
      h2.param = h2.bind(void 0, "param");
      h2.pre = h2.bind(void 0, "pre");
      h2.progress = h2.bind(void 0, "progress");
      h2.q = h2.bind(void 0, "q");
      h2.rp = h2.bind(void 0, "rp");
      h2.rt = h2.bind(void 0, "rt");
      h2.ruby = h2.bind(void 0, "ruby");
      h2.s = h2.bind(void 0, "s");
      h2.samp = h2.bind(void 0, "samp");
      h2.section = h2.bind(void 0, "section");
      h2.select = h2.bind(void 0, "select");
      h2.small = h2.bind(void 0, "small");
      h2.source = h2.bind(void 0, "source");
      h2.span = h2.bind(void 0, "span");
      h2.strong = h2.bind(void 0, "strong");
      h2.sub = h2.bind(void 0, "sub");
      h2.summary = h2.bind(void 0, "summary");
      h2.sup = h2.bind(void 0, "sup");
      h2.table = h2.bind(void 0, "table");
      h2.tbody = h2.bind(void 0, "tbody");
      h2.td = h2.bind(void 0, "td");
      h2.textarea = h2.bind(void 0, "textarea");
      h2.tfoot = h2.bind(void 0, "tfoot");
      h2.th = h2.bind(void 0, "th");
      h2.thead = h2.bind(void 0, "thead");
      h2.time = h2.bind(void 0, "time");
      h2.title = h2.bind(void 0, "title");
      h2.tr = h2.bind(void 0, "tr");
      h2.track = h2.bind(void 0, "track");
      h2.u = h2.bind(void 0, "u");
      h2.ul = h2.bind(void 0, "ul");
      h2.var_ = h2.bind(void 0, "var");
      h2.video = h2.bind(void 0, "video");
      h2.wbr = h2.bind(void 0, "wbr");
    })(h || (h = {}));
    (function(VirtualDOM2) {
      function realize(node) {
        return Private8.createDOMNode(node);
      }
      VirtualDOM2.realize = realize;
      function render(content, host) {
        let oldContent = Private8.hostMap.get(host) || [];
        let newContent = Private8.asContentArray(content);
        Private8.hostMap.set(host, newContent);
        Private8.updateContent(host, oldContent, newContent);
      }
      VirtualDOM2.render = render;
    })(VirtualDOM || (VirtualDOM = {}));
    (function(Private31) {
      Private31.hostMap = /* @__PURE__ */ new WeakMap();
      function asContentArray(value) {
        if (!value) {
          return [];
        }
        if (value instanceof Array) {
          return value;
        }
        return [value];
      }
      Private31.asContentArray = asContentArray;
      function createDOMNode(node) {
        let host = arguments[1] || null;
        const before = arguments[2] || null;
        if (host) {
          host.insertBefore(createDOMNode(node), before);
        } else {
          if (node.type === "text") {
            return document.createTextNode(node.content);
          }
          host = document.createElement(node.tag);
          addAttrs(host, node.attrs);
          if (node.renderer) {
            node.renderer.render(host, {
              attrs: node.attrs,
              children: node.children
            });
            return host;
          }
          for (let i2 = 0, n = node.children.length; i2 < n; ++i2) {
            createDOMNode(node.children[i2], host);
          }
        }
        return host;
      }
      Private31.createDOMNode = createDOMNode;
      function updateContent(host, oldContent, newContent) {
        if (oldContent === newContent) {
          return;
        }
        let oldKeyed = collectKeys(host, oldContent);
        let oldCopy = oldContent.slice();
        let currElem = host.firstChild;
        let newCount = newContent.length;
        for (let i2 = 0; i2 < newCount; ++i2) {
          if (i2 >= oldCopy.length) {
            createDOMNode(newContent[i2], host);
            continue;
          }
          let oldVNode = oldCopy[i2];
          let newVNode = newContent[i2];
          if (oldVNode === newVNode) {
            currElem = currElem.nextSibling;
            continue;
          }
          if (oldVNode.type === "text" && newVNode.type === "text") {
            if (currElem.textContent !== newVNode.content) {
              currElem.textContent = newVNode.content;
            }
            currElem = currElem.nextSibling;
            continue;
          }
          if (oldVNode.type === "text" || newVNode.type === "text") {
            ArrayExt2.insert(oldCopy, i2, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          if (!oldVNode.renderer != !newVNode.renderer) {
            ArrayExt2.insert(oldCopy, i2, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          let newKey = newVNode.attrs.key;
          if (newKey && newKey in oldKeyed) {
            let pair = oldKeyed[newKey];
            if (pair.vNode !== oldVNode) {
              ArrayExt2.move(oldCopy, oldCopy.indexOf(pair.vNode, i2 + 1), i2);
              host.insertBefore(pair.element, currElem);
              oldVNode = pair.vNode;
              currElem = pair.element;
            }
          }
          if (oldVNode === newVNode) {
            currElem = currElem.nextSibling;
            continue;
          }
          let oldKey = oldVNode.attrs.key;
          if (oldKey && oldKey !== newKey) {
            ArrayExt2.insert(oldCopy, i2, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          if (oldVNode.tag !== newVNode.tag) {
            ArrayExt2.insert(oldCopy, i2, newVNode);
            createDOMNode(newVNode, host, currElem);
            continue;
          }
          updateAttrs(currElem, oldVNode.attrs, newVNode.attrs);
          if (newVNode.renderer) {
            newVNode.renderer.render(currElem, {
              attrs: newVNode.attrs,
              children: newVNode.children
            });
          } else {
            updateContent(currElem, oldVNode.children, newVNode.children);
          }
          currElem = currElem.nextSibling;
        }
        removeContent(host, oldCopy, newCount, true);
      }
      Private31.updateContent = updateContent;
      function removeContent(host, oldContent, newCount, _sentinel) {
        for (let i2 = oldContent.length - 1; i2 >= newCount; --i2) {
          const oldNode = oldContent[i2];
          const child = _sentinel ? host.lastChild : host.childNodes[i2];
          if (oldNode.type === "text")
            ;
          else if (oldNode.renderer && oldNode.renderer.unrender) {
            oldNode.renderer.unrender(child, {
              attrs: oldNode.attrs,
              children: oldNode.children
            });
          } else {
            removeContent(child, oldNode.children, 0, false);
          }
          if (_sentinel) {
            host.removeChild(child);
          }
        }
      }
      const specialAttrs = {
        key: true,
        className: true,
        htmlFor: true,
        dataset: true,
        style: true
      };
      function addAttrs(element, attrs) {
        for (let name2 in attrs) {
          if (name2 in specialAttrs) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = attrs[name2];
          } else {
            element.setAttribute(name2, attrs[name2]);
          }
        }
        if (attrs.className !== void 0) {
          element.setAttribute("class", attrs.className);
        }
        if (attrs.htmlFor !== void 0) {
          element.setAttribute("for", attrs.htmlFor);
        }
        if (attrs.dataset) {
          addDataset(element, attrs.dataset);
        }
        if (attrs.style) {
          addStyle(element, attrs.style);
        }
      }
      function updateAttrs(element, oldAttrs, newAttrs) {
        if (oldAttrs === newAttrs) {
          return;
        }
        let name2;
        for (name2 in oldAttrs) {
          if (name2 in specialAttrs || name2 in newAttrs) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = null;
          } else {
            element.removeAttribute(name2);
          }
        }
        for (name2 in newAttrs) {
          if (name2 in specialAttrs || oldAttrs[name2] === newAttrs[name2]) {
            continue;
          }
          if (name2.substr(0, 2) === "on") {
            element[name2] = newAttrs[name2];
          } else {
            element.setAttribute(name2, newAttrs[name2]);
          }
        }
        if (oldAttrs.className !== newAttrs.className) {
          if (newAttrs.className !== void 0) {
            element.setAttribute("class", newAttrs.className);
          } else {
            element.removeAttribute("class");
          }
        }
        if (oldAttrs.htmlFor !== newAttrs.htmlFor) {
          if (newAttrs.htmlFor !== void 0) {
            element.setAttribute("for", newAttrs.htmlFor);
          } else {
            element.removeAttribute("for");
          }
        }
        if (oldAttrs.dataset !== newAttrs.dataset) {
          updateDataset(element, oldAttrs.dataset || {}, newAttrs.dataset || {});
        }
        if (oldAttrs.style !== newAttrs.style) {
          updateStyle(element, oldAttrs.style || {}, newAttrs.style || {});
        }
      }
      function addDataset(element, dataset) {
        for (let name2 in dataset) {
          element.setAttribute(`data-${name2}`, dataset[name2]);
        }
      }
      function updateDataset(element, oldDataset, newDataset) {
        for (let name2 in oldDataset) {
          if (!(name2 in newDataset)) {
            element.removeAttribute(`data-${name2}`);
          }
        }
        for (let name2 in newDataset) {
          if (oldDataset[name2] !== newDataset[name2]) {
            element.setAttribute(`data-${name2}`, newDataset[name2]);
          }
        }
      }
      function addStyle(element, style) {
        let elemStyle = element.style;
        let name2;
        for (name2 in style) {
          elemStyle[name2] = style[name2];
        }
      }
      function updateStyle(element, oldStyle, newStyle) {
        let elemStyle = element.style;
        let name2;
        for (name2 in oldStyle) {
          if (!(name2 in newStyle)) {
            elemStyle[name2] = "";
          }
        }
        for (name2 in newStyle) {
          if (oldStyle[name2] !== newStyle[name2]) {
            elemStyle[name2] = newStyle[name2];
          }
        }
      }
      function collectKeys(host, content) {
        let node = host.firstChild;
        let keyMap = /* @__PURE__ */ Object.create(null);
        for (let vNode of content) {
          if (vNode.type === "element" && vNode.attrs.key) {
            keyMap[vNode.attrs.key] = { vNode, element: node };
          }
          node = node.nextSibling;
        }
        return keyMap;
      }
    })(Private8 || (Private8 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/algorithm/dist/index.es6.js
function* empty() {
  return;
}
function find2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function max(object, fn) {
  let result = void 0;
  for (const value of object) {
    if (result === void 0) {
      result = value;
      continue;
    }
    if (fn(value, result) > 0) {
      result = value;
    }
  }
  return result;
}
function every(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* retro(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt3, Private9, StringExt3;
var init_index_es69 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt3 || (ArrayExt3 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private9 || (Private9 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt3 || (StringExt3 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt, ElementExt, Platform, Selector2, Private10;
var init_index_es610 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt3) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt3.copyText = copyText;
    })(ClipboardExt || (ClipboardExt = {}));
    (function(ElementExt3) {
      function boxSizing(element) {
        let style = window.getComputedStyle(element);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt2 = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt2 + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt2,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt3.boxSizing = boxSizing;
      function sizeLimits(element) {
        let style = window.getComputedStyle(element);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt3.sizeLimits = sizeLimits;
      function hitTest(element, clientX, clientY) {
        let rect = element.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt3.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element) {
        let ar = area.getBoundingClientRect();
        let er = element.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt3.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt || (ElementExt = {}));
    (function(Platform3) {
      Platform3.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform3.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform3.IS_IE = /Trident/.test(navigator.userAgent);
      Platform3.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform3.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform3.accelKey = accelKey;
    })(Platform || (Platform = {}));
    (function(Selector4) {
      function calculateSpecificity(selector) {
        if (selector in Private10.specificityCache) {
          return Private10.specificityCache[selector];
        }
        let result = Private10.calculateSingle(selector);
        return Private10.specificityCache[selector] = result;
      }
      Selector4.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private10.validityCache) {
          return Private10.validityCache[selector];
        }
        let result = true;
        try {
          Private10.testElem.querySelector(selector);
        } catch (err) {
          result = false;
        }
        return Private10.validityCache[selector] = result;
      }
      Selector4.isValid = isValid;
      function matches(element, selector) {
        return Private10.protoMatchFunc.call(element, selector);
      }
      Selector4.matches = matches;
    })(Selector2 || (Selector2 = {}));
    (function(Private31) {
      Private31.specificityCache = /* @__PURE__ */ Object.create(null);
      Private31.validityCache = /* @__PURE__ */ Object.create(null);
      Private31.testElem = document.createElement("div");
      Private31.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a = 0;
        let b = 0;
        let c = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a++;
            continue;
          }
          if (match(CLASS_RE)) {
            b++;
            continue;
          }
          if (match(ATTR_RE)) {
            b++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b++;
            continue;
          }
          if (match(TYPE_RE)) {
            c++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a = Math.min(a, 255);
        b = Math.min(b, 255);
        c = Math.min(c, 255);
        return a << 16 | b << 8 | c;
      }
      Private31.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private10 || (Private10 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList, Private11;
var init_index_es611 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private11.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private11.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private11.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private11.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private11.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private11.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private11.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from;
    })(LinkedList || (LinkedList = {}));
    (function(Private31) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private31.LinkedListNode = LinkedListNode;
    })(Private11 || (Private11 = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/messaging/dist/index.es6.js
var Message, ConflatableMessage, MessageLoop;
var init_index_es612 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es69();
    init_index_es611();
    Message = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage = class extends Message {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i2 = hooks.indexOf(hook);
        if (i2 === -1) {
          return;
        }
        hooks[i2] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt3.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt3.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop || (MessageLoop = {}));
  }
});

// ../../node_modules/@lumino/widgets/node_modules/@lumino/properties/dist/index.es6.js
var AttachedProperty3, Private12;
var init_index_es613 = __esm({
  "../../node_modules/@lumino/widgets/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty3 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private12.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private12.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private12.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private12.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private12.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty3 || (AttachedProperty3 = {}));
    (function(Private31) {
      Private31.ownerData = /* @__PURE__ */ new WeakMap();
      Private31.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private31.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private31.ownerData.set(owner, map2);
        return map2;
      }
      Private31.ensureMap = ensureMap;
    })(Private12 || (Private12 = {}));
  }
});

// ../../node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag, Private13;
var init_index_es614 = __esm({
  "../../node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es65();
    Drag = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element, edge, distance } = this._scrollTarget;
          let d2 = Private13.SCROLL_EDGE_SIZE - distance;
          let f = Math.pow(d2 / Private13.SCROLL_EDGE_SIZE, 2);
          let s = Math.max(1, Math.round(f * Private13.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element.scrollTop -= s;
              break;
            case "left":
              element.scrollLeft -= s;
              break;
            case "right":
              element.scrollLeft += s;
              break;
            case "bottom":
              element.scrollTop += s;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private13.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private13.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private13.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target = Private13.findScrollTarget(event);
        if (!this._scrollTarget && !target) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private13.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private13.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private13.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private13.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private13.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private13.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag2) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag2.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private13.overrideCursor(cursor, doc);
      }
      Drag2.overrideCursor = overrideCursor;
    })(Drag || (Drag = {}));
    (function(Private31) {
      Private31.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private31.validateAction = validateAction;
      function findElementBehindBackdrop(event, root = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private31.cursorBackdrop.style.zIndex = "-1000";
          const element = root.elementFromPoint(event.clientX, event.clientY);
          Private31.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element };
          return element;
        } else {
          const transform2 = Private31.cursorBackdrop.style.transform;
          if (lastElementSearch && transform2 === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private31.cursorBackdrop.getBoundingClientRect();
          Private31.cursorBackdrop.style.zIndex = "-1000";
          const element = root.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private31.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform: transform2, element };
          return element;
        }
      }
      Private31.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x = event.clientX;
        let y = event.clientY;
        let element = findElementBehindBackdrop(event);
        for (; element; element = element.parentElement) {
          if (!element.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r2 = element.getBoundingClientRect();
          let top = r2.top + offsetY;
          let left = r2.left + offsetX;
          let right = left + r2.width;
          let bottom = top + r2.height;
          if (x < left || x >= right || y < top || y >= bottom) {
            continue;
          }
          let dl = x - left + 1;
          let dt2 = y - top + 1;
          let dr = right - x;
          let db = bottom - y;
          let distance = Math.min(dl, dt2, dr, db);
          if (distance > Private31.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt2:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element.scrollWidth - element.clientWidth;
          let dsh = element.scrollHeight - element.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element, edge, distance };
        }
        return null;
      }
      Private31.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private31.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private31.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private31.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private31.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private31.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private31.cursorBackdrop.isConnected) {
          Private31.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private31.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private31.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private31.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private31.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private31.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private31.cursorBackdrop);
          }
        });
      }
      Private31.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private31.cursorBackdrop) {
          return;
        }
        Private31.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private31.cursorBackdrop) {
          return;
        }
        let element = findElementBehindBackdrop();
        if (!element) {
          return;
        }
        const scrollTarget = element.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private31.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private31.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private31.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private31.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private31.cursorBackdrop = createCursorBackdrop();
    })(Private13 || (Private13 = {}));
  }
});

// ../../node_modules/@lumino/commands/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt4, Private14, StringExt4;
var init_index_es615 = __esm({
  "../../node_modules/@lumino/commands/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt4 || (ArrayExt4 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private14 || (Private14 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt4 || (StringExt4 = {}));
  }
});

// ../../node_modules/@lumino/commands/node_modules/@lumino/domutils/dist/index.es6.js
var ClipboardExt2, ElementExt2, Platform2, Selector3, Private15;
var init_index_es616 = __esm({
  "../../node_modules/@lumino/commands/node_modules/@lumino/domutils/dist/index.es6.js"() {
    (function(ClipboardExt3) {
      function copyText(text) {
        const body = document.body;
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          event.clipboardData.setData("text", text);
          body.removeEventListener("copy", handler, true);
        };
        body.addEventListener("copy", handler, true);
        document.execCommand("copy");
      }
      ClipboardExt3.copyText = copyText;
    })(ClipboardExt2 || (ClipboardExt2 = {}));
    (function(ElementExt3) {
      function boxSizing(element) {
        let style = window.getComputedStyle(element);
        let bt = parseFloat(style.borderTopWidth) || 0;
        let bl = parseFloat(style.borderLeftWidth) || 0;
        let br = parseFloat(style.borderRightWidth) || 0;
        let bb = parseFloat(style.borderBottomWidth) || 0;
        let pt2 = parseFloat(style.paddingTop) || 0;
        let pl = parseFloat(style.paddingLeft) || 0;
        let pr = parseFloat(style.paddingRight) || 0;
        let pb = parseFloat(style.paddingBottom) || 0;
        let hs = bl + pl + pr + br;
        let vs = bt + pt2 + pb + bb;
        return {
          borderTop: bt,
          borderLeft: bl,
          borderRight: br,
          borderBottom: bb,
          paddingTop: pt2,
          paddingLeft: pl,
          paddingRight: pr,
          paddingBottom: pb,
          horizontalSum: hs,
          verticalSum: vs
        };
      }
      ElementExt3.boxSizing = boxSizing;
      function sizeLimits(element) {
        let style = window.getComputedStyle(element);
        let minWidth = parseFloat(style.minWidth) || 0;
        let minHeight = parseFloat(style.minHeight) || 0;
        let maxWidth = parseFloat(style.maxWidth) || Infinity;
        let maxHeight = parseFloat(style.maxHeight) || Infinity;
        maxWidth = Math.max(minWidth, maxWidth);
        maxHeight = Math.max(minHeight, maxHeight);
        return { minWidth, minHeight, maxWidth, maxHeight };
      }
      ElementExt3.sizeLimits = sizeLimits;
      function hitTest(element, clientX, clientY) {
        let rect = element.getBoundingClientRect();
        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
      }
      ElementExt3.hitTest = hitTest;
      function scrollIntoViewIfNeeded(area, element) {
        let ar = area.getBoundingClientRect();
        let er = element.getBoundingClientRect();
        if (er.top <= ar.top && er.bottom >= ar.bottom) {
          return;
        }
        if (er.top < ar.top && er.height <= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.bottom > ar.bottom && er.height >= ar.height) {
          area.scrollTop -= ar.top - er.top;
          return;
        }
        if (er.top < ar.top && er.height > ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
        if (er.bottom > ar.bottom && er.height < ar.height) {
          area.scrollTop -= ar.bottom - er.bottom;
          return;
        }
      }
      ElementExt3.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
    })(ElementExt2 || (ElementExt2 = {}));
    (function(Platform3) {
      Platform3.IS_MAC = !!navigator.platform.match(/Mac/i);
      Platform3.IS_WIN = !!navigator.platform.match(/Win/i);
      Platform3.IS_IE = /Trident/.test(navigator.userAgent);
      Platform3.IS_EDGE = /Edge/.test(navigator.userAgent);
      function accelKey(event) {
        return Platform3.IS_MAC ? event.metaKey : event.ctrlKey;
      }
      Platform3.accelKey = accelKey;
    })(Platform2 || (Platform2 = {}));
    (function(Selector4) {
      function calculateSpecificity(selector) {
        if (selector in Private15.specificityCache) {
          return Private15.specificityCache[selector];
        }
        let result = Private15.calculateSingle(selector);
        return Private15.specificityCache[selector] = result;
      }
      Selector4.calculateSpecificity = calculateSpecificity;
      function isValid(selector) {
        if (selector in Private15.validityCache) {
          return Private15.validityCache[selector];
        }
        let result = true;
        try {
          Private15.testElem.querySelector(selector);
        } catch (err) {
          result = false;
        }
        return Private15.validityCache[selector] = result;
      }
      Selector4.isValid = isValid;
      function matches(element, selector) {
        return Private15.protoMatchFunc.call(element, selector);
      }
      Selector4.matches = matches;
    })(Selector3 || (Selector3 = {}));
    (function(Private31) {
      Private31.specificityCache = /* @__PURE__ */ Object.create(null);
      Private31.validityCache = /* @__PURE__ */ Object.create(null);
      Private31.testElem = document.createElement("div");
      Private31.protoMatchFunc = (() => {
        let proto = Element.prototype;
        return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
          let elem = this;
          let matches = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
          return Array.prototype.indexOf.call(matches, elem) !== -1;
        };
      })();
      function calculateSingle(selector) {
        selector = selector.split(",", 1)[0];
        let a = 0;
        let b = 0;
        let c = 0;
        function match(re) {
          let match2 = selector.match(re);
          if (match2 === null) {
            return false;
          }
          selector = selector.slice(match2[0].length);
          return true;
        }
        selector = selector.replace(NEGATION_RE, " $1 ");
        while (selector.length > 0) {
          if (match(ID_RE)) {
            a++;
            continue;
          }
          if (match(CLASS_RE)) {
            b++;
            continue;
          }
          if (match(ATTR_RE)) {
            b++;
            continue;
          }
          if (match(PSEUDO_ELEM_RE)) {
            c++;
            continue;
          }
          if (match(PSEDUO_CLASS_RE)) {
            b++;
            continue;
          }
          if (match(TYPE_RE)) {
            c++;
            continue;
          }
          if (match(IGNORE_RE)) {
            continue;
          }
          return 0;
        }
        a = Math.min(a, 255);
        b = Math.min(b, 255);
        c = Math.min(c, 255);
        return a << 16 | b << 8 | c;
      }
      Private31.calculateSingle = calculateSingle;
      const ID_RE = /^#[^\s\+>~#\.\[:]+/;
      const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
      const ATTR_RE = /^\[[^\]]+\]/;
      const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
      const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
      const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
      const IGNORE_RE = /^[\s\+>~\*]+/;
      const NEGATION_RE = /:not\(([^\)]+)\)/g;
    })(Private15 || (Private15 = {}));
  }
});

// ../../node_modules/@lumino/keyboard/dist/index.es6.js
function getKeyboardLayout() {
  return Private16.keyboardLayout;
}
var KeycodeLayout, EN_US, Private16;
var init_index_es617 = __esm({
  "../../node_modules/@lumino/keyboard/dist/index.es6.js"() {
    KeycodeLayout = class {
      /**
       * Construct a new keycode layout.
       *
       * @param name - The human readable name for the layout.
       *
       * @param codes - A mapping of keycode to key value.
       *
       * @param modifierKeys - Array of modifier key names
       */
      constructor(name2, codes, modifierKeys = []) {
        this.name = name2;
        this._codes = codes;
        this._keys = KeycodeLayout.extractKeys(codes);
        this._modifierKeys = KeycodeLayout.convertToKeySet(modifierKeys);
      }
      /**
       * Get an array of the key values supported by the layout.
       *
       * @returns A new array of the supported key values.
       */
      keys() {
        return Object.keys(this._keys);
      }
      /**
       * Test whether the given key is a valid value for the layout.
       *
       * @param key - The user provided key to test for validity.
       *
       * @returns `true` if the key is valid, `false` otherwise.
       */
      isValidKey(key2) {
        return key2 in this._keys;
      }
      /**
       * Test whether the given key is a modifier key.
       *
       * @param key - The user provided key.
       *
       * @returns `true` if the key is a modifier key, `false` otherwise.
       */
      isModifierKey(key2) {
        return key2 in this._modifierKeys;
      }
      /**
       * Get the key for a `'keydown'` event.
       *
       * @param event - The event object for a `'keydown'` event.
       *
       * @returns The associated key value, or an empty string if
       *   the event does not represent a valid primary key.
       */
      keyForKeydownEvent(event) {
        return this._codes[event.keyCode] || "";
      }
    };
    (function(KeycodeLayout2) {
      function extractKeys(codes) {
        let keys = /* @__PURE__ */ Object.create(null);
        for (let c in codes) {
          keys[codes[c]] = true;
        }
        return keys;
      }
      KeycodeLayout2.extractKeys = extractKeys;
      function convertToKeySet(keys) {
        let keySet = Object(null);
        for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
          keySet[keys[i2]] = true;
        }
        return keySet;
      }
      KeycodeLayout2.convertToKeySet = convertToKeySet;
    })(KeycodeLayout || (KeycodeLayout = {}));
    EN_US = new KeycodeLayout(
      "en-us",
      {
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        27: "Escape",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        48: "0",
        49: "1",
        50: "2",
        51: "3",
        52: "4",
        53: "5",
        54: "6",
        55: "7",
        56: "8",
        57: "9",
        59: ";",
        61: "=",
        65: "A",
        66: "B",
        67: "C",
        68: "D",
        69: "E",
        70: "F",
        71: "G",
        72: "H",
        73: "I",
        74: "J",
        75: "K",
        76: "L",
        77: "M",
        78: "N",
        79: "O",
        80: "P",
        81: "Q",
        82: "R",
        83: "S",
        84: "T",
        85: "U",
        86: "V",
        87: "W",
        88: "X",
        89: "Y",
        90: "Z",
        91: "Meta",
        93: "ContextMenu",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Meta"
        // firefox
      },
      ["Shift", "Ctrl", "Alt", "Meta"]
      // modifier keys
    );
    (function(Private31) {
      Private31.keyboardLayout = EN_US;
    })(Private16 || (Private16 = {}));
  }
});

// ../../node_modules/@lumino/commands/dist/index.es6.js
var import_coreutils6, CommandRegistry, Private17;
var init_index_es618 = __esm({
  "../../node_modules/@lumino/commands/dist/index.es6.js"() {
    init_index_es615();
    import_coreutils6 = __toESM(require_dist());
    init_index_es65();
    init_index_es616();
    init_index_es617();
    init_index_es63();
    CommandRegistry = class {
      constructor() {
        this._timerID = 0;
        this._replaying = false;
        this._keystrokes = [];
        this._keydownEvents = [];
        this._keyBindings = [];
        this._exactKeyMatch = null;
        this._commands = /* @__PURE__ */ new Map();
        this._commandChanged = new Signal(this);
        this._commandExecuted = new Signal(this);
        this._keyBindingChanged = new Signal(this);
        this._holdKeyBindingPromises = /* @__PURE__ */ new Map();
      }
      /**
       * A signal emitted when a command has changed.
       *
       * #### Notes
       * This signal is useful for visual representations of commands which
       * need to refresh when the state of a relevant command has changed.
       */
      get commandChanged() {
        return this._commandChanged;
      }
      /**
       * A signal emitted when a command has executed.
       *
       * #### Notes
       * Care should be taken when consuming this signal. The command system is used
       * by many components for many user actions. Handlers registered with this
       * signal must return quickly to ensure the overall application remains responsive.
       */
      get commandExecuted() {
        return this._commandExecuted;
      }
      /**
       * A signal emitted when a key binding is changed.
       */
      get keyBindingChanged() {
        return this._keyBindingChanged;
      }
      /**
       * A read-only array of the key bindings in the registry.
       */
      get keyBindings() {
        return this._keyBindings;
      }
      /**
       * List the ids of the registered commands.
       *
       * @returns A new array of the registered command ids.
       */
      listCommands() {
        return Array.from(this._commands.keys());
      }
      /**
       * Test whether a specific command is registered.
       *
       * @param id - The id of the command of interest.
       *
       * @returns `true` if the command is registered, `false` otherwise.
       */
      hasCommand(id) {
        return this._commands.has(id);
      }
      /**
       * Add a command to the registry.
       *
       * @param id - The unique id of the command.
       *
       * @param options - The options for the command.
       *
       * @returns A disposable which will remove the command.
       *
       * @throws An error if the given `id` is already registered.
       */
      addCommand(id, options) {
        if (this._commands.has(id)) {
          throw new Error(`Command '${id}' already registered.`);
        }
        this._commands.set(id, Private17.createCommand(options));
        this._commandChanged.emit({ id, type: "added" });
        return new DisposableDelegate(() => {
          this._commands.delete(id);
          this._commandChanged.emit({ id, type: "removed" });
        });
      }
      /**
       * Notify listeners that the state of a command has changed.
       *
       * @param id - The id of the command which has changed. If more than
       *   one command has changed, this argument should be omitted.
       *
       * @throws An error if the given `id` is not registered.
       *
       * #### Notes
       * This method should be called by the command author whenever the
       * application state changes such that the results of the command
       * metadata functions may have changed.
       *
       * This will cause the `commandChanged` signal to be emitted.
       */
      notifyCommandChanged(id) {
        if (id !== void 0 && !this._commands.has(id)) {
          throw new Error(`Command '${id}' is not registered.`);
        }
        this._commandChanged.emit({ id, type: id ? "changed" : "many-changed" });
      }
      /**
       * Get the description for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The description for the command.
       */
      describedBy(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        let cmd = this._commands.get(id);
        return Promise.resolve((_a = cmd === null || cmd === void 0 ? void 0 : cmd.describedBy.call(void 0, args)) !== null && _a !== void 0 ? _a : { args: null });
      }
      /**
       * Get the display label for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The display label for the command, or an empty string
       *   if the command is not registered.
       */
      label(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        let cmd = this._commands.get(id);
        return (_a = cmd === null || cmd === void 0 ? void 0 : cmd.label.call(void 0, args)) !== null && _a !== void 0 ? _a : "";
      }
      /**
       * Get the mnemonic index for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The mnemonic index for the command, or `-1` if the
       *   command is not registered.
       */
      mnemonic(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.mnemonic.call(void 0, args) : -1;
      }
      /**
       * Get the icon renderer for a specific command.
       *
       * DEPRECATED: if set to a string value, the .icon field will
       * function as an alias for the .iconClass field, for backwards
       * compatibility. In the future when this is removed, the default
       * return type will become undefined.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon renderer for the command or `undefined`.
       */
      icon(id, args = import_coreutils6.JSONExt.emptyObject) {
        var _a;
        return (_a = this._commands.get(id)) === null || _a === void 0 ? void 0 : _a.icon.call(void 0, args);
      }
      /**
       * Get the icon class for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon class for the command, or an empty string if
       *   the command is not registered.
       */
      iconClass(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.iconClass.call(void 0, args) : "";
      }
      /**
       * Get the icon label for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The icon label for the command, or an empty string if
       *   the command is not registered.
       */
      iconLabel(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.iconLabel.call(void 0, args) : "";
      }
      /**
       * Get the short form caption for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The caption for the command, or an empty string if the
       *   command is not registered.
       */
      caption(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.caption.call(void 0, args) : "";
      }
      /**
       * Get the usage help text for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The usage text for the command, or an empty string if
       *   the command is not registered.
       */
      usage(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.usage.call(void 0, args) : "";
      }
      /**
       * Get the extra class name for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The class name for the command, or an empty string if
       *   the command is not registered.
       */
      className(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.className.call(void 0, args) : "";
      }
      /**
       * Get the dataset for a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns The dataset for the command, or an empty dataset if
       *   the command is not registered.
       */
      dataset(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.dataset.call(void 0, args) : {};
      }
      /**
       * Test whether a specific command is enabled.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is enabled,
       *   or `false` if the command is not registered.
       */
      isEnabled(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isEnabled.call(void 0, args) : false;
      }
      /**
       * Test whether a specific command is toggled.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is toggled,
       *   or `false` if the command is not registered.
       */
      isToggled(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isToggled.call(void 0, args) : false;
      }
      /**
       * Test whether a specific command is toggleable.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is toggleable,
       *   or `false` if the command is not registered.
       */
      isToggleable(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isToggleable : false;
      }
      /**
       * Test whether a specific command is visible.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A boolean indicating whether the command is visible,
       *   or `false` if the command is not registered.
       */
      isVisible(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        return cmd ? cmd.isVisible.call(void 0, args) : false;
      }
      /**
       * Execute a specific command.
       *
       * @param id - The id of the command of interest.
       *
       * @param args - The arguments for the command.
       *
       * @returns A promise which resolves with the result of the command.
       *
       * #### Notes
       * The promise will reject if the command throws an exception,
       * or if the command is not registered.
       */
      execute(id, args = import_coreutils6.JSONExt.emptyObject) {
        let cmd = this._commands.get(id);
        if (!cmd) {
          return Promise.reject(new Error(`Command '${id}' not registered.`));
        }
        let value;
        try {
          value = cmd.execute.call(void 0, args);
        } catch (err) {
          value = Promise.reject(err);
        }
        let result = Promise.resolve(value);
        this._commandExecuted.emit({ id, args, result });
        return result;
      }
      /**
       * Add a key binding to the registry.
       *
       * @param options - The options for creating the key binding.
       *
       * @returns A disposable which removes the added key binding.
       *
       * #### Notes
       * If multiple key bindings are registered for the same sequence, the
       * binding with the highest selector specificity is executed first. A
       * tie is broken by using the most recently added key binding.
       *
       * Ambiguous key bindings are resolved with a timeout. As an example,
       * suppose two key bindings are registered: one with the key sequence
       * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
       * presses `Ctrl D`, the first binding cannot be immediately executed
       * since the user may intend to complete the chord with `Ctrl W`. For
       * such cases, a timer is used to allow the chord to be completed. If
       * the chord is not completed before the timeout, the first binding
       * is executed.
       */
      addKeyBinding(options) {
        let binding = Private17.createKeyBinding(options);
        this._keyBindings.push(binding);
        this._keyBindingChanged.emit({ binding, type: "added" });
        return new DisposableDelegate(() => {
          ArrayExt4.removeFirstOf(this._keyBindings, binding);
          this._keyBindingChanged.emit({ binding, type: "removed" });
        });
      }
      /**
       * Process a `'keydown'` event and invoke a matching key binding.
       *
       * @param event - The event object for a `'keydown'` event.
       *
       * #### Notes
       * This should be called in response to a `'keydown'` event in order
       * to invoke the command for the best matching key binding.
       *
       * The registry **does not** install its own listener for `'keydown'`
       * events. This allows the application full control over the nodes
       * and phase for which the registry processes `'keydown'` events.
       *
       * When the keydown event is processed, if the event target or any of its
       * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown
       * events will not invoke commands.
       */
      processKeydownEvent(event) {
        if (event.defaultPrevented || this._replaying || CommandRegistry.isModifierKeyPressed(event)) {
          return;
        }
        const keystroke = CommandRegistry.keystrokeForKeydownEvent(event);
        if (!keystroke) {
          this._replayKeydownEvents();
          this._clearPendingState();
          return;
        }
        this._keystrokes.push(keystroke);
        const { exact, partial } = Private17.matchKeyBinding(this._keyBindings, this._keystrokes, event);
        const hasPartial = partial.length !== 0;
        if (!exact && !hasPartial) {
          this._replayKeydownEvents();
          this._clearPendingState();
          return;
        }
        if ((exact === null || exact === void 0 ? void 0 : exact.preventDefault) || partial.some((match) => match.preventDefault)) {
          event.preventDefault();
          event.stopPropagation();
        }
        this._keydownEvents.push(event);
        if (exact && !hasPartial) {
          this._executeKeyBinding(exact);
          this._clearPendingState();
          return;
        }
        if (exact) {
          this._exactKeyMatch = exact;
        }
        this._startTimer();
      }
      /**
       * Delay the execution of any command matched against the given 'keydown' event
       * until the `permission` to execute is granted.
       *
       * @param event - The event object for a `'keydown'` event.
       * @param permission - The promise with value indicating whether to proceed with the execution.
       *
       * ### Note
       * This enables the caller of `processKeydownEvent` to asynchronously prevent the
       * execution of the command based on external events.
       */
      holdKeyBindingExecution(event, permission) {
        this._holdKeyBindingPromises.set(event, permission);
      }
      /**
       * Start or restart the pending timeout.
       */
      _startTimer() {
        this._clearTimer();
        this._timerID = window.setTimeout(() => {
          this._onPendingTimeout();
        }, Private17.CHORD_TIMEOUT);
      }
      /**
       * Clear the pending timeout.
       */
      _clearTimer() {
        if (this._timerID !== 0) {
          clearTimeout(this._timerID);
          this._timerID = 0;
        }
      }
      /**
       * Replay the keydown events which were suppressed.
       */
      _replayKeydownEvents() {
        if (this._keydownEvents.length === 0) {
          return;
        }
        this._replaying = true;
        this._keydownEvents.forEach(Private17.replayKeyEvent);
        this._replaying = false;
      }
      /**
       * Execute the command for the given key binding.
       *
       * If the command is missing or disabled, a warning will be logged.
       *
       * The execution will not proceed if any of the events leading to
       * the keybinding matching were held with the permission resolving to false.
       */
      async _executeKeyBinding(binding) {
        if (this._holdKeyBindingPromises.size !== 0) {
          const keydownEvents = [...this._keydownEvents];
          const executionAllowed = (await Promise.race([
            Promise.all(keydownEvents.map(async (event) => {
              var _a;
              return (_a = this._holdKeyBindingPromises.get(event)) !== null && _a !== void 0 ? _a : Promise.resolve(true);
            })),
            new Promise((resolve) => {
              setTimeout(() => resolve([false]), Private17.KEYBINDING_HOLD_TIMEOUT);
            })
          ])).every(Boolean);
          this._holdKeyBindingPromises.clear();
          if (!executionAllowed) {
            return;
          }
        }
        let { command, args } = binding;
        let newArgs = {
          _luminoEvent: { type: "keybinding", keys: binding.keys },
          ...args
        };
        if (!this.hasCommand(command) || !this.isEnabled(command, newArgs)) {
          let word = this.hasCommand(command) ? "enabled" : "registered";
          let keys = binding.keys.join(", ");
          let msg1 = `Cannot execute key binding '${keys}':`;
          let msg2 = `command '${command}' is not ${word}.`;
          console.warn(`${msg1} ${msg2}`);
          return;
        }
        await this.execute(command, newArgs);
      }
      /**
       * Clear the internal pending state.
       */
      _clearPendingState() {
        this._clearTimer();
        this._exactKeyMatch = null;
        this._keystrokes.length = 0;
        this._keydownEvents.length = 0;
      }
      /**
       * Handle the partial match timeout.
       */
      _onPendingTimeout() {
        this._timerID = 0;
        if (this._exactKeyMatch) {
          this._executeKeyBinding(this._exactKeyMatch);
        } else {
          this._replayKeydownEvents();
        }
        this._clearPendingState();
      }
    };
    (function(CommandRegistry2) {
      function parseKeystroke(keystroke) {
        let key2 = "";
        let alt = false;
        let cmd = false;
        let ctrl = false;
        let shift = false;
        for (let token of keystroke.split(/\s+/)) {
          if (token === "Accel") {
            if (Platform2.IS_MAC) {
              cmd = true;
            } else {
              ctrl = true;
            }
          } else if (token === "Alt") {
            alt = true;
          } else if (token === "Cmd") {
            cmd = true;
          } else if (token === "Ctrl") {
            ctrl = true;
          } else if (token === "Shift") {
            shift = true;
          } else if (token.length > 0) {
            key2 = token;
          }
        }
        return { cmd, ctrl, alt, shift, key: key2 };
      }
      CommandRegistry2.parseKeystroke = parseKeystroke;
      function normalizeKeystroke(keystroke) {
        let mods = "";
        let parts = parseKeystroke(keystroke);
        if (parts.ctrl) {
          mods += "Ctrl ";
        }
        if (parts.alt) {
          mods += "Alt ";
        }
        if (parts.shift) {
          mods += "Shift ";
        }
        if (parts.cmd && Platform2.IS_MAC) {
          mods += "Cmd ";
        }
        return mods + parts.key;
      }
      CommandRegistry2.normalizeKeystroke = normalizeKeystroke;
      function normalizeKeys(options) {
        let keys;
        if (Platform2.IS_WIN) {
          keys = options.winKeys || options.keys;
        } else if (Platform2.IS_MAC) {
          keys = options.macKeys || options.keys;
        } else {
          keys = options.linuxKeys || options.keys;
        }
        return keys.map(normalizeKeystroke);
      }
      CommandRegistry2.normalizeKeys = normalizeKeys;
      function formatKeystroke(keystroke) {
        return typeof keystroke === "string" ? formatSingleKey(keystroke) : keystroke.map(formatSingleKey).join(", ");
        function formatSingleKey(key2) {
          let mods = [];
          let separator = Platform2.IS_MAC ? " " : "+";
          let parts = parseKeystroke(key2);
          if (parts.ctrl) {
            mods.push("Ctrl");
          }
          if (parts.alt) {
            mods.push("Alt");
          }
          if (parts.shift) {
            mods.push("Shift");
          }
          if (Platform2.IS_MAC && parts.cmd) {
            mods.push("Cmd");
          }
          mods.push(parts.key);
          return mods.map(Private17.formatKey).join(separator);
        }
      }
      CommandRegistry2.formatKeystroke = formatKeystroke;
      function isModifierKeyPressed(event) {
        let layout = getKeyboardLayout();
        let key2 = layout.keyForKeydownEvent(event);
        return layout.isModifierKey(key2);
      }
      CommandRegistry2.isModifierKeyPressed = isModifierKeyPressed;
      function keystrokeForKeydownEvent(event) {
        let layout = getKeyboardLayout();
        let key2 = layout.keyForKeydownEvent(event);
        if (!key2 || layout.isModifierKey(key2)) {
          return "";
        }
        let mods = [];
        if (event.ctrlKey) {
          mods.push("Ctrl");
        }
        if (event.altKey) {
          mods.push("Alt");
        }
        if (event.shiftKey) {
          mods.push("Shift");
        }
        if (event.metaKey && Platform2.IS_MAC) {
          mods.push("Cmd");
        }
        mods.push(key2);
        return mods.join(" ");
      }
      CommandRegistry2.keystrokeForKeydownEvent = keystrokeForKeydownEvent;
    })(CommandRegistry || (CommandRegistry = {}));
    (function(Private31) {
      Private31.CHORD_TIMEOUT = 1e3;
      Private31.KEYBINDING_HOLD_TIMEOUT = 1e3;
      function createCommand(options) {
        return {
          execute: options.execute,
          describedBy: asFunc(typeof options.describedBy === "function" ? options.describedBy : { args: null, ...options.describedBy }, () => {
            return { args: null };
          }),
          label: asFunc(options.label, emptyStringFunc),
          mnemonic: asFunc(options.mnemonic, negativeOneFunc),
          icon: asFunc(options.icon, undefinedFunc),
          iconClass: asFunc(options.iconClass, emptyStringFunc),
          iconLabel: asFunc(options.iconLabel, emptyStringFunc),
          caption: asFunc(options.caption, emptyStringFunc),
          usage: asFunc(options.usage, emptyStringFunc),
          className: asFunc(options.className, emptyStringFunc),
          dataset: asFunc(options.dataset, emptyDatasetFunc),
          isEnabled: options.isEnabled || trueFunc,
          isToggled: options.isToggled || falseFunc,
          isToggleable: options.isToggleable || !!options.isToggled,
          isVisible: options.isVisible || trueFunc
        };
      }
      Private31.createCommand = createCommand;
      function createKeyBinding(options) {
        var _a;
        return {
          keys: CommandRegistry.normalizeKeys(options),
          selector: validateSelector(options),
          command: options.command,
          args: options.args || import_coreutils6.JSONExt.emptyObject,
          preventDefault: (_a = options.preventDefault) !== null && _a !== void 0 ? _a : true
        };
      }
      Private31.createKeyBinding = createKeyBinding;
      function matchKeyBinding(bindings, keys, event) {
        let exact = null;
        let partial = [];
        let distance = Infinity;
        let specificity = 0;
        for (let i2 = 0, n = bindings.length; i2 < n; ++i2) {
          let binding = bindings[i2];
          let sqm = matchSequence(binding.keys, keys);
          if (sqm === 0) {
            continue;
          }
          if (sqm === 2) {
            if (targetDistance(binding.selector, event) !== -1) {
              partial.push(binding);
            }
            continue;
          }
          let td = targetDistance(binding.selector, event);
          if (td === -1 || td > distance) {
            continue;
          }
          let sp = Selector3.calculateSpecificity(binding.selector);
          if (!exact || td < distance || sp >= specificity) {
            exact = binding;
            distance = td;
            specificity = sp;
          }
        }
        return { exact, partial };
      }
      Private31.matchKeyBinding = matchKeyBinding;
      function replayKeyEvent(event) {
        event.target.dispatchEvent(cloneKeyboardEvent(event));
      }
      Private31.replayKeyEvent = replayKeyEvent;
      function formatKey(key2) {
        if (Platform2.IS_MAC) {
          return MAC_DISPLAY.hasOwnProperty(key2) ? MAC_DISPLAY[key2] : key2;
        } else {
          return WIN_DISPLAY.hasOwnProperty(key2) ? WIN_DISPLAY[key2] : key2;
        }
      }
      Private31.formatKey = formatKey;
      const MAC_DISPLAY = {
        Backspace: "\u232B",
        Tab: "\u21E5",
        Enter: "\u23CE",
        Shift: "\u21E7",
        Ctrl: "\u2303",
        Alt: "\u2325",
        Escape: "\u238B",
        PageUp: "\u21DE",
        PageDown: "\u21DF",
        End: "\u2198",
        Home: "\u2196",
        ArrowLeft: "\u2190",
        ArrowUp: "\u2191",
        ArrowRight: "\u2192",
        ArrowDown: "\u2193",
        Delete: "\u2326",
        Cmd: "\u2318"
      };
      const WIN_DISPLAY = {
        Escape: "Esc",
        PageUp: "Page Up",
        PageDown: "Page Down",
        ArrowLeft: "Left",
        ArrowUp: "Up",
        ArrowRight: "Right",
        ArrowDown: "Down",
        Delete: "Del"
      };
      const emptyStringFunc = () => "";
      const negativeOneFunc = () => -1;
      const trueFunc = () => true;
      const falseFunc = () => false;
      const emptyDatasetFunc = () => ({});
      const undefinedFunc = () => void 0;
      function asFunc(value, dfault) {
        if (value === void 0) {
          return dfault;
        }
        if (typeof value === "function") {
          return value;
        }
        return () => value;
      }
      function validateSelector(options) {
        if (options.selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${options.selector}`);
        }
        if (!Selector3.isValid(options.selector)) {
          throw new Error(`Invalid selector: ${options.selector}`);
        }
        return options.selector;
      }
      function matchSequence(bindKeys, userKeys) {
        if (bindKeys.length < userKeys.length) {
          return 0;
        }
        for (let i2 = 0, n = userKeys.length; i2 < n; ++i2) {
          if (bindKeys[i2] !== userKeys[i2]) {
            return 0;
          }
        }
        if (bindKeys.length > userKeys.length) {
          return 2;
        }
        return 1;
      }
      function targetDistance(selector, event) {
        let targ = event.target;
        let curr = event.currentTarget;
        for (let dist = 0; targ !== null; targ = targ.parentElement, ++dist) {
          if (targ.hasAttribute("data-lm-suppress-shortcuts")) {
            return -1;
          }
          if (Selector3.matches(targ, selector)) {
            return dist;
          }
          if (targ === curr) {
            return -1;
          }
        }
        return -1;
      }
      function cloneKeyboardEvent(event) {
        let clone = document.createEvent("Event");
        let bubbles = event.bubbles || true;
        let cancelable = event.cancelable || true;
        clone.initEvent(event.type || "keydown", bubbles, cancelable);
        clone.key = event.key || "";
        clone.keyCode = event.keyCode || 0;
        clone.which = event.keyCode || 0;
        clone.ctrlKey = event.ctrlKey || false;
        clone.altKey = event.altKey || false;
        clone.shiftKey = event.shiftKey || false;
        clone.metaKey = event.metaKey || false;
        clone.view = event.view || window;
        return clone;
      }
    })(Private17 || (Private17 = {}));
  }
});

// ../../node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils7, BoxSizer, BoxEngine, Title, Widget, Private$j, Layout, LayoutItem, Private$i, PanelLayout, Utils, Utils$1, SplitLayout, Private$h, AccordionLayout, Private$g, Panel, Private$f, SplitPanel, Private$e, AccordionPanel, Private$d, BoxLayout, Private$c, BoxPanel, Private$b, CommandPalette, Private$a, Menu, Private$9, Private$8, ARROW_KEYS, TabBar, Private$7, DockLayout, Private$6, DockPanel, Private$5, FocusTracker, GridLayout, Private$4, MenuBar, Private$3, Private$2, SingletonLayout, StackedLayout, Private$1, Private18;
var init_index_es619 = __esm({
  "../../node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es69();
    import_coreutils7 = __toESM(require_dist());
    init_index_es610();
    init_index_es612();
    init_index_es613();
    init_index_es63();
    init_index_es614();
    init_index_es618();
    init_index_es68();
    init_index_es65();
    init_index_es617();
    BoxSizer = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine2) {
      function calc(sizers, space) {
        let count = sizers.length;
        if (count === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i2 = 0; i2 < count; ++i2) {
          let sizer = sizers[i2];
          let min = sizer.minSize;
          let max2 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min, Math.min(hint, max2));
          totalSize += sizer.size;
          totalMin += min;
          totalMax += max2;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i2 = 0; i2 < count; ++i2) {
            let sizer = sizers[i2];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i2 = 0; i2 < count; ++i2) {
            let sizer = sizers[i2];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i2 = 0; i2 < count; ++i2) {
              let sizer = sizers[i2];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i2 = 0; i2 < count; ++i2) {
              let sizer = sizers[i2];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i2 = 0; i2 < count; ++i2) {
              let sizer = sizers[i2];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i2 = 0; i2 < count; ++i2) {
              let sizer = sizers[i2];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine2.calc = calc;
      function adjust(sizers, index, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index, delta);
        } else {
          shrinkSizer(sizers, index, -delta);
        }
      }
      BoxEngine2.adjust = adjust;
      function growSizer(sizers, index, delta) {
        let growLimit = 0;
        for (let i2 = 0; i2 <= index; ++i2) {
          let sizer = sizers[i2];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i2 = index + 1, n = sizers.length; i2 < n; ++i2) {
          let sizer = sizers[i2];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i2 = index; i2 >= 0 && grow > 0; --i2) {
          let sizer = sizers[i2];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i2 = index + 1, n = sizers.length; i2 < n && shrink > 0; ++i2) {
          let sizer = sizers[i2];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
      function shrinkSizer(sizers, index, delta) {
        let growLimit = 0;
        for (let i2 = index + 1, n = sizers.length; i2 < n; ++i2) {
          let sizer = sizers[i2];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i2 = 0; i2 <= index; ++i2) {
          let sizer = sizers[i2];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i2 = index + 1, n = sizers.length; i2 < n && grow > 0; ++i2) {
          let sizer = sizers[i2];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i2 = index; i2 >= 0 && shrink > 0; --i2) {
          let sizer = sizers[i2];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
    })(BoxEngine || (BoxEngine = {}));
    Title = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget.HiddenMode.Display;
        this.node = Private$j.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop.clearData(this);
        AttachedProperty3.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       */
      get isHidden() {
        return this.testFlag(Widget.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       */
      get isVisible() {
        return this.testFlag(Widget.Flag.IsVisible);
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget.ChildMessage("child-removed", this);
          MessageLoop.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget.ChildMessage("child-added", this);
          MessageLoop.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name2) {
        return this.node.classList.contains(name2);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name2) {
        this.node.classList.add(name2);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name2) {
        this.node.classList.remove(name2);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name2, force) {
        if (force === true) {
          this.node.classList.add(name2);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name2);
          return false;
        }
        return this.node.classList.toggle(name2);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop.postMessage(this, Widget.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);
        }
        this.clearFlag(Widget.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget.ChildMessage("child-shown", this);
          MessageLoop.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);
        }
        this.setFlag(Widget.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop.sendMessage(this, Widget.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget.ChildMessage("child-hidden", this);
          MessageLoop.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden) {
        if (hidden) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget.Flag.IsVisible);
            }
            this.setFlag(Widget.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget.Flag.IsVisible);
            this.clearFlag(Widget.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden) {
        if (hidden) {
          switch (this._hiddenMode) {
            case Widget.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget2) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget2.HiddenMode || (Widget2.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget2.Flag || (Widget2.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message("before-show");
        Msg.AfterShow = new Message("after-show");
        Msg.BeforeHide = new Message("before-hide");
        Msg.AfterHide = new Message("after-hide");
        Msg.BeforeAttach = new Message("before-attach");
        Msg.AfterAttach = new Message("after-attach");
        Msg.BeforeDetach = new Message("before-detach");
        Msg.AfterDetach = new Message("after-detach");
        Msg.ParentChanged = new Message("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage("update-request");
        Msg.FitRequest = new ConflatableMessage("fit-request");
        Msg.ActivateRequest = new ConflatableMessage("activate-request");
        Msg.CloseRequest = new ConflatableMessage("close-request");
      })(Widget2.Msg || (Widget2.Msg = {}));
      class ChildMessage extends Message {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget2.ChildMessage = ChildMessage;
      class ResizeMessage extends Message {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget2.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget2.ResizeMessage || (Widget2.ResizeMessage = {}));
      function attach(widget, host, ref = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop.sendMessage(widget, Widget2.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref);
        MessageLoop.sendMessage(widget, Widget2.Msg.AfterAttach);
      }
      Widget2.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop.sendMessage(widget, Widget2.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop.sendMessage(widget, Widget2.Msg.AfterDetach);
      }
      Widget2.detach = detach;
    })(Widget || (Widget = {}));
    (function(Private31) {
      Private31.titleProperty = new AttachedProperty3({
        name: "title",
        create: (owner) => new Title({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private31.createNode = createNode;
    })(Private$j || (Private$j = {}));
    Layout = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty3.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout2) {
      function getHorizontalAlignment(widget) {
        return Private$i.horizontalAlignmentProperty.get(widget);
      }
      Layout2.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i.horizontalAlignmentProperty.set(widget, value);
      }
      Layout2.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i.verticalAlignmentProperty.get(widget);
      }
      Layout2.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i.verticalAlignmentProperty.set(widget, value);
      }
      Layout2.setVerticalAlignment = setVerticalAlignment;
    })(Layout || (Layout = {}));
    LayoutItem = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget.ResizeMessage(clampW, clampH);
          MessageLoop.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private31) {
      Private31.horizontalAlignmentProperty = new AttachedProperty3({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private31.verticalAlignmentProperty = new AttachedProperty3({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i || (Private$i = {}));
    PanelLayout = class extends Layout {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index, widget) {
        widget.parent = this.parent;
        let i2 = this._widgets.indexOf(widget);
        let j = Math.max(0, Math.min(index, this._widgets.length));
        if (i2 === -1) {
          ArrayExt3.insert(this._widgets, j, widget);
          if (this.parent) {
            this.attachWidget(j, widget);
          }
          return;
        }
        if (j === this._widgets.length) {
          j--;
        }
        if (i2 === j) {
          return;
        }
        ArrayExt3.move(this._widgets, i2, j);
        if (this.parent) {
          this.moveWidget(i2, j, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index) {
        let widget = ArrayExt3.removeAt(this._widgets, index);
        if (widget && this.parent) {
          this.detachWidget(index, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index = 0;
        for (const widget of this) {
          this.attachWidget(index++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index, widget) {
        let ref = this.parent.node.children[index];
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        let ref = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index, widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
    };
    (function(Utils2) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils2.clampDimension = clampDimension;
    })(Utils || (Utils = {}));
    Utils$1 = Utils;
    SplitLayout = class extends PanelLayout {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n = this._sizers.length;
        let temp = sizes.slice(0, n);
        while (temp.length < n) {
          temp.push(0);
        }
        let normed = Private$h.normalize(temp);
        for (let i2 = 0; i2 < n; ++i2) {
          let sizer = this._sizers[i2];
          sizer.sizeHint = normed[i2];
          sizer.size = normed[i2];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index, position) {
        let handle = this._handles[index];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine.adjust(this._sizers, index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        let item = new LayoutItem(widget);
        let handle = Private$h.createHandle(this.renderer);
        let average = Private$h.averageSize(this._sizers);
        let sizer = Private$h.createSizer(average);
        ArrayExt3.insert(this._items, index, item);
        ArrayExt3.insert(this._sizers, index, sizer);
        ArrayExt3.insert(this._handles, index, handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        ArrayExt3.move(this._sizers, fromIndex, toIndex);
        ArrayExt3.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        let handle = ArrayExt3.removeAt(this._handles, index);
        ArrayExt3.removeAt(this._sizers, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i2, isHorizontal, left, top, height, width, size) {
        const item = this._items[i2];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i2].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size, height);
          left += size;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size);
          top += size;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          if (this._items[i2].isHidden) {
            this._handles[i2].classList.add("lm-mod-hidden");
          } else {
            this._handles[i2].classList.remove("lm-mod-hidden");
            lastHandleIndex = i2;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          let sizer = this._sizers[i2];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          nVisible += +!this._items[i2].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset = delta / 2;
                break;
              case "end":
                extra = 0;
                offset = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          const item = this._items[i2];
          const size = item.isHidden ? 0 : this._sizers[i2].size + extra;
          this.updateItemPosition(i2, horz, horz ? left + offset : left, horz ? top : top + offset, height, width, size);
          const fullOffset = this.widgetOffset + (this._handles[i2].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size + fullOffset;
          } else {
            top += size + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout2) {
      function getStretch(widget) {
        return Private$h.stretchProperty.get(widget);
      }
      SplitLayout2.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h.stretchProperty.set(widget, value);
      }
      SplitLayout2.setStretch = setStretch;
    })(SplitLayout || (SplitLayout = {}));
    (function(Private31) {
      Private31.stretchProperty = new AttachedProperty3({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size) {
        let sizer = new BoxSizer();
        sizer.sizeHint = Math.floor(size);
        return sizer;
      }
      Private31.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private31.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v2, s) => v2 + s.size, 0) / sizers.length || 0;
      }
      Private31.averageSize = averageSize;
      function normalize(values) {
        let n = values.length;
        if (n === 0) {
          return [];
        }
        let sum = values.reduce((a, b) => a + Math.abs(b), 0);
        return sum === 0 ? values.map((v2) => 1 / n) : values.map((v2) => v2 / sum);
      }
      Private31.normalize = normalize;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout) {
          child.parent.fit();
        }
      }
    })(Private$h || (Private$h = {}));
    AccordionLayout = class extends SplitLayout {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$1.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index, widget) {
        const oldTitle = this._titles[index];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g.createTitle(this.renderer, widget.title, expanded);
        this._titles[index] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils7.UUID.uuid4()}`;
        }
        super.insertWidget(index, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index, widget) {
        const title = Private$g.createTitle(this.renderer, widget.title);
        ArrayExt3.insert(this._titles, index, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        const title = ArrayExt3.removeAt(this._titles, index);
        this.parent.node.removeChild(title);
        super.detachWidget(index, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i2, isHorizontal, left, top, height, width, size) {
        const titleStyle = this._titles[i2].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i2, isHorizontal, left, top, height, width, size);
      }
    };
    (function(Private31) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private31.createTitle = createTitle;
    })(Private$g || (Private$g = {}));
    Panel = class extends Widget {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index, widget) {
        this.layout.insertWidget(index, widget);
      }
    };
    (function(Private31) {
      function createLayout(options) {
        return options.layout || new PanelLayout();
      }
      Private31.createLayout = createLayout;
    })(Private$f || (Private$f = {}));
    SplitPanel = class extends Panel {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index = ArrayExt3.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor);
        this._pressData = { index, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel2) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel2.Renderer = Renderer;
      SplitPanel2.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout.getStretch(widget);
      }
      SplitPanel2.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout.setStretch(widget, value);
      }
      SplitPanel2.setStretch = setStretch;
    })(SplitPanel || (SplitPanel = {}));
    (function(Private31) {
      function createLayout(options) {
        return options.layout || new SplitLayout({
          renderer: options.renderer || SplitPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private31.createLayout = createLayout;
    })(Private$e || (Private$e = {}));
    AccordionPanel = class extends SplitPanel {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index) {
        const widget = this.layout.widgets[index];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index) {
        const widget = this.layout.widgets[index];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index, widget) {
        super.insertWidget(index, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index = ArrayExt3.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index >= 0) {
          this.layout.updateTitle(index, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index) {
        const layout = this.layout;
        const widget = layout.widgets[index];
        if (!widget) {
          return void 0;
        }
        const isHidden = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden) {
          const currentSize = widgetSizes[index];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_, idx) => {
              if (idx !== index) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target = event.target;
        if (target) {
          const index = ArrayExt3.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        let handled = false;
        if (target) {
          const index = ArrayExt3.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index + length + direction) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index) {
        const title = this.titles[index];
        const widget = this.layout.widgets[index];
        const newSize = this._computeWidgetSize(index);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index);
      }
    };
    (function(AccordionPanel2) {
      class Renderer extends SplitPanel.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key2 = this._titleKeys.get(data);
          if (key2 === void 0) {
            key2 = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key2);
          }
          return key2;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel2.Renderer = Renderer;
      AccordionPanel2.defaultRenderer = new Renderer();
    })(AccordionPanel || (AccordionPanel = {}));
    (function(Private31) {
      function createLayout(options) {
        return options.layout || new AccordionLayout({
          renderer: options.renderer || AccordionPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private31.createLayout = createLayout;
    })(Private$d || (Private$d = {}));
    BoxLayout = class extends PanelLayout {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        ArrayExt3.insert(this._items, index, new LayoutItem(widget));
        ArrayExt3.insert(this._sizers, index, new BoxSizer());
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        ArrayExt3.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        ArrayExt3.removeAt(this._sizers, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          nVisible += +!this._items[i2].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          let sizer = this._sizers[i2];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          nVisible += +!this._items[i2].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset = delta / 2;
              break;
            case "end":
              extra = 0;
              offset = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          if (item.isHidden) {
            continue;
          }
          let size = this._sizers[i2].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset, top, size + extra, height);
              left += size + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset, width, size + extra);
              top += size + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset - size - extra, top, size + extra, height);
              left -= size + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset - size - extra, width, size + extra);
              top -= size + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout2) {
      function getStretch(widget) {
        return Private$c.stretchProperty.get(widget);
      }
      BoxLayout2.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c.stretchProperty.set(widget, value);
      }
      BoxLayout2.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c.sizeBasisProperty.get(widget);
      }
      BoxLayout2.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c.sizeBasisProperty.set(widget, value);
      }
      BoxLayout2.setSizeBasis = setSizeBasis;
    })(BoxLayout || (BoxLayout = {}));
    (function(Private31) {
      Private31.stretchProperty = new AttachedProperty3({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private31.sizeBasisProperty = new AttachedProperty3({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private31.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private31.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout) {
          child.parent.fit();
        }
      }
    })(Private$c || (Private$c = {}));
    BoxPanel = class extends Panel {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel2) {
      function getStretch(widget) {
        return BoxLayout.getStretch(widget);
      }
      BoxPanel2.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout.setStretch(widget, value);
      }
      BoxPanel2.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout.getSizeBasis(widget);
      }
      BoxPanel2.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout.setSizeBasis(widget, value);
      }
      BoxPanel2.setSizeBasis = setSizeBasis;
    })(BoxPanel || (BoxPanel = {}));
    (function(Private31) {
      function createLayout(options) {
        return options.layout || new BoxLayout(options);
      }
      Private31.createLayout = createLayout;
    })(Private$b || (Private$b = {}));
    CommandPalette = class extends Widget {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index) {
        let item = ArrayExt3.removeAt(this._items, index);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.isHidden) {
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a.search(this._items, query);
          this._activeIndex = query ? ArrayExt3.findFirstIndex(results, Private$a.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i2 = 0, n = results.length; i2 < n; ++i2) {
          let result = results[i2];
          if (result.type === "header") {
            let indices = result.indices;
            let category = result.category;
            content[i2] = renderer.renderHeader({ category, indices });
          } else {
            let item = result.item;
            let indices = result.indices;
            let active = i2 === activeIndex;
            content[i2] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n = this._results.length;
        let start = ai < n - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n - 1 : start - 1;
        this._activeIndex = ArrayExt3.findFirstIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n = this._results.length;
        let start = ai <= 0 ? n - 1 : ai - 1;
        let stop = start === n - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt3.findLastIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index) {
        if (!this._results) {
          return;
        }
        let part = this._results[index];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette2) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name2 = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name2 += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name2 += " lm-mod-toggled";
          }
          if (data.active) {
            name2 += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name2 += ` ${extra}`;
          }
          return name2;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt3.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt3.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette2.Renderer = Renderer;
      CommandPalette2.defaultRenderer = new Renderer();
    })(CommandPalette || (CommandPalette = {}));
    (function(Private31) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private31.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private31.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private31.search = search;
      function canActivate(result) {
        return result.type === "item" && result.item.isEnabled;
      }
      Private31.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          let item = items[i2];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt3.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j = ArrayExt3.lowerBound(indices, pivot, (a, b) => a - b);
        let categoryIndices = indices.slice(0, j);
        let labelIndices = indices.slice(j);
        for (let i2 = 0, n = labelIndices.length; i2 < n; ++i2) {
          labelIndices[i2] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a, b) {
        let m1 = a.matchType - b.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a.score - b.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i2 = 0;
        switch (a.matchType) {
          case 0:
            i1 = a.labelIndices[0];
            i2 = b.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a.categoryIndices[0];
            i2 = b.categoryIndices[0];
            break;
        }
        if (i1 !== i2) {
          return i1 - i2;
        }
        let d2 = a.item.category.localeCompare(b.item.category);
        if (d2 !== 0) {
          return d2;
        }
        let r1 = a.item.rank;
        let r2 = b.item.rank;
        if (r1 !== r2) {
          return r1 < r2 ? -1 : 1;
        }
        return a.item.label.localeCompare(b.item.label);
      }
      function createResults(scores) {
        let visited = new Array(scores.length);
        ArrayExt3.fill(visited, false);
        let results = [];
        for (let i2 = 0, n = scores.length; i2 < n; ++i2) {
          if (visited[i2]) {
            continue;
          }
          let { item, categoryIndices } = scores[i2];
          let category = item.category;
          results.push({ type: "header", category, indices: categoryIndices });
          for (let j = i2; j < n; ++j) {
            if (visited[j]) {
              continue;
            }
            let { item: item2, labelIndices } = scores[j];
            if (item2.category !== category) {
              continue;
            }
            results.push({ type: "item", item: item2, indices: labelIndices });
            visited[j] = true;
          }
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils7.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt3.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils7.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a || (Private$a = {}));
    Menu = class extends Widget {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$9.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$9.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n - 1 : start - 1;
        this.activeIndex = ArrayExt3.findFirstIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n - 1 : ai - 1;
        let stop = start === n - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt3.findLastIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i2 = Math.max(0, Math.min(index, this._items.length));
        let item = Private$9.createItem(this, options);
        ArrayExt3.insert(this._items, i2, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt3.removeAt(this._items, index);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x, y, options = {}) {
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        Private$9.openRootMenu(this, x, y, forceX, forceY);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$9.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          let item = items[i2];
          let active = i2 === activeIndex;
          let collapsed = collapsedFlags[i2];
          content[i2] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i2;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key2 = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key2) {
          return;
        }
        let start = this._activeIndex + 1;
        let result = Private$9.findMnemonic(this._items, key2, start);
        if (result.index !== -1 && !result.multiple) {
          this.activeIndex = result.index;
          this.triggerActiveItem();
        } else if (result.index !== -1) {
          this.activeIndex = result.index;
        } else if (result.auto !== -1) {
          this.activeIndex = result.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === this._activeIndex) {
          return;
        }
        this.activeIndex = index;
        index = this.activeIndex;
        if (index === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$9.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$9.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$9.saveWindowData();
      }
    };
    (function(Menu2) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name2 = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name2 += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name2 += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name2 += " lm-mod-hidden";
          }
          if (data.active) {
            name2 += " lm-mod-active";
          }
          if (data.collapsed) {
            name2 += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name2 += ` ${extra}`;
          }
          return name2;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result = { ...dataset, type, command };
          } else {
            result = { ...dataset, type };
          }
          return result;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              aria.role = "menuitem";
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu2.Renderer = Renderer;
      Menu2.defaultRenderer = new Renderer();
    })(Menu || (Menu = {}));
    (function(Private31) {
      Private31.TIMER_DELAY = 300;
      Private31.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private31.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private31.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private31.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem(owner.commands, options);
      }
      Private31.createItem = createItem;
      function hitTestMenus(menu, x, y) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x, y)) {
            return true;
          }
        }
        return false;
      }
      Private31.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result = new Array(items.length);
        ArrayExt3.fill(result, false);
        let k1 = 0;
        let n = items.length;
        for (; k1 < n; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result[k1] = true;
        }
        let k2 = n - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result[k2] = true;
        }
        let hide = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide = false;
          } else if (hide) {
            result[k1] = true;
          } else {
            hide = true;
          }
        }
        return result;
      }
      Private31.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x, y, forceX, forceY) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget.attach(menu, document.body);
        let { width, height } = node.getBoundingClientRect();
        if (!forceX && x + width > px + cw) {
          x = px + cw - width;
        }
        if (!forceY && y + height > py + ch) {
          if (y > py + ch) {
            y = py + ch - height;
          } else {
            y = y - height;
          }
        }
        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;
        style.opacity = "1";
      }
      Private31.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x = itemRect.right - Private31.SUBMENU_OVERLAP;
        if (x + width > px + cw) {
          x = itemRect.left + Private31.SUBMENU_OVERLAP - width;
        }
        let y = itemRect.top - box.borderTop - box.paddingTop;
        if (y + height > py + ch) {
          y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;
        style.opacity = "1";
      }
      Private31.openSubmenu = openSubmenu;
      function findMnemonic(items, key2, start) {
        let index = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key2.toUpperCase();
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          let k = (i2 + start) % n;
          let item = items[k];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index === -1) {
                index = k;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k;
          }
        }
        return { index, multiple, auto };
      }
      Private31.findMnemonic = findMnemonic;
      class MenuItem {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils7.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt3.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils7.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$9 || (Private$9 = {}));
    (function(Private31) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private31.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target = event.target;
        if (!target) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target)) {
          target = document.elementFromPoint(event.clientX, event.clientY);
          if (!target || !currentTarget.contains(target)) {
            return null;
          }
        }
        let result = [];
        let availableItems = items.slice();
        while (target !== null) {
          let matches = [];
          for (let i2 = 0, n = availableItems.length; i2 < n; ++i2) {
            let item = availableItems[i2];
            if (!item) {
              continue;
            }
            if (!Selector2.matches(target, item.selector)) {
              continue;
            }
            matches.push(item);
            availableItems[i2] = null;
          }
          if (matches.length !== 0) {
            if (groupByTarget) {
              matches.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result.push(...matches);
          }
          if (target === currentTarget) {
            break;
          }
          target = target.parentElement;
        }
        if (!groupByTarget) {
          result.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result;
      }
      Private31.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector2.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a, b) {
        let r1 = a.rank;
        let r2 = b.rank;
        if (r1 !== r2) {
          return r1 < r2 ? -1 : 1;
        }
        return a.id - b.id;
      }
      function itemCmp(a, b) {
        let s1 = Selector2.calculateSpecificity(a.selector);
        let s2 = Selector2.calculateSpecificity(b.selector);
        if (s1 !== s2) {
          return s2 - s1;
        }
        return itemCmpRank(a, b);
      }
    })(Private$8 || (Private$8 = {}));
    ARROW_KEYS = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar = class extends Widget {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$7.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt2 = this._titles[pi] || null;
        let ci = value;
        let ct2 = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt2;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt2,
          currentIndex: ci,
          currentTitle: ct2
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index, value) {
        this._releaseMouse();
        let title = Private$7.asTitle(value);
        let i2 = this._titles.indexOf(title);
        let j = Math.max(0, Math.min(index, this._titles.length));
        if (i2 === -1) {
          ArrayExt3.insert(this._titles, j, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j, title);
          return title;
        }
        if (j === this._titles.length) {
          j--;
        }
        if (i2 === j) {
          return title;
        }
        ArrayExt3.move(this._titles, i2, j);
        this.update();
        this._adjustCurrentForMove(i2, j);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index) {
        this._releaseMouse();
        let title = ArrayExt3.removeAt(this._titles, index);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt2 = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt2,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i2 = 0, n = titles.length; i2 < n; ++i2) {
          let title = titles[i2];
          let current = title === currentTitle;
          let zIndex = current ? n : n - i2 - 1;
          let tabIndex = tabHandlingTabindex === i2 ? 0 : -1;
          content[i2] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index = -1;
        }
        return index;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index === -1) {
          return;
        }
        let title = this.titles[index];
        let label = tabs[index].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index = ArrayExt3.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index;
            }
          }
        } else if (ARROW_KEYS.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index],
          index,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$7.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$7.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$7.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index];
          let title = this._titles[index];
          this._tabDetachRequested.emit({
            index,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$7.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index = ArrayExt3.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index !== data.index) {
            return;
          }
          let title = this._titles[index];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index, title });
            return;
          }
          let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$7.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$7.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$7.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i2 = data.index;
          let j = data.targetIndex;
          if (j === -1 || i2 === j) {
            return;
          }
          ArrayExt3.move(this._titles, i2, j);
          this._adjustCurrentForMove(i2, j);
          this._tabMoved.emit({
            fromIndex: i2,
            toIndex: j,
            title: this._titles[j]
          });
          MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$7.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i2, title) {
        let ct2 = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i2;
          this._previousTitle = ct2;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct2,
            currentIndex: i2,
            currentTitle: title
          });
          return;
        }
        if (ci >= i2) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i2, j) {
        if (this._currentIndex === i2) {
          this._currentIndex = j;
        } else if (this._currentIndex < i2 && this._currentIndex >= j) {
          this._currentIndex++;
        } else if (this._currentIndex > i2 && this._currentIndex <= j) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i2, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i2) {
          if (ci > i2) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i2,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i2, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i2,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i2 - 1);
          this._currentChanged.emit({
            previousIndex: i2,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i2, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i2,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i2,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar2) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key2 = this.createTabKey(data);
          let id = key2;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key: key2, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key: key2, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key2 = this._tabKeys.get(data.title);
          if (key2 === void 0) {
            key2 = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key2);
          }
          return key2;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name2 = "lm-TabBar-tab";
          if (data.title.className) {
            name2 += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name2 += " lm-mod-closable";
          }
          if (data.current) {
            name2 += " lm-mod-current";
          }
          return name2;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name2 = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
      }
      Renderer._nInstance = 0;
      TabBar2.Renderer = Renderer;
      TabBar2.defaultRenderer = new Renderer();
      TabBar2.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar || (TabBar = {}));
    (function(Private31) {
      Private31.DRAG_THRESHOLD = 5;
      Private31.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private31.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title ? value : new Title(value);
      }
      Private31.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private31.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i2 = 0, n = tabs.length; i2 < n; ++i2) {
          let node = tabs[i2];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i2] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i2] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private31.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private31.DRAG_THRESHOLD || dy >= Private31.DRAG_THRESHOLD;
      }
      Private31.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private31.DETACH_THRESHOLD || event.clientX >= rect.right + Private31.DETACH_THRESHOLD || event.clientY < rect.top - Private31.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private31.DETACH_THRESHOLD;
      }
      Private31.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i2 = 0, n = tabs.length; i2 < n; ++i2) {
          let pxPos;
          let layout = data.tabLayout[i2];
          let threshold = layout.pos + (layout.size >> 1);
          if (i2 < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i2 + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i2);
          } else if (i2 > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i2);
          } else if (i2 === data.index) {
            let ideal = clientPos - pressPos;
            let limit = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i2].style.left = pxPos;
          } else {
            tabs[i2].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private31.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private31.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private31.resetTabPositions = resetTabPositions;
    })(Private$7 || (Private$7 = {}));
    DockLayout = class extends Layout {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v2) {
        if (this._hiddenMode === v2) {
          return;
        }
        this._hiddenMode = v2;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$6.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$6.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref) {
          refNode = this._root.findTabNode(ref);
        }
        if (ref && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x = clientX - rect.left - this._box.borderLeft;
        let y = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x, y);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x, y, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$6.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i2 = ArrayExt3.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt3.removeAt(splitNode.handles, i2);
        ArrayExt3.removeAt(splitNode.sizers, i2);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$6.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j] = childNode;
          return;
        }
        let splitHandle = ArrayExt3.removeAt(parentNode.handles, j);
        ArrayExt3.removeAt(parentNode.children, j);
        ArrayExt3.removeAt(parentNode.sizers, j);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i3 = 0, n = childNode.children.length; i3 < n; ++i3) {
          let gChild = childNode.children[i3];
          let gHandle = childNode.handles[i3];
          let gSizer = childNode.sizers[i3];
          ArrayExt3.insert(parentNode.children, j + i3, gChild);
          ArrayExt3.insert(parentNode.handles, j + i3, gHandle);
          ArrayExt3.insert(parentNode.sizers, j + i3, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$6.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref, refNode, after) {
        if (widget === ref) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$6.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index;
        if (ref) {
          index = refNode.tabBar.titles.indexOf(ref.title);
        } else {
          index = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);
        Private$6.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref, refNode, orientation, after, merge2 = false) {
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root = this._splitRoot(orientation);
          let i3 = after ? root.children.length : 0;
          root.normalizeSizes();
          let sizer = Private$6.createSizer(refNode ? 1 : Private$6.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt3.insert(root.children, i3, tabNode2);
          ArrayExt3.insert(root.sizers, i3, sizer);
          ArrayExt3.insert(root.handles, i3, this._createHandle());
          tabNode2.parent = root;
          root.normalizeSizes();
          root.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i3 = splitNode.children.indexOf(refNode);
          if (merge2) {
            let j3 = i3 + (after ? 1 : -1);
            let sibling = splitNode.children[j3];
            if (sibling instanceof Private$6.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s = splitNode.sizers[i3].sizeHint /= 2;
          let j2 = i3 + (after ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt3.insert(splitNode.children, j2, tabNode2);
          ArrayExt3.insert(splitNode.sizers, j2, Private$6.createSizer(s));
          ArrayExt3.insert(splitNode.handles, j2, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i2 = ArrayExt3.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$6.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$6.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j = after ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt3.insert(childNode.children, j, tabNode);
        ArrayExt3.insert(childNode.sizers, j, Private$6.createSizer(0.5));
        ArrayExt3.insert(childNode.handles, j, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt3.insert(splitNode.children, i2, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$6.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$6.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$6.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x = this._box.paddingTop;
        let y = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x, y, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private31) {
      Private31.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private31.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result;
        if (config.type === "tab-area") {
          result = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result;
      }
      Private31.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private31.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer();
          let widgetSizer = new BoxSizer();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x, y) {
          if (x < this._left || x >= this._left + this._width) {
            return null;
          }
          if (y < this._top || y >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size = this.sizers[0].size;
            tabBarItem.update(left, top, width, size);
            top += size;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size = this.sizers[1].size;
            widgetItem.update(left, top, width, size);
          }
        }
      }
      Private31.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
            let result = this.children[i2].findTabNode(widget);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index = this.handles.indexOf(handle);
          if (index !== -1) {
            return { index, node: this };
          }
          for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
            let result = this.children[i2].findSplitNode(handle);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x, y) {
          for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
            let result = this.children[i2].hitTestTabNodes(x, y);
            if (result) {
              return result;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i2) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i2 === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n = this.sizers.length;
          if (n === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v2, sizer) => v2 + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n = this.sizers.length;
          if (n === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v2, size) => v2 + size, 0);
          if (sum === 0) {
            for (let i2 = sizes.length - 1; i2 > -1; i2--) {
              sizes[i2] = 1 / n;
            }
          } else {
            for (let i2 = sizes.length - 1; i2 > -1; i2--) {
              sizes[i2] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
            let limits = this.children[i2].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i2].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i2].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine.calc(this.sizers, space);
          for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
            let child = this.children[i2];
            let size = this.sizers[i2].size;
            let handleStyle = this.handles[i2].style;
            if (horizontal) {
              child.update(left, top, size, height, spacing, items);
              left += size;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size, spacing, items);
              top += size;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private31.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private31.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private31.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index = config.currentIndex;
        if (index !== -1 && (index < 0 || index >= widgets.length)) {
          index = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children = [];
        let sizes = [];
        for (let i2 = 0, n = config.children.length; i2 < n; ++i2) {
          let child = normalizeAreaConfig(config.children[i2], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children.push(child);
            sizes.push(Math.abs(config.sizes[i2] || 0));
          } else {
            children.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children.length === 0) {
          return null;
        }
        if (children.length === 1) {
          return children[0];
        }
        return { type: "split-area", orientation, children, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private31.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i2) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i2]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$6 || (Private$6 = {}));
    DockPanel = class extends Widget {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel.defaultRenderer;
        this._edges = options.edges || Private$5.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v2) {
        this.layout.hiddenMode = v2;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$5.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find2(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref = target ? Private$5.getDropRef(target.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop.postMessage(this, Private$5.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target = event.target;
        let handle = find2(layout.handles(), (handle2) => handle2.contains(target));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$5.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$5.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$5.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$5.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-top":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height / 2;
            break;
          case "widget-left":
            top = target.top;
            left = target.left;
            right = target.right + target.width / 2;
            bottom = target.bottom;
            break;
          case "widget-right":
            top = target.top;
            left = target.left + target.width / 2;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-bottom":
            top = target.top + target.height / 2;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target.tabBar.node.getBoundingClientRect().height;
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$5.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
        MessageLoop.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset } = args;
        let mimeData = new import_coreutils7.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset) {
          dragImage.style.top = `-${offset.y}px`;
          dragImage.style.left = `-${offset.x}px`;
        }
        this._drag = new Drag({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel2) {
      class Overlay {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel2.Overlay = Overlay;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel2.Renderer = Renderer;
      DockPanel2.defaultRenderer = new Renderer();
    })(DockPanel || (DockPanel = {}));
    (function(Private31) {
      Private31.GOLDEN_RATIO = 0.618;
      Private31.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private31.LayoutModified = new ConflatableMessage("layout-modified");
      Private31.isGeneratedTabBarProperty = new AttachedProperty3({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private31.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt2 = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt2, pr, pb, pl);
          switch (pd) {
            case pt2:
              if (pt2 < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target = layout.hitTestTabAreas(clientX, clientY);
        if (!target) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target };
        }
        let al = target.x - target.left + 1;
        let at2 = target.y - target.top + 1;
        let ar = target.left + target.width - target.x;
        let ab = target.top + target.height - target.y;
        const tabHeight = target.tabBar.node.getBoundingClientRect().height;
        if (at2 < tabHeight) {
          return { zone: "widget-tab", target };
        }
        let rx = Math.round(target.width / 3);
        let ry = Math.round(target.height / 3);
        if (al > rx && ar > rx && at2 > ry && ab > ry) {
          return { zone: "widget-all", target };
        }
        al /= rx;
        at2 /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at2, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at2:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target };
      }
      Private31.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private31.getDropRef = getDropRef;
    })(Private$5 || (Private$5 = {}));
    FocusTracker = class {
      constructor() {
        this._counter = 0;
        this._widgets = [];
        this._activeWidget = null;
        this._currentWidget = null;
        this._numbers = /* @__PURE__ */ new Map();
        this._nodes = /* @__PURE__ */ new Map();
        this._activeChanged = new Signal(this);
        this._currentChanged = new Signal(this);
      }
      /**
       * Dispose of the resources held by the tracker.
       */
      dispose() {
        if (this._counter < 0) {
          return;
        }
        this._counter = -1;
        Signal.clearData(this);
        for (const widget of this._widgets) {
          widget.node.removeEventListener("focus", this, true);
          widget.node.removeEventListener("blur", this, true);
        }
        this._activeWidget = null;
        this._currentWidget = null;
        this._nodes.clear();
        this._numbers.clear();
        this._widgets.length = 0;
      }
      /**
       * A signal emitted when the current widget has changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when the active widget has changed.
       */
      get activeChanged() {
        return this._activeChanged;
      }
      /**
       * A flag indicating whether the tracker is disposed.
       */
      get isDisposed() {
        return this._counter < 0;
      }
      /**
       * The current widget in the tracker.
       *
       * #### Notes
       * The current widget is the widget among the tracked widgets which
       * has the *descendant node* which has most recently been focused.
       *
       * The current widget will not be updated if the node loses focus. It
       * will only be updated when a different tracked widget gains focus.
       *
       * If the current widget is removed from the tracker, the previous
       * current widget will be restored.
       *
       * This behavior is intended to follow a user's conceptual model of
       * a semantically "current" widget, where the "last thing of type X"
       * to be interacted with is the "current instance of X", regardless
       * of whether that instance still has focus.
       */
      get currentWidget() {
        return this._currentWidget;
      }
      /**
       * The active widget in the tracker.
       *
       * #### Notes
       * The active widget is the widget among the tracked widgets which
       * has the *descendant node* which is currently focused.
       */
      get activeWidget() {
        return this._activeWidget;
      }
      /**
       * A read only array of the widgets being tracked.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Get the focus number for a particular widget in the tracker.
       *
       * @param widget - The widget of interest.
       *
       * @returns The focus number for the given widget, or `-1` if the
       *   widget has not had focus since being added to the tracker, or
       *   is not contained by the tracker.
       *
       * #### Notes
       * The focus number indicates the relative order in which the widgets
       * have gained focus. A widget with a larger number has gained focus
       * more recently than a widget with a smaller number.
       *
       * The `currentWidget` will always have the largest focus number.
       *
       * All widgets start with a focus number of `-1`, which indicates that
       * the widget has not been focused since being added to the tracker.
       */
      focusNumber(widget) {
        let n = this._numbers.get(widget);
        return n === void 0 ? -1 : n;
      }
      /**
       * Test whether the focus tracker contains a given widget.
       *
       * @param widget - The widget of interest.
       *
       * @returns `true` if the widget is tracked, `false` otherwise.
       */
      has(widget) {
        return this._numbers.has(widget);
      }
      /**
       * Add a widget to the focus tracker.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * A widget will be automatically removed from the tracker if it
       * is disposed after being added.
       *
       * If the widget is already tracked, this is a no-op.
       */
      add(widget) {
        if (this._numbers.has(widget)) {
          return;
        }
        let focused = widget.node.contains(document.activeElement);
        let n = focused ? this._counter++ : -1;
        this._widgets.push(widget);
        this._numbers.set(widget, n);
        this._nodes.set(widget.node, widget);
        widget.node.addEventListener("focus", this, true);
        widget.node.addEventListener("blur", this, true);
        widget.disposed.connect(this._onWidgetDisposed, this);
        if (focused) {
          this._setWidgets(widget, widget);
        }
      }
      /**
       * Remove a widget from the focus tracker.
       *
       * #### Notes
       * If the widget is the `currentWidget`, the previous current widget
       * will become the new `currentWidget`.
       *
       * A widget will be automatically removed from the tracker if it
       * is disposed after being added.
       *
       * If the widget is not tracked, this is a no-op.
       */
      remove(widget) {
        if (!this._numbers.has(widget)) {
          return;
        }
        widget.disposed.disconnect(this._onWidgetDisposed, this);
        widget.node.removeEventListener("focus", this, true);
        widget.node.removeEventListener("blur", this, true);
        ArrayExt3.removeFirstOf(this._widgets, widget);
        this._nodes.delete(widget.node);
        this._numbers.delete(widget);
        if (this._currentWidget !== widget) {
          return;
        }
        let valid = this._widgets.filter((w) => this._numbers.get(w) !== -1);
        let previous = max(valid, (first, second) => {
          let a = this._numbers.get(first);
          let b = this._numbers.get(second);
          return a - b;
        }) || null;
        this._setWidgets(previous, null);
      }
      /**
       * Handle the DOM events for the focus tracker.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tracked nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "focus":
            this._evtFocus(event);
            break;
          case "blur":
            this._evtBlur(event);
            break;
        }
      }
      /**
       * Set the current and active widgets for the tracker.
       */
      _setWidgets(current, active) {
        let oldCurrent = this._currentWidget;
        this._currentWidget = current;
        let oldActive = this._activeWidget;
        this._activeWidget = active;
        if (oldCurrent !== current) {
          this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });
        }
        if (oldActive !== active) {
          this._activeChanged.emit({ oldValue: oldActive, newValue: active });
        }
      }
      /**
       * Handle the `'focus'` event for a tracked widget.
       */
      _evtFocus(event) {
        let widget = this._nodes.get(event.currentTarget);
        if (widget !== this._currentWidget) {
          this._numbers.set(widget, this._counter++);
        }
        this._setWidgets(widget, widget);
      }
      /**
       * Handle the `'blur'` event for a tracked widget.
       */
      _evtBlur(event) {
        let widget = this._nodes.get(event.currentTarget);
        let focusTarget = event.relatedTarget;
        if (!focusTarget) {
          this._setWidgets(this._currentWidget, null);
          return;
        }
        if (widget.node.contains(focusTarget)) {
          return;
        }
        if (!find2(this._widgets, (w) => w.node.contains(focusTarget))) {
          this._setWidgets(this._currentWidget, null);
          return;
        }
      }
      /**
       * Handle the `disposed` signal for a tracked widget.
       */
      _onWidgetDisposed(sender) {
        this.remove(sender);
      }
    };
    GridLayout = class extends Layout {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer()];
        this._columnSizers = [new BoxSizer()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$4.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$4.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$4.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$4.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$4.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$4.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index) {
        let sizer = this._rowSizers[index];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index, value) {
        let sizer = this._rowSizers[index];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index) {
        let sizer = this._columnSizers[index];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index, value) {
        let sizer = this._columnSizers[index];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i2 = ArrayExt3.findFirstIndex(this._items, (it2) => it2.widget === widget);
        if (i2 !== -1) {
          return;
        }
        this._items.push(new LayoutItem(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i2 = ArrayExt3.findFirstIndex(this._items, (it2) => it2.widget === widget);
        if (i2 === -1) {
          return;
        }
        let item = ArrayExt3.removeAt(this._items, i2);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i2 = 0, n = this.rowCount; i2 < n; ++i2) {
          this._rowSizers[i2].minSize = 0;
        }
        for (let i2 = 0, n = this.columnCount; i2 < n; ++i2) {
          this._columnSizers[i2].minSize = 0;
        }
        let items = this._items.filter((it2) => !it2.isHidden);
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          items[i2].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$4.rowSpanCmp);
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          let item = items[i2];
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$4.distributeMin(this._rowSizers, r1, r2, item.minHeight);
        }
        items.sort(Private$4.columnSpanCmp);
        for (let i2 = 0, n = items.length; i2 < n; ++i2) {
          let item = items[i2];
          let config = GridLayout.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$4.distributeMin(this._columnSizers, c1, c2, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i2 = 0, n = this.rowCount; i2 < n; ++i2) {
          minH += this._rowSizers[i2].minSize;
        }
        for (let i2 = 0, n = this.columnCount; i2 < n; ++i2) {
          minW += this._columnSizers[i2].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i2 = 0, pos = top, n = this.rowCount; i2 < n; ++i2) {
          this._rowStarts[i2] = pos;
          pos += this._rowSizers[i2].size + this._rowSpacing;
        }
        for (let i2 = 0, pos = left, n = this.columnCount; i2 < n; ++i2) {
          this._columnStarts[i2] = pos;
          pos += this._columnSizers[i2].size + this._columnSpacing;
        }
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x = this._columnStarts[c1];
          let y = this._rowStarts[r1];
          let w = this._columnStarts[c2] + this._columnSizers[c2].size - x;
          let h2 = this._rowStarts[r2] + this._rowSizers[r2].size - y;
          item.update(x, y, w, h2);
        }
      }
    };
    (function(GridLayout2) {
      function getCellConfig(widget) {
        return Private$4.cellConfigProperty.get(widget);
      }
      GridLayout2.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$4.cellConfigProperty.set(widget, Private$4.normalizeConfig(value));
      }
      GridLayout2.setCellConfig = setCellConfig;
    })(GridLayout || (GridLayout = {}));
    (function(Private31) {
      Private31.cellConfigProperty = new AttachedProperty3({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private31.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private31.clampValue = clampValue;
      function rowSpanCmp(a, b) {
        let c1 = Private31.cellConfigProperty.get(a.widget);
        let c2 = Private31.cellConfigProperty.get(b.widget);
        return c1.rowSpan - c2.rowSpan;
      }
      Private31.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a, b) {
        let c1 = Private31.cellConfigProperty.get(a.widget);
        let c2 = Private31.cellConfigProperty.get(b.widget);
        return c1.columnSpan - c2.columnSpan;
      }
      Private31.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count) {
        count = Math.max(1, Math.floor(count));
        while (sizers.length < count) {
          sizers.push(new BoxSizer());
        }
        if (sizers.length > count) {
          sizers.length = count;
        }
      }
      Private31.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i2, minSize) {
        if (i2 < i1) {
          return;
        }
        if (i1 === i2) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i3 = i1; i3 <= i2; ++i3) {
          totalMin += sizers[i3].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i2 - i1 + 1);
        for (let i3 = i1; i3 <= i2; ++i3) {
          sizers[i3].minSize += portion;
        }
      }
      Private31.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout) {
          child.parent.fit();
        }
      }
    })(Private$4 || (Private$4 = {}));
    MenuBar = class extends Widget {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$3.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index, menu, update = true) {
        this._closeChildMenu();
        let i2 = this._menus.indexOf(menu);
        let j = Math.max(0, Math.min(index, this._menus.length));
        if (i2 === -1) {
          ArrayExt3.insert(this._menus, j, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j === this._menus.length) {
          j--;
        }
        if (i2 === j) {
          return;
        }
        ArrayExt3.move(this._menus, i2, j);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt3.removeAt(this._menus, index);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i2 = 0; i2 < length; ++i2) {
          content[i2] = renderer.renderItem({
            title: menus[i2].title,
            active: i2 === activeIndex,
            tabbable: i2 === tabFocusIndex,
            disabled: menus[i2].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i2;
              this.activeIndex = i2;
            }
          });
          totalMenuSize += this._menuItemSizes[i2];
          if (menus[i2].title.label === this._overflowMenuOptions.title) {
            isVisible = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i2 = menus.length - 2; i2 >= length; i2--) {
              const submenu = this.menus[i2];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n = this._overflowMenu.items.length;
            for (let i2 = 0; i2 < n; ++i2) {
              let index = menus.length - 1 - i2;
              if (screenSize - totalMenuSize > this._menuItemSizes[index]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index = -1;
        let n = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i2 = 0; i2 < n; i2++) {
            let item = itemMenus[i2];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index === -1) {
              index = i2;
            }
          }
        } else {
          for (let i2 = 0; i2 < this._menuItemSizes.length; i2++) {
            totalMenuSize += this._menuItemSizes[i2];
            if (totalMenuSize > screenSize) {
              index = i2;
              break;
            }
          }
        }
        this._overflowIndex = index;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction;
          let n = this._menus.length;
          for (let i2 = 0; i2 < n; i2++) {
            let index = (n + start2 + direction * i2) % n;
            if (this._menus[index].items.length) {
              this._focusItemAt(index);
              return;
            }
          }
          return;
        }
        let key2 = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key2) {
          return;
        }
        let start = this._activeIndex + 1;
        let result = Private$3.findMnemonic(this._menus, key2, start);
        if (result.index !== -1 && !result.multiple) {
          this.activeIndex = result.index;
          this.openActiveMenu();
        } else if (result.index !== -1) {
          this.activeIndex = result.index;
          this._focusItemAt(this.activeIndex);
        } else if (result.auto !== -1) {
          this.activeIndex = result.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index);
          Menu.saveWindowData();
          this.activeIndex = index;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index = ArrayExt3.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index === this._activeIndex) {
          return;
        }
        if (index === -1 && this._childMenu) {
          return;
        }
        const position = index >= 0 && this._childMenu ? this._positionForMenu(index) : null;
        Menu.saveWindowData();
        this.activeIndex = index;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index) {
        let itemNode = this.contentNode.children[index];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index) {
        const itemNode = this.contentNode.childNodes[index];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i2 = this._activeIndex;
        let n = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i2 === n - 1 ? 0 : i2 + 1;
            break;
          case "previous":
            this.activeIndex = i2 === 0 ? n - 1 : i2 - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar2) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name2 = "lm-MenuBar-item";
          if (data.title.className) {
            name2 += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name2 += " lm-mod-active";
          }
          return name2;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name2} ${extra}` : name2;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar2.Renderer = Renderer;
      MenuBar2.defaultRenderer = new Renderer();
    })(MenuBar || (MenuBar = {}));
    (function(Private31) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private31.createNode = createNode;
      function findMnemonic(menus, key2, start) {
        let index = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key2.toUpperCase();
        for (let i2 = 0, n = menus.length; i2 < n; ++i2) {
          let k = (i2 + start) % n;
          let title = menus[k].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index === -1) {
                index = k;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k;
          }
        }
        return { index, multiple, auto };
      }
      Private31.findMnemonic = findMnemonic;
    })(Private$3 || (Private$3 = {}));
    (function(Private31) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private31.createNode = createNode;
      function findPart(scrollBar, target) {
        if (scrollBar.thumbNode.contains(target)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target)) {
          return "increment";
        }
        return null;
      }
      Private31.findPart = findPart;
    })(Private$2 || (Private$2 = {}));
    SingletonLayout = class extends Layout {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
    };
    StackedLayout = class extends PanelLayout {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v2) {
        if (this._hiddenMode === v2) {
          return;
        }
        this._hiddenMode = v2;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w) => {
            w.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        if (this._hiddenMode === Widget.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget.HiddenMode.Display;
        }
        ArrayExt3.insert(this._items, index, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt3.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        let item = ArrayExt3.removeAt(this._items, index);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget.HiddenMode.Scale) {
          widget.hiddenMode = Widget.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          nVisible += +!this._items[i2].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
          let item = this._items[i2];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i2}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private31) {
      function createLayout(options) {
        return options.layout || new StackedLayout();
      }
      Private31.createLayout = createLayout;
    })(Private$1 || (Private$1 = {}));
    (function(Private31) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private31.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private31.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private18 || (Private18 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/commandpalettesvg.js
var searchHeaderIcon, CommandPaletteSvg;
var init_commandpalettesvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/commandpalettesvg.js"() {
    init_index_es68();
    init_index_es619();
    init_style();
    init_utils2();
    init_iconimports();
    searchHeaderIcon = filterListIcon.bindprops({
      stylesheet: "commandPaletteHeader",
      className: "jp-icon-hoverShow-content"
    });
    (function(CommandPaletteSvg2) {
      class Renderer extends CommandPalette.Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          const content = this.formatHeader(data);
          return h.li({
            className: classes("lm-CommandPalette-header", "jp-icon-hoverShow")
          }, content, h.span(searchHeaderIcon));
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          const className = this.createIconClass(data);
          if (data.item.isToggled) {
            return h.div({ className }, checkIcon, data.item.iconLabel);
          }
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-CommandPalette-itemIcon";
          return classes(LabIconStyle.styleClass({
            stylesheet: "commandPaletteItem"
          }), data.item.iconClass, name2);
        }
      }
      CommandPaletteSvg2.Renderer = Renderer;
      CommandPaletteSvg2.defaultRenderer = new Renderer();
    })(CommandPaletteSvg || (CommandPaletteSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/menusvg.js
var submenuIcon, MenuSvg;
var init_menusvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/menusvg.js"() {
    init_index_es63();
    init_index_es68();
    init_index_es619();
    init_style();
    init_utils2();
    init_iconimports();
    submenuIcon = caretRightIcon.bindprops({
      stylesheet: "menuItem"
    });
    MenuSvg = class extends Menu {
      /**
       * construct a new menu. Overrides the default renderer
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options) {
        options.renderer = options.renderer || MenuSvg.defaultRenderer;
        super(options);
      }
      /**
       * insert a menu item into the menu at the specified index. Replaces the
       * default renderer for submenus
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index, options) {
        if (options.submenu) {
          MenuSvg.overrideDefaultRenderer(options.submenu);
        }
        return super.insertItem(index, options);
      }
    };
    (function(MenuSvg2) {
      function overrideDefaultRenderer(menu) {
        if (menu.renderer === Menu.defaultRenderer) {
          menu.renderer = MenuSvg2.defaultRenderer;
        }
        const originalInsertItem = menu.insertItem.bind(menu);
        menu.insertItem = (index, options) => {
          if (options.submenu) {
            MenuSvg2.overrideDefaultRenderer(options.submenu);
          }
          return originalInsertItem(index, options);
        };
        for (const item of menu._items) {
          if (item.submenu) {
            overrideDefaultRenderer(item.submenu);
          }
        }
      }
      MenuSvg2.overrideDefaultRenderer = overrideDefaultRenderer;
      class Renderer extends Menu.Renderer {
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          const className = this.createIconClass(data);
          if (data.item.isToggled) {
            return h.div({ className }, checkIcon, data.item.iconLabel);
          }
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name2 = "lm-Menu-itemIcon";
          if (data.item.type === "separator") {
            return classes(data.item.iconClass, name2);
          } else {
            return classes(LabIconStyle.styleClass({ stylesheet: "menuItem" }), data.item.iconClass, name2);
          }
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          const className = "lm-Menu-itemSubmenuIcon";
          if (data.item.type === "submenu") {
            return h.div({ className }, submenuIcon);
          } else {
            return h.div({ className });
          }
        }
      }
      MenuSvg2.Renderer = Renderer;
      MenuSvg2.defaultRenderer = new Renderer();
    })(MenuSvg || (MenuSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/tabbarsvg.js
var TabBarSvg, DockPanelSvg;
var init_tabbarsvg = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/tabbarsvg.js"() {
    init_lib();
    init_index_es68();
    init_index_es619();
    init_style();
    init_utils2();
    init_iconimports();
    TabBarSvg = class extends TabBar {
      /**
       * Construct a new tab bar. Overrides the default renderer.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        var _a;
        super({ renderer: TabBarSvg.defaultRenderer, ...options });
        const trans = ((_a = TabBarSvg.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
        addIcon.element({
          container: this.addButtonNode,
          title: trans.__("New Launcher")
        });
      }
    };
    TabBarSvg.translator = null;
    (function(TabBarSvg2) {
      class Renderer extends TabBar.Renderer {
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          var _a;
          const trans = ((_a = TabBarSvg2.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
          const title = data.title.label ? trans.__("Close %1", data.title.label) : trans.__("Close tab");
          const className = classes("jp-icon-hover lm-TabBar-tabCloseIcon", LabIconStyle.styleClass({
            elementPosition: "center",
            height: "16px",
            width: "16px"
          }));
          return hpass("div", { className, title }, closeIcon);
        }
      }
      TabBarSvg2.Renderer = Renderer;
      TabBarSvg2.defaultRenderer = new Renderer();
    })(TabBarSvg || (TabBarSvg = {}));
    DockPanelSvg = class extends DockPanel {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super({
          renderer: DockPanelSvg.defaultRenderer,
          ...options
        });
      }
    };
    (function(DockPanelSvg2) {
      class Renderer extends DockPanel.Renderer {
        /**
         * Create a new tab bar (with inline svg icons enabled
         * for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar() {
          const bar = new TabBarSvg();
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
      }
      DockPanelSvg2.Renderer = Renderer;
      DockPanelSvg2.defaultRenderer = new Renderer();
    })(DockPanelSvg || (DockPanelSvg = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/index.js
var init_widgets = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/widgets/index.js"() {
    init_commandpalettesvg();
    init_menusvg();
    init_tabbarsvg();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/icon/index.js
var init_icon2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/icon/index.js"() {
    init_iconimports();
    init_labicon();
    init_widgets();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/inputgroup.js
function InputGroup(props) {
  const { className, inputRef, rightIcon, ...others } = props;
  return import_react3.default.createElement(
    "div",
    { className: classes("jp-InputGroup", className) },
    import_react3.default.createElement("input", { ref: inputRef, ...others }),
    rightIcon && import_react3.default.createElement("span", { className: "jp-InputGroupAction" }, typeof rightIcon === "string" ? import_react3.default.createElement(LabIcon.resolveReact, { icon: rightIcon, elementPosition: "center", tag: "span" }) : import_react3.default.createElement(rightIcon.react, { elementPosition: "center", tag: "span" }))
  );
}
var import_react3;
var init_inputgroup = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/inputgroup.js"() {
    import_react3 = __toESM(require_react());
    init_icon2();
    init_utils2();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/button.js
function Button(props) {
  const { minimal, small, children, ...others } = props;
  return import_react4.default.createElement("button", { ...others, className: classes(props.className, minimal ? "jp-mod-minimal" : "", small ? "jp-mod-small" : "", "jp-Button") }, children);
}
var import_react4;
var init_button = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/button.js"() {
    import_react4 = __toESM(require_react());
    init_utils2();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/collapser.js
var init_collapser = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/collapser.js"() {
    init_index_es63();
    init_index_es619();
  }
});

// ../../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../../node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React13 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React13.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component8) {
          var prototype = Component8.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has5 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has5(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key2, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key: key2,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key2 = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key2 = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key2 = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key2 || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key2) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key2, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i2 = 0; i2 < node.length; i2++) {
                var child = node[i2];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key2 = keys[i2];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key2, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key2, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i2 = 0; i2 < children.length; i2++) {
                      validateChildKeys(children[i2], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key2) {
          {
            return jsxWithValidation(type, props, key2, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key2) {
          {
            return jsxWithValidation(type, props, key2, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.jsx = jsx;
        exports2.jsxs = jsxs;
      })();
    }
  }
});

// ../../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../../node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../../node_modules/@rjsf/utils/lib/isObject.js
var init_isObject = __esm({
  "../../node_modules/@rjsf/utils/lib/isObject.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/allowAdditionalItems.js
var init_allowAdditionalItems = __esm({
  "../../node_modules/@rjsf/utils/lib/allowAdditionalItems.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/asNumber.js
var init_asNumber = __esm({
  "../../node_modules/@rjsf/utils/lib/asNumber.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/constants.js
var ID_KEY;
var init_constants = __esm({
  "../../node_modules/@rjsf/utils/lib/constants.js"() {
    ID_KEY = "$id";
  }
});

// ../../node_modules/@rjsf/utils/lib/getUiOptions.js
var init_getUiOptions = __esm({
  "../../node_modules/@rjsf/utils/lib/getUiOptions.js"() {
    init_constants();
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/canExpand.js
var init_canExpand = __esm({
  "../../node_modules/@rjsf/utils/lib/canExpand.js"() {
    init_getUiOptions();
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject4(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject4;
  }
});

// ../../node_modules/@rjsf/utils/lib/createErrorHandler.js
var import_isPlainObject;
var init_createErrorHandler = __esm({
  "../../node_modules/@rjsf/utils/lib/createErrorHandler.js"() {
    import_isPlainObject = __toESM(require_isPlainObject());
    init_constants();
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject8(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject8;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject8 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject8(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject8 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject8(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key2) {
      var data = map2.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size = data.size;
      data.set(key2, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set7) {
      var index = -1, result = Array(set7.size);
      set7.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/isEqualWith.js
var require_isEqualWith = __commonJS({
  "../../node_modules/lodash/isEqualWith.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqualWith2(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result = customizer ? customizer(value, other) : void 0;
      return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
    }
    module2.exports = isEqualWith2;
  }
});

// ../../node_modules/@rjsf/utils/lib/deepEquals.js
var import_isEqualWith;
var init_deepEquals = __esm({
  "../../node_modules/@rjsf/utils/lib/deepEquals.js"() {
    import_isEqualWith = __toESM(require_isEqualWith());
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key2)) {
          return cache.get(key2);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key2, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key2) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key2;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get17(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get17;
  }
});

// ../../node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "../../node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty5(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key2 in value) {
        if (hasOwnProperty.call(value, key2)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty5;
  }
});

// ../../node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "../../node_modules/jsonpointer/jsonpointer.js"(exports2) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str))
        return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p2 = 1, len = pointer.length; p2 < len; ) {
        if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__")
          return obj;
        part = untilde(pointer[p2++]);
        hasNextPart = len > p2;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-")
              obj[part] = [];
            else
              obj[part] = {};
          }
        }
        if (!hasNextPart)
          break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0)
        delete obj[part];
      else
        obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "")
          return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get17(obj, pointer) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1)
        return obj;
      for (var p2 = 1; p2 < len; ) {
        obj = obj[untilde(pointer[p2++])];
        if (len === p2)
          return obj;
        if (typeof obj !== "object" || obj === null)
          return void 0;
      }
    }
    function set7(obj, pointer, value) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0)
        throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get17(object, compiled);
        },
        set: function(object, value) {
          return set7(object, compiled, value);
        }
      };
    }
    exports2.get = get17;
    exports2.set = set7;
    exports2.compile = compile;
  }
});

// ../../node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../../node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key2] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../../node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key2];
        }
        if (isNew) {
          baseAssignValue(object, key2, newValue);
        } else {
          assignValue(object, key2, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../../node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../../node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../../node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject8 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject8(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../../node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../../node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../../node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../../node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// ../../node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../../node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../../node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../../node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// ../../node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../../node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../../node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../../node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../../node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../../node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../../node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../../node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// ../../node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../../node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../../node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../../node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../../node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../../node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// ../../node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../../node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../../node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../../node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../../node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../../node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../../node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../../node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject8 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject8(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../../node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../../node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../../node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../../node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../../node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../../node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// ../../node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../../node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../../node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../../node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../../node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../../node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject8 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key2, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject8(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key3) {
          result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// ../../node_modules/lodash/last.js
var require_last = __commonJS({
  "../../node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// ../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "../../node_modules/lodash/_parent.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path2) {
      return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
    }
    module2.exports = parent;
  }
});

// ../../node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "../../node_modules/lodash/_baseUnset.js"(exports2, module2) {
    var castPath = require_castPath();
    var last = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path2) {
      path2 = castPath(path2, object);
      object = parent(object, path2);
      return object == null || delete object[toKey(last(path2))];
    }
    module2.exports = baseUnset;
  }
});

// ../../node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "../../node_modules/lodash/_customOmitClone.js"(exports2, module2) {
    var isPlainObject4 = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject4(value) ? void 0 : value;
    }
    module2.exports = customOmitClone;
  }
});

// ../../node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// ../../node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// ../../node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "../../node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// ../../node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// ../../node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// ../../node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// ../../node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// ../../node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "../../node_modules/lodash/_flatRest.js"(exports2, module2) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module2.exports = flatRest;
  }
});

// ../../node_modules/lodash/omit.js
var require_omit = __commonJS({
  "../../node_modules/lodash/omit.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit4 = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path2) {
        path2 = castPath(path2, object);
        isDeep || (isDeep = path2.length > 1);
        return path2;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    module2.exports = omit4;
  }
});

// ../../node_modules/@rjsf/utils/lib/findSchemaDefinition.js
var import_jsonpointer, import_omit;
var init_findSchemaDefinition = __esm({
  "../../node_modules/@rjsf/utils/lib/findSchemaDefinition.js"() {
    import_jsonpointer = __toESM(require_jsonpointer());
    import_omit = __toESM(require_omit());
    init_constants();
  }
});

// ../../node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key2) {
      return object != null && hasOwnProperty.call(object, key2);
    }
    module2.exports = baseHas;
  }
});

// ../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key2 = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key2))) {
          break;
        }
        object = object[key2];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/lodash/has.js
var require_has = __commonJS({
  "../../node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has5(object, path2) {
      return object != null && hasPath(object, path2, baseHas);
    }
    module2.exports = has5;
  }
});

// ../../node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "../../node_modules/lodash/isNumber.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module2.exports = isNumber3;
  }
});

// ../../node_modules/lodash/isString.js
var require_isString = __commonJS({
  "../../node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString4(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString4;
  }
});

// ../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key2 = props[fromRight ? length : ++index];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../../node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// ../../node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../../node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// ../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key2 = data[0], objValue = object[key2], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key2 in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key2, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject8 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject8(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key2 = result[length], value = object[key2];
        result[length] = [key2, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key2, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key2) {
      return object != null && key2 in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get17 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get17(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key2) {
      return function(object) {
        return object == null ? void 0 : object[key2];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    module2.exports = property;
  }
});

// ../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "../../node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// ../../node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "../../node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce2(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce2;
  }
});

// ../../node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "../../node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// ../../node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../../node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// ../../node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../../node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// ../../node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../../node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject8 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject8(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject8(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// ../../node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "../../node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// ../../node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "../../node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// ../../node_modules/lodash/times.js
var require_times = __commonJS({
  "../../node_modules/lodash/times.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var castFunction = require_castFunction();
    var toInteger = require_toInteger();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_ARRAY_LENGTH = 4294967295;
    var nativeMin = Math.min;
    function times3(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
      iteratee = castFunction(iteratee);
      n -= MAX_ARRAY_LENGTH;
      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }
    module2.exports = times3;
  }
});

// ../../node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js
var import_get;
var init_getOptionMatchingSimpleDiscriminator = __esm({
  "../../node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js"() {
    import_get = __toESM(require_get());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getMatchingOption.js
var import_get2, import_has, import_isNumber;
var init_getMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getMatchingOption.js"() {
    import_get2 = __toESM(require_get());
    import_has = __toESM(require_has());
    import_isNumber = __toESM(require_isNumber());
    init_constants();
    init_getOptionMatchingSimpleDiscriminator();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js
var init_getFirstMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js"() {
    init_getMatchingOption();
  }
});

// ../../node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "../../node_modules/lodash/isEqual.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual8(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual8;
  }
});

// ../../node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "../../node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject8 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path2, value, customizer) {
      if (!isObject8(object)) {
        return object;
      }
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key2 = toKey(path2[index]), newValue = value;
        if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key2];
          newValue = customizer ? customizer(objValue, key2, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject8(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key2, newValue);
        nested = nested[key2];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// ../../node_modules/lodash/set.js
var require_set = __commonJS({
  "../../node_modules/lodash/set.js"(exports2, module2) {
    var baseSet = require_baseSet();
    function set7(object, path2, value) {
      return object == null ? object : baseSet(object, path2, value);
    }
    module2.exports = set7;
  }
});

// ../../node_modules/lodash/transform.js
var require_transform = __commonJS({
  "../../node_modules/lodash/transform.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject8 = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform2(object, iteratee, accumulator) {
      var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject8(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
        return iteratee(accumulator, value, index, object2);
      });
      return accumulator;
    }
    module2.exports = transform2;
  }
});

// ../../node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "../../node_modules/lodash/_assignMergeValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key2, value) {
      if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    module2.exports = assignMergeValue;
  }
});

// ../../node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../../node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// ../../node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "../../node_modules/lodash/_safeGet.js"(exports2, module2) {
    function safeGet(object, key2) {
      if (key2 === "constructor" && typeof object[key2] === "function") {
        return;
      }
      if (key2 == "__proto__") {
        return;
      }
      return object[key2];
    }
    module2.exports = safeGet;
  }
});

// ../../node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "../../node_modules/lodash/toPlainObject.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module2.exports = toPlainObject;
  }
});

// ../../node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "../../node_modules/lodash/_baseMergeDeep.js"(exports2, module2) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject8 = require_isObject();
    var isPlainObject4 = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key2, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject4(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject8(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key2, newValue);
    }
    module2.exports = baseMergeDeep;
  }
});

// ../../node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "../../node_modules/lodash/_baseMerge.js"(exports2, module2) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject8 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key2) {
        stack || (stack = new Stack());
        if (isObject8(srcValue)) {
          baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key2, newValue);
        }
      }, keysIn);
    }
    module2.exports = baseMerge;
  }
});

// ../../node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// ../../node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject8 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject8(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// ../../node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "../../node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// ../../node_modules/lodash/merge.js
var require_merge = __commonJS({
  "../../node_modules/lodash/merge.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module2.exports = merge2;
  }
});

// ../../node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  "../../node_modules/lodash/flattenDeep.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep2(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    module2.exports = flattenDeep2;
  }
});

// ../../node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../../node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// ../../node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../../node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// ../../node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../../node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// ../../node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../../node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// ../../node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../../node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// ../../node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../../node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// ../../node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../../node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// ../../node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../../node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// ../../node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../../node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set7 = iteratee ? null : createSet(array);
        if (set7) {
          return setToArray(set7);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// ../../node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "../../node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq2(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq2;
  }
});

// ../../node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../../node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep3(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep3;
  }
});

// ../../node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../../node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key2, collection2) {
        result[++index] = iteratee(value, key2, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// ../../node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "../../node_modules/lodash/_baseSortBy.js"(exports2, module2) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// ../../node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "../../node_modules/lodash/_compareAscending.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// ../../node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "../../node_modules/lodash/_compareMultiple.js"(exports2, module2) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// ../../node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "../../node_modules/lodash/_baseOrderBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key2, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// ../../node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "../../node_modules/lodash/sortBy.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// ../../node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "../../node_modules/lodash/uniqWith.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// ../../node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key2 = props[propsIndex];
          var value = object[key2];
          if (value === void 0 || eq(value, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
            object[key2] = source[key2];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// ../../node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  "../../node_modules/lodash/_baseIntersection.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseIntersection;
  }
});

// ../../node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  "../../node_modules/lodash/_castArrayLikeObject.js"(exports2, module2) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module2.exports = castArrayLikeObject;
  }
});

// ../../node_modules/lodash/intersectionWith.js
var require_intersectionWith = __commonJS({
  "../../node_modules/lodash/intersectionWith.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var last = require_last();
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    module2.exports = intersectionWith;
  }
});

// ../../node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "../../node_modules/lodash/isBoolean.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module2.exports = isBoolean;
  }
});

// ../../node_modules/json-schema-compare/src/index.js
var require_src = __commonJS({
  "../../node_modules/json-schema-compare/src/index.js"(exports2, module2) {
    var isEqual8 = require_isEqual();
    var sortBy = require_sortBy();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var defaults = require_defaults();
    var intersectionWith = require_intersectionWith();
    var isPlainObject4 = require_isPlainObject();
    var isBoolean = require_isBoolean();
    var normalizeArray = (val) => Array.isArray(val) ? val : [val];
    var undef = (val) => val === void 0;
    var keys = (obj) => isPlainObject4(obj) || Array.isArray(obj) ? Object.keys(obj) : [];
    var has5 = (obj, key2) => obj.hasOwnProperty(key2);
    var stringArray = (arr) => sortBy(uniq2(arr));
    var undefEmpty = (val) => undef(val) || Array.isArray(val) && val.length === 0;
    var keyValEqual = (a, b, key2, compare2) => b && has5(b, key2) && a && has5(a, key2) && compare2(a[key2], b[key2]);
    var undefAndZero = (a, b) => undef(a) && b === 0 || undef(b) && a === 0 || isEqual8(a, b);
    var falseUndefined = (a, b) => undef(a) && b === false || undef(b) && a === false || isEqual8(a, b);
    var emptySchema = (schema) => undef(schema) || isEqual8(schema, {}) || schema === true;
    var emptyObjUndef = (schema) => undef(schema) || isEqual8(schema, {});
    var isSchema = (val) => undef(val) || isPlainObject4(val) || val === true || val === false;
    function undefArrayEqual(a, b) {
      if (undefEmpty(a) && undefEmpty(b)) {
        return true;
      } else {
        return isEqual8(stringArray(a), stringArray(b));
      }
    }
    function unsortedNormalizedArray(a, b) {
      a = normalizeArray(a);
      b = normalizeArray(b);
      return isEqual8(stringArray(a), stringArray(b));
    }
    function schemaGroup(a, b, key2, compare2) {
      var allProps = uniq2(keys(a).concat(keys(b)));
      if (emptyObjUndef(a) && emptyObjUndef(b)) {
        return true;
      } else if (emptyObjUndef(a) && keys(b).length) {
        return false;
      } else if (emptyObjUndef(b) && keys(a).length) {
        return false;
      }
      return allProps.every(function(key3) {
        var aVal = a[key3];
        var bVal = b[key3];
        if (Array.isArray(aVal) && Array.isArray(bVal)) {
          return isEqual8(stringArray(a), stringArray(b));
        } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
          return false;
        } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
          return false;
        }
        return keyValEqual(a, b, key3, compare2);
      });
    }
    function items(a, b, key2, compare2) {
      if (isPlainObject4(a) && isPlainObject4(b)) {
        return compare2(a, b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        return schemaGroup(a, b, key2, compare2);
      } else {
        return isEqual8(a, b);
      }
    }
    function unsortedArray(a, b, key2, compare2) {
      var uniqueA = uniqWith(a, compare2);
      var uniqueB = uniqWith(b, compare2);
      var inter = intersectionWith(uniqueA, uniqueB, compare2);
      return inter.length === Math.max(uniqueA.length, uniqueB.length);
    }
    var comparers = {
      title: isEqual8,
      uniqueItems: falseUndefined,
      minLength: undefAndZero,
      minItems: undefAndZero,
      minProperties: undefAndZero,
      required: undefArrayEqual,
      enum: undefArrayEqual,
      type: unsortedNormalizedArray,
      items,
      anyOf: unsortedArray,
      allOf: unsortedArray,
      oneOf: unsortedArray,
      properties: schemaGroup,
      patternProperties: schemaGroup,
      dependencies: schemaGroup
    };
    var acceptsUndefined = [
      "properties",
      "patternProperties",
      "dependencies",
      "uniqueItems",
      "minLength",
      "minItems",
      "minProperties",
      "required"
    ];
    var schemaProps = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
    function compare(a, b, options) {
      options = defaults(options, {
        ignore: []
      });
      if (emptySchema(a) && emptySchema(b)) {
        return true;
      }
      if (!isSchema(a) || !isSchema(b)) {
        throw new Error("Either of the values are not a JSON schema.");
      }
      if (a === b) {
        return true;
      }
      if (isBoolean(a) && isBoolean(b)) {
        return a === b;
      }
      if (a === void 0 && b === false || b === void 0 && a === false) {
        return false;
      }
      if (undef(a) && !undef(b) || !undef(a) && undef(b)) {
        return false;
      }
      var allKeys = uniq2(Object.keys(a).concat(Object.keys(b)));
      if (options.ignore.length) {
        allKeys = allKeys.filter((k) => options.ignore.indexOf(k) === -1);
      }
      if (!allKeys.length) {
        return true;
      }
      function innerCompare(a2, b2) {
        return compare(a2, b2, options);
      }
      return allKeys.every(function(key2) {
        var aValue = a[key2];
        var bValue = b[key2];
        if (schemaProps.indexOf(key2) !== -1) {
          return compare(aValue, bValue, options);
        }
        var comparer = comparers[key2];
        if (!comparer) {
          comparer = isEqual8;
        }
        if (isEqual8(aValue, bValue)) {
          return true;
        }
        if (acceptsUndefined.indexOf(key2) === -1) {
          if (!has5(a, key2) && has5(b, key2) || has5(a, key2) && !has5(b, key2)) {
            return aValue === bValue;
          }
        }
        var result = comparer(aValue, bValue, key2, innerCompare);
        if (!isBoolean(result)) {
          throw new Error("Comparer must return true or false");
        }
        return result;
      });
    }
    module2.exports = compare;
  }
});

// ../../node_modules/validate.io-array/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/validate.io-array/lib/index.js"(exports2, module2) {
    "use strict";
    function isArray(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    module2.exports = Array.isArray || isArray;
  }
});

// ../../node_modules/validate.io-number/lib/index.js
var require_lib8 = __commonJS({
  "../../node_modules/validate.io-number/lib/index.js"(exports2, module2) {
    "use strict";
    function isNumber3(value) {
      return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
    }
    module2.exports = isNumber3;
  }
});

// ../../node_modules/validate.io-integer/lib/index.js
var require_lib9 = __commonJS({
  "../../node_modules/validate.io-integer/lib/index.js"(exports2, module2) {
    "use strict";
    var isNumber3 = require_lib8();
    function isInteger(value) {
      return isNumber3(value) && value % 1 === 0;
    }
    module2.exports = isInteger;
  }
});

// ../../node_modules/validate.io-integer-array/lib/index.js
var require_lib10 = __commonJS({
  "../../node_modules/validate.io-integer-array/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib7();
    var isInteger = require_lib9();
    function isIntegerArray(value) {
      var len;
      if (!isArray(value)) {
        return false;
      }
      len = value.length;
      if (!len) {
        return false;
      }
      for (var i2 = 0; i2 < len; i2++) {
        if (!isInteger(value[i2])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isIntegerArray;
  }
});

// ../../node_modules/validate.io-function/lib/index.js
var require_lib11 = __commonJS({
  "../../node_modules/validate.io-function/lib/index.js"(exports2, module2) {
    "use strict";
    function isFunction(value) {
      return typeof value === "function";
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/compute-gcd/lib/index.js
var require_lib12 = __commonJS({
  "../../node_modules/compute-gcd/lib/index.js"(exports2, module2) {
    "use strict";
    var isArray = require_lib7();
    var isIntegerArray = require_lib10();
    var isFunction = require_lib11();
    var MAXINT = Math.pow(2, 31) - 1;
    function gcd(a, b) {
      var k = 1, t2;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2;
        b = b / 2;
        k = k * 2;
      }
      while (a % 2 === 0) {
        a = a / 2;
      }
      while (b) {
        while (b % 2 === 0) {
          b = b / 2;
        }
        if (a > b) {
          t2 = b;
          b = a;
          a = t2;
        }
        b = b - a;
      }
      return k * a;
    }
    function bitwise(a, b) {
      var k = 0, t2;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while ((a & 1) === 0 && (b & 1) === 0) {
        a >>>= 1;
        b >>>= 1;
        k++;
      }
      while ((a & 1) === 0) {
        a >>>= 1;
      }
      while (b) {
        while ((b & 1) === 0) {
          b >>>= 1;
        }
        if (a > b) {
          t2 = b;
          b = a;
          a = t2;
        }
        b = b - a;
      }
      return a << k;
    }
    function compute() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i2;
      args = new Array(nargs);
      for (i2 = 0; i2 < nargs; i2++) {
        args[i2] = arguments[i2];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a <= MAXINT && b <= MAXINT) {
            return bitwise(a, b);
          } else {
            return gcd(a, b);
          }
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i2 = 0; i2 < len; i2++) {
          a[i2] = clbk(arr[i2], i2);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i2 = 0; i2 < len; i2++) {
        a = arr[i2];
        if (a < 0) {
          arr[i2] = -a;
        }
      }
      a = arr[0];
      for (i2 = 1; i2 < len; i2++) {
        b = arr[i2];
        if (b <= MAXINT && a <= MAXINT) {
          a = bitwise(a, b);
        } else {
          a = gcd(a, b);
        }
      }
      return a;
    }
    module2.exports = compute;
  }
});

// ../../node_modules/compute-lcm/lib/index.js
var require_lib13 = __commonJS({
  "../../node_modules/compute-lcm/lib/index.js"(exports2, module2) {
    "use strict";
    var gcd = require_lib12();
    var isArray = require_lib7();
    var isIntegerArray = require_lib10();
    var isFunction = require_lib11();
    function lcm() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i2;
      args = new Array(nargs);
      for (i2 = 0; i2 < nargs; i2++) {
        args[i2] = arguments[i2];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a === 0 || b === 0) {
            return 0;
          }
          return a / gcd(a, b) * b;
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i2 = 0; i2 < len; i2++) {
          a[i2] = clbk(arr[i2], i2);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i2 = 0; i2 < len; i2++) {
        a = arr[i2];
        if (a < 0) {
          arr[i2] = -a;
        }
      }
      a = arr[0];
      for (i2 = 1; i2 < len; i2++) {
        b = arr[i2];
        if (a === 0 || b === 0) {
          return 0;
        }
        a = a / gcd(a, b) * b;
      }
      return a;
    }
    module2.exports = lcm;
  }
});

// ../../node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "../../node_modules/lodash/_customDefaultsMerge.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var isObject8 = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key2, object, source, stack) {
      if (isObject8(objValue) && isObject8(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module2.exports = customDefaultsMerge;
  }
});

// ../../node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "../../node_modules/lodash/mergeWith.js"(exports2, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module2.exports = mergeWith;
  }
});

// ../../node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "../../node_modules/lodash/defaultsDeep.js"(exports2, module2) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module2.exports = defaultsDeep;
  }
});

// ../../node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  "../../node_modules/lodash/intersection.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module2.exports = intersection;
  }
});

// ../../node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "../../node_modules/lodash/_baseIndexOfWith.js"(exports2, module2) {
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseIndexOfWith;
  }
});

// ../../node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "../../node_modules/lodash/_basePullAll.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module2.exports = basePullAll;
  }
});

// ../../node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "../../node_modules/lodash/pullAll.js"(exports2, module2) {
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module2.exports = pullAll;
  }
});

// ../../node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach2(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach2;
  }
});

// ../../node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../../node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// ../../node_modules/lodash/without.js
var require_without = __commonJS({
  "../../node_modules/lodash/without.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module2.exports = without;
  }
});

// ../../node_modules/json-schema-merge-allof/src/common.js
var require_common = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/common.js"(exports2, module2) {
    var flatten = require_flatten();
    var flattenDeep2 = require_flattenDeep();
    var isPlainObject4 = require_isPlainObject();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var without = require_without();
    function deleteUndefinedProps(returnObject) {
      for (const prop in returnObject) {
        if (has5(returnObject, prop) && isEmptySchema(returnObject[prop])) {
          delete returnObject[prop];
        }
      }
      return returnObject;
    }
    var allUniqueKeys = (arr) => uniq2(flattenDeep2(arr.map(keys)));
    var getValues = (schemas, key2) => schemas.map((schema) => schema && schema[key2]);
    var has5 = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName);
    var keys = (obj) => {
      if (isPlainObject4(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    };
    var notUndefined = (val) => val !== void 0;
    var isSchema = (val) => isPlainObject4(val) || val === true || val === false;
    var isEmptySchema = (obj) => !keys(obj).length && obj !== false && obj !== true;
    var withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)));
    module2.exports = {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      has: has5,
      isEmptySchema,
      isSchema,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js
var require_properties = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"(exports2, module2) {
    var compare = require_src();
    var forEach2 = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    } = require_common();
    function removeFalseSchemas(target) {
      forEach2(target, function(schema, prop) {
        if (schema === false) {
          delete target[prop];
        }
      });
    }
    function mergeSchemaGroup(group, mergeSchemas2) {
      const allKeys = allUniqueKeys(group);
      return allKeys.reduce(function(all, key2) {
        const schemas = getValues(group, key2);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key2] = mergeSchemas2(compacted, key2);
        return all;
      }, {});
    }
    module2.exports = {
      keywords: ["properties", "patternProperties", "additionalProperties"],
      resolver(values, parents, mergers, options) {
        if (!options.ignoreAdditionalProperties) {
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownKeys = keys(subSchema.properties);
            const ownPatternKeys = keys(subSchema.patternProperties);
            const ownPatterns = ownPatternKeys.map((k) => new RegExp(k));
            otherSubSchemas.forEach(function(other) {
              const allOtherKeys = keys(other.properties);
              const keysMatchingPattern = allOtherKeys.filter((k) => ownPatterns.some((pk) => pk.test(k)));
              const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);
              additionalKeys.forEach(function(key2) {
                other.properties[key2] = mergers.properties([
                  other.properties[key2],
                  subSchema.additionalProperties
                ], key2);
              });
            });
          });
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownPatternKeys = keys(subSchema.patternProperties);
            if (subSchema.additionalProperties === false) {
              otherSubSchemas.forEach(function(other) {
                const allOtherPatterns = keys(other.patternProperties);
                const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);
                additionalPatternKeys.forEach((key2) => delete other.patternProperties[key2]);
              });
            }
          });
        }
        const returnObject = {
          additionalProperties: mergers.additionalProperties(values.map((s) => s.additionalProperties)),
          patternProperties: mergeSchemaGroup(values.map((s) => s.patternProperties), mergers.patternProperties),
          properties: mergeSchemaGroup(values.map((s) => s.properties), mergers.properties)
        };
        if (returnObject.additionalProperties === false) {
          removeFalseSchemas(returnObject.properties);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js
var require_items = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"(exports2, module2) {
    var compare = require_src();
    var forEach2 = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      has: has5,
      isSchema,
      notUndefined,
      uniqWith
    } = require_common();
    function removeFalseSchemasFromArray(target) {
      forEach2(target, function(schema, index) {
        if (schema === false) {
          target.splice(index, 1);
        }
      });
    }
    function getItemSchemas(subSchemas, key2) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          const schemaAtPos = sub.items[key2];
          if (isSchema(schemaAtPos)) {
            return schemaAtPos;
          } else if (has5(sub, "additionalItems")) {
            return sub.additionalItems;
          }
        } else {
          return sub.items;
        }
        return void 0;
      });
    }
    function getAdditionalSchemas(subSchemas) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          return sub.additionalItems;
        }
        return sub.items;
      });
    }
    function mergeItems(group, mergeSchemas2, items) {
      const allKeys = allUniqueKeys(items);
      return allKeys.reduce(function(all, key2) {
        const schemas = getItemSchemas(group, key2);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key2] = mergeSchemas2(compacted, key2);
        return all;
      }, []);
    }
    module2.exports = {
      keywords: ["items", "additionalItems"],
      resolver(values, parents, mergers) {
        const items = values.map((s) => s.items);
        const itemsCompacted = items.filter(notUndefined);
        const returnObject = {};
        if (itemsCompacted.every(isSchema)) {
          returnObject.items = mergers.items(items);
        } else {
          returnObject.items = mergeItems(values, mergers.items, items);
        }
        let schemasAtLastPos;
        if (itemsCompacted.every(Array.isArray)) {
          schemasAtLastPos = values.map((s) => s.additionalItems);
        } else if (itemsCompacted.some(Array.isArray)) {
          schemasAtLastPos = getAdditionalSchemas(values);
        }
        if (schemasAtLastPos) {
          returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);
        }
        if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
          removeFalseSchemasFromArray(returnObject.items);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// ../../node_modules/json-schema-merge-allof/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/json-schema-merge-allof/src/index.js"(exports2, module2) {
    var cloneDeep3 = require_cloneDeep();
    var compare = require_src();
    var computeLcm = require_lib13();
    var defaultsDeep = require_defaultsDeep();
    var flatten = require_flatten();
    var flattenDeep2 = require_flattenDeep();
    var intersection = require_intersection();
    var intersectionWith = require_intersectionWith();
    var isEqual8 = require_isEqual();
    var isPlainObject4 = require_isPlainObject();
    var pullAll = require_pullAll();
    var sortBy = require_sortBy();
    var uniq2 = require_uniq();
    var uniqWith = require_uniqWith();
    var propertiesResolver = require_properties();
    var itemsResolver = require_items();
    var contains = (arr, val) => arr.indexOf(val) !== -1;
    var isSchema = (val) => isPlainObject4(val) || val === true || val === false;
    var isFalse = (val) => val === false;
    var isTrue = (val) => val === true;
    var schemaResolver = (compacted, key2, mergeSchemas2) => mergeSchemas2(compacted);
    var stringArray = (values) => sortBy(uniq2(flattenDeep2(values)));
    var notUndefined = (val) => val !== void 0;
    var allUniqueKeys = (arr) => uniq2(flattenDeep2(arr.map(keys)));
    var first = (compacted) => compacted[0];
    var required = (compacted) => stringArray(compacted);
    var maximumValue = (compacted) => Math.max.apply(Math, compacted);
    var minimumValue = (compacted) => Math.min.apply(Math, compacted);
    var uniqueItems = (compacted) => compacted.some(isTrue);
    var examples = (compacted) => uniqWith(flatten(compacted), isEqual8);
    function compareProp(key2) {
      return function(a, b) {
        return compare({
          [key2]: a
        }, { [key2]: b });
      };
    }
    function getAllOf(schema) {
      let { allOf = [], ...copy } = schema;
      copy = isPlainObject4(schema) ? copy : schema;
      return [copy, ...allOf.map(getAllOf)];
    }
    function getValues(schemas, key2) {
      return schemas.map((schema) => schema && schema[key2]);
    }
    function tryMergeSchemaGroups(schemaGroups, mergeSchemas2) {
      return schemaGroups.map(function(schemas, index) {
        try {
          return mergeSchemas2(schemas, index);
        } catch (e) {
          return void 0;
        }
      }).filter(notUndefined);
    }
    function keys(obj) {
      if (isPlainObject4(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    }
    function getAnyOfCombinations(arrOfArrays, combinations) {
      combinations = combinations || [];
      if (!arrOfArrays.length) {
        return combinations;
      }
      const values = arrOfArrays.slice(0).shift();
      const rest = arrOfArrays.slice(1);
      if (combinations.length) {
        return getAnyOfCombinations(rest, flatten(combinations.map((combination) => values.map((item) => [item].concat(combination)))));
      }
      return getAnyOfCombinations(rest, values.map((item) => item));
    }
    function throwIncompatible(values, paths) {
      let asJSON;
      try {
        asJSON = values.map(function(val) {
          return JSON.stringify(val, null, 2);
        }).join("\n");
      } catch (variable) {
        asJSON = values.join(", ");
      }
      throw new Error('Could not resolve values for path:"' + paths.join(".") + '". They are probably incompatible. Values: \n' + asJSON);
    }
    function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas2, options, parents) {
      if (complexKeywords.length) {
        const resolverConfig = options.complexResolvers[resolverName];
        if (!resolverConfig || !resolverConfig.resolver) {
          throw new Error("No resolver found for " + resolverName);
        }
        const extractedKeywordsOnly = schemas.map((schema) => complexKeywords.reduce((all, key2) => {
          if (schema[key2] !== void 0)
            all[key2] = schema[key2];
          return all;
        }, {}));
        const unique = uniqWith(extractedKeywordsOnly, compare);
        const mergers = resolverConfig.keywords.reduce((all, key2) => ({
          ...all,
          [key2]: (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key2, extraKey))
        }), {});
        const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);
        if (!isPlainObject4(result)) {
          throwIncompatible(unique, parents.concat(resolverName));
        }
        return result;
      }
    }
    function createRequiredMetaArray(arr) {
      return { required: arr };
    }
    var schemaGroupProps = ["properties", "patternProperties", "definitions", "dependencies"];
    var schemaArrays = ["anyOf", "oneOf"];
    var schemaProps = [
      "additionalProperties",
      "additionalItems",
      "contains",
      "propertyNames",
      "not",
      "items"
    ];
    var defaultResolvers = {
      type(compacted) {
        if (compacted.some(Array.isArray)) {
          const normalized = compacted.map(function(val) {
            return Array.isArray(val) ? val : [val];
          });
          const common = intersection.apply(null, normalized);
          if (common.length === 1) {
            return common[0];
          } else if (common.length > 1) {
            return uniq2(common);
          }
        }
      },
      dependencies(compacted, paths, mergeSchemas2) {
        const allChildren = allUniqueKeys(compacted);
        return allChildren.reduce(function(all, childKey) {
          const childSchemas = getValues(compacted, childKey);
          let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual8);
          const innerArrays = innerCompacted.filter(Array.isArray);
          if (innerArrays.length) {
            if (innerArrays.length === innerCompacted.length) {
              all[childKey] = stringArray(innerCompacted);
            } else {
              const innerSchemas = innerCompacted.filter(isSchema);
              const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);
              all[childKey] = mergeSchemas2(innerSchemas.concat(arrayMetaScheams), childKey);
            }
            return all;
          }
          innerCompacted = uniqWith(innerCompacted, compare);
          all[childKey] = mergeSchemas2(innerCompacted, childKey);
          return all;
        }, {});
      },
      oneOf(compacted, paths, mergeSchemas2) {
        const combinations = getAnyOfCombinations(cloneDeep3(compacted));
        const result = tryMergeSchemaGroups(combinations, mergeSchemas2);
        const unique = uniqWith(result, compare);
        if (unique.length) {
          return unique;
        }
      },
      not(compacted) {
        return { anyOf: compacted };
      },
      pattern(compacted) {
        return compacted.map((r2) => "(?=" + r2 + ")").join("");
      },
      multipleOf(compacted) {
        let integers = compacted.slice(0);
        let factor = 1;
        while (integers.some((n) => !Number.isInteger(n))) {
          integers = integers.map((n) => n * 10);
          factor = factor * 10;
        }
        return computeLcm(integers) / factor;
      },
      enum(compacted) {
        const enums = intersectionWith.apply(null, compacted.concat(isEqual8));
        if (enums.length) {
          return sortBy(enums);
        }
      }
    };
    defaultResolvers.$id = first;
    defaultResolvers.$ref = first;
    defaultResolvers.$schema = first;
    defaultResolvers.additionalItems = schemaResolver;
    defaultResolvers.additionalProperties = schemaResolver;
    defaultResolvers.anyOf = defaultResolvers.oneOf;
    defaultResolvers.contains = schemaResolver;
    defaultResolvers.default = first;
    defaultResolvers.definitions = defaultResolvers.dependencies;
    defaultResolvers.description = first;
    defaultResolvers.examples = examples;
    defaultResolvers.exclusiveMaximum = minimumValue;
    defaultResolvers.exclusiveMinimum = maximumValue;
    defaultResolvers.items = itemsResolver;
    defaultResolvers.maximum = minimumValue;
    defaultResolvers.maxItems = minimumValue;
    defaultResolvers.maxLength = minimumValue;
    defaultResolvers.maxProperties = minimumValue;
    defaultResolvers.minimum = maximumValue;
    defaultResolvers.minItems = maximumValue;
    defaultResolvers.minLength = maximumValue;
    defaultResolvers.minProperties = maximumValue;
    defaultResolvers.properties = propertiesResolver;
    defaultResolvers.propertyNames = schemaResolver;
    defaultResolvers.required = required;
    defaultResolvers.title = first;
    defaultResolvers.uniqueItems = uniqueItems;
    var defaultComplexResolvers = {
      properties: propertiesResolver,
      items: itemsResolver
    };
    function merger(rootSchema, options, totalSchemas) {
      totalSchemas = totalSchemas || [];
      options = defaultsDeep(options, {
        ignoreAdditionalProperties: false,
        resolvers: defaultResolvers,
        complexResolvers: defaultComplexResolvers,
        deep: true
      });
      const complexResolvers = Object.entries(options.complexResolvers);
      function mergeSchemas2(schemas, base, parents) {
        schemas = cloneDeep3(schemas.filter(notUndefined));
        parents = parents || [];
        const merged2 = isPlainObject4(base) ? base : {};
        if (!schemas.length) {
          return;
        }
        if (schemas.some(isFalse)) {
          return false;
        }
        if (schemas.every(isTrue)) {
          return true;
        }
        schemas = schemas.filter(isPlainObject4);
        const allKeys = allUniqueKeys(schemas);
        if (options.deep && contains(allKeys, "allOf")) {
          return merger({
            allOf: schemas
          }, options, totalSchemas);
        }
        const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) => allKeys.filter((k) => resolverConf.keywords.includes(k)));
        complexKeysArr.forEach((keys2) => pullAll(allKeys, keys2));
        allKeys.forEach(function(key2) {
          const values = getValues(schemas, key2);
          const compacted = uniqWith(values.filter(notUndefined), compareProp(key2));
          if (compacted.length === 1 && contains(schemaArrays, key2)) {
            merged2[key2] = compacted[0].map((schema) => mergeSchemas2([schema], schema));
          } else if (compacted.length === 1 && !contains(schemaGroupProps, key2) && !contains(schemaProps, key2)) {
            merged2[key2] = compacted[0];
          } else {
            const resolver = options.resolvers[key2] || options.resolvers.defaultResolver;
            if (!resolver)
              throw new Error("No resolver found for key " + key2 + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
            const merger2 = (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key2, extraKey));
            merged2[key2] = resolver(compacted, parents.concat(key2), merger2, options);
            if (merged2[key2] === void 0) {
              throwIncompatible(compacted, parents.concat(key2));
            } else if (merged2[key2] === void 0) {
              delete merged2[key2];
            }
          }
        });
        return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({
          ...all,
          ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas2, options, parents)
        }), merged2);
      }
      const allSchemas = flattenDeep2(getAllOf(rootSchema));
      const merged = mergeSchemas2(allSchemas);
      return merged;
    }
    merger.options = {
      resolvers: defaultResolvers
    };
    module2.exports = merger;
  }
});

// ../../node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js
var import_get3, import_isString;
var init_getDiscriminatorFieldFromSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js"() {
    import_get3 = __toESM(require_get());
    import_isString = __toESM(require_isString());
  }
});

// ../../node_modules/@rjsf/utils/lib/guessType.js
var init_guessType = __esm({
  "../../node_modules/@rjsf/utils/lib/guessType.js"() {
  }
});

// ../../node_modules/lodash/union.js
var require_union = __commonJS({
  "../../node_modules/lodash/union.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union2 = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module2.exports = union2;
  }
});

// ../../node_modules/@rjsf/utils/lib/getSchemaType.js
var init_getSchemaType = __esm({
  "../../node_modules/@rjsf/utils/lib/getSchemaType.js"() {
    init_guessType();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeSchemas.js
var import_union;
var init_mergeSchemas = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeSchemas.js"() {
    import_union = __toESM(require_union());
    init_constants();
    init_getSchemaType();
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/retrieveSchema.js
var import_get4, import_isEqual, import_set, import_times, import_transform, import_merge, import_flattenDeep, import_uniq, import_json_schema_merge_allof;
var init_retrieveSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/retrieveSchema.js"() {
    import_get4 = __toESM(require_get());
    import_isEqual = __toESM(require_isEqual());
    import_set = __toESM(require_set());
    import_times = __toESM(require_times());
    import_transform = __toESM(require_transform());
    import_merge = __toESM(require_merge());
    import_flattenDeep = __toESM(require_flattenDeep());
    import_uniq = __toESM(require_uniq());
    import_json_schema_merge_allof = __toESM(require_src2());
    init_constants();
    init_findSchemaDefinition();
    init_getDiscriminatorFieldFromSchema();
    init_guessType();
    init_isObject();
    init_mergeSchemas();
    init_getFirstMatchingOption();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js
var import_get5, import_has2, import_isNumber2, import_isObject5, import_isString2, import_reduce, import_times2;
var init_getClosestMatchingOption = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js"() {
    import_get5 = __toESM(require_get());
    import_has2 = __toESM(require_has());
    import_isNumber2 = __toESM(require_isNumber());
    import_isObject5 = __toESM(require_isObject());
    import_isString2 = __toESM(require_isString());
    import_reduce = __toESM(require_reduce());
    import_times2 = __toESM(require_times());
    init_getFirstMatchingOption();
    init_retrieveSchema();
    init_constants();
    init_guessType();
    init_getDiscriminatorFieldFromSchema();
    init_getOptionMatchingSimpleDiscriminator();
  }
});

// ../../node_modules/@rjsf/utils/lib/isFixedItems.js
var init_isFixedItems = __esm({
  "../../node_modules/@rjsf/utils/lib/isFixedItems.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js
var import_get6;
var init_mergeDefaultsWithFormData = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js"() {
    import_get6 = __toESM(require_get());
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/mergeObjects.js
var init_mergeObjects = __esm({
  "../../node_modules/@rjsf/utils/lib/mergeObjects.js"() {
    init_isObject();
  }
});

// ../../node_modules/@rjsf/utils/lib/isConstant.js
var init_isConstant = __esm({
  "../../node_modules/@rjsf/utils/lib/isConstant.js"() {
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isSelect.js
var init_isSelect = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isSelect.js"() {
    init_isConstant();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isMultiSelect.js
var init_isMultiSelect = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isMultiSelect.js"() {
    init_isSelect();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
var import_get7, import_isEmpty, AdditionalItemsHandling;
var init_getDefaultFormState = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js"() {
    import_get7 = __toESM(require_get());
    import_isEmpty = __toESM(require_isEmpty());
    init_constants();
    init_findSchemaDefinition();
    init_getClosestMatchingOption();
    init_getDiscriminatorFieldFromSchema();
    init_getSchemaType();
    init_isObject();
    init_isFixedItems();
    init_mergeDefaultsWithFormData();
    init_mergeObjects();
    init_mergeSchemas();
    init_isMultiSelect();
    init_retrieveSchema();
    (function(AdditionalItemsHandling2) {
      AdditionalItemsHandling2[AdditionalItemsHandling2["Ignore"] = 0] = "Ignore";
      AdditionalItemsHandling2[AdditionalItemsHandling2["Invert"] = 1] = "Invert";
      AdditionalItemsHandling2[AdditionalItemsHandling2["Fallback"] = 2] = "Fallback";
    })(AdditionalItemsHandling || (AdditionalItemsHandling = {}));
  }
});

// ../../node_modules/@rjsf/utils/lib/isCustomWidget.js
var init_isCustomWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/isCustomWidget.js"() {
    init_getUiOptions();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/isFilesArray.js
var init_isFilesArray = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/isFilesArray.js"() {
    init_constants();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js
var init_getDisplayLabel = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js"() {
    init_constants();
    init_getSchemaType();
    init_getUiOptions();
    init_isCustomWidget();
    init_isFilesArray();
    init_isMultiSelect();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/mergeValidationData.js
var import_isEmpty2;
var init_mergeValidationData = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/mergeValidationData.js"() {
    import_isEmpty2 = __toESM(require_isEmpty());
    init_mergeObjects();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js
var import_get8, import_has3, NO_VALUE;
var init_sanitizeDataForNewSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js"() {
    import_get8 = __toESM(require_get());
    import_has3 = __toESM(require_has());
    init_constants();
    init_retrieveSchema();
    NO_VALUE = Symbol("no Value");
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/toIdSchema.js
var import_get9, import_isEqual2;
var init_toIdSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/toIdSchema.js"() {
    import_get9 = __toESM(require_get());
    import_isEqual2 = __toESM(require_isEqual());
    init_constants();
    init_isObject();
    init_retrieveSchema();
    init_getSchemaType();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/toPathSchema.js
var import_get10, import_isEqual3, import_set2;
var init_toPathSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/toPathSchema.js"() {
    import_get10 = __toESM(require_get());
    import_isEqual3 = __toESM(require_isEqual());
    import_set2 = __toESM(require_set());
    init_constants();
    init_getDiscriminatorFieldFromSchema();
    init_getClosestMatchingOption();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/schema/index.js
var init_schema = __esm({
  "../../node_modules/@rjsf/utils/lib/schema/index.js"() {
    init_getDefaultFormState();
    init_getDisplayLabel();
    init_getClosestMatchingOption();
    init_getFirstMatchingOption();
    init_getMatchingOption();
    init_isFilesArray();
    init_isMultiSelect();
    init_isSelect();
    init_mergeValidationData();
    init_retrieveSchema();
    init_sanitizeDataForNewSchema();
    init_toIdSchema();
    init_toPathSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/createSchemaUtils.js
var init_createSchemaUtils = __esm({
  "../../node_modules/@rjsf/utils/lib/createSchemaUtils.js"() {
    init_deepEquals();
    init_schema();
  }
});

// ../../node_modules/@rjsf/utils/lib/dataURItoBlob.js
var init_dataURItoBlob = __esm({
  "../../node_modules/@rjsf/utils/lib/dataURItoBlob.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/replaceStringParameters.js
var init_replaceStringParameters = __esm({
  "../../node_modules/@rjsf/utils/lib/replaceStringParameters.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/englishStringTranslator.js
var init_englishStringTranslator = __esm({
  "../../node_modules/@rjsf/utils/lib/englishStringTranslator.js"() {
    init_replaceStringParameters();
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js
var init_enumOptionsValueForIndex = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js
var import_isEqual4;
var init_enumOptionsDeselectValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js"() {
    import_isEqual4 = __toESM(require_isEqual());
    init_enumOptionsValueForIndex();
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js
var import_isEqual5;
var init_enumOptionsIsSelected = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js"() {
    import_isEqual5 = __toESM(require_isEqual());
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js
var init_enumOptionsIndexForValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js"() {
    init_enumOptionsIsSelected();
  }
});

// ../../node_modules/lodash/isNil.js
var require_isNil = __commonJS({
  "../../node_modules/lodash/isNil.js"(exports2, module2) {
    function isNil2(value) {
      return value == null;
    }
    module2.exports = isNil2;
  }
});

// ../../node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js
var import_isNil;
var init_enumOptionsSelectValue = __esm({
  "../../node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js"() {
    init_enumOptionsValueForIndex();
    import_isNil = __toESM(require_isNil());
  }
});

// ../../node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js
var import_cloneDeep, import_get11, import_set3;
var init_ErrorSchemaBuilder = __esm({
  "../../node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js"() {
    import_cloneDeep = __toESM(require_cloneDeep());
    import_get11 = __toESM(require_get());
    import_set3 = __toESM(require_set());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/getDateElementProps.js
var init_getDateElementProps = __esm({
  "../../node_modules/@rjsf/utils/lib/getDateElementProps.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/rangeSpec.js
var init_rangeSpec = __esm({
  "../../node_modules/@rjsf/utils/lib/rangeSpec.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/getInputProps.js
var init_getInputProps = __esm({
  "../../node_modules/@rjsf/utils/lib/getInputProps.js"() {
    init_rangeSpec();
  }
});

// ../../node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js
var init_getSubmitButtonOptions = __esm({
  "../../node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js"() {
    init_constants();
    init_getUiOptions();
  }
});

// ../../node_modules/@rjsf/utils/lib/getTemplate.js
var init_getTemplate = __esm({
  "../../node_modules/@rjsf/utils/lib/getTemplate.js"() {
  }
});

// ../../node_modules/@rjsf/utils/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../../node_modules/@rjsf/utils/node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element2;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.SuspenseList = SuspenseList;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isSuspenseList = isSuspenseList;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// ../../node_modules/@rjsf/utils/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../../node_modules/@rjsf/utils/node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// ../../node_modules/@rjsf/utils/lib/getWidget.js
var import_jsx_runtime, import_react5, import_react_is, import_get12, import_set4;
var init_getWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/getWidget.js"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
    import_react5 = __toESM(require_react());
    import_react_is = __toESM(require_react_is());
    import_get12 = __toESM(require_get());
    import_set4 = __toESM(require_set());
    init_getSchemaType();
  }
});

// ../../node_modules/@rjsf/utils/lib/hashForSchema.js
var init_hashForSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/hashForSchema.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/hasWidget.js
var init_hasWidget = __esm({
  "../../node_modules/@rjsf/utils/lib/hasWidget.js"() {
    init_getWidget();
  }
});

// ../../node_modules/@rjsf/utils/lib/idGenerators.js
function idGenerator(id, suffix) {
  const theId = (0, import_isString3.default)(id) ? id : id[ID_KEY];
  return `${theId}__${suffix}`;
}
function descriptionId(id) {
  return idGenerator(id, "description");
}
function errorId(id) {
  return idGenerator(id, "error");
}
function examplesId(id) {
  return idGenerator(id, "examples");
}
function helpId(id) {
  return idGenerator(id, "help");
}
function ariaDescribedByIds(id, includeExamples = false) {
  const examples = includeExamples ? ` ${examplesId(id)}` : "";
  return `${errorId(id)} ${descriptionId(id)} ${helpId(id)}${examples}`;
}
var import_isString3;
var init_idGenerators = __esm({
  "../../node_modules/@rjsf/utils/lib/idGenerators.js"() {
    import_isString3 = __toESM(require_isString());
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/labelValue.js
var init_labelValue = __esm({
  "../../node_modules/@rjsf/utils/lib/labelValue.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/localToUTC.js
var init_localToUTC = __esm({
  "../../node_modules/@rjsf/utils/lib/localToUTC.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/toConstant.js
var init_toConstant = __esm({
  "../../node_modules/@rjsf/utils/lib/toConstant.js"() {
    init_constants();
  }
});

// ../../node_modules/@rjsf/utils/lib/optionsList.js
var init_optionsList = __esm({
  "../../node_modules/@rjsf/utils/lib/optionsList.js"() {
    init_toConstant();
  }
});

// ../../node_modules/@rjsf/utils/lib/orderProperties.js
var init_orderProperties = __esm({
  "../../node_modules/@rjsf/utils/lib/orderProperties.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/pad.js
var init_pad = __esm({
  "../../node_modules/@rjsf/utils/lib/pad.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/parseDateString.js
var init_parseDateString = __esm({
  "../../node_modules/@rjsf/utils/lib/parseDateString.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js
var init_schemaRequiresTrueValue = __esm({
  "../../node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/shouldRender.js
var init_shouldRender = __esm({
  "../../node_modules/@rjsf/utils/lib/shouldRender.js"() {
    init_deepEquals();
  }
});

// ../../node_modules/@rjsf/utils/lib/toDateString.js
var init_toDateString = __esm({
  "../../node_modules/@rjsf/utils/lib/toDateString.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/toErrorList.js
var import_isPlainObject2;
var init_toErrorList = __esm({
  "../../node_modules/@rjsf/utils/lib/toErrorList.js"() {
    import_isPlainObject2 = __toESM(require_isPlainObject());
    init_constants();
  }
});

// ../../node_modules/lodash/toPath.js
var require_toPath = __commonJS({
  "../../node_modules/lodash/toPath.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var copyArray = require_copyArray();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var stringToPath = require_stringToPath();
    var toKey = require_toKey();
    var toString = require_toString();
    function toPath2(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }
    module2.exports = toPath2;
  }
});

// ../../node_modules/@rjsf/utils/lib/toErrorSchema.js
var import_toPath;
var init_toErrorSchema = __esm({
  "../../node_modules/@rjsf/utils/lib/toErrorSchema.js"() {
    import_toPath = __toESM(require_toPath());
    init_ErrorSchemaBuilder();
  }
});

// ../../node_modules/@rjsf/utils/lib/unwrapErrorHandler.js
var import_isPlainObject3;
var init_unwrapErrorHandler = __esm({
  "../../node_modules/@rjsf/utils/lib/unwrapErrorHandler.js"() {
    import_isPlainObject3 = __toESM(require_isPlainObject());
  }
});

// ../../node_modules/@rjsf/utils/lib/utcToLocal.js
var init_utcToLocal = __esm({
  "../../node_modules/@rjsf/utils/lib/utcToLocal.js"() {
    init_pad();
  }
});

// ../../node_modules/@rjsf/utils/lib/validationDataMerge.js
var import_isEmpty3;
var init_validationDataMerge = __esm({
  "../../node_modules/@rjsf/utils/lib/validationDataMerge.js"() {
    import_isEmpty3 = __toESM(require_isEmpty());
    init_mergeObjects();
    init_toErrorList();
  }
});

// ../../node_modules/@rjsf/utils/lib/withIdRefPrefix.js
var import_isObject11;
var init_withIdRefPrefix = __esm({
  "../../node_modules/@rjsf/utils/lib/withIdRefPrefix.js"() {
    init_constants();
    import_isObject11 = __toESM(require_isObject());
  }
});

// ../../node_modules/@rjsf/utils/lib/types.js
var init_types = __esm({
  "../../node_modules/@rjsf/utils/lib/types.js"() {
  }
});

// ../../node_modules/@rjsf/utils/lib/enums.js
var TranslatableString;
var init_enums = __esm({
  "../../node_modules/@rjsf/utils/lib/enums.js"() {
    (function(TranslatableString2) {
      TranslatableString2["ArrayItemTitle"] = "Item";
      TranslatableString2["MissingItems"] = "Missing items definition";
      TranslatableString2["YesLabel"] = "Yes";
      TranslatableString2["NoLabel"] = "No";
      TranslatableString2["CloseLabel"] = "Close";
      TranslatableString2["ErrorsLabel"] = "Errors";
      TranslatableString2["NewStringDefault"] = "New Value";
      TranslatableString2["AddButton"] = "Add";
      TranslatableString2["AddItemButton"] = "Add Item";
      TranslatableString2["CopyButton"] = "Copy";
      TranslatableString2["MoveDownButton"] = "Move down";
      TranslatableString2["MoveUpButton"] = "Move up";
      TranslatableString2["RemoveButton"] = "Remove";
      TranslatableString2["NowLabel"] = "Now";
      TranslatableString2["ClearLabel"] = "Clear";
      TranslatableString2["AriaDateLabel"] = "Select a date";
      TranslatableString2["PreviewLabel"] = "Preview";
      TranslatableString2["DecrementAriaLabel"] = "Decrease value by 1";
      TranslatableString2["IncrementAriaLabel"] = "Increase value by 1";
      TranslatableString2["UnknownFieldType"] = "Unknown field type %1";
      TranslatableString2["OptionPrefix"] = "Option %1";
      TranslatableString2["TitleOptionPrefix"] = "%1 option %2";
      TranslatableString2["KeyLabel"] = "%1 Key";
      TranslatableString2["InvalidObjectField"] = 'Invalid "%1" object field configuration: <em>%2</em>.';
      TranslatableString2["UnsupportedField"] = "Unsupported field schema.";
      TranslatableString2["UnsupportedFieldWithId"] = "Unsupported field schema for field <code>%1</code>.";
      TranslatableString2["UnsupportedFieldWithReason"] = "Unsupported field schema: <em>%1</em>.";
      TranslatableString2["UnsupportedFieldWithIdAndReason"] = "Unsupported field schema for field <code>%1</code>: <em>%2</em>.";
      TranslatableString2["FilesInfo"] = "**%1** (%2, %3 bytes)";
    })(TranslatableString || (TranslatableString = {}));
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/ParserValidator.js
var import_get13, import_isEqual6;
var init_ParserValidator = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/ParserValidator.js"() {
    import_get13 = __toESM(require_get());
    import_isEqual6 = __toESM(require_isEqual());
    init_constants();
    init_hashForSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/schemaParser.js
var import_forEach, import_isEqual7;
var init_schemaParser = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/schemaParser.js"() {
    import_forEach = __toESM(require_forEach());
    import_isEqual7 = __toESM(require_isEqual());
    init_constants();
    init_ParserValidator();
    init_retrieveSchema();
  }
});

// ../../node_modules/@rjsf/utils/lib/parser/index.js
var init_parser = __esm({
  "../../node_modules/@rjsf/utils/lib/parser/index.js"() {
    init_schemaParser();
  }
});

// ../../node_modules/@rjsf/utils/lib/index.js
var init_lib2 = __esm({
  "../../node_modules/@rjsf/utils/lib/index.js"() {
    init_allowAdditionalItems();
    init_asNumber();
    init_canExpand();
    init_createErrorHandler();
    init_createSchemaUtils();
    init_dataURItoBlob();
    init_deepEquals();
    init_englishStringTranslator();
    init_enumOptionsDeselectValue();
    init_enumOptionsIndexForValue();
    init_enumOptionsIsSelected();
    init_enumOptionsSelectValue();
    init_enumOptionsValueForIndex();
    init_ErrorSchemaBuilder();
    init_findSchemaDefinition();
    init_getDateElementProps();
    init_getDiscriminatorFieldFromSchema();
    init_getInputProps();
    init_getSchemaType();
    init_getSubmitButtonOptions();
    init_getTemplate();
    init_getUiOptions();
    init_getWidget();
    init_guessType();
    init_hashForSchema();
    init_hasWidget();
    init_idGenerators();
    init_isConstant();
    init_isCustomWidget();
    init_isFixedItems();
    init_isObject();
    init_labelValue();
    init_localToUTC();
    init_mergeDefaultsWithFormData();
    init_mergeObjects();
    init_mergeSchemas();
    init_optionsList();
    init_orderProperties();
    init_pad();
    init_parseDateString();
    init_rangeSpec();
    init_replaceStringParameters();
    init_schemaRequiresTrueValue();
    init_shouldRender();
    init_toConstant();
    init_toDateString();
    init_toErrorList();
    init_toErrorSchema();
    init_unwrapErrorHandler();
    init_utcToLocal();
    init_validationDataMerge();
    init_withIdRefPrefix();
    init_getOptionMatchingSimpleDiscriminator();
    init_types();
    init_enums();
    init_constants();
    init_parser();
    init_schema();
  }
});

// ../../node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "../../node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path2 = paths[index], value = baseGet(object, path2);
        if (predicate(value, path2)) {
          baseSet(result, castPath(path2, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// ../../node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "../../node_modules/lodash/_basePick.js"(exports2, module2) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path2) {
        return hasIn(object, path2);
      });
    }
    module2.exports = basePick;
  }
});

// ../../node_modules/lodash/pick.js
var require_pick = __commonJS({
  "../../node_modules/lodash/pick.js"(exports2, module2) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module2.exports = pick;
  }
});

// ../../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key2, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c < 3 ? d2(r2) : c > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn)
      context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key2] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p2 in m)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
      __createBinding(o, m, p2);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n) {
    if (g[n])
      i2[n] = function(v2) {
        return new Promise(function(a, b) {
          q.push([n, v2, a, b]) > 1 || resume(n, v2);
        });
      };
  }
  function resume(n, v2) {
    try {
      step(g[n](v2));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v2) {
    if (f(v2), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n, f) {
    i2[n] = o[n] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o[n](v2)), done: false } : f ? f(v2) : v2;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../../node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d2, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d3[p2] = b2[p2];
      };
      return extendStatics(d2, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t2[p2] = s[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault: __importDefault2,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/ArrayField.js
var import_jsx_runtime2, import_react6, import_cloneDeep2, import_get14, import_isObject13, import_set5;
var init_ArrayField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/ArrayField.js"() {
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    import_react6 = __toESM(require_react());
    init_lib2();
    import_cloneDeep2 = __toESM(require_cloneDeep());
    import_get14 = __toESM(require_get());
    import_isObject13 = __toESM(require_isObject());
    import_set5 = __toESM(require_set());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/BooleanField.js
var import_jsx_runtime3, import_isObject14;
var init_BooleanField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/BooleanField.js"() {
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    init_lib2();
    import_isObject14 = __toESM(require_isObject());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js
var import_jsx_runtime4, import_react7, import_get15, import_isEmpty4, import_omit2;
var init_MultiSchemaField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js"() {
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    import_react7 = __toESM(require_react());
    import_get15 = __toESM(require_get());
    import_isEmpty4 = __toESM(require_isEmpty());
    import_omit2 = __toESM(require_omit());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/NumberField.js
var import_jsx_runtime5, import_react8;
var init_NumberField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/NumberField.js"() {
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    import_react8 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/markdown-to-jsx/dist/index.modern.js
function _t(t2) {
  return "( *)(" + (1 === t2 ? ct : at) + ") +";
}
function st(t2) {
  return new RegExp("^" + (1 === t2 ? ut : it));
}
function dt(t2) {
  return new RegExp("^" + (1 === t2 ? ut : it) + "[^\\n]*(?:\\n(?!\\1" + (1 === t2 ? ct : at) + " )[^\\n]*)*(\\n|$)", "gm");
}
function gt(t2) {
  const n = 1 === t2 ? ct : at;
  return new RegExp("^( *)(" + n + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + n + " (?!" + n + " ))\\n*|\\s*\\n*$)");
}
var t, r, i, d, p, $, v, S, z, A, L, R, ct, at, ut, it, lt, ft, pt, mt, yt, ht, $t, vt, Ht;
var init_index_modern = __esm({
  "../../node_modules/markdown-to-jsx/dist/index.modern.js"() {
    t = __toESM(require_react(), 1);
    r = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "className", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((t2, n) => (t2[n.toLowerCase()] = n, t2), { for: "htmlFor" });
    i = /^( *>[^\n]+(\n[^\n]+)*\n*)+\n{2,}/;
    d = /^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/;
    p = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/;
    $ = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
    v = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
    S = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/;
    z = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?([^>]*)\/{0}>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1)[\s\S])*?)<\/\1>\n*/i;
    A = /^<!--[\s\S]*?(?:-->)/;
    L = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i;
    R = /^(.*\|?.*)\n *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*)\n?/;
    ct = "(?:\\d+\\.)";
    at = "(?:[*+-])";
    ut = _t(1);
    it = _t(2);
    lt = st(1);
    ft = st(2);
    pt = dt(1);
    mt = dt(2);
    yt = gt(1);
    ht = gt(2);
    $t = [i, d, p, $, S, v, A, R, pt, yt, mt, ht];
    vt = [...$t, /^[^\n]+(?:  \n|\n{2,})/, z, L];
    !function(t2) {
      t2[t2.MAX = 0] = "MAX", t2[t2.HIGH = 1] = "HIGH", t2[t2.MED = 2] = "MED", t2[t2.LOW = 3] = "LOW", t2[t2.MIN = 4] = "MIN";
    }(Ht || (Ht = {}));
  }
});

// ../../node_modules/lodash/unset.js
var require_unset = __commonJS({
  "../../node_modules/lodash/unset.js"(exports2, module2) {
    var baseUnset = require_baseUnset();
    function unset2(object, path2) {
      return object == null ? true : baseUnset(object, path2);
    }
    module2.exports = unset2;
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/ObjectField.js
var import_jsx_runtime6, import_react9, import_get16, import_has4, import_isObject15, import_set6, import_unset;
var init_ObjectField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/ObjectField.js"() {
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    import_react9 = __toESM(require_react());
    init_lib2();
    init_index_modern();
    import_get16 = __toESM(require_get());
    import_has4 = __toESM(require_has());
    import_isObject15 = __toESM(require_isObject());
    import_set6 = __toESM(require_set());
    import_unset = __toESM(require_unset());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/SchemaField.js
var import_jsx_runtime7, import_react10, import_isObject16, import_omit3;
var init_SchemaField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/SchemaField.js"() {
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    import_react10 = __toESM(require_react());
    init_lib2();
    import_isObject16 = __toESM(require_isObject());
    import_omit3 = __toESM(require_omit());
    init_index_modern();
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/StringField.js
var import_jsx_runtime8;
var init_StringField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/StringField.js"() {
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/NullField.js
var import_react11;
var init_NullField = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/NullField.js"() {
    import_react11 = __toESM(require_react());
  }
});

// ../../node_modules/@rjsf/core/lib/components/fields/index.js
var init_fields = __esm({
  "../../node_modules/@rjsf/core/lib/components/fields/index.js"() {
    init_ArrayField();
    init_BooleanField();
    init_MultiSchemaField();
    init_NumberField();
    init_ObjectField();
    init_SchemaField();
    init_StringField();
    init_NullField();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js
var import_jsx_runtime9;
var init_ArrayFieldDescriptionTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js"() {
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js
var import_jsx_runtime10;
var init_ArrayFieldItemTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js"() {
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js
var import_jsx_runtime11;
var init_ArrayFieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js"() {
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js
var import_jsx_runtime12;
var init_ArrayFieldTitleTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js"() {
    import_jsx_runtime12 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js
var import_jsx_runtime13, import_react12;
var init_BaseInputTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js"() {
    import_jsx_runtime13 = __toESM(require_jsx_runtime());
    import_react12 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js
var import_jsx_runtime14;
var init_SubmitButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js"() {
    import_jsx_runtime14 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js
var import_jsx_runtime15;
var init_IconButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js"() {
    import_jsx_runtime15 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js
var import_jsx_runtime16;
var init_AddButton = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js"() {
    import_jsx_runtime16 = __toESM(require_jsx_runtime());
    init_lib2();
    init_IconButton();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js
var init_ButtonTemplates = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js"() {
    init_SubmitButton();
    init_AddButton();
    init_IconButton();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/DescriptionField.js
var import_jsx_runtime17;
var init_DescriptionField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/DescriptionField.js"() {
    import_jsx_runtime17 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ErrorList.js
var import_jsx_runtime18;
var init_ErrorList = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ErrorList.js"() {
    import_jsx_runtime18 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js
var import_jsx_runtime19;
var init_Label = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js"() {
    import_jsx_runtime19 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js
var import_jsx_runtime20;
var init_FieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js"() {
    import_jsx_runtime20 = __toESM(require_jsx_runtime());
    init_lib2();
    init_Label();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js
var init_FieldTemplate2 = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js"() {
    init_FieldTemplate();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js
var import_jsx_runtime21;
var init_FieldErrorTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js"() {
    import_jsx_runtime21 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js
var import_jsx_runtime22;
var init_FieldHelpTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js"() {
    import_jsx_runtime22 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js
var import_jsx_runtime23;
var init_ObjectFieldTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js"() {
    import_jsx_runtime23 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/TitleField.js
var import_jsx_runtime24;
var init_TitleField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/TitleField.js"() {
    import_jsx_runtime24 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js
var import_jsx_runtime25;
var init_UnsupportedField = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js"() {
    import_jsx_runtime25 = __toESM(require_jsx_runtime());
    init_lib2();
    init_index_modern();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js
var import_jsx_runtime26;
var init_WrapIfAdditionalTemplate = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js"() {
    import_jsx_runtime26 = __toESM(require_jsx_runtime());
    init_lib2();
    init_Label();
  }
});

// ../../node_modules/@rjsf/core/lib/components/templates/index.js
var init_templates = __esm({
  "../../node_modules/@rjsf/core/lib/components/templates/index.js"() {
    init_ArrayFieldDescriptionTemplate();
    init_ArrayFieldItemTemplate();
    init_ArrayFieldTemplate();
    init_ArrayFieldTitleTemplate();
    init_BaseInputTemplate();
    init_ButtonTemplates();
    init_DescriptionField();
    init_ErrorList();
    init_FieldTemplate2();
    init_FieldErrorTemplate();
    init_FieldHelpTemplate();
    init_ObjectFieldTemplate();
    init_TitleField();
    init_UnsupportedField();
    init_WrapIfAdditionalTemplate();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js
var import_jsx_runtime27, import_react13;
var init_AltDateWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js"() {
    import_jsx_runtime27 = __toESM(require_jsx_runtime());
    import_react13 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js
var import_jsx_runtime28;
var init_AltDateTimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js"() {
    import_jsx_runtime28 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js
var import_jsx_runtime29, import_react14;
var init_CheckboxWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js"() {
    import_jsx_runtime29 = __toESM(require_jsx_runtime());
    import_react14 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js
var import_jsx_runtime30, import_react15;
var init_CheckboxesWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js"() {
    import_jsx_runtime30 = __toESM(require_jsx_runtime());
    import_react15 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js
var import_jsx_runtime31;
var init_ColorWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js"() {
    import_jsx_runtime31 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/DateWidget.js
var import_jsx_runtime32, import_react16;
var init_DateWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/DateWidget.js"() {
    import_jsx_runtime32 = __toESM(require_jsx_runtime());
    import_react16 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js
var import_jsx_runtime33;
var init_DateTimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js"() {
    import_jsx_runtime33 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js
var import_jsx_runtime34;
var init_EmailWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js"() {
    import_jsx_runtime34 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/FileWidget.js
var import_jsx_runtime35, import_react17;
var init_FileWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/FileWidget.js"() {
    import_jsx_runtime35 = __toESM(require_jsx_runtime());
    import_react17 = __toESM(require_react());
    init_lib2();
    init_index_modern();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js
var import_jsx_runtime36;
var init_HiddenWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js"() {
    import_jsx_runtime36 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js
var import_jsx_runtime37;
var init_PasswordWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js"() {
    import_jsx_runtime37 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js
var import_jsx_runtime38, import_react18;
var init_RadioWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js"() {
    import_jsx_runtime38 = __toESM(require_jsx_runtime());
    import_react18 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js
var import_jsx_runtime39;
var init_RangeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js"() {
    import_jsx_runtime39 = __toESM(require_jsx_runtime());
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js
var import_jsx_runtime40, import_react19;
var init_SelectWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js"() {
    import_jsx_runtime40 = __toESM(require_jsx_runtime());
    import_react19 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js
function TextareaWidget({ id, options = {}, placeholder, value, required, disabled, readonly, autofocus = false, onChange, onBlur, onFocus }) {
  const handleChange = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2), [onChange, options.emptyValue]);
  const handleBlur = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onBlur(id, value2), [onBlur, id]);
  const handleFocus = (0, import_react20.useCallback)(({ target: { value: value2 } }) => onFocus(id, value2), [id, onFocus]);
  return (0, import_jsx_runtime41.jsx)("textarea", { id, name: id, className: "form-control", value: value ? value : "", placeholder, required, disabled, readOnly: readonly, autoFocus: autofocus, rows: options.rows, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": ariaDescribedByIds(id) });
}
var import_jsx_runtime41, import_react20;
var init_TextareaWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js"() {
    import_jsx_runtime41 = __toESM(require_jsx_runtime());
    import_react20 = __toESM(require_react());
    init_lib2();
    TextareaWidget.defaultProps = {
      autofocus: false,
      options: {}
    };
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TextWidget.js
var import_jsx_runtime42;
var init_TextWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TextWidget.js"() {
    import_jsx_runtime42 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js
var import_jsx_runtime43, import_react21;
var init_TimeWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js"() {
    import_jsx_runtime43 = __toESM(require_jsx_runtime());
    import_react21 = __toESM(require_react());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/URLWidget.js
var import_jsx_runtime44;
var init_URLWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/URLWidget.js"() {
    import_jsx_runtime44 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js
var import_jsx_runtime45;
var init_UpDownWidget = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js"() {
    import_jsx_runtime45 = __toESM(require_jsx_runtime());
    init_lib2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/widgets/index.js
var init_widgets2 = __esm({
  "../../node_modules/@rjsf/core/lib/components/widgets/index.js"() {
    init_AltDateWidget();
    init_AltDateTimeWidget();
    init_CheckboxWidget();
    init_CheckboxesWidget();
    init_ColorWidget();
    init_DateWidget();
    init_DateTimeWidget();
    init_EmailWidget();
    init_FileWidget();
    init_HiddenWidget();
    init_PasswordWidget();
    init_RadioWidget();
    init_RangeWidget();
    init_SelectWidget();
    init_TextareaWidget();
    init_TextWidget();
    init_TimeWidget();
    init_URLWidget();
    init_UpDownWidget();
  }
});

// ../../node_modules/@rjsf/core/lib/getDefaultRegistry.js
var init_getDefaultRegistry = __esm({
  "../../node_modules/@rjsf/core/lib/getDefaultRegistry.js"() {
    init_lib2();
    init_fields();
    init_templates();
    init_widgets2();
  }
});

// ../../node_modules/@rjsf/core/lib/components/Form.js
var import_jsx_runtime46, import_react22, import_get17, import_isEmpty5, import_pick, import_toPath2;
var init_Form = __esm({
  "../../node_modules/@rjsf/core/lib/components/Form.js"() {
    import_jsx_runtime46 = __toESM(require_jsx_runtime());
    import_react22 = __toESM(require_react());
    init_lib2();
    import_get17 = __toESM(require_get());
    import_isEmpty5 = __toESM(require_isEmpty());
    import_pick = __toESM(require_pick());
    import_toPath2 = __toESM(require_toPath());
    init_getDefaultRegistry();
  }
});

// ../../node_modules/@rjsf/core/lib/withTheme.js
var import_jsx_runtime47, import_react23;
var init_withTheme = __esm({
  "../../node_modules/@rjsf/core/lib/withTheme.js"() {
    import_jsx_runtime47 = __toESM(require_jsx_runtime());
    import_react23 = __toESM(require_react());
    init_Form();
  }
});

// ../../node_modules/@rjsf/core/lib/index.js
var init_lib3 = __esm({
  "../../node_modules/@rjsf/core/lib/index.js"() {
    init_Form();
    init_withTheme();
    init_getDefaultRegistry();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/form.js
var import_coreutils8, import_react24;
var init_form = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/form.js"() {
    init_lib();
    import_coreutils8 = __toESM(require_dist());
    init_lib3();
    init_lib2();
    import_react24 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/interface.js
var init_interface = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/interface.js"() {
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/htmlselect.js
var React5;
var init_htmlselect = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/htmlselect.js"() {
    React5 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/iframe.js
var Private19;
var init_iframe = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/iframe.js"() {
    init_index_es619();
    (function(Private31) {
      function createNode() {
        const node = document.createElement("div");
        const iframe = document.createElement("iframe");
        iframe.setAttribute("sandbox", "");
        iframe.style.height = "100%";
        iframe.style.width = "100%";
        node.appendChild(iframe);
        return node;
      }
      Private31.createNode = createNode;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/algorithm/dist/index.es6.js
function find3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function every2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some2(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* map(object, fn) {
  let index = 0;
  for (const value of object) {
    yield fn(value, index++);
  }
}
function* retro2(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt5, Private20, StringExt5;
var init_index_es620 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt5 || (ArrayExt5 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private20 || (Private20 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt5 || (StringExt5 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/menu.js
var IRankedMenu;
var init_menu = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/menu.js"() {
    init_index_es620();
    init_index_es65();
    init_index_es63();
    init_index_es619();
    (function(IRankedMenu2) {
      IRankedMenu2.DEFAULT_RANK = 100;
    })(IRankedMenu || (IRankedMenu = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList2, Private21;
var init_index_es621 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList2 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private21.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private21.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private21.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private21.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private21.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private21.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private21.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from;
    })(LinkedList2 || (LinkedList2 = {}));
    (function(Private31) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private31.LinkedListNode = LinkedListNode;
    })(Private21 || (Private21 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/messaging/dist/index.es6.js
var MessageLoop2;
var init_index_es622 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es620();
    init_index_es621();
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every2(retro2(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some2(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i2 = hooks.indexOf(hook);
        if (i2 === -1) {
          return;
        }
        hooks[i2] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt5.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList2();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt5.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop2 || (MessageLoop2 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/properties/dist/index.es6.js
var AttachedProperty4, Private22;
var init_index_es623 = __esm({
  "../../node_modules/@jupyterlab/ui-components/node_modules/@lumino/properties/dist/index.es6.js"() {
    AttachedProperty4 = class {
      /**
       * Construct a new attached property.
       *
       * @param options - The options for initializing the property.
       */
      constructor(options) {
        this._pid = Private22.nextPID();
        this.name = options.name;
        this._create = options.create;
        this._coerce = options.coerce || null;
        this._compare = options.compare || null;
        this._changed = options.changed || null;
      }
      /**
       * Get the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @returns The current value of the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and assigned as the current value of the property.
       */
      get(owner) {
        let value;
        let map2 = Private22.ensureMap(owner);
        if (this._pid in map2) {
          value = map2[this._pid];
        } else {
          value = map2[this._pid] = this._createValue(owner);
        }
        return value;
      }
      /**
       * Set the current value of the property for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * @param value - The value for the property.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      set(owner, value) {
        let oldValue;
        let map2 = Private22.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, value);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Explicitly coerce the current property value for a given owner.
       *
       * @param owner - The property owner of interest.
       *
       * #### Notes
       * If the value has not yet been set, the default value will be
       * computed and used as the previous value for the comparison.
       */
      coerce(owner) {
        let oldValue;
        let map2 = Private22.ensureMap(owner);
        if (this._pid in map2) {
          oldValue = map2[this._pid];
        } else {
          oldValue = map2[this._pid] = this._createValue(owner);
        }
        let newValue = this._coerceValue(owner, oldValue);
        this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
      }
      /**
       * Get or create the default value for the given owner.
       */
      _createValue(owner) {
        let create2 = this._create;
        return create2(owner);
      }
      /**
       * Coerce the value for the given owner.
       */
      _coerceValue(owner, value) {
        let coerce = this._coerce;
        return coerce ? coerce(owner, value) : value;
      }
      /**
       * Compare the old value and new value for equality.
       */
      _compareValue(oldValue, newValue) {
        let compare = this._compare;
        return compare ? compare(oldValue, newValue) : oldValue === newValue;
      }
      /**
       * Run the change notification if the given values are different.
       */
      _maybeNotify(owner, oldValue, newValue) {
        let changed = this._changed;
        if (changed && !this._compareValue(oldValue, newValue)) {
          changed(owner, oldValue, newValue);
        }
      }
    };
    (function(AttachedProperty5) {
      function clearData(owner) {
        Private22.ownerData.delete(owner);
      }
      AttachedProperty5.clearData = clearData;
    })(AttachedProperty4 || (AttachedProperty4 = {}));
    (function(Private31) {
      Private31.ownerData = /* @__PURE__ */ new WeakMap();
      Private31.nextPID = (() => {
        let id = 0;
        return () => {
          let rand = Math.random();
          let stem = `${rand}`.slice(2);
          return `pid-${stem}-${id++}`;
        };
      })();
      function ensureMap(owner) {
        let map2 = Private31.ownerData.get(owner);
        if (map2) {
          return map2;
        }
        map2 = /* @__PURE__ */ Object.create(null);
        Private31.ownerData.set(owner, map2);
        return map2;
      }
      Private31.ensureMap = ensureMap;
    })(Private22 || (Private22 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/vdom.js
var React6, import_client2, ReactWidget, VDomRenderer, UseSignal, VDomModel;
var init_vdom = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/vdom.js"() {
    init_index_es622();
    init_index_es63();
    init_index_es619();
    React6 = __toESM(require_react());
    import_client2 = __toESM(require_client());
    ReactWidget = class extends Widget {
      constructor() {
        super();
        this._rootDOM = null;
      }
      /**
       * Creates a new `ReactWidget` that renders a constant element.
       * @param element React element to render.
       */
      static create(element) {
        return new class extends ReactWidget {
          render() {
            return element;
          }
        }();
      }
      /**
       * Called to update the state of the widget.
       *
       * The default implementation of this method triggers
       * VDOM based rendering by calling the `renderDOM` method.
       */
      onUpdateRequest(msg) {
        this.renderPromise = this.renderDOM();
      }
      /**
       * Called after the widget is attached to the DOM
       */
      onAfterAttach(msg) {
        MessageLoop2.sendMessage(this, Widget.Msg.UpdateRequest);
      }
      /**
       * Called before the widget is detached from the DOM.
       */
      onBeforeDetach(msg) {
        if (this._rootDOM !== null) {
          this._rootDOM.unmount();
          this._rootDOM = null;
        }
      }
      /**
       * Render the React nodes to the DOM.
       *
       * @returns a promise that resolves when the rendering is done.
       */
      renderDOM() {
        return new Promise((resolve) => {
          const vnode = this.render();
          if (this._rootDOM === null) {
            this._rootDOM = (0, import_client2.createRoot)(this.node);
          }
          if (Array.isArray(vnode)) {
            this._rootDOM.render(vnode);
            requestIdleCallback(() => resolve());
          } else if (vnode) {
            this._rootDOM.render(vnode);
            requestIdleCallback(() => resolve());
          } else {
            this._rootDOM.unmount();
            this._rootDOM = null;
            requestIdleCallback(() => resolve());
          }
        });
      }
    };
    VDomRenderer = class extends ReactWidget {
      /**
       * Create a new VDomRenderer
       */
      constructor(model) {
        super();
        this._modelChanged = new Signal(this);
        this.model = model !== null && model !== void 0 ? model : null;
      }
      /**
       * A signal emitted when the model changes.
       */
      get modelChanged() {
        return this._modelChanged;
      }
      /**
       * Set the model and fire changed signals.
       */
      set model(newValue) {
        if (this._model === newValue) {
          return;
        }
        if (this._model) {
          this._model.stateChanged.disconnect(this.update, this);
        }
        this._model = newValue;
        if (newValue) {
          newValue.stateChanged.connect(this.update, this);
        }
        this.update();
        this._modelChanged.emit(void 0);
      }
      /**
       * Get the current model.
       */
      get model() {
        return this._model;
      }
      /**
       * Dispose this widget.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._model = null;
        super.dispose();
      }
    };
    UseSignal = class extends React6.Component {
      constructor(props) {
        super(props);
        this.slot = (sender, args) => {
          if (this.props.shouldUpdate && !this.props.shouldUpdate(sender, args)) {
            return;
          }
          this.setState({ value: [sender, args] });
        };
        this.state = { value: [this.props.initialSender, this.props.initialArgs] };
      }
      componentDidMount() {
        this.props.signal.connect(this.slot);
      }
      componentWillUnmount() {
        this.props.signal.disconnect(this.slot);
      }
      render() {
        return this.props.children(...this.state.value);
      }
    };
    VDomModel = class {
      constructor() {
        this.stateChanged = new Signal(this);
        this._isDisposed = false;
      }
      /**
       * Test whether the model is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose the model.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/toolbar.js
function ToolbarButtonComponent(props) {
  var _a, _b;
  const handleMouseDown = (event) => {
    var _a2;
    if (event.button === 0) {
      event.preventDefault();
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const handleKeyDown = (event) => {
    var _a2;
    const { key: key2 } = event;
    if (key2 === "Enter" || key2 === " ") {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const handleClick = (event) => {
    var _a2;
    if (event.button === 0) {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const getTooltip = () => {
    if (props.enabled === false && props.disabledTooltip) {
      return props.disabledTooltip;
    } else if (props.pressed && props.pressedTooltip) {
      return props.pressedTooltip;
    } else {
      return props.tooltip || props.iconLabel;
    }
  };
  return React7.createElement(
    Button,
    { className: props.className ? props.className + " jp-ToolbarButtonComponent" : "jp-ToolbarButtonComponent", "aria-pressed": props.pressed, "aria-disabled": props.enabled === false, ...props.dataset, disabled: props.enabled === false, onClick: ((_a = props.actualOnClick) !== null && _a !== void 0 ? _a : false) ? handleClick : void 0, onMouseDown: !((_b = props.actualOnClick) !== null && _b !== void 0 ? _b : false) ? handleMouseDown : void 0, onKeyDown: handleKeyDown, title: getTooltip(), minimal: true },
    (props.icon || props.iconClass) && React7.createElement(LabIcon.resolveReact, { icon: props.pressed ? props.pressedIcon : props.icon, iconClass: (
      // add some extra classes for proper support of icons-as-css-background
      classes(props.iconClass, "jp-Icon")
    ), className: "jp-ToolbarButtonComponent-icon", tag: "span", stylesheet: "toolbarButton" }),
    props.label && React7.createElement("span", { className: "jp-ToolbarButtonComponent-label" }, props.label)
  );
}
function addToolbarButtonClass(w) {
  w.addClass("jp-ToolbarButton");
  return w;
}
var React7, TOOLBAR_CLASS, TOOLBAR_ITEM_CLASS, TOOLBAR_OPENER_NAME, TOOLBAR_SPACER_CLASS, ToolbarLayout, Toolbar, ReactiveToolbar, ToolbarButton, ToolbarPopup, ToolbarPopupOpener, Private23;
var init_toolbar = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/toolbar.js"() {
    init_lib();
    init_index_es620();
    init_index_es618();
    init_index_es622();
    init_index_es623();
    init_index_es619();
    init_index_es64();
    React7 = __toESM(require_react());
    init_button();
    init_icon2();
    init_utils2();
    init_vdom();
    TOOLBAR_CLASS = "jp-Toolbar";
    TOOLBAR_ITEM_CLASS = "jp-Toolbar-item";
    TOOLBAR_OPENER_NAME = "toolbar-popup-opener";
    TOOLBAR_SPACER_CLASS = "jp-Toolbar-spacer";
    ToolbarLayout = class extends PanelLayout {
      constructor() {
        super(...arguments);
        this._dirty = false;
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * If any child widget is visible, expand the toolbar height to the normal
       * toolbar height.
       */
      onFitRequest(msg) {
        super.onFitRequest(msg);
        if (this.parent.isAttached) {
          if (some2(this.widgets, (w) => !w.isHidden)) {
            this.parent.node.style.minHeight = "var(--jp-private-toolbar-height)";
            this.parent.removeClass("jp-Toolbar-micro");
          } else {
            this.parent.node.style.minHeight = "";
            this.parent.addClass("jp-Toolbar-micro");
          }
        }
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget.Msg.UpdateRequest);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        if (this.parent.isVisible) {
          this._dirty = false;
        }
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        super.onChildShown(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        super.onChildHidden(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index, widget) {
        super.attachWidget(index, widget);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index, widget) {
        super.detachWidget(index, widget);
        this.parent.fit();
      }
    };
    Toolbar = class extends Widget {
      /**
       * Construct a new toolbar widget.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.addClass(TOOLBAR_CLASS);
        this.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new ToolbarLayout();
      }
      /**
       * Get an iterator over the ordered toolbar item names.
       *
       * @returns An iterator over the toolbar item names.
       */
      names() {
        const layout = this.layout;
        return map(layout.widgets, (widget) => {
          return Private23.nameProperty.get(widget);
        });
      }
      /**
       * Add an item to the end of the toolbar.
       *
       * @param name - The name of the widget to add to the toolbar.
       *
       * @param widget - The widget to add to the toolbar.
       *
       * @param index - The optional name of the item to insert after.
       *
       * @returns Whether the item was added to toolbar.  Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      addItem(name2, widget) {
        const layout = this.layout;
        return this.insertItem(layout.widgets.length, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertItem(index, name2, widget) {
        const existing = find3(this.names(), (value) => value === name2);
        if (existing) {
          return false;
        }
        widget.addClass(TOOLBAR_ITEM_CLASS);
        const layout = this.layout;
        const j = Math.max(0, Math.min(index, layout.widgets.length));
        layout.insertWidget(j, widget);
        Private23.nameProperty.set(widget, name2);
        return true;
      }
      /**
       * Insert an item into the toolbar at the after a target item.
       *
       * @param at - The target item to insert after.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertAfter(at2, name2, widget) {
        return this._insertRelative(at2, 1, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the before a target item.
       *
       * @param at - The target item to insert before.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertBefore(at2, name2, widget) {
        return this._insertRelative(at2, 0, name2, widget);
      }
      _insertRelative(at2, offset, name2, widget) {
        const nameWithIndex = map(this.names(), (name3, i2) => {
          return { name: name3, index: i2 };
        });
        const target = find3(nameWithIndex, (x) => x.name === at2);
        if (target) {
          return this.insertItem(target.index + offset, name2, widget);
        }
        return false;
      }
      /**
       * Handle the DOM events for the widget.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the dock panel's node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this.handleClick(event);
            break;
          default:
            break;
        }
      }
      /**
       * Handle a DOM click event.
       */
      handleClick(event) {
        event.stopPropagation();
        if (event.target instanceof HTMLLabelElement) {
          const forId = event.target.getAttribute("for");
          if (forId && this.node.querySelector(`#${forId}`)) {
            return;
          }
        }
        if (this.node.contains(document.activeElement)) {
          return;
        }
        if (this.parent) {
          this.parent.activate();
        }
      }
      /**
       * Handle `after-attach` messages for the widget.
       */
      onAfterAttach(msg) {
        this.node.addEventListener("click", this);
      }
      /**
       * Handle `before-detach` messages for the widget.
       */
      onBeforeDetach(msg) {
        this.node.removeEventListener("click", this);
      }
    };
    ReactiveToolbar = class extends Toolbar {
      /**
       * Construct a new toolbar widget.
       */
      constructor() {
        super();
        this.popupOpener = new ToolbarPopupOpener();
        this._widgetWidths = {};
        this.insertItem(0, TOOLBAR_OPENER_NAME, this.popupOpener);
        this.popupOpener.hide();
        this._resizer = new Throttler(this._onResize.bind(this), 500);
      }
      /**
       * Dispose of the widget and its descendant widgets.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        if (this._resizer) {
          this._resizer.dispose();
        }
        super.dispose();
      }
      /**
       * Insert an item into the toolbar at the after a target item.
       *
       * @param at - The target item to insert after.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar or if the target
       *   is the toolbar pop-up opener.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertAfter(at2, name2, widget) {
        if (at2 === TOOLBAR_OPENER_NAME) {
          return false;
        }
        return super.insertAfter(at2, name2, widget);
      }
      /**
       * Insert an item into the toolbar at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param name - The name of the item.
       *
       * @param widget - The widget to add.
       *
       * @returns Whether the item was added to the toolbar. Returns false if
       *   an item of the same name is already in the toolbar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       * The item can be removed from the toolbar by setting its parent to `null`.
       */
      insertItem(index, name2, widget) {
        if (widget instanceof ToolbarPopupOpener) {
          return super.insertItem(index, name2, widget);
        } else {
          const j = Math.max(0, Math.min(index, this.layout.widgets.length - 1));
          return super.insertItem(j, name2, widget);
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * It will hide the pop-up panel
       */
      onBeforeHide(msg) {
        this.popupOpener.hidePopup();
        super.onBeforeHide(msg);
      }
      onResize(msg) {
        super.onResize(msg);
        if (msg.width > 0 && this._resizer) {
          void this._resizer.invoke();
        }
      }
      _onResize() {
        if (this.parent && this.parent.isAttached) {
          const toolbarWidth = this.node.clientWidth;
          const opener = this.popupOpener;
          const openerWidth = 30;
          const toolbarPadding = 2;
          const layout = this.layout;
          let width = opener.isHidden ? toolbarPadding : toolbarPadding + openerWidth;
          let index = 0;
          const widgetsToRemove = [];
          const toIndex = layout.widgets.length - 1;
          while (index < toIndex) {
            const widget = layout.widgets[index];
            this._saveWidgetWidth(widget);
            width += this._getWidgetWidth(widget);
            if (widgetsToRemove.length === 0 && opener.isHidden && width + openerWidth > toolbarWidth) {
              width += openerWidth;
            }
            if (width > toolbarWidth) {
              widgetsToRemove.push(widget);
            }
            index++;
          }
          while (widgetsToRemove.length > 0) {
            const widget = widgetsToRemove.pop();
            width -= this._getWidgetWidth(widget);
            opener.addWidget(widget);
          }
          if (opener.widgetCount() > 0) {
            const widgetsToAdd = [];
            let index2 = 0;
            let widget = opener.widgetAt(index2);
            const widgetCount = opener.widgetCount();
            width += this._getWidgetWidth(widget);
            if (widgetCount === 1 && width - openerWidth <= toolbarWidth) {
              width -= openerWidth;
            }
            while (width < toolbarWidth && index2 < widgetCount) {
              widgetsToAdd.push(widget);
              index2++;
              widget = opener.widgetAt(index2);
              if (widget) {
                width += this._getWidgetWidth(widget);
              } else {
                break;
              }
            }
            while (widgetsToAdd.length > 0) {
              const widget2 = widgetsToAdd.shift();
              this.addItem(Private23.nameProperty.get(widget2), widget2);
            }
          }
          if (opener.widgetCount() > 0) {
            opener.updatePopup();
            opener.show();
          } else {
            opener.hide();
          }
        }
      }
      _saveWidgetWidth(widget) {
        const widgetName = Private23.nameProperty.get(widget);
        this._widgetWidths[widgetName] = widget.hasClass(TOOLBAR_SPACER_CLASS) ? 2 : widget.node.clientWidth;
      }
      _getWidgetWidth(widget) {
        const widgetName = Private23.nameProperty.get(widget);
        return this._widgetWidths[widgetName];
      }
    };
    (function(Toolbar2) {
      function createSpacerItem() {
        return new Private23.Spacer();
      }
      Toolbar2.createSpacerItem = createSpacerItem;
    })(Toolbar || (Toolbar = {}));
    ToolbarButton = class extends ReactWidget {
      /**
       * Creates a toolbar button
       * @param props props for underlying `ToolbarButton` component
       */
      constructor(props = {}) {
        var _a, _b;
        super();
        this.props = props;
        addToolbarButtonClass(this);
        this._enabled = (_a = props.enabled) !== null && _a !== void 0 ? _a : true;
        this._pressed = this._enabled && ((_b = props.pressed) !== null && _b !== void 0 ? _b : false);
        this._onClick = props.onClick;
      }
      /**
       * Sets the pressed state for the button
       * @param value true if button is pressed, false otherwise
       */
      set pressed(value) {
        if (this.enabled && value !== this._pressed) {
          this._pressed = value;
          this.update();
        }
      }
      /**
       * Returns true if button is pressed, false otherwise
       */
      get pressed() {
        return this._pressed;
      }
      /**
       * Sets the enabled state for the button
       * @param value true to enable the button, false otherwise
       */
      set enabled(value) {
        if (value != this._enabled) {
          this._enabled = value;
          if (!this._enabled) {
            this._pressed = false;
          }
          this.update();
        }
      }
      /**
       * Returns true if button is enabled, false otherwise
       */
      get enabled() {
        return this._enabled;
      }
      /**
       * Sets the click handler for the button
       * @param value click handler
       */
      set onClick(value) {
        if (value !== this._onClick) {
          this._onClick = value;
          this.update();
        }
      }
      /**
       * Returns the click handler for the button
       */
      get onClick() {
        return this._onClick;
      }
      render() {
        return React7.createElement(ToolbarButtonComponent, { ...this.props, pressed: this.pressed, enabled: this.enabled, onClick: this.onClick });
      }
    };
    ToolbarPopup = class extends Widget {
      /**
       *  Construct a new ToolbarPopup
       */
      constructor() {
        super();
        this.width = 0;
        this.addClass("jp-Toolbar-responsive-popup");
        this.layout = new PanelLayout();
        Widget.attach(this, document.body);
        this.hide();
      }
      /**
       * Updates the width of the popup, this
       * should match with the toolbar width
       *
       * @param width - The width to resize to
       * @protected
       */
      updateWidth(width) {
        if (width > 0) {
          this.width = width;
          this.node.style.width = `${width}px`;
        }
      }
      /**
       * Aligns the popup to left bottom of widget
       *
       * @param widget the widget to align to
       * @private
       */
      alignTo(widget) {
        const { height: widgetHeight, width: widgetWidth, x: widgetX, y: widgetY } = widget.node.getBoundingClientRect();
        const width = this.width;
        this.node.style.left = `${widgetX + widgetWidth - width + 1}px`;
        this.node.style.top = `${widgetY + widgetHeight + 1}px`;
      }
      /**
       * Inserts the widget at specified index
       * @param index the index
       * @param widget widget to add
       */
      insertWidget(index, widget) {
        this.layout.insertWidget(0, widget);
      }
      /**
       *  Total number of widgets in the popup
       */
      widgetCount() {
        return this.layout.widgets.length;
      }
      /**
       * Returns the widget at index
       * @param index the index
       */
      widgetAt(index) {
        return this.layout.widgets[index];
      }
    };
    ToolbarPopupOpener = class extends ToolbarButton {
      /**
       *  Create a new popup opener
       */
      constructor(props = {}) {
        const trans = (props.translator || nullTranslator).load("jupyterlab");
        super({
          icon: ellipsesIcon,
          onClick: () => {
            this.handleClick();
          },
          tooltip: trans.__("More commands")
        });
        this.addClass("jp-Toolbar-responsive-opener");
        this.popup = new ToolbarPopup();
      }
      /**
       * Add widget to the popup, prepends widgets
       * @param widget the widget to add
       */
      addWidget(widget) {
        this.popup.insertWidget(0, widget);
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.popup.dispose();
        super.dispose();
      }
      /**
       * Hides the opener and the popup
       */
      hide() {
        super.hide();
        this.hidePopup();
      }
      /**
       * Hides the popup
       */
      hidePopup() {
        this.popup.hide();
      }
      /**
       *  Updates width and position of the popup
       *  to align with the toolbar
       */
      updatePopup() {
        this.popup.updateWidth(this.parent.node.clientWidth);
        this.popup.alignTo(this.parent);
      }
      /**
       * Returns widget at index in the popup
       * @param index
       */
      widgetAt(index) {
        return this.popup.widgetAt(index);
      }
      /**
       * Returns total number of widgets in the popup
       *
       * @returns Number of widgets
       */
      widgetCount() {
        return this.popup.widgetCount();
      }
      handleClick() {
        this.updatePopup();
        this.popup.setHidden(!this.popup.isHidden);
      }
    };
    (function(Private31) {
      function propsFromCommand(options) {
        var _a, _b, _c;
        const { commands, id, args } = options;
        const iconClass = commands.iconClass(id, args);
        const iconLabel = commands.iconLabel(id, args);
        const icon = (_a = options.icon) !== null && _a !== void 0 ? _a : commands.icon(id, args);
        const label = commands.label(id, args);
        let className = commands.className(id, args);
        if (commands.isToggled(id, args)) {
          className += " lm-mod-toggled";
        }
        if (!commands.isVisible(id, args)) {
          className += " lm-mod-hidden";
        }
        let tooltip = commands.caption(id, args) || options.label || label || iconLabel;
        const binding = commands.keyBindings.find((b) => b.command === id);
        if (binding) {
          const ks = binding.keys.map(CommandRegistry.formatKeystroke).join(", ");
          tooltip = `${tooltip} (${ks})`;
        }
        const onClick = () => {
          void commands.execute(id, args);
        };
        const enabled = commands.isEnabled(id, args);
        return {
          className,
          dataset: { "data-command": options.id },
          icon,
          iconClass,
          tooltip: (_b = options.caption) !== null && _b !== void 0 ? _b : tooltip,
          onClick,
          enabled,
          label: (_c = options.label) !== null && _c !== void 0 ? _c : label
        };
      }
      Private31.propsFromCommand = propsFromCommand;
      Private31.nameProperty = new AttachedProperty4({
        name: "name",
        create: () => ""
      });
      class Spacer extends Widget {
        /**
         * Construct a new spacer widget.
         */
        constructor() {
          super();
          this.addClass(TOOLBAR_SPACER_CLASS);
        }
      }
      Private31.Spacer = Spacer;
    })(Private23 || (Private23 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/panelwithtoolbar.js
var init_panelwithtoolbar = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/panelwithtoolbar.js"() {
    init_index_es619();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/search.js
var import_react25;
var init_search2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/search.js"() {
    init_index_es620();
    import_react25 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/sidepanel.js
var init_sidepanel = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/sidepanel.js"() {
    init_lib();
    init_index_es619();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/spinner.js
var Spinner;
var init_spinner = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/spinner.js"() {
    init_index_es619();
    Spinner = class extends Widget {
      /**
       * Construct a spinner widget.
       */
      constructor() {
        super();
        this.addClass("jp-Spinner");
        this.node.tabIndex = -1;
        const content = document.createElement("div");
        content.className = "jp-SpinnerContent";
        this.node.appendChild(content);
      }
      /**
       * Handle `'activate-request'` messages.
       */
      onActivateRequest(msg) {
        this.node.focus();
      }
    };
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/styling.js
var Styling, Private24;
var init_styling = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/styling.js"() {
    init_icon2();
    (function(Styling2) {
      function styleNode(node, className = "") {
        styleNodeByTag(node, "select", className);
        styleNodeByTag(node, "textarea", className);
        styleNodeByTag(node, "input", className);
        styleNodeByTag(node, "button", className);
      }
      Styling2.styleNode = styleNode;
      function styleNodeByTag(node, tagName, className = "") {
        if (node.localName === tagName) {
          node.classList.add("jp-mod-styled");
        }
        if (node.localName === "select") {
          const multiple = node.hasAttribute("multiple");
          wrapSelect(node, multiple);
        }
        const nodes = node.getElementsByTagName(tagName);
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const child = nodes[i2];
          child.classList.add("jp-mod-styled");
          if (className) {
            child.classList.add(className);
          }
          if (tagName === "select") {
            const multiple = child.hasAttribute("multiple");
            wrapSelect(child, multiple);
          }
        }
      }
      Styling2.styleNodeByTag = styleNodeByTag;
      function wrapSelect(node, multiple) {
        const wrapper = document.createElement("div");
        wrapper.classList.add("jp-select-wrapper");
        node.addEventListener("focus", Private24.onFocus);
        node.addEventListener("blur", Private24.onFocus);
        node.classList.add("jp-mod-styled");
        if (node.parentElement) {
          node.parentElement.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
        if (multiple) {
          wrapper.classList.add("multiple");
        } else {
          wrapper.appendChild(caretDownEmptyIcon.element({
            tag: "span",
            stylesheet: "select",
            right: "8px",
            top: "5px",
            width: "18px"
          }));
        }
        return wrapper;
      }
      Styling2.wrapSelect = wrapSelect;
    })(Styling || (Styling = {}));
    (function(Private31) {
      function onFocus(event) {
        const target = event.target;
        const parent = target.parentElement;
        if (!parent) {
          return;
        }
        if (event.type === "focus") {
          parent.classList.add("jp-mod-focused");
        } else {
          parent.classList.remove("jp-mod-focused");
        }
      }
      Private31.onFocus = onFocus;
    })(Private24 || (Private24 = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/switch.js
var init_switch = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/switch.js"() {
    init_index_es63();
    init_index_es619();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/windowedlist.js
var import_coreutils9, MAXIMUM_TIME_REMAINING, passiveIfSupported, WindowedList, WindowedLayout;
var init_windowedlist = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/windowedlist.js"() {
    init_index_es620();
    import_coreutils9 = __toESM(require_dist());
    init_index_es622();
    init_index_es64();
    init_index_es63();
    init_index_es619();
    MAXIMUM_TIME_REMAINING = 50;
    passiveIfSupported = false;
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: function() {
          passiveIfSupported = { passive: true };
        }
      }));
    } catch (err) {
    }
    WindowedList = class extends Widget {
      /**
       * Constructor
       *
       * @param options Constructor options
       */
      constructor(options) {
        var _a;
        const node = document.createElement("div");
        node.className = "jp-WindowedPanel-outer";
        const innerElement = node.appendChild(document.createElement("div"));
        innerElement.className = "jp-WindowedPanel-inner";
        const windowContainer = innerElement.appendChild(document.createElement("div"));
        windowContainer.className = "jp-WindowedPanel-window";
        super({ node });
        this._needsUpdate = false;
        super.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new WindowedLayout();
        this._viewModel = options.model;
        this._innerElement = innerElement;
        this._isScrolling = null;
        this._windowElement = windowContainer;
        this._scrollToItem = null;
        this._scrollRepaint = null;
        this._scrollUpdateWasRequested = false;
        this._updater = new Throttler(() => this.update(), 50);
        this._resizeObserver = null;
        this._viewModel.stateChanged.connect(this.onStateChanged, this);
      }
      /**
       * Whether the parent is hidden or not.
       *
       * This should be set externally if a container is hidden to
       * stop updating the widget size when hidden.
       */
      get isParentHidden() {
        return this._isParentHidden;
      }
      set isParentHidden(v2) {
        this._isParentHidden = v2;
      }
      /**
       * Widget layout
       */
      get layout() {
        return super.layout;
      }
      /**
       * Viewport
       */
      get viewportNode() {
        return this._windowElement;
      }
      /**
       * Windowed list view model
       */
      get viewModel() {
        return this._viewModel;
      }
      /**
       * Dispose the windowed list.
       */
      dispose() {
        this._updater.dispose();
        super.dispose();
      }
      /**
       * Callback on event.
       *
       * @param event Event
       */
      handleEvent(event) {
        switch (event.type) {
          case "scroll":
            this.onScroll(event);
            break;
        }
      }
      /**
       * Scroll to the specified offset `scrollTop`.
       *
       * @param scrollOffset Offset to scroll
       *
       * @deprecated since v4 This is an internal helper. Prefer calling `scrollToItem`.
       */
      scrollTo(scrollOffset) {
        if (!this.viewModel.windowingActive) {
          this.node.scrollTo({ top: scrollOffset });
          return;
        }
        scrollOffset = Math.max(0, scrollOffset);
        if (scrollOffset !== this.viewModel.scrollOffset) {
          this.viewModel.scrollOffset = scrollOffset;
          this._scrollUpdateWasRequested = true;
          this.update();
        }
      }
      /**
       * Scroll to the specified item.
       *
       * By default, the list will scroll as little as possible to ensure the item is visible. You can control the alignment of the item though by specifying a second alignment parameter. Acceptable values are:
       *
       *   auto (default) - Scroll as little as possible to ensure the item is visible. (If the item is already visible, it won't scroll at all.)
       *   smart - If the item is already visible (including the margin), don't scroll at all. If it is less than one viewport away, scroll so that it becomes visible (including the margin). If it is more than one viewport away, scroll so that it is centered within the list.
       *   center - Center align the item within the list.
       *   end - Align the item to the end of the list
       *   start - Align the item to the beginning of the list
       *
       * @param index Item index to scroll to
       * @param align Type of alignment
       * @param margin In 'smart' mode the viewport proportion to add
       */
      scrollToItem(index, align = "auto", margin = 0.25) {
        if (!this.viewModel.windowingActive) {
          const widget = this.layout.widgets[index];
          if (widget === null || widget === void 0 ? void 0 : widget.node.scrollIntoView) {
            widget.node.scrollIntoView({
              block: ["auto", "smart"].includes(align) ? "nearest" : align
            });
          }
          return Promise.resolve();
        }
        if (!this._isScrolling || this._scrollToItem === null || this._scrollToItem[0] !== index || this._scrollToItem[1] !== align) {
          if (this._isScrolling) {
            this._isScrolling.reject("Scrolling to a new item is requested.");
          }
          this._isScrolling = new import_coreutils9.PromiseDelegate();
        }
        this._scrollToItem = [index, align];
        this._resetScrollToItem();
        this.scrollTo(this.viewModel.getOffsetForIndexAndAlignment(Math.max(0, Math.min(index, this._viewModel.widgetCount - 1)), align, margin));
        return this._isScrolling.promise;
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        super.onAfterAttach(msg);
        if (this._viewModel.windowingActive) {
          this._addListeners();
        } else {
          this._applyNoWindowingStyles();
        }
        this.viewModel.height = this.node.getBoundingClientRect().height;
        const style = window.getComputedStyle(this.node);
        this.viewModel.paddingTop = parseFloat(style.paddingTop);
      }
      /**
       * A message handler invoked on an `'before-detach'` message.
       */
      onBeforeDetach(msg) {
        if (this._viewModel.windowingActive) {
          this._removeListeners();
        }
      }
      /**
       * Callback on scroll event
       *
       * @param event Scroll event
       */
      onScroll(event) {
        const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;
        if (!this._scrollUpdateWasRequested && Math.abs(this.viewModel.scrollOffset - scrollTop) > 1) {
          const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          this.viewModel.scrollOffset = scrollOffset;
          this._scrollUpdateWasRequested = false;
          this.update();
        }
      }
      /**
       * A message handler invoked on an `'resize-request'` message.
       */
      onResize(msg) {
        const previousHeight = this.viewModel.height;
        this.viewModel.height = msg.height >= 0 ? msg.height : this.node.getBoundingClientRect().height;
        if (this.viewModel.height !== previousHeight) {
          void this._updater.invoke();
        }
        super.onResize(msg);
      }
      /**
       * Callback on view model change
       *
       * @param model Windowed list model
       * @param changes Change
       */
      onStateChanged(model, changes) {
        switch (changes.name) {
          case "windowingActive":
            if (this.viewModel.windowingActive) {
              this._addListeners();
              this.onScroll({ currentTarget: this.node });
              return;
            } else {
              this._removeListeners();
            }
            break;
        }
        this.update();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
        if (this.viewModel.windowingActive) {
          if (this._scrollRepaint === null) {
            this._needsUpdate = false;
            this._scrollRepaint = window.requestAnimationFrame(() => {
              this._scrollRepaint = null;
              this._update();
              if (this._needsUpdate) {
                this.update();
              }
            });
          } else {
            this._needsUpdate = true;
          }
        } else {
          this._update();
        }
      }
      _addListeners() {
        if (!this._resizeObserver) {
          this._resizeObserver = new ResizeObserver(this._onWidgetResize.bind(this));
        }
        for (const widget of this.layout.widgets) {
          this._resizeObserver.observe(widget.node);
          widget.disposed.connect(() => {
            var _a;
            return (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(widget.node);
          });
        }
        this.node.addEventListener("scroll", this, passiveIfSupported);
        this._windowElement.style.position = "absolute";
      }
      _applyNoWindowingStyles() {
        this._windowElement.style.position = "relative";
        this._windowElement.style.top = "0px";
      }
      _removeListeners() {
        var _a;
        this.node.removeEventListener("scroll", this);
        (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        this._resizeObserver = null;
        this._applyNoWindowingStyles();
      }
      _update() {
        var _a;
        if (this.isDisposed || !this.layout) {
          return;
        }
        const newWindowIndex = this.viewModel.getRangeToRender();
        if (newWindowIndex !== null) {
          const [startIndex, stopIndex] = newWindowIndex;
          const toAdd = [];
          if (stopIndex >= 0) {
            for (let index = startIndex; index <= stopIndex; index++) {
              const widget = this.viewModel.widgetRenderer(index);
              widget.dataset.windowedListIndex = `${index}`;
              toAdd.push(widget);
            }
          }
          const nWidgets = this.layout.widgets.length;
          for (let itemIdx = nWidgets - 1; itemIdx >= 0; itemIdx--) {
            if (!toAdd.includes(this.layout.widgets[itemIdx])) {
              (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.layout.widgets[itemIdx].node);
              this.layout.removeWidget(this.layout.widgets[itemIdx]);
            }
          }
          for (let index = 0; index < toAdd.length; index++) {
            const item = toAdd[index];
            if (this._resizeObserver && !this.layout.widgets.includes(item)) {
              this._resizeObserver.observe(item.node);
              item.disposed.connect(() => {
                var _a2;
                return (_a2 = this._resizeObserver) === null || _a2 === void 0 ? void 0 : _a2.unobserve(item.node);
              });
            }
            this.layout.insertWidget(index, item);
          }
          if (this.viewModel.windowingActive) {
            if (stopIndex >= 0) {
              const estimatedTotalHeight = this.viewModel.getEstimatedTotalSize();
              this._innerElement.style.height = `${estimatedTotalHeight}px`;
              const [top, minHeight] = this.viewModel.getSpan(startIndex, stopIndex);
              this._windowElement.style.top = `${top}px`;
              this._windowElement.style.minHeight = `${minHeight}px`;
            } else {
              this._innerElement.style.height = `0px`;
              this._windowElement.style.top = `0px`;
              this._windowElement.style.minHeight = `0px`;
            }
            if (this._scrollUpdateWasRequested) {
              this.node.scrollTop = this.viewModel.scrollOffset;
              this._scrollUpdateWasRequested = false;
            }
          }
        }
        let index2 = -1;
        for (const w of this.viewportNode.children) {
          const currentIdx = parseInt(w.dataset.windowedListIndex, 10);
          if (currentIdx < index2) {
            throw new Error("Inconsistent dataset index");
          } else {
            index2 = currentIdx;
          }
        }
      }
      _onWidgetResize(entries) {
        this._resetScrollToItem();
        if (this.isHidden || this.isParentHidden) {
          return;
        }
        const newSizes = [];
        for (let entry of entries) {
          if (entry.target.isConnected) {
            newSizes.push({
              index: parseInt(entry.target.dataset.windowedListIndex, 10),
              size: entry.borderBoxSize[0].blockSize
            });
          }
        }
        if (this.viewModel.setWidgetSize(newSizes)) {
          if (this._scrollToItem) {
            this.scrollToItem(...this._scrollToItem).catch((reason) => {
              console.log(reason);
            });
          }
          this.update();
        }
      }
      _resetScrollToItem() {
        if (this._resetScrollToItemTimeout) {
          clearTimeout(this._resetScrollToItemTimeout);
        }
        if (this._scrollToItem) {
          this._resetScrollToItemTimeout = window.setTimeout(() => {
            this._scrollToItem = null;
            if (this._isScrolling) {
              this._isScrolling.resolve();
              this._isScrolling = null;
            }
          }, MAXIMUM_TIME_REMAINING);
        }
      }
    };
    WindowedList.DEFAULT_WIDGET_SIZE = 50;
    WindowedLayout = class extends PanelLayout {
      /**
       * Constructor
       */
      constructor() {
        super({ fitPolicy: "set-no-constraint" });
      }
      /**
       * Specialized parent type definition
       */
      get parent() {
        return super.parent;
      }
      set parent(value) {
        super.parent = value;
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index, widget) {
        let ref = this.parent.viewportNode.children[index];
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.BeforeAttach);
        }
        this.parent.viewportNode.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index, widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.BeforeDetach);
        }
        this.parent.viewportNode.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget.Msg.AfterDetach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        let ref = this.parent.viewportNode.children[toIndex];
        if (fromIndex < toIndex) {
          ref.insertAdjacentElement("afterend", widget.node);
        } else {
          ref.insertAdjacentElement("beforebegin", widget.node);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * This is a reimplementation of the base class method,
       * and is a no-op.
       */
      onUpdateRequest(msg) {
      }
    };
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/components/index.js
var init_components = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/components/index.js"() {
    init_button();
    init_collapser();
    init_form();
    init_htmlselect();
    init_iframe();
    init_inputgroup();
    init_interface();
    init_menu();
    init_panelwithtoolbar();
    init_search2();
    init_sidepanel();
    init_spinner();
    init_styling();
    init_switch();
    init_toolbar();
    init_vdom();
    init_windowedlist();
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/hoverbox.js
var HOVERBOX_CLASS, OUTOFVIEW_Z_INDEX, HoverBox;
var init_hoverbox = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/hoverbox.js"() {
    HOVERBOX_CLASS = "jp-HoverBox";
    OUTOFVIEW_Z_INDEX = "-1000";
    (function(HoverBox2) {
      function setGeometry(options) {
        const { anchor, host, node, privilege, outOfViewDisplay } = options;
        const hostRect = host.getBoundingClientRect();
        if (!node.classList.contains(HOVERBOX_CLASS)) {
          node.classList.add(HOVERBOX_CLASS);
        }
        if (node.style.visibility) {
          node.style.visibility = "";
        }
        if (node.style.zIndex === "") {
          node.style.zIndex = "";
        }
        node.style.maxHeight = "";
        node.style.marginTop = "";
        const style = options.style || window.getComputedStyle(node);
        const spaceAbove = anchor.top - hostRect.top;
        const spaceBelow = hostRect.bottom - anchor.bottom;
        const marginTop = parseInt(style.marginTop, 10) || 0;
        const marginLeft = parseInt(style.marginLeft, 10) || 0;
        const minHeight = parseInt(style.minHeight, 10) || options.minHeight;
        let maxHeight = parseInt(style.maxHeight, 10) || options.maxHeight;
        const renderBelow = privilege === "forceAbove" ? false : privilege === "forceBelow" ? true : privilege === "above" ? spaceAbove < maxHeight && spaceAbove < spaceBelow : spaceBelow >= maxHeight || spaceBelow >= spaceAbove;
        if (renderBelow) {
          maxHeight = Math.min(spaceBelow - marginTop, maxHeight);
        } else {
          maxHeight = Math.min(spaceAbove, maxHeight);
          node.style.marginTop = "0px";
        }
        node.style.maxHeight = `${maxHeight}px`;
        const withinBounds = maxHeight >= minHeight && (spaceBelow >= minHeight || spaceAbove >= minHeight);
        if (!withinBounds) {
          node.style.zIndex = OUTOFVIEW_Z_INDEX;
          node.style.visibility = "hidden";
          return;
        }
        if (options.size) {
          node.style.width = `${options.size.width}px`;
          node.style.height = `${options.size.height}px`;
          node.style.contain = "strict";
        } else {
          node.style.contain = "";
          node.style.width = "auto";
          node.style.height = "";
        }
        const initialHeight = options.size ? options.size.height : node.getBoundingClientRect().height;
        const offsetAbove = options.offset && options.offset.vertical && options.offset.vertical.above || 0;
        const offsetBelow = options.offset && options.offset.vertical && options.offset.vertical.below || 0;
        let top = renderBelow ? hostRect.bottom - spaceBelow + offsetBelow : hostRect.top + spaceAbove - initialHeight + offsetAbove;
        node.style.top = `${Math.floor(top)}px`;
        const offsetHorizontal = options.offset && options.offset.horizontal || 0;
        let left = anchor.left + offsetHorizontal;
        node.style.left = `${Math.ceil(left)}px`;
        let rect = node.getBoundingClientRect();
        let right = rect.right;
        if (right > window.innerWidth) {
          left -= right - window.innerWidth;
          right = window.innerWidth;
          node.style.left = `${Math.ceil(left)}px`;
        }
        if (left < offsetHorizontal - marginLeft) {
          left = offsetHorizontal - marginLeft;
          node.style.left = `${Math.ceil(left)}px`;
        }
        node.style.zIndex = "-1000";
        const bottom = rect.bottom;
        const includesLeftTop = host.contains(document.elementFromPoint(left, top));
        const includesRightTop = host.contains(document.elementFromPoint(right, top));
        const includesRightBottom = host.contains(document.elementFromPoint(right, bottom));
        const includesLeftBottom = host.contains(document.elementFromPoint(left, bottom));
        node.style.zIndex = "";
        const topEdgeInside = includesLeftTop || includesRightTop;
        const bottomEdgeInside = includesLeftBottom || includesRightBottom;
        const leftEdgeInside = includesLeftTop || includesLeftBottom;
        const rightEdgeInside = includesRightBottom || includesRightTop;
        const height = bottom - top;
        const width = right - left;
        const overTheTop = top < hostRect.top;
        const belowTheBottom = bottom > hostRect.bottom;
        const beforeTheLeft = left + marginLeft < hostRect.left;
        const afterTheRight = right > hostRect.right;
        let hide = false;
        let leftChanged = false;
        let topChanged = false;
        if (overTheTop) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.top) || "hidden-inside") {
            case "hidden-inside":
              if (!topEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!bottomEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.top > top) {
                top = hostRect.top;
                topChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.top > bottom) {
                top = hostRect.top - height;
                topChanged = true;
              }
              break;
          }
        }
        if (belowTheBottom) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.bottom) || "hidden-outside") {
            case "hidden-inside":
              if (!bottomEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!topEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.bottom < bottom) {
                top = hostRect.bottom - height;
                topChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.bottom < top) {
                top = hostRect.bottom;
                topChanged = true;
              }
              break;
          }
        }
        if (beforeTheLeft) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.left) || "hidden-inside") {
            case "hidden-inside":
              if (!leftEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!rightEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.left > left + marginLeft) {
                left = hostRect.left - marginLeft;
                leftChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.left > right) {
                left = hostRect.left - marginLeft - width;
                leftChanged = true;
              }
              break;
          }
        }
        if (afterTheRight) {
          switch ((outOfViewDisplay === null || outOfViewDisplay === void 0 ? void 0 : outOfViewDisplay.right) || "hidden-outside") {
            case "hidden-inside":
              if (!rightEdgeInside) {
                hide = true;
              }
              break;
            case "hidden-outside":
              if (!leftEdgeInside) {
                hide = true;
              }
              break;
            case "stick-inside":
              if (hostRect.right < right) {
                left = hostRect.right - width;
                leftChanged = true;
              }
              break;
            case "stick-outside":
              if (hostRect.right < left) {
                left = hostRect.right;
                leftChanged = true;
              }
              break;
          }
        }
        if (hide) {
          node.style.zIndex = OUTOFVIEW_Z_INDEX;
          node.style.visibility = "hidden";
        }
        if (leftChanged) {
          node.style.left = `${Math.ceil(left)}px`;
        }
        if (topChanged) {
          node.style.top = `${Math.ceil(top)}px`;
        }
      }
      HoverBox2.setGeometry = setGeometry;
    })(HoverBox || (HoverBox = {}));
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/tokens.js
var import_coreutils10, IFormRendererRegistry, ILabIconManager;
var init_tokens2 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/tokens.js"() {
    import_coreutils10 = __toESM(require_dist());
    IFormRendererRegistry = new import_coreutils10.Token("@jupyterlab/ui-components:IFormRendererRegistry", "A service for settings form renderer registration.");
    ILabIconManager = new import_coreutils10.Token("@jupyterlab/ui-components:ILabIconManager", "A service to register and request icons.");
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/FormRendererRegistry.js
var init_FormRendererRegistry = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/FormRendererRegistry.js"() {
  }
});

// ../../node_modules/@jupyterlab/ui-components/lib/index.js
var init_lib4 = __esm({
  "../../node_modules/@jupyterlab/ui-components/lib/index.js"() {
    init_components();
    init_icon2();
    init_hoverbox();
    init_tokens2();
    init_utils2();
    init_FormRendererRegistry();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof(key2) === "symbol" ? key2 : String(key2);
}
var init_toPropertyKey = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// ../../node_modules/@jupyterlab/observables/lib/observablemap.js
var ObservableMap, Private25;
var init_observablemap = __esm({
  "../../node_modules/@jupyterlab/observables/lib/observablemap.js"() {
    init_index_es63();
    ObservableMap = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._itemCmp = options.itemCmp || Private25.itemCmp;
        if (options.values) {
          for (const key2 in options.values) {
            this._map.set(key2, options.values[key2]);
          }
        }
      }
      /**
       * The type of the Observable.
       */
      get type() {
        return "Map";
      }
      /**
       * A signal emitted when the map has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Whether this map has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The number of key-value pairs in the map.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Set a key-value pair in the map
       *
       * @param key - The key to set.
       *
       * @param value - The value for the key.
       *
       * @returns the old value for the key, or undefined
       *   if that did not exist.
       *
       * @throws if the new value is undefined.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      set(key2, value) {
        const oldVal = this._map.get(key2);
        if (value === void 0) {
          throw Error("Cannot set an undefined value, use remove");
        }
        const itemCmp = this._itemCmp;
        if (oldVal !== void 0 && itemCmp(oldVal, value)) {
          return oldVal;
        }
        this._map.set(key2, value);
        this._changed.emit({
          type: oldVal ? "change" : "add",
          key: key2,
          oldValue: oldVal,
          newValue: value
        });
        return oldVal;
      }
      /**
       * Get a value for a given key.
       *
       * @param key - the key.
       *
       * @returns the value for that key.
       */
      get(key2) {
        return this._map.get(key2);
      }
      /**
       * Check whether the map has a key.
       *
       * @param key - the key to check.
       *
       * @returns `true` if the map has the key, `false` otherwise.
       */
      has(key2) {
        return this._map.has(key2);
      }
      /**
       * Get a list of the keys in the map.
       *
       * @returns - a list of keys.
       */
      keys() {
        const keyList = [];
        this._map.forEach((v2, k) => {
          keyList.push(k);
        });
        return keyList;
      }
      /**
       * Get a list of the values in the map.
       *
       * @returns - a list of values.
       */
      values() {
        const valList = [];
        this._map.forEach((v2, k) => {
          valList.push(v2);
        });
        return valList;
      }
      /**
       * Remove a key from the map
       *
       * @param key - the key to remove.
       *
       * @returns the value of the given key,
       *   or undefined if that does not exist.
       *
       * #### Notes
       * This is a no-op if the value does not change.
       */
      delete(key2) {
        const oldVal = this._map.get(key2);
        const removed = this._map.delete(key2);
        if (removed) {
          this._changed.emit({
            type: "remove",
            key: key2,
            oldValue: oldVal,
            newValue: void 0
          });
        }
        return oldVal;
      }
      /**
       * Set the ObservableMap to an empty map.
       */
      clear() {
        const keyList = this.keys();
        for (let i2 = 0; i2 < keyList.length; i2++) {
          this.delete(keyList[i2]);
        }
      }
      /**
       * Dispose of the resources held by the map.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._map.clear();
      }
    };
    (function(Private31) {
      function itemCmp(first, second) {
        return first === second;
      }
      Private31.itemCmp = itemCmp;
    })(Private25 || (Private25 = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/node_modules/@lumino/algorithm/dist/index.es6.js
function every3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* retro3(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
var ArrayExt6, Private26, StringExt6;
var init_index_es624 = __esm({
  "../../node_modules/@jupyterlab/observables/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt6 || (ArrayExt6 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private26 || (Private26 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt6 || (StringExt6 = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList3, Private27;
var init_index_es625 = __esm({
  "../../node_modules/@jupyterlab/observables/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList3 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values) {
        this.clear();
        for (const value of values) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private27.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private27.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private27.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private27.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private27.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private27.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private27.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList4) {
      function from(values) {
        let list = new LinkedList4();
        list.assign(values);
        return list;
      }
      LinkedList4.from = from;
    })(LinkedList3 || (LinkedList3 = {}));
    (function(Private31) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private31.LinkedListNode = LinkedListNode;
    })(Private27 || (Private27 = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/node_modules/@lumino/messaging/dist/index.es6.js
var Message2, MessageLoop3;
var init_index_es626 = __esm({
  "../../node_modules/@jupyterlab/observables/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es624();
    init_index_es625();
    Message2 = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    (function(MessageLoop4) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every3(retro3(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop4.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some3(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop4.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop4.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i2 = hooks.indexOf(hook);
        if (i2 === -1) {
          return;
        }
        hooks[i2] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop4.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt6.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop4.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop4.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop4.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop4.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList3();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result = true;
        try {
          if (typeof hook === "function") {
            result = hook(handler, msg);
          } else {
            result = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt6.removeAllWhere(hooks, isNull);
      }
      function isNull(value) {
        return value === null;
      }
    })(MessageLoop3 || (MessageLoop3 = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/lib/observablejson.js
var import_coreutils11, ObservableJSON;
var init_observablejson = __esm({
  "../../node_modules/@jupyterlab/observables/lib/observablejson.js"() {
    import_coreutils11 = __toESM(require_dist());
    init_index_es626();
    init_observablemap();
    ObservableJSON = class extends ObservableMap {
      /**
       * Construct a new observable JSON object.
       */
      constructor(options = {}) {
        super({
          itemCmp: import_coreutils11.JSONExt.deepEqual,
          values: options.values
        });
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const out = /* @__PURE__ */ Object.create(null);
        const keys = this.keys();
        for (const key2 of keys) {
          const value = this.get(key2);
          if (value !== void 0) {
            out[key2] = import_coreutils11.JSONExt.deepCopy(value);
          }
        }
        return out;
      }
    };
    (function(ObservableJSON2) {
      class ChangeMessage extends Message2 {
        /**
         * Create a new metadata changed message.
         */
        constructor(type, args) {
          super(type);
          this.args = args;
        }
      }
      ObservableJSON2.ChangeMessage = ChangeMessage;
    })(ObservableJSON || (ObservableJSON = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/lib/observablestring.js
var init_observablestring = __esm({
  "../../node_modules/@jupyterlab/observables/lib/observablestring.js"() {
    init_index_es63();
  }
});

// ../../node_modules/@jupyterlab/observables/lib/observablelist.js
var ObservableList, Private28;
var init_observablelist = __esm({
  "../../node_modules/@jupyterlab/observables/lib/observablelist.js"() {
    init_index_es624();
    init_index_es63();
    ObservableList = class {
      /**
       * Construct a new observable map.
       */
      constructor(options = {}) {
        this._array = [];
        this._isDisposed = false;
        this._changed = new Signal(this);
        if (options.values) {
          for (const value of options.values) {
            this._array.push(value);
          }
        }
        this._itemCmp = options.itemCmp || Private28.itemCmp;
      }
      /**
       * The type of this object.
       */
      get type() {
        return "List";
      }
      /**
       * A signal emitted when the list has changed.
       */
      get changed() {
        return this._changed;
      }
      /**
       * The length of the list.
       */
      get length() {
        return this._array.length;
      }
      /**
       * Test whether the list has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the list.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this.clear();
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting at the front of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       */
      [Symbol.iterator]() {
        return this._array[Symbol.iterator]();
      }
      /**
       * Get the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @returns The value at the specified index.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      get(index) {
        return this._array[index];
      }
      /**
       * Set the value at the specified index.
       *
       * @param index - The positive integer index of interest.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral or out of range.
       */
      set(index, value) {
        const oldValue = this._array[index];
        if (value === void 0) {
          throw new Error("Cannot set an undefined item");
        }
        const itemCmp = this._itemCmp;
        if (itemCmp(oldValue, value)) {
          return;
        }
        this._array[index] = value;
        this._changed.emit({
          type: "set",
          oldIndex: index,
          newIndex: index,
          oldValues: [oldValue],
          newValues: [value]
        });
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      push(value) {
        const num = this._array.push(value);
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex: this.length - 1,
          oldValues: [],
          newValues: [value]
        });
        return num;
      }
      /**
       * Insert a value into the list at a specific index.
       *
       * @param index - The index at which to insert the value.
       *
       * @param value - The value to set at the specified index.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       *
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * The value -2 as oldIndex can be used to distinguish from the push
       * method which will use a value -1.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insert(index, value) {
        if (index === this._array.length) {
          this._array.push(value);
        } else {
          ArrayExt6.insert(this._array, index, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex: index,
          oldValues: [],
          newValues: [value]
        });
      }
      /**
       * Remove the first occurrence of a value from the list.
       *
       * @param value - The value of interest.
       *
       * @returns The index of the removed value, or `-1` if the value
       *   is not contained in the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       */
      removeValue(value) {
        const itemCmp = this._itemCmp;
        const index = ArrayExt6.findFirstIndex(this._array, (item) => {
          return itemCmp(item, value);
        });
        this.remove(index);
        return index;
      }
      /**
       * Remove and return the value at a specific index.
       *
       * @param index - The index of the value of interest.
       *
       * @returns The value at the specified index, or `undefined` if the
       *   index is out of range.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the removed value and beyond are invalidated.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      remove(index) {
        const value = ArrayExt6.removeAt(this._array, index);
        if (value === void 0) {
          return;
        }
        this._changed.emit({
          type: "remove",
          oldIndex: index,
          newIndex: -1,
          newValues: [],
          oldValues: [value]
        });
        return value;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * All current iterators are invalidated.
       */
      clear() {
        const copy = this._array.slice();
        this._array.length = 0;
        this._changed.emit({
          type: "remove",
          oldIndex: 0,
          newIndex: 0,
          newValues: [],
          oldValues: copy
        });
      }
      /**
       * Move a value from one index to another.
       *
       * @param fromIndex - The index of the element to move.
       *
       * @param toIndex - The index to move the element to.
       *
       * #### Complexity
       * Constant.
       *
       * #### Iterator Validity
       * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
       * and beyond are invalidated.
       *
       * #### Undefined Behavior
       * A `fromIndex` or a `toIndex` which is non-integral.
       */
      move(fromIndex, toIndex) {
        if (this.length <= 1 || fromIndex === toIndex) {
          return;
        }
        const values = [this._array[fromIndex]];
        ArrayExt6.move(this._array, fromIndex, toIndex);
        this._changed.emit({
          type: "move",
          oldIndex: fromIndex,
          newIndex: toIndex,
          oldValues: values,
          newValues: values
        });
      }
      /**
       * Push a set of values to the back of the list.
       *
       * @param values - An iterable set of values to add.
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Notes
       * By convention, the oldIndex is set to -1 to indicate
       * an push operation.
       *
       * #### Iterator Validity
       * No changes.
       */
      pushAll(values) {
        const newIndex = this.length;
        for (const value of values) {
          this._array.push(value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -1,
          newIndex,
          oldValues: [],
          newValues: Array.from(values)
        });
        return this.length;
      }
      /**
       * Insert a set of items into the list at the specified index.
       *
       * @param index - The index at which to insert the values.
       *
       * @param values - The values to insert at the specified index.
       *
       * #### Complexity.
       * Linear.
       *
       * #### Iterator Validity
       * No changes.
       *
       * #### Notes
       * The `index` will be clamped to the bounds of the list.
       * By convention, the oldIndex is set to -2 to indicate
       * an insert operation.
       *
       * #### Undefined Behavior.
       * An `index` which is non-integral.
       */
      insertAll(index, values) {
        const newIndex = index;
        for (const value of values) {
          ArrayExt6.insert(this._array, index++, value);
        }
        this._changed.emit({
          type: "add",
          oldIndex: -2,
          newIndex,
          oldValues: [],
          newValues: Array.from(values)
        });
      }
      /**
       * Remove a range of items from the list.
       *
       * @param startIndex - The start index of the range to remove (inclusive).
       *
       * @param endIndex - The end index of the range to remove (exclusive).
       *
       * @returns The new length of the list.
       *
       * #### Complexity
       * Linear.
       *
       * #### Iterator Validity
       * Iterators pointing to the first removed value and beyond are invalid.
       *
       * #### Undefined Behavior
       * A `startIndex` or `endIndex` which is non-integral.
       */
      removeRange(startIndex, endIndex) {
        const oldValues = this._array.slice(startIndex, endIndex);
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          ArrayExt6.removeAt(this._array, startIndex);
        }
        this._changed.emit({
          type: "remove",
          oldIndex: startIndex,
          newIndex: -1,
          oldValues,
          newValues: []
        });
        return this.length;
      }
    };
    (function(Private31) {
      function itemCmp(first, second) {
        return first === second;
      }
      Private31.itemCmp = itemCmp;
    })(Private28 || (Private28 = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/lib/undoablelist.js
var ObservableUndoableList;
var init_undoablelist = __esm({
  "../../node_modules/@jupyterlab/observables/lib/undoablelist.js"() {
    init_observablelist();
    ObservableUndoableList = class extends ObservableList {
      /**
       * Construct a new undoable observable list.
       */
      constructor(serializer) {
        super();
        this._inCompound = false;
        this._isUndoable = true;
        this._madeCompoundChange = false;
        this._index = -1;
        this._stack = [];
        this._serializer = serializer;
        this.changed.connect(this._onListChanged, this);
      }
      /**
       * Whether the object can redo changes.
       */
      get canRedo() {
        return this._index < this._stack.length - 1;
      }
      /**
       * Whether the object can undo changes.
       */
      get canUndo() {
        return this._index >= 0;
      }
      /**
       * Begin a compound operation.
       *
       * @param isUndoAble - Whether the operation is undoable.
       *   The default is `true`.
       */
      beginCompoundOperation(isUndoAble) {
        this._inCompound = true;
        this._isUndoable = isUndoAble !== false;
        this._madeCompoundChange = false;
      }
      /**
       * End a compound operation.
       */
      endCompoundOperation() {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
          this._index++;
        }
      }
      /**
       * Undo an operation.
       */
      undo() {
        if (!this.canUndo) {
          return;
        }
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes.reverse()) {
          this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
      }
      /**
       * Redo an operation.
       */
      redo() {
        if (!this.canRedo) {
          return;
        }
        this._index++;
        const changes = this._stack[this._index];
        this._isUndoable = false;
        for (const change of changes) {
          this._redoChange(change);
        }
        this._isUndoable = true;
      }
      /**
       * Clear the change stack.
       */
      clearUndo() {
        this._index = -1;
        this._stack = [];
      }
      /**
       * Handle a change in the list.
       */
      _onListChanged(list, change) {
        if (this.isDisposed || !this._isUndoable) {
          return;
        }
        if (!this._inCompound || !this._madeCompoundChange) {
          this._stack = this._stack.slice(0, this._index + 1);
        }
        const evt = this._copyChange(change);
        if (this._stack[this._index + 1]) {
          this._stack[this._index + 1].push(evt);
        } else {
          this._stack.push([evt]);
        }
        if (!this._inCompound) {
          this._index++;
        } else {
          this._madeCompoundChange = true;
        }
      }
      /**
       * Undo a change event.
       */
      _undoChange(change) {
        let index = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            for (let length = change.newValues.length; length > 0; length--) {
              this.remove(change.newIndex);
            }
            break;
          case "set":
            index = change.oldIndex;
            for (const value of change.oldValues) {
              this.set(index++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            index = change.oldIndex;
            for (const value of change.oldValues) {
              this.insert(index++, serializer.fromJSON(value));
            }
            break;
          case "move":
            this.move(change.newIndex, change.oldIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Redo a change event.
       */
      _redoChange(change) {
        let index = 0;
        const serializer = this._serializer;
        switch (change.type) {
          case "add":
            index = change.newIndex;
            for (const value of change.newValues) {
              this.insert(index++, serializer.fromJSON(value));
            }
            break;
          case "set":
            index = change.newIndex;
            for (const value of change.newValues) {
              this.set(change.newIndex++, serializer.fromJSON(value));
            }
            break;
          case "remove":
            for (let length = change.oldValues.length; length > 0; length--) {
              this.remove(change.oldIndex);
            }
            break;
          case "move":
            this.move(change.oldIndex, change.newIndex);
            break;
          default:
            return;
        }
      }
      /**
       * Copy a change as JSON.
       */
      _copyChange(change) {
        const oldValues = [];
        for (const value of change.oldValues) {
          oldValues.push(this._serializer.toJSON(value));
        }
        const newValues = [];
        for (const value of change.newValues) {
          newValues.push(this._serializer.toJSON(value));
        }
        return {
          type: change.type,
          oldIndex: change.oldIndex,
          newIndex: change.newIndex,
          oldValues,
          newValues
        };
      }
    };
    (function(ObservableUndoableList2) {
      class IdentitySerializer {
        /**
         * Identity serialize.
         */
        toJSON(value) {
          return value;
        }
        /**
         * Identity deserialize.
         */
        fromJSON(value) {
          return value;
        }
      }
      ObservableUndoableList2.IdentitySerializer = IdentitySerializer;
    })(ObservableUndoableList || (ObservableUndoableList = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/lib/modeldb.js
var import_coreutils12, ObservableValue;
var init_modeldb = __esm({
  "../../node_modules/@jupyterlab/observables/lib/modeldb.js"() {
    import_coreutils12 = __toESM(require_dist());
    init_index_es65();
    init_index_es63();
    ObservableValue = class {
      /**
       * Constructor for the value.
       *
       * @param initialValue: the starting value for the `ObservableValue`.
       */
      constructor(initialValue = null) {
        this._value = null;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this._value = initialValue;
      }
      /**
       * The observable type.
       */
      get type() {
        return "Value";
      }
      /**
       * Whether the value has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The changed signal.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the current value, or `undefined` if it has not been set.
       */
      get() {
        return this._value;
      }
      /**
       * Set the current value.
       */
      set(value) {
        const oldValue = this._value;
        if (import_coreutils12.JSONExt.deepEqual(oldValue, value)) {
          return;
        }
        this._value = value;
        this._changed.emit({
          oldValue,
          newValue: value
        });
      }
      /**
       * Dispose of the resources held by the value.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
        this._value = null;
      }
    };
    (function(ObservableValue2) {
      class IChangedArgs {
      }
      ObservableValue2.IChangedArgs = IChangedArgs;
    })(ObservableValue || (ObservableValue = {}));
  }
});

// ../../node_modules/@jupyterlab/observables/lib/index.js
var init_lib5 = __esm({
  "../../node_modules/@jupyterlab/observables/lib/index.js"() {
    init_modeldb();
    init_observablejson();
    init_observablelist();
    init_observablemap();
    init_observablestring();
    init_undoablelist();
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/hover.js
function showPopup(options) {
  const dialog = new Popup(options);
  if (!options.startHidden) {
    dialog.launch();
  }
  return dialog;
}
var Popup;
var init_hover = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/hover.js"() {
    init_lib4();
    init_index_es619();
    Popup = class extends Widget {
      /**
       * Construct a new Popup.
       */
      constructor(options) {
        super();
        this._body = options.body;
        this._body.addClass("jp-StatusBar-HoverItem");
        this._anchor = options.anchor;
        this._align = options.align;
        if (options.hasDynamicSize) {
          this._observer = new ResizeObserver(() => {
            this.update();
          });
        }
        const layout = this.layout = new PanelLayout();
        layout.addWidget(options.body);
        this._body.node.addEventListener("resize", () => {
          this.update();
        });
      }
      /**
       * Attach the popup widget to the page.
       */
      launch() {
        this._setGeometry();
        Widget.attach(this, document.body);
        this.update();
        this._anchor.addClass("jp-mod-clicked");
        this._anchor.removeClass("jp-mod-highlight");
      }
      /**
       * Handle `'update'` messages for the widget.
       */
      onUpdateRequest(msg) {
        this._setGeometry();
        super.onUpdateRequest(msg);
      }
      /**
       * Handle `'after-attach'` messages for the widget.
       */
      onAfterAttach(msg) {
        var _a;
        document.addEventListener("click", this, false);
        this.node.addEventListener("keydown", this, false);
        window.addEventListener("resize", this, false);
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.observe(this._body.node);
      }
      /**
       * Handle `'before-detach'` messages for the widget.
       */
      onBeforeDetach(msg) {
        var _a;
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        document.removeEventListener("click", this, false);
        this.node.removeEventListener("keydown", this, false);
        window.removeEventListener("resize", this, false);
      }
      /**
       * Handle `'resize'` messages for the widget.
       */
      onResize() {
        this.update();
      }
      /**
       * Dispose of the widget.
       */
      dispose() {
        var _a;
        (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        super.dispose();
        this._anchor.removeClass("jp-mod-clicked");
        this._anchor.addClass("jp-mod-highlight");
      }
      /**
       * Handle DOM events for the widget.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeydown(event);
            break;
          case "click":
            this._evtClick(event);
            break;
          case "resize":
            this.onResize();
            break;
          default:
            break;
        }
      }
      _evtClick(event) {
        if (!!event.target && !(this._body.node.contains(event.target) || this._anchor.node.contains(event.target))) {
          this.dispose();
        }
      }
      _evtKeydown(event) {
        switch (event.keyCode) {
          case 27:
            event.stopPropagation();
            event.preventDefault();
            this.dispose();
            break;
          default:
            break;
        }
      }
      _setGeometry() {
        let aligned = 0;
        const anchorRect = this._anchor.node.getBoundingClientRect();
        const bodyRect = this._body.node.getBoundingClientRect();
        if (this._align === "right") {
          aligned = -(bodyRect.width - anchorRect.width);
        }
        const style = window.getComputedStyle(this._body.node);
        HoverBox.setGeometry({
          anchor: anchorRect,
          host: document.body,
          maxHeight: 500,
          minHeight: 20,
          node: this._body.node,
          offset: {
            horizontal: aligned
          },
          privilege: "forceAbove",
          style
        });
      }
    };
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/text.js
function TextItem(props) {
  const { title, source, className, ...rest } = props;
  return React9.createElement("span", { className: `jp-StatusBar-TextItem ${className}`, title, ...rest }, source);
}
var React9;
var init_text = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/text.js"() {
    React9 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/group.js
function GroupItem(props) {
  const { spacing, children, className, ...rest } = props;
  const numChildren = React10.Children.count(children);
  return React10.createElement("div", { className: `jp-StatusBar-GroupItem ${className || ""}`, ...rest }, React10.Children.map(children, (child, i2) => {
    if (i2 === 0) {
      return React10.createElement("div", { style: { marginRight: `${spacing}px` } }, child);
    } else if (i2 === numChildren - 1) {
      return React10.createElement("div", { style: { marginLeft: `${spacing}px` } }, child);
    } else {
      return React10.createElement("div", { style: { margin: `0px ${spacing}px` } }, child);
    }
  }));
}
var React10;
var init_group = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/group.js"() {
    React10 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/progressBar.js
var React11;
var init_progressBar = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/progressBar.js"() {
    React11 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/progressCircle.js
var import_react26;
var init_progressCircle = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/progressCircle.js"() {
    import_react26 = __toESM(require_react());
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/components/index.js
var init_components2 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/components/index.js"() {
    init_group();
    init_hover();
    init_progressBar();
    init_text();
    init_progressCircle();
  }
});

// ../../node_modules/@jupyterlab/statusbar/node_modules/@lumino/algorithm/dist/index.es6.js
var ArrayExt7, Private29, StringExt7;
var init_index_es627 = __esm({
  "../../node_modules/@jupyterlab/statusbar/node_modules/@lumino/algorithm/dist/index.es6.js"() {
    (function(ArrayExt8) {
      function firstIndexOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.firstIndexOf = firstIndexOf;
      function lastIndexOf(array, value, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (start < stop) {
          span = start + 1 + (n - stop);
        } else {
          span = start - stop + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start - i2 + n) % n;
          if (array[j] === value) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.lastIndexOf = lastIndexOf;
      function findFirstIndex(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          let j = (start + i2) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findFirstIndex = findFirstIndex;
      function findLastIndex(array, fn, start = -1, stop = 0) {
        let n = array.length;
        if (n === 0) {
          return -1;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let d2;
        if (start < stop) {
          d2 = start + 1 + (n - stop);
        } else {
          d2 = start - stop + 1;
        }
        for (let i2 = 0; i2 < d2; ++i2) {
          let j = (start - i2 + n) % n;
          if (fn(array[j], j)) {
            return j;
          }
        }
        return -1;
      }
      ArrayExt8.findLastIndex = findLastIndex;
      function findFirstValue(array, fn, start = 0, stop = -1) {
        let index = findFirstIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findFirstValue = findFirstValue;
      function findLastValue(array, fn, start = -1, stop = 0) {
        let index = findLastIndex(array, fn, start, stop);
        return index !== -1 ? array[index] : void 0;
      }
      ArrayExt8.findLastValue = findLastValue;
      function lowerBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) < 0) {
            begin = middle + 1;
            span -= half + 1;
          } else {
            span = half;
          }
        }
        return begin;
      }
      ArrayExt8.lowerBound = lowerBound;
      function upperBound(array, value, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let begin = start;
        let span = stop - start + 1;
        while (span > 0) {
          let half = span >> 1;
          let middle = begin + half;
          if (fn(array[middle], value) > 0) {
            span = half;
          } else {
            begin = middle + 1;
            span -= half + 1;
          }
        }
        return begin;
      }
      ArrayExt8.upperBound = upperBound;
      function shallowEqual(a, b, fn) {
        if (a === b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i2 = 0, n = a.length; i2 < n; ++i2) {
          if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      ArrayExt8.shallowEqual = shallowEqual;
      function slice(array, options = {}) {
        let { start, stop, step } = options;
        if (step === void 0) {
          step = 1;
        }
        if (step === 0) {
          throw new Error("Slice `step` cannot be zero.");
        }
        let n = array.length;
        if (start === void 0) {
          start = step < 0 ? n - 1 : 0;
        } else if (start < 0) {
          start = Math.max(start + n, step < 0 ? -1 : 0);
        } else if (start >= n) {
          start = step < 0 ? n - 1 : n;
        }
        if (stop === void 0) {
          stop = step < 0 ? -1 : n;
        } else if (stop < 0) {
          stop = Math.max(stop + n, step < 0 ? -1 : 0);
        } else if (stop >= n) {
          stop = step < 0 ? n - 1 : n;
        }
        let length;
        if (step < 0 && stop >= start || step > 0 && start >= stop) {
          length = 0;
        } else if (step < 0) {
          length = Math.floor((stop - start + 1) / step + 1);
        } else {
          length = Math.floor((stop - start - 1) / step + 1);
        }
        let result = [];
        for (let i2 = 0; i2 < length; ++i2) {
          result[i2] = array[start + i2 * step];
        }
        return result;
      }
      ArrayExt8.slice = slice;
      function move(array, fromIndex, toIndex) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (fromIndex < 0) {
          fromIndex = Math.max(0, fromIndex + n);
        } else {
          fromIndex = Math.min(fromIndex, n - 1);
        }
        if (toIndex < 0) {
          toIndex = Math.max(0, toIndex + n);
        } else {
          toIndex = Math.min(toIndex, n - 1);
        }
        if (fromIndex === toIndex) {
          return;
        }
        let value = array[fromIndex];
        let d2 = fromIndex < toIndex ? 1 : -1;
        for (let i2 = fromIndex; i2 !== toIndex; i2 += d2) {
          array[i2] = array[i2 + d2];
        }
        array[toIndex] = value;
      }
      ArrayExt8.move = move;
      function reverse(array, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        while (start < stop) {
          let a = array[start];
          let b = array[stop];
          array[start++] = b;
          array[stop--] = a;
        }
      }
      ArrayExt8.reverse = reverse;
      function rotate(array, delta, start = 0, stop = -1) {
        let n = array.length;
        if (n <= 1) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        if (start >= stop) {
          return;
        }
        let length = stop - start + 1;
        if (delta > 0) {
          delta = delta % length;
        } else if (delta < 0) {
          delta = (delta % length + length) % length;
        }
        if (delta === 0) {
          return;
        }
        let pivot = start + delta;
        reverse(array, start, pivot - 1);
        reverse(array, pivot, stop);
        reverse(array, start, stop);
      }
      ArrayExt8.rotate = rotate;
      function fill(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let span;
        if (stop < start) {
          span = stop + 1 + (n - start);
        } else {
          span = stop - start + 1;
        }
        for (let i2 = 0; i2 < span; ++i2) {
          array[(start + i2) % n] = value;
        }
      }
      ArrayExt8.fill = fill;
      function insert(array, index, value) {
        let n = array.length;
        if (index < 0) {
          index = Math.max(0, index + n);
        } else {
          index = Math.min(index, n);
        }
        for (let i2 = n; i2 > index; --i2) {
          array[i2] = array[i2 - 1];
        }
        array[index] = value;
      }
      ArrayExt8.insert = insert;
      function removeAt(array, index) {
        let n = array.length;
        if (index < 0) {
          index += n;
        }
        if (index < 0 || index >= n) {
          return void 0;
        }
        let value = array[index];
        for (let i2 = index + 1; i2 < n; ++i2) {
          array[i2 - 1] = array[i2];
        }
        array.length = n - 1;
        return value;
      }
      ArrayExt8.removeAt = removeAt;
      function removeFirstOf(array, value, start = 0, stop = -1) {
        let index = firstIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeFirstOf = removeFirstOf;
      function removeLastOf(array, value, start = -1, stop = 0) {
        let index = lastIndexOf(array, value, start, stop);
        if (index !== -1) {
          removeAt(array, index);
        }
        return index;
      }
      ArrayExt8.removeLastOf = removeLastOf;
      function removeAllOf(array, value, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllOf = removeAllOf;
      function removeFirstWhere(array, fn, start = 0, stop = -1) {
        let value;
        let index = findFirstIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeFirstWhere = removeFirstWhere;
      function removeLastWhere(array, fn, start = -1, stop = 0) {
        let value;
        let index = findLastIndex(array, fn, start, stop);
        if (index !== -1) {
          value = removeAt(array, index);
        }
        return { index, value };
      }
      ArrayExt8.removeLastWhere = removeLastWhere;
      function removeAllWhere(array, fn, start = 0, stop = -1) {
        let n = array.length;
        if (n === 0) {
          return 0;
        }
        if (start < 0) {
          start = Math.max(0, start + n);
        } else {
          start = Math.min(start, n - 1);
        }
        if (stop < 0) {
          stop = Math.max(0, stop + n);
        } else {
          stop = Math.min(stop, n - 1);
        }
        let count = 0;
        for (let i2 = 0; i2 < n; ++i2) {
          if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
            count++;
          } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
            count++;
          } else if (count > 0) {
            array[i2 - count] = array[i2];
          }
        }
        if (count > 0) {
          array.length = n - count;
        }
        return count;
      }
      ArrayExt8.removeAllWhere = removeAllWhere;
    })(ArrayExt7 || (ArrayExt7 = {}));
    (function(Private31) {
      function rangeLength(start, stop, step) {
        if (step === 0) {
          return Infinity;
        }
        if (start > stop && step > 0) {
          return 0;
        }
        if (start < stop && step < 0) {
          return 0;
        }
        return Math.ceil((stop - start) / step);
      }
      Private31.rangeLength = rangeLength;
    })(Private29 || (Private29 = {}));
    (function(StringExt8) {
      function findIndices(source, query, start = 0) {
        let indices = new Array(query.length);
        for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
          j = source.indexOf(query[i2], j);
          if (j === -1) {
            return null;
          }
          indices[i2] = j;
        }
        return indices;
      }
      StringExt8.findIndices = findIndices;
      function matchSumOfSquares(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2] - start;
          score += j * j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfSquares = matchSumOfSquares;
      function matchSumOfDeltas(source, query, start = 0) {
        let indices = findIndices(source, query, start);
        if (!indices) {
          return null;
        }
        let score = 0;
        let last = start - 1;
        for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
          let j = indices[i2];
          score += j - last - 1;
          last = j;
        }
        return { score, indices };
      }
      StringExt8.matchSumOfDeltas = matchSumOfDeltas;
      function highlight(source, indices, fn) {
        let result = [];
        let k = 0;
        let last = 0;
        let n = indices.length;
        while (k < n) {
          let i2 = indices[k];
          let j = indices[k];
          while (++k < n && indices[k] === j + 1) {
            j++;
          }
          if (last < i2) {
            result.push(source.slice(last, i2));
          }
          if (i2 < j + 1) {
            result.push(fn(source.slice(i2, j + 1)));
          }
          last = j + 1;
        }
        if (last < source.length) {
          result.push(source.slice(last));
        }
        return result;
      }
      StringExt8.highlight = highlight;
      function cmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      StringExt8.cmp = cmp;
    })(StringExt7 || (StringExt7 = {}));
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/statusbar.js
var Private30;
var init_statusbar = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/statusbar.js"() {
    init_index_es627();
    init_index_es65();
    init_index_es619();
    (function(Private31) {
      Private31.statusItemDefaults = {
        align: "left",
        rank: 0,
        isActive: () => true,
        activeStateChanged: void 0
      };
    })(Private30 || (Private30 = {}));
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/tokens.js
var import_coreutils13, IStatusBar;
var init_tokens3 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/tokens.js"() {
    import_coreutils13 = __toESM(require_dist());
    IStatusBar = new import_coreutils13.Token("@jupyterlab/statusbar:IStatusBar", "A service for the status bar on the application. Use this if you want to add new status bar items.");
  }
});

// ../../node_modules/@jupyterlab/statusbar/lib/index.js
var init_lib6 = __esm({
  "../../node_modules/@jupyterlab/statusbar/lib/index.js"() {
    init_components2();
    init_statusbar();
    init_tokens3();
  }
});

export {
  require_jsx_runtime,
  __assign,
  __rest,
  __awaiter,
  __spreadArray,
  tslib_es6_exports,
  init_tslib_es6,
  require_dist,
  Signal,
  init_index_es63 as init_index_es6,
  init_index_es65 as init_index_es62,
  require_lib5 as require_lib,
  Widget,
  PanelLayout,
  Panel,
  BoxLayout,
  BoxPanel,
  TabBar,
  FocusTracker,
  init_index_es619 as init_index_es63,
  require_lib2,
  classes,
  Button,
  LabIcon,
  circleEmptyIcon,
  circleIcon,
  closeIcon,
  kernelIcon,
  lineFormIcon,
  offlineBoltIcon,
  refreshIcon,
  stopIcon,
  terminalIcon,
  nullTranslator,
  require_lib as require_lib3,
  init_lib,
  require_isEqual,
  InputGroup,
  ReactWidget,
  VDomRenderer,
  UseSignal,
  VDomModel,
  Toolbar,
  ReactiveToolbar,
  ToolbarButtonComponent,
  ToolbarButton,
  Spinner,
  Styling,
  init_lib4 as init_lib2,
  ObservableMap,
  ObservableJSON,
  ObservableList,
  init_lib5 as init_lib3,
  GroupItem,
  showPopup,
  TextItem,
  init_lib6 as init_lib4,
  _extends,
  init_extends,
  _typeof,
  init_typeof,
  _toPropertyKey,
  init_toPropertyKey,
  _defineProperty,
  init_defineProperty,
  _arrayLikeToArray,
  init_arrayLikeToArray,
  _unsupportedIterableToArray,
  init_unsupportedIterableToArray
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=/myst_assets_folder/_shared/chunk-54HHBP5N.js.map
