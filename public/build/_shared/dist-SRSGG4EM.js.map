{
  "version": 3,
  "sources": ["../../../../../node_modules/trie-prefix-tree/dist/config.js", "../../../../../node_modules/trie-prefix-tree/dist/append.js", "../../../../../node_modules/trie-prefix-tree/dist/create.js", "../../../../../node_modules/trie-prefix-tree/dist/utils.js", "../../../../../node_modules/trie-prefix-tree/dist/checkPrefix.js", "../../../../../node_modules/trie-prefix-tree/dist/recursePrefix.js", "../../../../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js", "../../../../../node_modules/trie-prefix-tree/dist/permutations.js", "../../../../../node_modules/trie-prefix-tree/dist/index.js", "../../../../../node_modules/color/node_modules/color-name/index.js", "../../../../../node_modules/color/node_modules/color-convert/conversions.js", "../../../../../node_modules/color/node_modules/color-convert/route.js", "../../../../../node_modules/color/node_modules/color-convert/index.js", "../../../../../node_modules/color/index.js", "../../../../../node_modules/myst-to-typst/dist/container.js", "../../../../../node_modules/myst-to-typst/dist/types.js", "../../../../../node_modules/myst-to-typst/dist/utils.js", "../../../../../node_modules/@unified-latex/package/cleveref/provides.ts", "../../../../../node_modules/@unified-latex/libs/builders.ts", "../../../../../node_modules/@unified-latex/libs/print-raw.ts", "../../../../../node_modules/@unified-latex/libs/match.ts", "../../../../../node_modules/@unified-latex/libs/list-math-children.ts", "../../../../../node_modules/@unified-latex/libs/visit.ts", "../../../../../node_modules/@unified-latex/index.ts", "../../../../../node_modules/@unified-latex/libs/trim.ts", "../../../../../node_modules/@unified-latex/libs/unified-latex-trim-environment-contents.ts", "../../../../../node_modules/@unified-latex/libs/unified-latex-trim-root.ts", "../../../../../node_modules/@unified-latex/libs/has-whitespace-equivalent.ts", "../../../../../node_modules/@unified-latex/libs/split-on-condition.ts", "../../../../../node_modules/@unified-latex/libs/split-on-macro.ts", "../../../../../node_modules/@unified-latex/libs/unsplit-on-macro.ts", "../../../../../node_modules/@unified-latex/libs/array-join.ts", "../../../../../node_modules/@unified-latex/libs/replace-node.ts", "../../../../../node_modules/@unified-latex/libs/utils/significant-node.ts", "../../../../../node_modules/@unified-latex/libs/utils/join-without-excess-whitespace.ts", "../../../../../node_modules/@unified-latex/libs/utils/wrap-significant-content.ts", "../../../../../node_modules/@unified-latex/libs/utils/replace-streaming-command-in-array.ts", "../../../../../node_modules/@unified-latex/libs/replace-streaming-command.ts", "../../../../../node_modules/@unified-latex/libs/replace-node-during-visit.ts", "../../../../../node_modules/@unified-latex/libs/unified-latex-streaming-command.ts", "../../../../../node_modules/@unified-latex/utils/enumerate.ts", "../../../../../node_modules/@unified-latex/package/exam/provides.ts", "../../../../../node_modules/@unified-latex/package/geometry/provides.ts", "../../../../../node_modules/@unified-latex/package/hyperref/provides.ts", "../../../../../node_modules/@unified-latex/package/latex2e/provides.ts", "../../../../../node_modules/@unified-latex/libs/decorate-array-for-pegjs.ts", "../../../../../node_modules/@unified-latex/libs/split-strings.ts", "../../../../../node_modules/@unified-latex/grammars/latex.pegjs", "../../../../../node_modules/@unified-latex/grammars/align-environment.pegjs", "../../../../../node_modules/@unified-latex/grammars/xparse-argspec.pegjs", "../../../../../node_modules/@unified-latex/grammars/pgfkeys.pegjs", "../../../../../node_modules/@unified-latex/grammars/macro-substitutions.pegjs", "../../../../../node_modules/@unified-latex/grammars/ligatures.pegjs", "../../../../../node_modules/@unified-latex/grammars/xcolor-expressions.pegjs", "../../../../../node_modules/@unified-latex/grammars/tabular-spec.pegjs", "../../../../../node_modules/@unified-latex/grammars/systeme-environment.pegjs", "../../../../../node_modules/@unified-latex/grammars/tex-glue.pegjs", "../../../../../node_modules/@unified-latex/grammars/tikz.pegjs", "../../../../../node_modules/@unified-latex/libs/pegjs-parsers.ts", "../../../../../node_modules/@unified-latex/libs/argspec-parser.ts", "../../../../../node_modules/@unified-latex/libs/scan.ts", "../../../../../node_modules/@unified-latex/libs/prefix-match.ts", "../../../../../node_modules/@unified-latex/libs/gobble-single-argument.ts", "../../../../../node_modules/@unified-latex/libs/gobble-arguments.ts", "../../../../../node_modules/@unified-latex/libs/attach-arguments.ts", "../../../../../node_modules/@unified-latex/libs/unified-latex-attach-macro-arguments.ts", "../../../../../node_modules/@unified-latex/libs/get-args-content.ts", "../../../../../node_modules/@unified-latex/package/listings/libs/argument-parser.ts", "../../../../../node_modules/@unified-latex/package/listings/provides.ts", "../../../../../node_modules/@unified-latex/package/makeidx/provides.ts", "../../../../../node_modules/@unified-latex/package/mathtools/provides.ts", "../../../../../node_modules/@unified-latex/package/minted/libs/argument-parser.ts", "../../../../../node_modules/@unified-latex/package/minted/provides.ts", "../../../../../node_modules/@unified-latex/package/nicematrix/provides.ts", "../../../../../node_modules/@unified-latex/package/systeme/provides.ts", "../../../../../node_modules/structured-clone/index.ts", "../../../../../node_modules/@unified-latex/package/tikz/libs/tikz-command-argument-parser.ts", "../../../../../node_modules/@unified-latex/package/tikz/provides.ts", "../../../../../node_modules/@unified-latex/package/tikz/libs/parser.ts", "../../../../../node_modules/@unified-latex/package/xcolor/provides.ts", "../../../../../node_modules/@unified-latex/package/xcolor/libs/predefined-colors.ts", "../../../../../node_modules/@unified-latex/package/xcolor/libs/parser.ts", "../../../../../node_modules/@unified-latex/package/xcolor/libs/xcolor.ts", "../../../../../node_modules/@unified-latex/package/xparse/provides.ts", "../../../../../node_modules/@unified-latex/package/beamer/provides.ts", "../../../../../node_modules/@unified-latex/package/multicol/provides.ts", "../../../../../node_modules/@unified-latex/index.ts", "../../../../../node_modules/@unified-latex/libs/process-environment.ts", "../../../../../node_modules/@unified-latex/libs/unified-latex-process-environment.ts", "../../../../../node_modules/@unified-latex/libs/find-region.ts", "../../../../../node_modules/@unified-latex/libs/regions.ts", "../../../../../node_modules/@unified-latex/libs/reparse-macro-names.ts", "../../../../../node_modules/@unified-latex/libs/special-regions.ts", "../../../../../node_modules/@unified-latex/libs/compiler-ast.ts", "../../../../../node_modules/@unified-latex/libs/parse-minimal.ts", "../../../../../node_modules/@unified-latex/libs/plugin-from-string-minimal.ts", "../../../../../node_modules/@unified-latex/libs/reparse-math.ts", "../../../../../node_modules/@unified-latex/libs/process-macros-and-environments.ts", "../../../../../node_modules/@unified-latex/libs/process-at-letter-and-expl-macros.ts", "../../../../../node_modules/@unified-latex/libs/plugin-from-string.ts", "../../../../../node_modules/@unified-latex/libs/parse.ts", "../../../../../node_modules/@unified-latex/libs/parse-math.ts", "../../../../../node_modules/tex-to-typst/dist/macros.js", "../../../../../node_modules/tex-to-typst/dist/index.js", "../../../../../node_modules/myst-to-typst/dist/math.js", "../../../../../node_modules/myst-to-typst/dist/table.js", "../../../../../node_modules/myst-to-typst/dist/index.js"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  END_WORD: '$',\n  END_WORD_REPLACER: '9a219a89-91cd-42e2-abd5-eb113af08ca8',\n  PERMS_MIN_LEN: 2\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = append;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction append(trie, letter, index, array) {\n  var isEndWordLetter = letter === _config2.default.END_WORD;\n  var isLastLetter = index === array.length - 1;\n\n  if (isEndWordLetter && !isLastLetter) {\n    trie[_config2.default.END_WORD] = 1;\n    trie[_config2.default.END_WORD_REPLACER] = {};\n    trie = trie[_config2.default.END_WORD_REPLACER];\n  } else {\n    trie[letter] = trie[letter] || {};\n    trie = trie[letter];\n  }\n\n  if (isLastLetter) {\n    trie[_config2.default.END_WORD] = 1;\n  }\n\n  return trie;\n}\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = create;\n\nvar _append = require('./append');\n\nvar _append2 = _interopRequireDefault(_append);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction create(input) {\n  if (!Array.isArray(input)) {\n    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));\n  }\n\n  var trie = input.reduce(function (accumulator, item) {\n    item.toLowerCase().split('').reduce(_append2.default, accumulator);\n\n    return accumulator;\n  }, {});\n\n  return trie;\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  objectCopy: function objectCopy(obj) {\n    if (typeof obj === 'undefined') {\n      return {};\n    }\n    return JSON.parse(JSON.stringify(obj));\n  },\n  stringify: function stringify(obj) {\n    var spacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n    if (typeof obj === 'undefined') {\n      return '';\n    }\n    return JSON.stringify(obj, null, spacer);\n  }\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = checkPrefix;\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction checkPrefix(prefixNode, prefix) {\n  var input = prefix.toLowerCase().split('');\n  var prefixFound = input.every(function (letter, index) {\n    if (!prefixNode[letter]) {\n      return false;\n    }\n    return prefixNode = prefixNode[letter];\n  });\n\n  return {\n    prefixFound: prefixFound,\n    prefixNode: prefixNode\n  };\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = recursePrefix;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// sort items as they're being found\n// to prevent slow .sort() in NodeJs\nvar pushInOrder = function pushInOrder(word, prefixes) {\n  var i = 0;\n\n  while (i < prefixes.length) {\n    if (word < prefixes[i]) {\n      break;\n    }\n    i += 1;\n  }\n\n  prefixes.splice(i, 0, word);\n\n  return prefixes;\n};\n\nfunction recursePrefix(node, prefix, sorted) {\n  var prefixes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  var word = prefix;\n\n  for (var branch in node) {\n    var currentLetter = branch;\n    if (branch === _config2.default.END_WORD && typeof node[branch] === 'number') {\n      if (sorted) {\n        pushInOrder(word, prefixes);\n      } else {\n        prefixes.push(word);\n      }\n      word = '';\n    } else if (branch === _config2.default.END_WORD_REPLACER) {\n      currentLetter = _config2.default.END_WORD;\n    }\n    recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);\n  }\n\n  return prefixes;\n}\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = recurseRandomWord;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction recurseRandomWord(node, prefix) {\n  var word = prefix;\n  var branches = Object.keys(node);\n  var branch = branches[Math.floor(Math.random() * branches.length)];\n\n  if (branch === _config2.default.END_WORD) {\n    return word;\n  }\n  return recurseRandomWord(node[branch], prefix + branch);\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = permutations;\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction permutations(letters, trie) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    type: 'anagram'\n  };\n\n  if (typeof letters !== 'string') {\n    throw 'Permutations expects string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n  }\n\n  var words = [];\n\n  var permute = function permute(word, node) {\n    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    var wordIsEmpty = word.length === 0;\n    var wordFound = words.indexOf(prefix) !== -1;\n    var endWordFound = node[_config2.default.END_WORD] === 1;\n\n    if (wordIsEmpty && endWordFound && !wordFound) {\n      words.push(prefix);\n    }\n\n    for (var i = 0, len = word.length; i < len; i++) {\n      var letter = word[i];\n\n      if (opts.type === 'sub-anagram') {\n        if (endWordFound && !(words.indexOf(prefix) !== -1)) {\n          words.push(prefix);\n        }\n      }\n\n      if (node[letter]) {\n        var remaining = word.substring(0, i) + word.substring(i + 1, len);\n        permute(remaining, node[letter], prefix + letter, words);\n      }\n    }\n\n    return words.sort();\n  };\n\n  return permute(letters, trie);\n};\nmodule.exports = exports['default'];", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = function (input) {\n  if (!Array.isArray(input)) {\n    throw 'Expected parameter Array, received ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input));\n  }\n\n  var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));\n\n  return {\n    /**\n     * Get the generated raw trie object\n    */\n    tree: function tree() {\n      return trie;\n    },\n\n\n    /**\n     * Get a string representation of the trie\n    */\n    dump: function dump() {\n      var spacer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      return _utils2.default.stringify(trie, spacer);\n    },\n\n\n    /**\n     * Add a new word to the trie\n     */\n    addWord: function addWord(word) {\n      if (typeof word !== 'string' || word === '') {\n        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var reducer = function reducer() {\n        return _append2.default.apply(undefined, arguments);\n      };\n\n      var input = word.toLowerCase().split('');\n      input.reduce(reducer, trie);\n\n      return this;\n    },\n\n\n    /**\n     * Remove an existing word from the trie\n     */\n    removeWord: function removeWord(word) {\n      if (typeof word !== 'string' || word === '') {\n        throw 'Expected parameter string, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var _checkPrefix = (0, _checkPrefix6.default)(trie, word),\n          prefixFound = _checkPrefix.prefixFound,\n          prefixNode = _checkPrefix.prefixNode;\n\n      if (prefixFound) {\n        delete prefixNode[_config2.default.END_WORD];\n      }\n\n      return this;\n    },\n\n\n    /**\n     * Check a prefix is valid\n     * @returns Boolean\n    */\n    isPrefix: function isPrefix(prefix) {\n      if (typeof prefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof prefix === 'undefined' ? 'undefined' : _typeof(prefix));\n      }\n\n      var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix),\n          prefixFound = _checkPrefix2.prefixFound;\n\n      return prefixFound;\n    },\n\n\n    /**\n    * Get a list of all words in the trie with the given prefix\n    * @returns Array\n    */\n    getPrefix: function getPrefix(strPrefix) {\n      var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (typeof strPrefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));\n      }\n\n      if (typeof sorted !== 'boolean') {\n        throw 'Expected sort parameter as boolean, received ' + (typeof sorted === 'undefined' ? 'undefined' : _typeof(sorted));\n      }\n\n      if (!this.isPrefix(strPrefix)) {\n        return [];\n      }\n\n      var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;\n\n      return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);\n    },\n\n\n    /**\n    * Get a random word in the trie with the given prefix\n    * @returns Array\n    */\n    getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {\n      if (typeof strPrefix !== 'string') {\n        throw 'Expected string prefix, received ' + (typeof strPrefix === 'undefined' ? 'undefined' : _typeof(strPrefix));\n      }\n\n      if (!this.isPrefix(strPrefix)) {\n        return '';\n      }\n\n      var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix),\n          prefixNode = _checkPrefix3.prefixNode;\n\n      return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);\n    },\n\n\n    /**\n    * Count the number of words with the given prefixSearch\n    * @returns Number\n    */\n    countPrefix: function countPrefix(strPrefix) {\n      var prefixes = this.getPrefix(strPrefix);\n\n      return prefixes.length;\n    },\n\n\n    /**\n    * Get all words in the trie\n    * @returns Array\n    */\n    getWords: function getWords() {\n      var sorted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      return this.getPrefix('', sorted);\n    },\n\n\n    /**\n    * Check the existence of a word in the trie\n    * @returns Boolean\n    */\n    hasWord: function hasWord(word) {\n      if (typeof word !== 'string') {\n        throw 'Expected string word, received ' + (typeof word === 'undefined' ? 'undefined' : _typeof(word));\n      }\n\n      var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word),\n          prefixFound = _checkPrefix4.prefixFound,\n          prefixNode = _checkPrefix4.prefixNode;\n\n      if (prefixFound) {\n        return prefixNode[_config2.default.END_WORD] === 1;\n      }\n\n      return false;\n    },\n\n\n    /**\n    * Get a list of valid anagrams that can be made from the given letters\n    * @returns Array\n    */\n    getAnagrams: function getAnagrams(letters) {\n      if (typeof letters !== 'string') {\n        throw 'Anagrams expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n      }\n\n      if (letters.length < PERMS_MIN_LEN) {\n        throw 'getAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';\n      }\n\n      return (0, _permutations2.default)(letters, trie, {\n        type: 'anagram'\n      });\n    },\n\n\n    /**\n    * Get a list of all sub-anagrams that can be made from the given letters\n    * @returns Array\n    */\n    getSubAnagrams: function getSubAnagrams(letters) {\n      if (typeof letters !== 'string') {\n        throw 'Expected string letters, received ' + (typeof letters === 'undefined' ? 'undefined' : _typeof(letters));\n      }\n\n      if (letters.length < PERMS_MIN_LEN) {\n        throw 'getSubAnagrams expects at least ' + PERMS_MIN_LEN + ' letters';\n      }\n\n      return (0, _permutations2.default)(letters, trie, {\n        type: 'sub-anagram'\n      });\n    }\n  };\n};\n\nvar _create = require('./create');\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _append = require('./append');\n\nvar _append2 = _interopRequireDefault(_append);\n\nvar _checkPrefix5 = require('./checkPrefix');\n\nvar _checkPrefix6 = _interopRequireDefault(_checkPrefix5);\n\nvar _recursePrefix = require('./recursePrefix');\n\nvar _recursePrefix2 = _interopRequireDefault(_recursePrefix);\n\nvar _recurseRandomWord = require('./recurseRandomWord');\n\nvar _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _permutations = require('./permutations');\n\nvar _permutations2 = _interopRequireDefault(_permutations);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;\n\n;\nmodule.exports = exports['default'];", "'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n", "/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n", "const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n", "const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n", "const colorString = require('color-string');\nconst convert = require('color-convert');\n\nconst skippedModels = [\n\t// To be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// Gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// Shouldn't really be in color-convert either...\n\t'hex',\n];\n\nconst hashedModelKeys = {};\nfor (const model of Object.keys(convert)) {\n\thashedModelKeys[[...convert[model].labels].sort().join('')] = model;\n}\n\nconst limiters = {};\n\nfunction Color(object, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(object, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tlet i;\n\tlet channels;\n\n\tif (object == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (object instanceof Color) {\n\t\tthis.model = object.model;\n\t\tthis.color = [...object.color];\n\t\tthis.valpha = object.valpha;\n\t} else if (typeof object === 'string') {\n\t\tconst result = colorString.get(object);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + object);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (object.length > 0) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tconst newArray = Array.prototype.slice.call(object, 0, channels);\n\t\tthis.color = zeroArray(newArray, channels);\n\t\tthis.valpha = typeof object[channels] === 'number' ? object[channels] : 1;\n\t} else if (typeof object === 'number') {\n\t\t// This is always RGB - can be converted later on.\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(object >> 16) & 0xFF,\n\t\t\t(object >> 8) & 0xFF,\n\t\t\tobject & 0xFF,\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tconst keys = Object.keys(object);\n\t\tif ('alpha' in object) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof object.alpha === 'number' ? object.alpha : 0;\n\t\t}\n\n\t\tconst hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(object));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tconst {labels} = convert[this.model];\n\t\tconst color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(object[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// Perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tconst limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString() {\n\t\treturn this.string();\n\t},\n\n\ttoJSON() {\n\t\treturn this[this.model]();\n\t},\n\n\tstring(places) {\n\t\tlet self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString(places) {\n\t\tconst self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray() {\n\t\treturn this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];\n\t},\n\n\tobject() {\n\t\tconst result = {};\n\t\tconst {channels} = convert[this.model];\n\t\tconst {labels} = convert[this.model];\n\n\t\tfor (let i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray() {\n\t\tconst rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject() {\n\t\tconst rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround(places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);\n\t},\n\n\talpha(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// Rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(95.047)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(108.833)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\thexa(value) {\n\t\tif (value !== undefined) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\tconst rgbArray = this.rgb().round().color;\n\n\t\tlet alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n\t\tif (alphaHex.length === 1) {\n\t\t\talphaHex = '0' + alphaHex;\n\t\t}\n\n\t\treturn colorString.to.hex(rgbArray) + alphaHex;\n\t},\n\n\trgbNumber() {\n\t\tconst rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity() {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tconst rgb = this.rgb().color;\n\n\t\tconst lum = [];\n\t\tfor (const [i, element] of rgb.entries()) {\n\t\t\tconst chan = element / 255;\n\t\t\tlum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast(color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tconst lum1 = this.luminosity();\n\t\tconst lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel(color2) {\n\t\t// https://www.w3.org/TR/WCAG/#contrast-enhanced\n\t\tconst contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark() {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tconst rgb = this.rgb().color;\n\t\tconst yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight() {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate() {\n\t\tconst rgb = this.rgb();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tlighten(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale() {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tconst rgb = this.rgb().color;\n\t\tconst value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(value, value, value);\n\t},\n\n\tfade(ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer(ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate(degrees) {\n\t\tconst hsl = this.hsl();\n\t\tlet hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix(mixinColor, weight) {\n\t\t// Ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\n\t\tconst color1 = mixinColor.rgb();\n\t\tconst color2 = this.rgb();\n\t\tconst p = weight === undefined ? 0.5 : weight;\n\n\t\tconst w = 2 * p - 1;\n\t\tconst a = color1.alpha() - color2.alpha();\n\n\t\tconst w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;\n\t\tconst w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n};\n\n// Model conversion methods and static constructors\nfor (const model of Object.keys(convert)) {\n\tif (skippedModels.includes(model)) {\n\t\tcontinue;\n\t}\n\n\tconst {channels} = convert[model];\n\n\t// Conversion methods\n\tColor.prototype[model] = function (...args) {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (args.length > 0) {\n\t\t\treturn new Color(args, model);\n\t\t}\n\n\t\treturn new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (...args) {\n\t\tlet color = args[0];\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(args, channels);\n\t\t}\n\n\t\treturn new Color(color, model);\n\t};\n}\n\nfunction roundTo(number, places) {\n\treturn Number(number.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (number) {\n\t\treturn roundTo(number, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tfor (const m of model) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t}\n\n\tmodel = model[0];\n\n\treturn function (value) {\n\t\tlet result;\n\n\t\tif (value !== undefined) {\n\t\t\tif (modifier) {\n\t\t\t\tvalue = modifier(value);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = value;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\n\nfunction zeroArray(array, length) {\n\tfor (let i = 0; i < length; i++) {\n\t\tif (typeof array[i] !== 'number') {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n\treturn array;\n}\n\nmodule.exports = Color;\n", "import { fileError } from 'myst-common';\nexport var CaptionKind;\n(function (CaptionKind) {\n    CaptionKind[\"fig\"] = \"fig\";\n    CaptionKind[\"eq\"] = \"eq\";\n    CaptionKind[\"code\"] = \"code\";\n    CaptionKind[\"table\"] = \"table\";\n})(CaptionKind || (CaptionKind = {}));\nfunction switchKind(node) {\n    switch (node.type) {\n        case 'iframe':\n        case 'image':\n            return CaptionKind.fig;\n        case 'table':\n            return CaptionKind.table;\n        case 'code':\n            return CaptionKind.code;\n        case 'math':\n            return CaptionKind.eq;\n        default:\n            return null;\n    }\n}\nexport function determineCaptionKind(node) {\n    var _a;\n    let kind = switchKind(node);\n    (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach((n) => {\n        if (!kind)\n            kind = determineCaptionKind(n);\n    });\n    return kind;\n}\nfunction renderFigureChild(node, state) {\n    const useBrackets = node.type !== 'image' && node.type !== 'table';\n    if (useBrackets)\n        state.write('[\\n');\n    else\n        state.write('\\n  ');\n    state.renderChildren({ children: [node] });\n    if (useBrackets)\n        state.write('\\n]');\n}\nexport const containerHandler = (node, state) => {\n    var _a, _b;\n    if (state.data.isInTable) {\n        fileError(state.file, 'Unable to render typst figure inside table', {\n            node,\n            source: 'myst-to-typst',\n        });\n        return;\n    }\n    state.ensureNewLine();\n    state.write('#show figure: set block(breakable: true)');\n    state.ensureNewLine();\n    const prevState = state.data.isInFigure;\n    state.data.isInFigure = true;\n    const { identifier: label, kind } = node;\n    const captions = (_a = node.children) === null || _a === void 0 ? void 0 : _a.filter((child) => child.type === 'caption' || child.type === 'legend');\n    const nonCaptions = (_b = node.children) === null || _b === void 0 ? void 0 : _b.filter((child) => child.type !== 'caption' && child.type !== 'legend');\n    if (!nonCaptions || nonCaptions.length === 0) {\n        fileError(state.file, `Figure with no non-caption content: ${label}`, {\n            node,\n            source: 'myst-to-typst',\n        });\n    }\n    if (nonCaptions && nonCaptions.length > 1) {\n        state.write('#figure((');\n        nonCaptions.forEach((item) => {\n            renderFigureChild(item, state);\n            state.write('\\n, ');\n        });\n        state.write(').join()');\n    }\n    else if (nonCaptions && nonCaptions.length === 1) {\n        state.write('#figure(');\n        renderFigureChild(nonCaptions[0], state);\n    }\n    else {\n        state.write('#figure([\\n  ');\n        state.renderChildren(node, 1);\n        state.write(']');\n    }\n    state.write(',');\n    if (captions === null || captions === void 0 ? void 0 : captions.length) {\n        state.write('\\n  caption: [\\n');\n        state.renderChildren({\n            children: captions\n                .map((cap) => cap.children)\n                .filter(Boolean)\n                .flat(),\n        });\n        state.write('\\n],');\n    }\n    if (kind) {\n        state.write(`\\n  kind: \"${kind}\",`);\n        state.write(`\\n  supplement: [${kind[0].toUpperCase() + kind.substring(1)}],`);\n    }\n    state.write('\\n)');\n    if (label)\n        state.write(` <${label}>`);\n    state.ensureNewLine(true);\n    state.addNewLine();\n    state.data.isInFigure = prevState;\n};\nexport const captionHandler = () => {\n    // blank\n};\n", "export const DEFAULT_IMAGE_WIDTH = 0.7;\nexport const DEFAULT_PAGE_WIDTH_PIXELS = 800;\n", "import { DEFAULT_IMAGE_WIDTH, DEFAULT_PAGE_WIDTH_PIXELS } from './types.js';\n// import emoji from './emoji.json';\n/** Removes nobreak and zero-width spaces */\nexport function cleanWhitespaceChars(text, nbsp = ' ') {\n    return text.replace(/\\u00A0/g, nbsp).replace(/[\\u200B-\\u200D\\uFEFF]/g, '');\n}\n// Funky placeholders (unlikely to be written ...?!)\nconst BACKSLASH_SPACE = 'xxxxBACKSLASHSPACExxxx';\nconst BACKSLASH = 'xxxxBACKSLASHxxxx';\nconst COMMENT = 'xxxxCOMMENTxxxx';\nconst COMMENT_SPACE = 'xxxxCOMMENTSPACExxxx';\nconst TILDE = 'xxxxTILDExxxx';\nconst hrefOnlyReplacements = {\n    // Not allowed characters\n    // Typst escaped characters are: \\ & ` $ # _ * @ { } [ ] ^\n    '&': '\\\\&',\n    '`': '\\\\`',\n    $: '\\\\$',\n    '#': '\\\\#',\n    _: '\\\\_',\n    '*': '\\\\*',\n    '{': '\\\\{',\n    '}': '\\\\}',\n    '[': '\\\\[',\n    ']': '\\\\]',\n    '^': '\\\\^',\n    '@': '\\\\@',\n};\nconst textOnlyReplacements = {\n    ...hrefOnlyReplacements,\n    // quotes\n    '\u2019': \"'\",\n    '\u2018': \"'\",\n    '\u201D': '\"',\n    '\u201C': '\"',\n    // guillemots\n    // '\u00BB': '>>', // These could be improved\n    // '\u00AB': '<<',\n    // '\u2026': '\\\\dots',\n    // '\u2013': '--',\n    // '\u2014': '---',\n    // Commands gobble fhttps://texfaq.org/FAQ-xspaceollowing space\n    // See: https://texfaq.org/FAQ-xspace\n    '\u00A9': '#emoji.copyright ',\n    '\u00AE': '#emoji.reg ',\n    '\u2122': '#emoji.tm ',\n    '<': '\\\\< ',\n    '>': '\\\\> ',\n    '\u00A0': '~',\n    '\u202F': '~',\n    // eslint-disable-next-line no-irregular-whitespace\n    // '\u2009': '\\\\,',\n    // ...Object.fromEntries(Object.entries(emoji).map(([k, v]) => [k, `#emoji.${v} `])),\n};\nconst arrows = {\n    '\u2194': 'arrow.l.r',\n    '\u21D4': 'arrow.l.r.double',\n    '\u2192': 'arrow.r',\n    '\u21D2': 'arrow.r.double',\n    '\u2190': 'arrow.l',\n    '\u21D0': 'arrow.l.double',\n};\nconst symbols = {\n    '\u2212': '-', // minus\n    '-': '-', // hyphen minus\n    '\uFE63': '-', // Small hyphen minus\n    '\uFF0D': '-', // Full-width Hyphen-minus\n    '\uFF0B': '+', // Full-width Plus\n};\nconst textReplacements = {\n    ...textOnlyReplacements,\n    ...arrows,\n    ...symbols,\n};\nconst mathReplacements = {\n    ...arrows,\n    ...symbols,\n    '\u00BD': '1/2',\n    '\u2153': '1/3',\n    '\u2154': '2/3',\n    '\u00BC': '1/4',\n    '\u2155': '1/5',\n    '\u2156': '2/5',\n    '\u2157': '3/5',\n    '\u2158': '4/5',\n    '\u2159': '1/6',\n    '\u215A': '5/6',\n    '\u2150': '1/7',\n    '\u215B': '1/8',\n    '\u215C': '3/8',\n    '\u215D': '5/8',\n    '\u215E': '7/8',\n    '\u2151': '1/9',\n    '\u2152': '1/10',\n    '\u00B1': 'plus.minus',\n    '\u00D7': 'times',\n    \u0391: 'A',\n    \u03B1: 'alpha',\n    \u0392: 'B',\n    \u03B2: 'beta',\n    \u00DF: 'beta',\n    \u0393: 'Gamma',\n    \u03B3: 'gamma',\n    \u0394: 'Delta',\n    '\u2206': 'Delta',\n    \u03B4: 'delta',\n    \u0395: 'E',\n    \u03B5: 'epsilon',\n    \u0396: 'Z',\n    \u03B6: 'zeta',\n    \u0397: 'H',\n    \u03B7: 'eta',\n    \u0398: 'Theta',\n    \u03B8: 'theta',\n    \u03D1: 'vartheta',\n    \u0399: 'I',\n    \u03B9: 'iota',\n    \u039A: 'K',\n    \u03BA: 'kappa',\n    \u039B: 'Lambda',\n    \u03BB: 'lambda',\n    \u039C: 'M',\n    \u03BC: 'mu',\n    \u039D: 'N',\n    \u03BD: 'nu',\n    \u039E: 'Xi',\n    \u03BE: 'xi',\n    \u039F: 'O',\n    \u03BF: 'o',\n    \u03A0: 'Pi',\n    \u03C0: 'pi',\n    \u03A1: 'P',\n    \u03C1: 'rho',\n    \u03A3: 'Sigma',\n    \u03C3: 'sigma',\n    \u03A4: 'T',\n    \u03C4: 'tau',\n    \u03A5: 'Upsilon',\n    \u03C5: 'upsilon',\n    \u03A6: 'Phi',\n    \u03D5: 'phi.alt',\n    \u03C6: 'phi',\n    \u03A7: 'X',\n    \u03C7: 'chi',\n    \u03A8: 'Psi',\n    \u03C8: 'psi',\n    \u03A9: 'Omega',\n    \u03C9: 'omega',\n    '\u2202': 'diff',\n    '\u221E': 'infty',\n    '\u2248': 'approx',\n    '\u2260': 'eq.not',\n    '\u2022': 'dot.c',\n    // '\u2030': '\\\\permille',\n};\nexport function nodeOnlyHasTextChildren(node) {\n    if (!node || !node.children || node.children.length === 0)\n        return false;\n    return node.children.reduce((previous, { type }) => previous && type === 'text', true);\n}\nexport function hrefToLatexText(text) {\n    const replacedArray = Array.from(text !== null && text !== void 0 ? text : '').map((char) => {\n        if (hrefOnlyReplacements[char])\n            return { kind: 'text', text: hrefOnlyReplacements[char] };\n        return { kind: 'text', text: char };\n    });\n    const replaced = replacedArray\n        .reduce((arr, next) => {\n        const prev = arr.slice(-1)[0];\n        if ((prev === null || prev === void 0 ? void 0 : prev.kind) === next.kind)\n            prev.text += next.text;\n        else\n            arr.push(next);\n        return arr;\n    }, [])\n        .reduce((s, next) => {\n        return s + next.text;\n    }, '');\n    return replaced;\n}\nexport function stringToTypstText(text) {\n    const escaped = (text !== null && text !== void 0 ? text : '')\n        .replace(/\\\\ /g, BACKSLASH_SPACE)\n        .replace(/\\\\/g, BACKSLASH)\n        .replace(/^\\/\\//g, COMMENT)\n        .replace(/\\s\\/\\//g, COMMENT_SPACE)\n        .replace(/~/g, TILDE);\n    const replacedArray = Array.from(escaped).map((char) => {\n        if (textReplacements[char])\n            return { kind: 'text', text: textReplacements[char] };\n        if (mathReplacements[char])\n            return { kind: 'math', text: mathReplacements[char] };\n        return { kind: 'text', text: char };\n    });\n    const replaced = replacedArray\n        .reduce((arr, next) => {\n        // Join any strings of math or text together (avoids $\\delta$$\\mu$ --> $\\delta\\mu$)\n        const prev = arr.slice(-1)[0];\n        if ((prev === null || prev === void 0 ? void 0 : prev.kind) === next.kind)\n            prev.text += next.text;\n        else\n            arr.push(next);\n        return arr;\n    }, [])\n        .reduce((s, next) => {\n        if (next.kind === 'math')\n            return `${s}$${next.text}$`;\n        return s + next.text;\n    }, '');\n    const final = replaced\n        .replace(new RegExp(BACKSLASH_SPACE, 'g'), '\\\\\\\\ ')\n        .replace(new RegExp(BACKSLASH, 'g'), '\\\\\\\\')\n        .replace(new RegExp(COMMENT_SPACE, 'g'), ' \\\\/\\\\/')\n        .replace(new RegExp(COMMENT, 'g'), '\\\\/\\\\/')\n        .replace(new RegExp(TILDE, 'g'), '$tilde$');\n    return cleanWhitespaceChars(final, '~');\n}\nexport function stringToTypstMath(text) {\n    const replaced = Array.from(text !== null && text !== void 0 ? text : '').reduce((s, char) => {\n        if (mathReplacements[char]) {\n            const space = s.slice(-1) === ' ' ? '' : ' ';\n            return `${s}${space}${mathReplacements[char]}`;\n        }\n        return s + char;\n    }, '');\n    const final = replaced.trim();\n    return cleanWhitespaceChars(final);\n}\nexport function getLatexImageWidth(width) {\n    if (typeof width === 'number' && Number.isNaN(width)) {\n        // If it is nan, return with the default.\n        return getLatexImageWidth(DEFAULT_IMAGE_WIDTH);\n    }\n    if (typeof width === 'string') {\n        if (width.endsWith('%')) {\n            return getLatexImageWidth(Number(width.replace('%', '')));\n        }\n        else if (width.endsWith('px')) {\n            return getLatexImageWidth(Number(width.replace('px', '')) / DEFAULT_PAGE_WIDTH_PIXELS);\n        }\n        console.log(`Unknown width ${width} in getLatexImageWidth`);\n        return getLatexImageWidth(DEFAULT_IMAGE_WIDTH);\n    }\n    let lineWidth = width !== null && width !== void 0 ? width : DEFAULT_IMAGE_WIDTH;\n    if (lineWidth < 1)\n        lineWidth *= 100;\n    return `${lineWidth}%`;\n}\nexport function getClasses(className) {\n    var _a;\n    const classes = (_a = className === null || className === void 0 ? void 0 : className.split(' ').map((s) => s.trim().toLowerCase()).filter((s) => !!s)) !== null && _a !== void 0 ? _a : [];\n    return Array.from(new Set(classes));\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    cref: { signature: \"s m\" },\n    Cref: { signature: \"s m\" },\n    crefrange: { signature: \"s m m\" },\n    Crefrange: { signature: \"s m m\" },\n    cpageref: { signature: \"s m\" },\n    Cpageref: { signature: \"s m\" },\n    ref: { signature: \"m\" },\n    pageref: { signature: \"m\" },\n    namecref: { signature: \"m\" },\n    nameCref: { signature: \"m\" },\n    lcnamecref: { signature: \"m\" },\n    namecrefs: { signature: \"m\" },\n    nameCrefs: { signature: \"m\" },\n    lcnamecrefs: { signature: \"m\" },\n    labelcref: { signature: \"m\" },\n    labelcpageref: { signature: \"m\" },\n    crefalias: { signature: \"m m\" },\n    crefname: { signature: \"m m m\" },\n    // XXX there are many more obscure commands to add here\n    // https://ctan.org/pkg/cleveref\n    crefdefaultlabelformat: { signature: \"m\" },\n    crefrangeconjunction: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import type * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype CoercibleNode = string | Ast.Node;\ntype CoercibleArgument = null | CoercibleNode | Ast.Argument;\ntype MacroSpecialOptions = {\n    escapeToken?: string;\n};\ntype ArgumentsSpecialOptions = {\n    braces?: string;\n    defaultOpenMark?: string;\n    defaultCloseMark?: string;\n};\ntype ArgumentSpecialOptions = {\n    braces?: string;\n    openMark?: string;\n    closeMark?: string;\n};\n\nfunction normalizeNode(node: CoercibleNode): Ast.Node {\n    if (typeof node === \"string\") {\n        return s(node);\n    }\n    return node;\n}\n\nfunction normalizeArgument(\n    arg: CoercibleArgument,\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument {\n    if (arg == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof arg === \"string\") {\n        return {\n            type: \"argument\",\n            openMark,\n            closeMark,\n            content: [s(arg)],\n        };\n    }\n    if (arg.type === \"argument\") {\n        return arg;\n    }\n    return { type: \"argument\", openMark, closeMark, content: [arg] };\n}\n\nfunction normalizeArgumentsList(\n    args?: CoercibleArgument | CoercibleArgument[],\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument[] {\n    if (args == null) {\n        return [];\n    }\n    if (Array.isArray(args)) {\n        return args.map((arg) => normalizeArgument(arg, openMark, closeMark));\n    }\n    return [normalizeArgument(args, openMark, closeMark)];\n}\n\ntype BracesPair = { openMark: string; closeMark: string };\nconst BRACES_MAP: Record<string, BracesPair> = {\n    \"*\": { openMark: \"\", closeMark: \"\" },\n    \"{\": { openMark: \"{\", closeMark: \"}\" },\n    \"[\": { openMark: \"[\", closeMark: \"]\" },\n    \"(\": { openMark: \"(\", closeMark: \")\" },\n    \"<\": { openMark: \"<\", closeMark: \">\" },\n};\nconst CLOSE_BRACES = new Set(\n    Object.values(BRACES_MAP)\n        .map((x) => x.closeMark)\n        .filter((x) => x)\n);\n\n/**\n * Turn a braces signature into an array of braces.\n */\nfunction bracesToOpenAndCloseMarks(braces: string): BracesPair[] {\n    const ret: BracesPair[] = [];\n\n    for (const char of braces.split(\"\")) {\n        if (CLOSE_BRACES.has(char)) {\n            continue;\n        }\n        const braces = BRACES_MAP[char];\n        if (braces == null) {\n            throw new Error(`Unknown open/close mark type \"${char}\"`);\n        }\n        braces;\n        ret.push(braces);\n    }\n\n    return ret;\n}\n\n/**\n * Create an Argument list. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * args([\"a\", \"b\"], { braces: \"[]{}\" });\n * ```\n * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, `(`, and `<`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function args(\n    args: CoercibleArgument | CoercibleArgument[],\n    special?: ArgumentsSpecialOptions\n): Ast.Argument[] {\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces.length !== args.length) {\n            throw new Error(\n                `There is a difference between the number of supplied braces and the number of supplied arguments. ${args.length} supplied with braces signature ${special.braces}`\n            );\n        }\n        return args.map((arg, i) =>\n            normalizeArgument(arg, braces[i].openMark, braces[i].closeMark)\n        );\n    }\n\n    const openMark = special?.defaultOpenMark ?? \"{\";\n    const closeMark = special?.defaultCloseMark ?? \"}\";\n    return normalizeArgumentsList(args, openMark, closeMark);\n}\n\n/**\n * Create an Argument. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * arg(\"a\", { braces: \"[]\" });\n * ```\n * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, `<`, and `(`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function arg(\n    args: CoercibleArgument | Ast.Node[],\n    special?: ArgumentSpecialOptions\n): Ast.Argument {\n    if (args == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof args === \"string\") {\n        args = s(args);\n    }\n    if (!Array.isArray(args) && args.type === \"argument\") {\n        return args;\n    }\n\n    let openMark = special?.openMark ?? \"{\";\n    let closeMark = special?.closeMark ?? \"}\";\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces[0]) {\n            openMark = braces[0].openMark;\n            closeMark = braces[0].closeMark;\n        }\n    }\n\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n\n    return { type: \"argument\", content: args, openMark, closeMark };\n}\n\n/**\n * Create a Macro with the given `name`. The macro\n * may be followed by any number of arguments.\n */\nexport function m(\n    name: string,\n    marcoArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: MacroSpecialOptions\n): Ast.Macro {\n    const args = normalizeArgumentsList(marcoArgs);\n    const escapeToken = special?.escapeToken;\n    const ret: Ast.Macro = { type: \"macro\", content: name };\n\n    if (args.length > 0) {\n        ret.args = args;\n    }\n    if (escapeToken != null) {\n        ret.escapeToken = escapeToken;\n    }\n\n    return ret;\n}\n\n/**\n * Create a String node from `value`\n */\nexport function s(value: string | Ast.String): Ast.String {\n    if (typeof value === \"string\") {\n        return { type: \"string\", content: value };\n    }\n    return value;\n}\n\n/**\n * Create an Environment node.\n */\nexport function env(\n    name: string,\n    body: CoercibleNode | CoercibleNode[],\n    envArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: unknown\n): Ast.Environment {\n    if (!Array.isArray(body)) {\n        body = [body];\n    }\n    const args = normalizeArgumentsList(envArgs, \"[\", \"]\");\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: name,\n        content: body.map(normalizeNode),\n    };\n    if (args.length > 0) {\n        ret.args = args;\n    }\n\n    return ret;\n}\n\n/**\n * Whitespace node.\n */\nexport const SP: Ast.Whitespace = { type: \"whitespace\" };\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype Printable = Ast.Node | Ast.Argument | string;\ntype PrintToken = string | typeof linebreak;\n\nexport const linebreak = Symbol(\"linebreak\");\nconst ESCAPE = \"\\\\\";\n\n/**\n * Renders the AST to an array inserting `linebreak` where needed;\n * This array may be nested.\n *\n * @param {*} node\n */\nfunction _printRaw(node: Printable | Printable[]): PrintToken[] {\n    if (typeof node === \"string\") {\n        return [node];\n    }\n    if (Array.isArray(node)) {\n        return ([] as PrintToken[]).concat(\n            ...node.map((n: Printable) => _printRaw(n))\n        );\n    }\n    // tmp variables\n    let argsString, escape;\n    switch (node.type) {\n        case \"root\":\n            return _printRaw(node.content);\n        case \"argument\":\n            return [node.openMark, ..._printRaw(node.content), node.closeMark];\n        case \"comment\":\n            let suffix = node.suffixParbreak ? \"\" : linebreak;\n            // A comment is responsible for printing its own leading whitespace\n            let leadingWhitespace = \"\";\n            if (node.sameline && node.leadingWhitespace) {\n                leadingWhitespace = \" \";\n            }\n            if (node.sameline) {\n                return [\n                    leadingWhitespace,\n                    \"%\",\n                    ..._printRaw(node.content),\n                    suffix,\n                ];\n            }\n            return [linebreak, \"%\", ..._printRaw(node.content), suffix];\n        case \"environment\":\n        case \"mathenv\":\n        case \"verbatim\":\n            let env = _printRaw(node.env);\n            let envStart: PrintToken[] = [ESCAPE + \"begin{\", ...env, \"}\"];\n            let envEnd: PrintToken[] = [ESCAPE + \"end{\", ...env, \"}\"];\n            argsString =\n                (node as any).args == null ? [] : _printRaw((node as any).args);\n            return [\n                ...envStart,\n                ...argsString,\n                ..._printRaw(node.content),\n                ...envEnd,\n            ];\n        case \"displaymath\":\n            return [ESCAPE + \"[\", ..._printRaw(node.content), ESCAPE + \"]\"];\n        case \"group\":\n            return [\"{\", ..._printRaw(node.content), \"}\"];\n        case \"inlinemath\":\n            return [\"$\", ..._printRaw(node.content), \"$\"];\n        case \"macro\":\n            argsString = node.args == null ? [] : _printRaw(node.args);\n            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;\n            return [escape, ..._printRaw(node.content), ...argsString];\n        case \"parbreak\":\n            return [linebreak, linebreak];\n        case \"string\":\n            return [node.content];\n        case \"verb\":\n            return [\n                ESCAPE,\n                node.env,\n                node.escape,\n                ..._printRaw(node.content),\n                node.escape,\n            ];\n        case \"whitespace\":\n            return [\" \"];\n\n        default:\n            console.warn(\n                \"Cannot find render for node \",\n                node,\n                `(of type ${typeof node})`\n            );\n            return [\"\" + node];\n    }\n}\n\n/**\n * Renders the AST to a string without any pretty printing.\n *\n * @param {*} node\n * @param {*} options - Setting `asArray` to `true` will return an array of strings and the symbol `linebreak`, so that printing can be customized.\n */\nexport function printRaw(\n    node: Printable | Printable[],\n    options?: { asArray: false }\n): string;\nexport function printRaw(\n    node: Printable | Printable[],\n    options: { asArray: true }\n): PrintToken[];\nexport function printRaw(node: Printable | Printable[], options?: object): any {\n    const asArray = options != null ? (options as any).asArray : false;\n    const printedTokens = _printRaw(node);\n    if (asArray) {\n        return printedTokens;\n    }\n    return printedTokens.map((x) => (x === linebreak ? \"\\n\" : x)).join(\"\");\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfo,\n    MacroInfo,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createMacroMatcher<S extends string>(\n    macros: Ast.Macro[] | S[] | Record<S, unknown>\n) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const macrosHash: Record<string, unknown> = Array.isArray(macros)\n        ? macros.length > 0\n            ? typeof macros[0] === \"string\"\n                ? Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro !== \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          return [macro, {}] as [string, MacroInfo];\n                      })\n                  )\n                : Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro === \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          if (macro.escapeToken != null) {\n                              return [\n                                  macro.content,\n                                  { escapeToken: macro.escapeToken },\n                              ] as [string, MacroInfo];\n                          }\n                          return [macro.content, {}] as [string, MacroInfo];\n                      })\n                  )\n            : {}\n        : macros;\n\n    return function matchAgainstMacros(node: any | Ast.Macro) {\n        if (node == null || node.type !== \"macro\") {\n            return false;\n        }\n        // At this point we have a macro type\n        const spec = macrosHash[node.content];\n        if (!spec) {\n            return false;\n        }\n\n        if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n            return (\n                (spec as MacroInfoRecord).escapeToken == null ||\n                (spec as MacroInfoRecord).escapeToken === node.escapeToken\n            );\n        }\n        return true;\n    } as Ast.TypeGuard<Ast.Macro & { content: S }>;\n}\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createEnvironmentMatcher(macros: string[] | Record<string, unknown>) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const environmentsHash = Array.isArray(macros)\n        ? Object.fromEntries(\n              macros.map((str) => {\n                  return [str, {}] as [string, EnvInfo];\n              })\n          )\n        : macros;\n\n    return function matchAgainstEnvironments(node: any | Ast.Environment) {\n        if (!match.anyEnvironment(node)) {\n            return false;\n        }\n        // At this point we have an environment type\n        const envName = printRaw(node.env);\n        const spec = environmentsHash[envName];\n        if (!spec) {\n            return false;\n        }\n\n        return true;\n    } as Ast.TypeGuard<Ast.Environment>;\n}\n\n/**\n * Functions to match different types of nodes.\n */\nexport const match = {\n    macro(node: any, macroName?: string): node is Ast.Macro {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"macro\" &&\n            (macroName == null || node.content === macroName)\n        );\n    },\n    anyMacro(node: any): node is Ast.Macro {\n        return match.macro(node);\n    },\n    environment(node: any, envName?: string): node is Ast.Environment {\n        if (node == null) {\n            return false;\n        }\n        return (\n            (node.type === \"environment\" || node.type === \"mathenv\") &&\n            (envName == null || printRaw(node.env) === envName)\n        );\n    },\n    anyEnvironment(node: any): node is Ast.Environment {\n        return match.environment(node);\n    },\n    comment(node: any): node is Ast.Comment {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"comment\";\n    },\n    parbreak(node: any): node is Ast.Parbreak {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"parbreak\";\n    },\n    whitespace(node: any): node is Ast.Whitespace {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"whitespace\";\n    },\n    /**\n     * Matches whitespace or a comment with leading whitespace.\n     */\n    whitespaceLike(\n        node: any\n    ): node is Ast.Whitespace | (Ast.Comment & { leadingWhitespace: true }) {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"whitespace\" ||\n            (node.type === \"whitespace\" && node.leadingWhitespace === true)\n        );\n    },\n    string(node: any, value?: string): node is Ast.String {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"string\" && (value == null || node.content === value)\n        );\n    },\n    anyString(node: any): node is Ast.String {\n        return match.string(node);\n    },\n    group(node: any): node is Ast.Group {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"group\";\n    },\n    argument(node: any): node is Ast.Argument {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"argument\";\n    },\n    blankArgument(node: any): boolean {\n        if (!match.argument(node)) {\n            return false;\n        }\n        return (\n            node.openMark === \"\" &&\n            node.closeMark === \"\" &&\n            node.content.length === 0\n        );\n    },\n    math(node: any): node is Ast.DisplayMath | Ast.InlineMath {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"displaymath\" || node.type === \"inlinemath\";\n    },\n    createMacroMatcher,\n    createEnvironmentMatcher,\n};\n\nexport const {\n    anyEnvironment,\n    anyMacro,\n    anyString,\n    argument,\n    blankArgument,\n    comment,\n    environment,\n    group,\n    macro,\n    math,\n    parbreak,\n    string,\n    whitespace,\n} = match;\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * List all props of the current node that should be processed\n * in math mode or not in math mode. If math mode is not specified in the node's render\n * info, empty lists are returned.\n *\n * For example `\\text{foo}` will report that `args` should *not* be processed in math mode,\n * since it's contents should always be processed in text mode.\n */\nexport function listMathChildren(node: Ast.Ast): {\n    enter: string[];\n    leave: string[];\n} {\n    const NULL_RETURN = { enter: [], leave: [] };\n    if (Array.isArray(node)) {\n        return NULL_RETURN;\n    }\n    if (match.math(node)) {\n        // When we enter a math environment, our content is always\n        // considered math mode\n        return { enter: [\"content\"], leave: [] };\n    }\n\n    const renderInfo: { inMathMode?: boolean } = node._renderInfo || {};\n    if (renderInfo.inMathMode == null) {\n        return NULL_RETURN;\n    }\n    if (match.macro(node)) {\n        if (renderInfo.inMathMode === true) {\n            return { enter: [\"args\"], leave: [] };\n        } else if (renderInfo.inMathMode === false) {\n            return { enter: [], leave: [\"args\"] };\n        }\n    }\n    if (match.environment(node)) {\n        if (renderInfo.inMathMode === true) {\n            return { enter: [\"content\"], leave: [] };\n        } else {\n            return { enter: [], leave: [\"content\"] };\n        }\n    }\n    return NULL_RETURN;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { listMathChildren } from \"./list-math-children\";\n\nexport type VisitorContext = {\n    /**\n     * Whether the node is being processed in math mode.\n     *\n     * This happens when the node is a director or indirect child\n     * of a math environment (e.g. `$abc$`), but not when an environment\n     * re-establishes text mode (e.g. `$\\text{abc}$`)\n     */\n    inMathMode?: boolean;\n    /**\n     * Whether the node has any ancestor that is processed in math mode.\n     */\n    hasMathModeAncestor?: boolean;\n};\n\ntype GetGuard<T> = T extends (x: any, ...y: any[]) => x is infer R ? R : never;\n/**\n * Gets the type that a type-guard function is guarding. If\n * the guard type cannot be determined, the input type is returned.\n */\ntype GuardTypeOf<T extends (x: any, ...y: any[]) => boolean> =\n    GetGuard<T> extends never\n        ? T extends (x: infer A) => any\n            ? A\n            : never\n        : GetGuard<T>;\n\n/**\n * Extracts the guard type from the `test` function provided in a\n * `VisitOptions` argument.\n */\ntype GuardFromOptions<\n    Opts extends VisitOptions,\n    PossibleTypes = Ast.Ast\n> = Opts extends {\n    test: infer R;\n}\n    ? R extends (x: any, ...y: any[]) => boolean\n        ? // A guard like `typeof Array.isArray` will return `any[]` as the type.\n          // This type cannot be narrowed, so instead we use it to pick from\n          // the set of all possible types.\n          Extract<PossibleTypes, GuardTypeOf<R>>\n        : PossibleTypes\n    : PossibleTypes;\n\n/**\n * Narrow the type `T` based on the `VisitOptions` supplied. If `{includeArrays: false}`\n * is specified in the `VisitOptions`, then arrays are excluded from `T`.\n */\ntype NarrowArraysBasedOnOptions<T, Opts extends VisitOptions> = Opts extends {\n    includeArrays: infer A;\n}\n    ? A extends true\n        ? T\n        : Exclude<T, any[]>\n    : Exclude<T, any[]>;\n\n/**\n * Get the type of the parameter to the `Visitor` function based on the\n * `VisitOptions` that are supplied.\n */\ntype VisitorTypeFromOptions<Opts extends VisitOptions> =\n    NarrowArraysBasedOnOptions<GuardFromOptions<Opts>, Opts>;\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = Symbol(\"continue\");\n/**\n * Do not traverse this node’s children\n */\nexport const SKIP = Symbol(\"skip\");\n/**\n * Stop traversing immediately\n */\nexport const EXIT = Symbol(\"exit\");\n\ntype Action = typeof CONTINUE | typeof SKIP | typeof EXIT;\ntype Index = number;\ntype ActionTuple = [Action] | [typeof SKIP, Index] | [typeof CONTINUE, Index];\n\n/**\n * A visitor takes a `node`, `key`, `index`, and ...\n *\n * @param key - The key of the parent that we were accessed through.\n */\ntype Visitor<T> = (\n    node: T,\n    info: VisitInfo\n) => null | undefined | Action | Index | ActionTuple | void;\ntype Visitors<T> = { enter?: Visitor<T>; leave?: Visitor<T> };\n\ntype VisitOptions = {\n    startingContext?: VisitorContext;\n    /**\n     * Type guard for types that are passed to the `visitor` function.\n     */\n    test?: (node: Ast.Ast, info: VisitInfo) => boolean;\n    /**\n     * Whether arrays will be sent to the `visitor` function. If falsy,\n     * only nodes will be past to `visitor`.\n     */\n    includeArrays?: boolean;\n};\n\nconst DEFAULT_CONTEXT: VisitorContext = {\n    inMathMode: false,\n    hasMathModeAncestor: false,\n};\n\nexport type VisitInfo = {\n    /**\n     * If the element was accessed via an attribute, the attribute key is specified.\n     */\n    readonly key: string | undefined;\n    /**\n     * If the element was accessed in an array, the index is specified.\n     */\n    readonly index: number | undefined;\n    /**\n     * A list of ancestor nodes, `[parent, grandparent, great-grandparent, ...]`\n     */\n    readonly parents: (Ast.Node | Ast.Argument)[];\n    /**\n     * If the element was accessed in an array, the array that it is part of.\n     */\n    readonly containingArray: (Ast.Node | Ast.Argument)[] | undefined;\n    /**\n     * The LaTeX context of the current match.\n     */\n    readonly context: VisitorContext;\n};\n\n/**\n * Visit children of tree which pass a test\n *\n * @param {Node} tree Abstract syntax tree to walk\n * @param {Visitor|Visitors} [visitor] Function to run for each node\n */\nexport function visit<Opts extends VisitOptions>(\n    tree: Ast.Ast,\n    visitor:\n        | Visitor<VisitorTypeFromOptions<Opts>>\n        | Visitors<VisitorTypeFromOptions<Opts>>,\n    options?: Opts\n) {\n    const {\n        startingContext = DEFAULT_CONTEXT,\n        test = () => true,\n        includeArrays = false,\n    } = options || {};\n    let enter: Visitor<VisitorTypeFromOptions<Opts>> | undefined;\n    let leave: Visitor<VisitorTypeFromOptions<Opts>> | undefined;\n\n    if (typeof visitor === \"function\") {\n        enter = visitor;\n    } else if (visitor && typeof visitor === \"object\") {\n        enter = visitor.enter;\n        leave = visitor.leave;\n    }\n\n    walk(tree, {\n        key: undefined,\n        index: undefined,\n        parents: [],\n        containingArray: undefined,\n        context: { ...startingContext },\n    });\n\n    /**\n     * @param {Node} node\n     * @param {string?} key\n     * @param {number?} index\n     * @param {Array.<Node>} parents\n     */\n    function walk(\n        node: Ast.Ast,\n        { key, index, parents, context, containingArray }: VisitInfo\n    ): ActionTuple {\n        const nodePassesTest = includeArrays\n            ? test(node, { key, index, parents, context, containingArray })\n            : !Array.isArray(node) &&\n              test(node, { key, index, parents, context, containingArray });\n\n        const result: ActionTuple =\n            enter && nodePassesTest\n                ? toResult(\n                      enter(node as any, {\n                          key,\n                          index,\n                          parents,\n                          context,\n                          containingArray,\n                      })\n                  )\n                : [CONTINUE];\n\n        if (result[0] === EXIT) {\n            return result;\n        }\n\n        if (result[0] === SKIP) {\n            return leave && nodePassesTest\n                ? toResult(\n                      leave(node as any, {\n                          key,\n                          index,\n                          parents,\n                          context,\n                          containingArray,\n                      })\n                  )\n                : result;\n        }\n\n        if (Array.isArray(node)) {\n            // The `value` array might be modified in place as we traverse it, so\n            // we use a traditional for loop.\n            for (let index = 0; index > -1 && index < node.length; index++) {\n                const item = node[index];\n                const result = walk(item, {\n                    key,\n                    index,\n                    parents,\n                    context,\n                    containingArray: node,\n                });\n                if (result[0] === EXIT) {\n                    return result;\n                }\n                if (typeof result[1] === \"number\") {\n                    // The for loop will increment i every pass. However,\n                    // if an index was returned, that's where we want to start next time.\n                    index = result[1] - 1;\n                }\n            }\n        } else {\n            // We don't want to recursively apply to the `content`\n            // of all types (e.g., comments and macros), so specify\n            // a blacklist.\n            let childProps: (\"content\" | \"args\")[] = [\"content\", \"args\"];\n            switch (node.type) {\n                case \"macro\":\n                    childProps = [\"args\"];\n                    break;\n                case \"comment\":\n                case \"string\":\n                case \"verb\":\n                case \"verbatim\":\n                    childProps = [];\n                    break;\n                default:\n                    break;\n            }\n\n            const mathModeProps = listMathChildren(node);\n            for (const key of childProps) {\n                const value = node[key as keyof typeof node] as\n                    | Ast.Ast\n                    | undefined;\n                const grandparents = [node].concat(parents);\n\n                if (value == null) {\n                    continue;\n                }\n\n                // We may switch in/out of math mode as we pass to node[key]\n                const newContext = { ...context };\n                if (mathModeProps.enter.includes(key)) {\n                    newContext.inMathMode = true;\n                    newContext.hasMathModeAncestor = true;\n                } else if (mathModeProps.leave.includes(key)) {\n                    newContext.inMathMode = false;\n                }\n\n                const result = walk(value, {\n                    key,\n                    index: undefined,\n                    parents: grandparents,\n                    context: newContext,\n                    containingArray: undefined,\n                });\n                if (result[0] === EXIT) {\n                    return result;\n                }\n            }\n        }\n\n        return leave && nodePassesTest\n            ? toResult(\n                  leave(node as any, {\n                      key,\n                      index,\n                      parents,\n                      context,\n                      containingArray,\n                  })\n              )\n            : result;\n    }\n}\n\n/**\n * Ensures a result is an `ActionTuple`s\n */\nfunction toResult(\n    value: null | undefined | void | Action | Index | ActionTuple\n): ActionTuple {\n    if (value == null) {\n        return [CONTINUE];\n    }\n\n    if (Array.isArray(value)) {\n        return value;\n    }\n\n    if (typeof value === \"number\") {\n        return [CONTINUE, value];\n    }\n\n    return [value];\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Updates the `._renderInfo` property on a node to include\n * whatever has been supplied to `renderInfo`. If `renderInfo`\n * is null, no update is performed.\n *\n * *This operation mutates `node`*\n */\nexport function updateRenderInfo(\n    node: Ast.Node | Ast.Argument,\n    renderInfo: object | null | undefined\n) {\n    if (renderInfo != null) {\n        node._renderInfo = { ...(node._renderInfo || {}), ...renderInfo };\n    }\n    return node;\n}\n\n/**\n * Removes any `_renderInfo` and `position` tags present in the AST. This\n * operation is _destructive_.\n */\nexport function trimRenderInfo<T extends Ast.Ast>(ast: T) {\n    visit(ast, (node) => {\n        delete node._renderInfo;\n        delete node.position;\n    });\n    return ast;\n}\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to help modify the `_renderInfo` of a `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you want to compare the structure of an AST without position information or extra information\n * that is kept for pretty-printing, these functions can be used to remove/modify the `_renderInfo`\n * of an `Ast.Node`.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Trims whitespace and parbreaks from the start and end\n * of an array. The number of trimmed nodes is returned.\n * Special care is taken to preserve comments, though any whitespace\n * before the first comment(s) or after the last comment(s) is trimmed.\n */\nexport function trim(nodes: Ast.Node[]): {\n    trimmedStart: number;\n    trimmedEnd: number;\n} {\n    if (!Array.isArray(nodes)) {\n        console.warn(\"Trying to trim a non-array ast\", nodes);\n        return nodes;\n    }\n\n    const { trimmedStart } = trimStart(nodes);\n    const { trimmedEnd } = trimEnd(nodes);\n\n    return { trimmedStart, trimmedEnd };\n}\n\n/**\n * Trim whitespace and parbreaks from the left of an array.\n */\nexport function trimStart(nodes: Ast.Node[]): { trimmedStart: number } {\n    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);\n\n    nodes.splice(0, start);\n\n    // If there are comments at the start, they might have leading whitespace.\n    // This leading whitespace should be trimmed\n    for (const leadingToken of nodes) {\n        if (!match.comment(leadingToken)) {\n            break;\n        }\n        if (leadingToken.leadingWhitespace || leadingToken.sameline) {\n            leadingToken.leadingWhitespace = false;\n        }\n        // Special care must be taken. If the comment was on the same line as a\n        // parskip, it will no longer be on the same line after the trimming.\n        // Thus, we must modify the comment.\n        if (start > 0 && leadingToken.sameline) {\n            leadingToken.sameline = false;\n        }\n    }\n\n    return { trimmedStart: start };\n}\n\n/**\n * Trim whitespace and parbreaks from the right of an array.\n */\nexport function trimEnd(nodes: Ast.Node[]): { trimmedEnd: number } {\n    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);\n\n    nodes.splice(nodes.length - end, end);\n\n    // Trim off any spaces belonging to trailing comments\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const trailingToken = nodes[i];\n        if (!match.comment(trailingToken)) {\n            break;\n        }\n\n        // Any parbreaks have been trimmed, so there is no suffix parbreak here!\n        delete trailingToken.suffixParbreak;\n\n        // We don't trim spaces before trailing same-line comments. This is a stylistic choice\n        // so that\n        // `foo %xxx` does not become `foo%xxx`.\n        // The latter is strictly \"correct\" for a trim function, but it is prettier to format\n        // code preserving the space before the sameline comment\n        if (\n            match.comment(trailingToken) &&\n            trailingToken.leadingWhitespace &&\n            !trailingToken.sameline\n        ) {\n            trailingToken.leadingWhitespace = false;\n        }\n    }\n\n    return { trimmedEnd: end };\n}\n\n/**\n * Returns the number of whitespace/parbreak nodes at the start and end of an array.\n */\nfunction amountOfLeadingAndTrailingWhitespace(ast: Ast.Node[]): {\n    start: number;\n    end: number;\n} {\n    let start = 0;\n    let end = 0;\n    for (const node of ast) {\n        if (match.whitespace(node) || match.parbreak(node)) {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    if (start === ast.length) {\n        return { start, end: 0 };\n    }\n\n    // Find the padding on the right\n    for (let i = ast.length - 1; i >= 0; i--) {\n        const node = ast[i];\n        if (match.whitespace(node) || match.parbreak(node)) {\n            end++;\n        } else {\n            break;\n        }\n    }\n\n    return { start, end };\n}\n", "import type { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { trim, trimEnd, trimStart } from \"./trim\";\n\ntype PluginOptions = void;\n\n/**\n * Unified plugin to trim the whitespace from the start/end of any environments, including\n * math environments.\n */\nexport const unifiedLatexTrimEnvironmentContents: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexTrimEnvironmentContents() {\n    return (tree) => {\n        visit(tree, (node) => {\n            if (!(match.math(node) || match.anyEnvironment(node))) {\n                return;\n            }\n\n            // If the first thing in the environment is a sameline comment,\n            // we actually want to start trimming *after* it.\n            let firstNode = node.content[0];\n            if (match.comment(firstNode) && firstNode.sameline) {\n                firstNode.suffixParbreak = false;\n                trimEnd(node.content);\n\n                // We play a nasty trick here. This call to `trimStart`\n                // will actually modify `node.content` if `node.content.slice(1)` starts\n                // with a comment that has leading whitespace (it will remove that whitespace).\n                // However, it won't remove any elements from `node.content`; we need\n                // to do that ourselves.\n                const { trimmedStart } = trimStart(node.content.slice(1));\n                node.content.splice(1, trimmedStart);\n            } else {\n                trim(node.content);\n            }\n        });\n    };\n};\n", "import type { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"./trim\";\n\ntype PluginOptions = void;\n\n/**\n * Unified plugin to trim the whitespace from the start/end of the root element.\n */\nexport const unifiedLatexTrimRoot: Plugin<PluginOptions[], Ast.Root, Ast.Root> =\n    function unifiedLatexTrimRoot() {\n        return (tree) => {\n            trim(tree.content);\n        };\n    };\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`\n * are counted as whitespace. Other comments are ignored.\n */\nexport function hasWhitespaceEquivalent(nodes: Ast.Node[]): {\n    start: boolean;\n    end: boolean;\n} {\n    let start = false;\n    let end = false;\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.comment(node)) {\n            // A comment with leading whitespace will render with leading whitespace,\n            // so if we encounter one, we should consider ourselves to have leading whitespace.\n            if (node.leadingWhitespace) {\n                start = true;\n                break;\n            }\n            continue;\n        }\n        if (match.whitespace(node)) {\n            start = true;\n        }\n        break;\n    }\n    for (let j = nodes.length - 1; j >= 0; j--) {\n        const node = nodes[j];\n        if (match.comment(node)) {\n            if (node.leadingWhitespace) {\n                end = true;\n                break;\n            }\n            continue;\n        }\n        if (match.whitespace(node)) {\n            end = true;\n        }\n        break;\n    }\n    return { start, end };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Split a list of nodes based on whether `splitFunc` returns `true`.\n * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then\n * there will be at most two segments returned.\n */\nexport function splitOnCondition(\n    nodes: Ast.Node[],\n    splitFunc: (node: Ast.Node) => boolean = () => false,\n    options?: { onlySplitOnFirstOccurrence?: boolean }\n): { segments: Ast.Node[][]; separators: Ast.Node[] } {\n    if (!Array.isArray(nodes)) {\n        throw new Error(`Can only split an Array, not ${nodes}`);\n    }\n\n    const { onlySplitOnFirstOccurrence = false } = options || {};\n\n    const splitIndices: number[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n        if (splitFunc(nodes[i])) {\n            splitIndices.push(i);\n            if (onlySplitOnFirstOccurrence) {\n                break;\n            }\n        }\n    }\n\n    // Short circuit if there is no splitting to be done\n    if (splitIndices.length === 0) {\n        return { segments: [nodes], separators: [] };\n    }\n\n    let separators = splitIndices.map((i) => nodes[i]);\n    let segments = splitIndices.map((splitEnd, i) => {\n        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;\n        return nodes.slice(splitStart, splitEnd);\n    });\n    segments.push(\n        nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)\n    );\n\n    return { segments, separators };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { splitOnCondition } from \"./split-on-condition\";\n\n/**\n * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`\n * is returned. The original array is reconstructed as\n * `segments[0] + macros[0] + segments[1] + ...`.\n *\n * @param {[object]} ast\n * @param {(string|[string])} macroName\n * @returns {{segments: [object], macros: [object]}}\n */\nexport function splitOnMacro(\n    ast: Ast.Node[],\n    macroName: string | string[]\n): { segments: Ast.Node[][]; macros: Ast.Macro[] } {\n    if (typeof macroName === \"string\") {\n        macroName = [macroName];\n    }\n    if (!Array.isArray(macroName)) {\n        throw new Error(\"Type coercion failed\");\n    }\n    const isSeparator = match.createMacroMatcher(macroName);\n    const { segments, separators } = splitOnCondition(ast, isSeparator);\n    return { segments, macros: separators as Ast.Macro[] };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Does the reverse of `splitOnMacro`\n */\nexport function unsplitOnMacro({\n    segments,\n    macros,\n}: {\n    segments: Ast.Node[][];\n    macros: Ast.Node[] | Ast.Node[][];\n}) {\n    if (segments.length === 0) {\n        console.warn(\"Trying to join zero segments\");\n        return [];\n    }\n    if (segments.length !== macros.length + 1) {\n        console.warn(\n            \"Mismatch between lengths of macros and segments when trying to unsplit\"\n        );\n    }\n\n    let ret = segments[0];\n    for (let i = 0; i < macros.length; i++) {\n        // Even though the type of macros[i] is node and not array,\n        // Array.concat still works\n        ret = ret.concat(macros[i]).concat(segments[i + 1]);\n    }\n\n    return ret;\n}\n", "/**\n * Joins an array of arrays with the item `sep`\n */\nexport function arrayJoin<T>(array: T[][], sep: T | T[]): T[] {\n    return array.flatMap((item, i) => {\n        if (i === 0) {\n            return item;\n        }\n        if (Array.isArray(sep)) {\n            return [...sep, ...item];\n        } else {\n            return [sep, ...item];\n        }\n    });\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { visit, VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If\n * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.\n * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.\n */\nexport function replaceNode(\n    ast: Ast.Ast,\n    visitor: (\n        node: Ast.Node | Ast.Argument,\n        info: VisitInfo\n    ) =>\n        | Ast.Node\n        | Ast.Argument\n        | (Ast.Node | Ast.Argument)[]\n        | null\n        | undefined\n        | void\n) {\n    visit(ast, {\n        leave: (node, info) => {\n            let replacement = visitor(node, info);\n            // Returning `undefined` or the same node means we shouldn't replace that node\n            if (typeof replacement === \"undefined\" || replacement === node) {\n                return;\n            }\n\n            if (!info.containingArray || info.index == null) {\n                throw new Error(\n                    \"Trying to replace node, but cannot find containing array\"\n                );\n            }\n\n            if (\n                replacement === null ||\n                (Array.isArray(replacement) && replacement.length === 0)\n            ) {\n                // A null return means that we delete the current node\n                info.containingArray.splice(info.index, 1);\n                return info.index;\n            }\n\n            if (!Array.isArray(replacement)) {\n                replacement = [replacement];\n            }\n\n            info.containingArray.splice(info.index, 1, ...replacement);\n            // We don't want to *reprocess* the nodes we just inserted into the array,\n            // lest we get stuck in a recursive loop if the replacement contains the original.\n            // Thus we jump to the index after our replacements.\n            return info.index + replacement.length;\n        },\n    });\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNode(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): Ast.Node | null {\n    const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);\n    if (index == null) {\n        return null;\n    }\n    return nodes[index];\n}\n\n/**\n * Returns the index of the last non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function lastSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the first non-whitespace/non-comment node in `nodes`. If there is no such\n * node, `null` is returned.\n */\nexport function firstSignificantNodeIndex(\n    nodes: Ast.Node[],\n    parbreaksAreInsignificant?: boolean\n): number | undefined {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (\n            match.whitespace(node) ||\n            match.comment(node) ||\n            (parbreaksAreInsignificant && match.parbreak(node))\n        ) {\n            continue;\n        }\n        return i;\n    }\n    return undefined;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimStart } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Is the node space-like? I.e., is it whitespace or\n * a comment with leading whitespace?\n */\nfunction isSpaceLike(node: Ast.Node): boolean {\n    return (\n        match.whitespace(node) ||\n        (match.comment(node) && Boolean(node.leadingWhitespace))\n    );\n}\n\n/**\n * Similar to `head.push(...tail)` except that whitespace at the start\n * of `tail` and the end of `head` is collapsed.\n */\nexport function joinWithoutExcessWhitespace(\n    head: Ast.Node[],\n    tail: Ast.Node[]\n): void {\n    if (tail.length === 0) {\n        return;\n    }\n    if (head.length === 0) {\n        head.push(...tail);\n        return;\n    }\n    const headEnd = head[head.length - 1];\n    const tailStart = tail[0];\n    // Whitespace we can just trim off from either end\n    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {\n        head.push(...tail.slice(1));\n        return;\n    }\n    // If there's no whitespace at one of the ends, no need to worry\n    // unless `tailStart` is a comment, in which case it should \"eat\"\n    // the whitespace\n    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {\n        if (match.whitespace(headEnd) && match.comment(tailStart)) {\n            const comment: Ast.Comment = {\n                type: \"comment\",\n                content: tailStart.content,\n                sameline: true,\n                leadingWhitespace: true,\n            };\n            tail = tail.slice(1);\n            trimStart(tail);\n            head.pop();\n            head.push(comment, ...tail);\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // If we're here, we have a comment with leading whitespace on one side\n    // and whitespace/comments on the other.\n    if (match.comment(headEnd) && match.comment(tailStart)) {\n        if (tailStart.leadingWhitespace || tailStart.sameline) {\n            head.push(\n                { type: \"comment\", content: tailStart.content },\n                ...tail.slice(1)\n            );\n            return;\n        }\n        head.push(...tail);\n        return;\n    }\n\n    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,\n    // but make sure the comment has leading whitespace!\n    let comment = match.comment(headEnd) ? headEnd : tailStart;\n    if (!match.comment(comment)) {\n        throw new Error(\n            `Expected a comment but found ${JSON.stringify(comment)}`\n        );\n    }\n\n    if (!comment.leadingWhitespace || !comment.sameline) {\n        comment = {\n            type: \"comment\",\n            content: comment.content,\n            leadingWhitespace: true,\n            sameline: true,\n        };\n    }\n\n    head.pop();\n    head.push(comment, ...tail.slice(1));\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Wraps `content` in the specified wrapper. This command is roughly equivalent to\n * `wrapper(content)` except that leading and trailing whitespace and comments are extracted\n * from `content` and moved to the front or back of the return array. For example,\n * `[\" \", \"foo\", \"bar\", \"% xxx\"]` -> `[\" \", wrapped([\"foo\", \"bar\"]), \"% xxx\"]`.\n *\n */\nexport function wrapSignificantContent(\n    content: Ast.Node[],\n    wrapper: (content: Ast.Node[]) => Ast.Node[] | Ast.Node\n): Ast.Node[] {\n    let hoistUntil = 0;\n    let hoistAfter = content.length;\n    for (let i = 0; i < content.length; i++) {\n        if (match.whitespace(content[i]) || match.comment(content[i])) {\n            hoistUntil = i + 1;\n            continue;\n        }\n        break;\n    }\n    for (let j = content.length - 1; j >= 0; j--) {\n        if (match.whitespace(content[j]) || match.comment(content[j])) {\n            hoistAfter = j;\n            continue;\n        }\n        break;\n    }\n\n    if (hoistUntil === 0 && hoistAfter === content.length) {\n        return ensureArray(wrapper(content));\n    }\n\n    const frontMatter = content.slice(0, hoistUntil);\n    const middle = content.slice(hoistUntil, hoistAfter);\n    const backMatter = content.slice(hoistAfter, content.length);\n\n    return frontMatter.concat(wrapper(middle), backMatter);\n}\n\nfunction ensureArray(x: Ast.Node | Ast.Node[]) {\n    if (!Array.isArray(x)) {\n        return [x];\n    }\n    return x;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { joinWithoutExcessWhitespace } from \"./join-without-excess-whitespace\";\nimport { wrapSignificantContent } from \"./wrap-significant-content\";\n\n/**\n * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.\n * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.\n * This function does not split based on parbreaks/etc.. It is right-associative and returns\n * the streaming commands that were encountered.\n */\nexport function replaceStreamingCommandInArray(\n    nodes: Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[]\n): { foundStreamingCommands: Ast.Node[] } {\n    // Streaming commands that come at the end don't do anything,\n    // so we should remove them\n    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {\n        nodes.pop();\n        trimEnd(nodes);\n    }\n\n    const foundStreamingCommands: Ast.Node[] = [];\n\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i];\n        if (isStreamingCommand(node)) {\n            const wrapper = (content: Ast.Node[]) => replacer(content, node);\n            let tail = nodes.slice(i + 1);\n            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.\n            trimStart(tail);\n            tail = wrapSignificantContent(tail, wrapper);\n            foundStreamingCommands.push(node);\n\n            // Trim off what we're about to replace!\n            nodes.splice(i);\n\n            joinWithoutExcessWhitespace(nodes, tail);\n        }\n    }\n\n    return { foundStreamingCommands };\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport {\n    splitOnCondition,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport {\n    trim,\n    trimEnd,\n    trimStart,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { firstSignificantNode } from \"./utils/significant-node\";\nimport { replaceStreamingCommandInArray } from \"./utils/replace-streaming-command-in-array\";\nimport { wrapSignificantContent } from \"./utils/wrap-significant-content\";\n\ntype Replacer = (nodes: Ast.Node[]) => Ast.Node[];\n\n/**\n * Process streaming commands in a group. If needed, \"escape\" the group.\n * For example, `{\\bfseries xx}` -> `\\textbf{xx}`, but `{foo \\bfseries xx}` -> `{foo \\textbf{xx}}`.\n */\nexport function replaceStreamingCommandInGroup(\n    group: Ast.Group,\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const content = group.content;\n    // If the group started with a streaming command, we want to pop\n    // out of the group. E.g. `{\\bfseries foo}` -> `\\textbf{foo}` and not `{\\textbf{foo}}`\n    let popFromGroup = isStreamingCommand(firstSignificantNode(content));\n\n    let innerProcessed = replaceStreamingCommand(\n        content,\n        isStreamingCommand,\n        replacer,\n        options\n    );\n\n    // If the group consisted of just streaming commands (for some reason...)\n    // it should be eliminated\n    if (innerProcessed.length === 0) {\n        return [];\n    }\n\n    if (popFromGroup) {\n        return innerProcessed;\n    } else {\n        return [{ type: \"group\", content: innerProcessed }];\n    }\n}\n\n/**\n * Given a group or a node array, look for streaming commands (e.g., `\\bfseries`) and replace them\n * with the specified macro. The \"arguments\" of the streaming command are passed to `replacer` and the return\n * value of `replacer` is inserted into the stream.\n *\n * By default, this command will split at parbreaks (since commands like `\\textbf{...} do not accept parbreaks in their\n * contents) and call `replacer` multiple times, once per paragraph.\n *\n * Commands are also split at environments and at any macros listed in `macrosThatBreakPars`.\n */\nexport function replaceStreamingCommand(\n    ast: Ast.Group | Ast.Node[],\n    isStreamingCommand: (node: any) => node is Ast.Macro,\n    replacer: (\n        content: Ast.Node[],\n        streamingCommand: Ast.Macro\n    ) => Ast.Node | Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    if (typeof isStreamingCommand !== \"function\") {\n        throw new Error(\n            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`\n        );\n    }\n\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    let processedContent: Ast.Node[] = [];\n    if (match.group(ast)) {\n        processedContent = replaceStreamingCommandInGroup(\n            ast,\n            isStreamingCommand,\n            replacer\n        );\n    }\n\n    if (Array.isArray(ast)) {\n        // Streaming commands that come at the end of a sequence of nodes don't do anything.\n        // They also will consume whitespace, so we should remove them and the whitespace.\n        const nodes = ast;\n        let scanIndex = nodes.length;\n        let sliceIndex = scanIndex;\n        while (\n            scanIndex > 0 &&\n            (isStreamingCommand(nodes[scanIndex - 1]) ||\n                match.whitespace(nodes[scanIndex - 1]))\n        ) {\n            scanIndex--;\n            if (isStreamingCommand(nodes[scanIndex])) {\n                sliceIndex = scanIndex;\n            }\n        }\n        if (sliceIndex !== nodes.length) {\n            nodes.splice(sliceIndex);\n        }\n\n        const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);\n        const envThatDoesntBreak = match.createEnvironmentMatcher(\n            environmentsThatDontBreakPars\n        );\n        // A \"par\" is anything that a streaming command shouldn't wrap and breaks the stream.\n        // This includes regular pars, but also environments and special macros like \\section\n        const isPar = (node: Ast.Node) =>\n            match.parbreak(node) ||\n            match.macro(node, \"par\") ||\n            macroThatBreaks(node) ||\n            (match.environment(node) && !envThatDoesntBreak(node)) ||\n            node.type === \"displaymath\";\n\n        // We split on both a parbreak and a literal `\\par`. But we will\n        // normalize everything to be parbreaks\n        const splitByPar = splitOnCondition(nodes, isPar);\n        splitByPar.separators = splitByPar.separators.map((sep) =>\n            match.macro(sep, \"par\") ? { type: \"parbreak\" } : sep\n        );\n\n        const replacers: Replacer[] = [];\n        let segments = splitByPar.segments.map((segment) => {\n            if (segment.length === 0) {\n                return segment;\n            }\n            function applyAccumulatedReplacers(nodes: Ast.Node[]): Ast.Node[] {\n                if (replacers.length === 0) {\n                    return nodes;\n                }\n                return wrapSignificantContent(\n                    nodes,\n                    composeReplacers(replacers)\n                );\n            }\n\n            const { foundStreamingCommands } = replaceStreamingCommandInArray(\n                segment,\n                isStreamingCommand,\n                replacer\n            );\n\n            // All streaming commands in `segment` have now been replaced. However,\n            // there might be commands from the previous paragraphs that should wrap\n            // the current segment!\n            const ret = applyAccumulatedReplacers(segment);\n\n            // Any streaming commands from this segment will carry over to the next,\n            // so keep track of them.\n            foundStreamingCommands.forEach((macro) => {\n                replacers.push((nodes: Ast.Node[]) => {\n                    const ret = replacer(nodes, macro as Ast.Macro);\n                    if (!Array.isArray(ret)) {\n                        return [ret];\n                    }\n                    return ret;\n                });\n            });\n\n            return ret;\n        });\n\n        // Leading/trailing whitespace was hoisted in front/back of each replacer.\n        // Since we're separated by parbreaks, we can safely trim all that whitespace.\n        if (segments.length > 1) {\n            segments.forEach((segment, i) => {\n                if (i === 0) {\n                    trimEnd(segment);\n                } else if (i === segments.length - 1) {\n                    trimStart(segment);\n                } else {\n                    trim(segment);\n                }\n            });\n        }\n\n        processedContent = unsplitOnMacro({\n            segments: segments,\n            macros: splitByPar.separators,\n        });\n    }\n\n    return processedContent;\n}\n\n/**\n * Given a sequence of replacer functions `[f, g, h]` return\n * `h \\circ g \\circ f`\n *\n * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers\n * @returns {(nodes: Ast.Node[]) => Ast.Node}\n */\nfunction composeReplacers(replacers: Replacer[]): Replacer {\n    if (replacers.length === 0) {\n        throw new Error(\"Cannot compose zero replacement functions\");\n    }\n    return (nodes: Ast.Node[]) => {\n        let ret = nodes;\n        for (let i = 0; i < replacers.length; i++) {\n            const func = replacers[i];\n            ret = func(ret);\n        }\n        return ret;\n    };\n}\n", "import { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Replaces the current node with `replacement`. It is assumed that the current\n * node is in an array that is a child of a parent element. If this is not the case,\n * the function will error.\n */\nexport function replaceNodeDuringVisit(\n    replacement: Ast.Node | Ast.Argument | (Ast.Node | Ast.Argument)[],\n    info: VisitInfo\n) {\n    const parent = info.parents[0];\n    if (!parent) {\n        throw new Error(`Cannot replace node: parent not found`);\n    }\n    const container = parent[info.key as keyof typeof parent] as\n        | (Ast.Node | Ast.Argument)[]\n        | undefined;\n    if (!Array.isArray(container)) {\n        throw new Error(`Cannot replace node: containing array not found`);\n    }\n    if (info.index == null) {\n        throw new Error(`Cannot replace node: node index undefined`);\n    }\n    if (!Array.isArray(replacement)) {\n        container[info.index] = replacement;\n    } else {\n        container.splice(info.index, 1, ...replacement);\n    }\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trimEnd, trimStart } from \"@unified-latex/unified-latex-util-trim\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { replaceStreamingCommand } from \"./replace-streaming-command\";\nimport { replaceNodeDuringVisit } from \"./replace-node-during-visit\";\n\ntype PluginOptions = {\n    replacers: Record<\n        string,\n        (\n            content: Ast.Node[],\n            streamingCommand: Ast.Macro\n        ) => Ast.Node | Ast.Node[]\n    >;\n};\n\n/**\n * Unified plugin to replace all found streaming commands with their argument-style equivalents.\n * This only applies to sections of the tree with no math ancestor.\n *\n * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.\n */\nexport const unifiedLatexReplaceStreamingCommands: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReplaceStreamingCommands(options) {\n    const { replacers = {} } = options || {};\n    const isReplaceable = match.createMacroMatcher(replacers);\n    return (tree) => {\n        // We traverse all groups before we replace nodes in other contexts\n        visit(\n            tree,\n            (group, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !group.content.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                let fixed = replaceStreamingCommand(\n                    group,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // We cannot replace the node unless we can access the containing array.\n                if (!info.containingArray || info.index == null) {\n                    return;\n                }\n\n                // `fixed` may consist of only whitespace. If this is the case,\n                // surrounding whitespace must trimmed before\n                // inserting the group's contents.\n                const prevToken = info.containingArray[info.index - 1];\n                const nextToken = info.containingArray[info.index + 1];\n                if (\n                    match.whitespaceLike(prevToken) &&\n                    match.whitespaceLike(fixed[0])\n                ) {\n                    trimStart(fixed);\n                }\n                if (\n                    match.whitespaceLike(nextToken) &&\n                    match.whitespaceLike(fixed[fixed.length - 1])\n                ) {\n                    trimEnd(fixed);\n                }\n                replaceNodeDuringVisit(fixed, info);\n            },\n            { test: match.group }\n        );\n\n        visit(\n            tree,\n            (nodes, info) => {\n                if (\n                    info.context.hasMathModeAncestor ||\n                    !nodes.some(isReplaceable)\n                ) {\n                    return;\n                }\n\n                const replaced = replaceStreamingCommand(\n                    nodes,\n                    isReplaceable,\n                    (content, command) => {\n                        return replacers[command.content](content, command);\n                    }\n                );\n\n                // If we get back a different array than we input, the replacement did\n                // not happen in-place. In this case we need to manipulate `nodes`.\n                if (replaced !== nodes) {\n                    nodes.length = 0;\n                    nodes.push(...replaced);\n                }\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport {\n    lastSignificantNode,\n    lastSignificantNodeIndex,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { splitOnMacro } from \"@unified-latex/unified-latex-util-split\";\nimport { trim, trimEnd } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Clean up any whitespace issues in an enumerate environment. In particular,\n *      * Remove any leading or ending whitespace\n *      * Ensure there is a par between occurrences of `\\item`\n *      * Ensure there is whitespace after each occurrence of `\\item` provided there is content there\n * `itemName` can be used to set what the \"item\" macro is called.\n *\n * This function attaches content following a `\\item` to the `\\item` macro with\n * `openMark` and `closeMark` set to empty. This allows hanging-indents to be rendered.\n */\nexport function cleanEnumerateBody(\n    ast: Ast.Node[],\n    itemName = \"item\"\n): Ast.Node[] {\n    let { segments, macros } = splitOnMacro(ast, itemName);\n    // Trim the content of each block, but make sure there is a space\n    // between each macro and the content. Since the first segment of content\n    // appears *before* any macro, don't add a space there.\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === 0) {\n            // The very first segment might be comment with leading whitespace. We don't want to trim that off\n            trimEnd(segment);\n        } else {\n            trim(segment);\n        }\n        // The very first segment comes before any `\\item` macros. It is either\n        // blank or contains comments (or is invalid LaTeX). We don't insert a space\n        // in this case.\n        if (segment.length > 0 && i > 0) {\n            segment.unshift({ type: \"whitespace\" });\n        }\n    }\n\n    let insertParbreakBefore: WeakSet<Ast.Node> = new WeakSet();\n\n    // We want a trailing indent for the `\\item` nodes. We will\n    // do this with a trick: we will add an argument to the index node\n    // with openMark=\" \" and closeMark=\"\"\n    let body: Ast.Node[] = macros.flatMap((node, i) => {\n        const segment = segments[i + 1];\n        const trailingComments = popTrailingComments(segment);\n        node.args = node.args || [];\n        node.args.push(arg(segment, { openMark: \"\", closeMark: \"\" }));\n        updateRenderInfo(node, { inParMode: true });\n\n        // The stream contains a mix of `\\item` macros and comments/parbreaks. We only\n        // want to insert parbreaks before `\\item` macros, so we record these for later.\n        if (i > 0 || segments[0]?.length > 0) {\n            insertParbreakBefore.add(node);\n        }\n\n        return [node, ...trailingComments];\n    });\n\n    // We want a parbreak between each `\\item` block and the preceding content.\n    // We've already logged the `\\item` macros in `insertParbreakBefore`.\n    body = body.flatMap((node) =>\n        insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node\n    );\n\n    body.unshift(...segments[0]);\n\n    // We have inserted parbreaks so some comments need to be told that there is a suffix parbreak\n    for (let i = 0; i < body.length - 1; i++) {\n        const node = body[i];\n        const nextNode = body[i + 1];\n        if (!match.parbreak(nextNode)) {\n            continue;\n        }\n        if (match.comment(node)) {\n            node.suffixParbreak = true;\n        }\n        // The heuristic for detecting an `item`-like node is that its last argument has no close mark.\n        // Regardless of what it is, if there is no close mark, when rendered we don't want two newlines to\n        // appear.\n        if (\n            match.macro(node) &&\n            node.args &&\n            node.args[node.args.length - 1].closeMark === \"\"\n        ) {\n            const args = node.args[node.args.length - 1].content;\n            const lastArg = args[args.length - 1];\n            if (match.comment(lastArg)) {\n                lastArg.suffixParbreak = true;\n            }\n        }\n    }\n\n    return body;\n}\n\n/**\n * Removes and returns any number of trailing comments/parbreaks from `nodes`.\n */\nfunction popTrailingComments(nodes: Ast.Node[]): Ast.Node[] {\n    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n    if (\n        lastNodeIndex === nodes.length - 1 ||\n        (lastNodeIndex == null && nodes.length === 0)\n    ) {\n        return [];\n    }\n\n    // If `nodes` has a non-zero length and we didn't find a significant node, everything is comments!\n    if (lastNodeIndex == null) {\n        lastNodeIndex = -1;\n    }\n    return nodes.splice(lastNodeIndex + 1);\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    answerline: { signature: \"o\" },\n    fillin: { signature: \"o o\" },\n    fullwidth: { signature: \"m\" },\n    fillwidthlines: { signature: \"m\" },\n    fillwidthdottedlines: { signature: \"m\" },\n    fillwidthgrid: { signature: \"m\" },\n    makeemptybox: { signature: \"m\" },\n    CorrectChoiceEmphasis: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    SolutionEmphasis: { signature: \"m\", renderInfo: { breakAround: true } },\n    uplevel: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkboxchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkedchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    marginpointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    extrawidth: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    bonuspointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    totalformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    qformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    titledquestion: { signature: \"m o\", renderInfo: { breakAround: true } },\n    pointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n    bonuspointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    choices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    checkboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparchoices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparcheckboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    parts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"part\"),\n    },\n    subparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subpart\"),\n    },\n    subsubparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subsubpart\"),\n    },\n    questions: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"question\"),\n    },\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    geometry: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    hypersetup: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    href: { signature: \"o m m\" },\n    url: { signature: \"m\" },\n    nolinkurl: { signature: \"m\" },\n    hyperbaseurl: { signature: \"m\" },\n    hyperimage: { signature: \"m m\" },\n    hyperdef: { signature: \"m m m\" },\n    hyperref: { signature: \"o m\" },\n    hyperlink: { signature: \"m m\" },\n    hypertarget: { signature: \"m m\" },\n    autoref: { signature: \"s m\" },\n    pageref: { signature: \"s m\" },\n    autopageref: { signature: \"s m\" },\n    pdfstringdef: { signature: \"m m\" },\n    pdfbookmark: { signature: \"o m m\" },\n    currentpdfbookmark: { signature: \"m m\" },\n    subpdfbookmark: { signature: \"m m\" },\n    belowpdfbookmark: { signature: \"m m\" },\n    texorpdfstring: { signature: \"m m\" },\n    thispdfpagelabel: { signature: \"m\" },\n    hypercalcbp: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    // Special\n    \"\\\\\": { signature: \"!s !o\", renderInfo: { breakAfter: true } },\n    _: { signature: \"m\", escapeToken: \"\" },\n    \"^\": { signature: \"m\", escapeToken: \"\" },\n    // \\newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands\n    // List can be found in latex2e.pdf \"An unofficial reference manual\"\n    newcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", \"name\", \"numArgs\", \"default\", \"body\"],\n        },\n    },\n    renewcommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", \"name\", \"numArgs\", \"default\", \"body\"],\n        },\n    },\n    providecommand: {\n        signature: \"s +m o +o +m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    newcounter: {\n        signature: \"m o\",\n        renderInfo: { breakAround: true },\n    },\n    usecounter: {\n        signature: \"m\",\n    },\n    setcounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    addtocounter: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    stepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    refstepcounter: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    // Lengths\n    newlength: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    addtolength: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settodepth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settoheight: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    settowidth: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Spaces\n    stretch: { signature: \"m\" },\n    hspace: { signature: \"s m\" },\n    vspace: { signature: \"s m\", renderInfo: { breakAround: true } },\n    vfill: { renderInfo: { breakAround: true } },\n    indent: { renderInfo: { breakAround: true } },\n    phantom: { signature: \"m\" },\n    vphantom: { signature: \"m\" },\n    hphantom: { signature: \"m\" },\n    noindent: { renderInfo: { breakAround: true } },\n    smallskip: { renderInfo: { breakAround: true } },\n    medskip: { renderInfo: { breakAround: true } },\n    bigskip: { renderInfo: { breakAround: true } },\n    smallbreak: { renderInfo: { breakAround: true } },\n    medbreak: { renderInfo: { breakAround: true } },\n    bigbreak: { renderInfo: { breakAround: true } },\n    newline: { renderInfo: { breakAround: true } },\n    linebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nolinebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    clearpage: { renderInfo: { breakAround: true } },\n    cleardoublepage: { renderInfo: { breakAround: true } },\n    newpage: { renderInfo: { breakAround: true } },\n    enlargethispage: { signature: \"s\", renderInfo: { breakAround: true } },\n    pagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    nopagebreak: { signature: \"o\", renderInfo: { breakAround: true } },\n    // Boxes\n    newsavebox: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    sbox: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    savebox: {\n        signature: \"m o o m\",\n        renderInfo: { breakAround: true },\n    },\n    mbox: { signature: \"m\" },\n    makebox: { signature: \"d() o o m\", renderInfo: { breakAround: true } },\n    fbox: { signature: \"m\" },\n    framebox: { signature: \"o o m\", renderInfo: { breakAround: true } },\n    frame: { signature: \"m\", renderInfo: { breakAround: true } },\n    parbox: { signature: \"o o o m m\", renderInfo: { breakAround: true } },\n    raisebox: { signature: \"m o o m\" },\n    marginpar: { signature: \"o m\", renderInfo: { breakAround: true } },\n    colorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    fcolorbox: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    rotatebox: { signature: \"o m m\" },\n    scalebox: { signature: \"m o m\" },\n    reflectbox: { signature: \"m\" },\n    resizebox: { signature: \"s m m m\" },\n    // Define environments\n    newenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    newtheorem: {\n        signature: \"s m o m o\",\n        renderInfo: { breakAround: true },\n    },\n    newfont: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    // Counters\n    alph: { signature: \"m\" },\n    Alph: { signature: \"m\" },\n    arabic: { signature: \"m\" },\n    roman: { signature: \"m\" },\n    Roman: { signature: \"m\" },\n    fnsymbol: { signature: \"m\" },\n    // Other\n    documentclass: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepackage: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    item: {\n        signature: \"o\",\n        renderInfo: { hangingIndent: true, namedArguments: [\"label\"] },\n    },\n    value: { signature: \"m\" },\n    centering: { renderInfo: { breakAround: true } },\n    input: { signature: \"m\", renderInfo: { breakAround: true } },\n    include: { signature: \"m\", renderInfo: { breakAround: true } },\n    includeonly: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    discretionary: { signature: \"m m m\" },\n    hyphenation: { signature: \"m m m\" },\n    footnote: { signature: \"o m\", renderInfo: { inParMode: true } },\n    footnotemark: { signature: \"o\" },\n    footnotetext: { signature: \"o m\", renderInfo: { inParMode: true } },\n    caption: {\n        signature: \"o m\",\n        renderInfo: { inParMode: true, breakAround: true },\n    },\n    // Math Commands\n    sqrt: { signature: \"o m\", renderInfo: { inMathMode: true } },\n    frac: { signature: \"m m\", renderInfo: { inMathMode: true } },\n    stackrel: { signature: \"m m\" },\n    ensuremath: { signature: \"m\", renderInfo: { inMathMode: true } },\n    // Layout commands\n    abstract: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    maketitle: { renderInfo: { breakAround: true } },\n    doublespacing: { renderInfo: { breakAround: true } },\n    singlespacing: { renderInfo: { breakAround: true } },\n    author: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    date: { signature: \"o m\", renderInfo: { breakAround: true } },\n    thanks: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    // amsart document class adds an optional argument\n    title: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, inParMode: true },\n    },\n    pagenumbering: { signature: \"m\", renderInfo: { breakAround: true } },\n    pagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    thispagestyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    // Colors\n    definecolor: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    pagecolor: { signature: \"o m\", renderInfo: { breakAround: true } },\n    nopagecolor: { renderInfo: { breakAround: true } },\n    multicolumn: { signature: \"m m m\" },\n    // Graphics\n    includegraphics: {\n        signature: \"s o o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    rule: { signature: \"o m m\" },\n    // Sectioning\n    part: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    chapter: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    section: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subsection: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subsubsection: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    paragraph: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    subparagraph: {\n        signature: \"s o m\",\n        renderInfo: {\n            breakAround: true,\n            inParMode: true,\n            namedArguments: [\"starred\", \"tocTitle\", \"title\"],\n        },\n    },\n    appendix: { renderInfo: { breakAround: true, inParMode: true } },\n    frontmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    mainmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    backmatter: { renderInfo: { breakAround: true, inParMode: true } },\n    // Citing and references\n    bibitem: { signature: \"o m\", renderInfo: { hangingIndent: true } },\n    cite: { signature: \"o m\" },\n    // Fonts\n    textrm: { signature: \"m\", renderInfo: { inParMode: true } },\n    textit: { signature: \"m\", renderInfo: { inParMode: true } },\n    textmd: { signature: \"m\", renderInfo: { inParMode: true } },\n    textbf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textup: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsl: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsf: { signature: \"m\", renderInfo: { inParMode: true } },\n    textsc: { signature: \"m\", renderInfo: { inParMode: true } },\n    texttt: { signature: \"m\", renderInfo: { inParMode: true } },\n    emph: { signature: \"m\", renderInfo: { inParMode: true } },\n    textnormal: { signature: \"m\", renderInfo: { inParMode: true } },\n    uppercase: { signature: \"m\", renderInfo: { inParMode: true } },\n    mathbf: { signature: \"m\" },\n    mathsf: { signature: \"m\" },\n    mathtt: { signature: \"m\" },\n    mathit: { signature: \"m\" },\n    mathnormal: { signature: \"m\" },\n    mathcal: { signature: \"m\" },\n    mathrm: { signature: \"m\" },\n    // Other\n    setlength: { signature: \"m m\", renderInfo: { breakAround: true } },\n    ref: { signature: \"s m\" },\n    label: { signature: \"o m\" }, // cleveref changes \\label to have this signature\n    printbibliography: { renderInfo: { breakAround: true } },\n    addtocontents: { signature: \"m m\", renderInfo: { breakAround: true } },\n    addcontentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    contentsline: { signature: \"m m m\", renderInfo: { breakAround: true } },\n    bibliography: { signature: \"m\", renderInfo: { breakAround: true } },\n    bibliographystyle: { signature: \"m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    document: {\n        processContent: (nodes) => {\n            trim(nodes);\n            return nodes;\n        },\n    },\n    array: { signature: \"o m\", renderInfo: { alignContent: true } },\n    description: { signature: \"o\", processContent: cleanEnumerateBody },\n    enumerate: {\n        signature: \"o\",\n        processContent: cleanEnumerateBody,\n        renderInfo: { pgfkeysArgs: true },\n    },\n    itemize: { signature: \"o\", processContent: cleanEnumerateBody },\n    trivlist: { signature: \"o\", processContent: cleanEnumerateBody },\n    list: { signature: \"m m\", processContent: cleanEnumerateBody },\n    figure: { signature: \"o\" },\n    \"figure*\": { signature: \"o\" },\n    filecontents: { signature: \"o m\" },\n    \"filecontents*\": { signature: \"o m\" },\n    minipage: { signature: \"o o o m\" },\n    picture: { signature: \"r() d()\" },\n    tabbing: { renderInfo: { alignContent: true } },\n    table: { signature: \"o\" },\n    tabular: { signature: \"o m\", renderInfo: { alignContent: true } },\n    \"tabular*\": { signature: \"m o m\", renderInfo: { alignContent: true } },\n    thebibliography: {\n        signature: \"m\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"bibitem\"),\n    },\n    // Math\n    math: { renderInfo: { inMathMode: true } },\n};\n", "type StringlikeArray = any[] & string;\n\n/**\n * Pegjs operates on strings. However, strings and arrays are very similar!\n * This function adds `charAt`, `charCodeAt`, and `substring` methods to\n * `array` so that `array` can then be fed to a Pegjs generated parser.\n *\n * @param {[object]} array\n * @returns {[object]}\n */\nexport function decorateArrayForPegjs(array: any[]): StringlikeArray {\n    (array as any).charAt = function (i: number) {\n        return this[i];\n    };\n    // We don't have a hope of imitating `charCodeAt`, so\n    // make it something that won't interfere\n    (array as any).charCodeAt = () => 0;\n    (array as any).substring = function (i: number, j: number) {\n        return this.slice(i, j);\n    };\n    // This function is called when reporting an error,\n    // so we convert back to a string.\n    (array as any).replace = function (a: string, b: string) {\n        const ret = JSON.stringify(this);\n        return ret.replace(a, b);\n    };\n    return array as StringlikeArray;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\n/**\n * Splits all multi-character strings into strings that are all single characters.\n */\nexport function splitStringsIntoSingleChars(nodes: Ast.Node[]): Ast.Node[] {\n    return nodes.flatMap((node) =>\n        match.anyString(node)\n            ? (Array.from(node.content).map((c) => ({\n                  type: \"string\",\n                  content: c,\n              })) as Ast.Node[])\n            : node\n    );\n}\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };\n      var peg$startRuleFunction = peg$parsedocument;\n      var peg$c0 = \"%\";\n      var peg$c1 = \".\";\n      var peg$c2 = \"verb*\";\n      var peg$c3 = \"verb\";\n      var peg$c4 = \"[\";\n      var peg$c5 = \"]\";\n      var peg$c6 = \"lstinline\";\n      var peg$c7 = \"mintinline\";\n      var peg$c8 = \"mint\";\n      var peg$c9 = \"minted\";\n      var peg$c10 = \"verbatim*\";\n      var peg$c11 = \"verbatim\";\n      var peg$c12 = \"filecontents*\";\n      var peg$c13 = \"filecontents\";\n      var peg$c14 = \"comment\";\n      var peg$c15 = \"lstlisting\";\n      var peg$c16 = \"(\";\n      var peg$c17 = \")\";\n      var peg$c18 = \"begin\";\n      var peg$c19 = \"end\";\n      var peg$c20 = \"equation*\";\n      var peg$c21 = \"equation\";\n      var peg$c22 = \"align*\";\n      var peg$c23 = \"align\";\n      var peg$c24 = \"alignat*\";\n      var peg$c25 = \"alignat\";\n      var peg$c26 = \"gather*\";\n      var peg$c27 = \"gather\";\n      var peg$c28 = \"multline*\";\n      var peg$c29 = \"multline\";\n      var peg$c30 = \"flalign*\";\n      var peg$c31 = \"flalign\";\n      var peg$c32 = \"split\";\n      var peg$c33 = \"math\";\n      var peg$c34 = \"displaymath\";\n      var peg$c35 = \"\\\\\";\n      var peg$c36 = \"{\";\n      var peg$c37 = \"}\";\n      var peg$c38 = \"$\";\n      var peg$c39 = \"&\";\n      var peg$c40 = \"\\r\";\n      var peg$c41 = \"\\n\";\n      var peg$c42 = \"\\r\\n\";\n      var peg$c43 = \"#\";\n      var peg$c44 = \"^\";\n      var peg$c45 = \"_\";\n      var peg$c46 = \"\\0\";\n      var peg$r0 = /^[^ \\t\\n\\r]/;\n      var peg$r1 = /^[ \\t]/;\n      var peg$r2 = /^[a-zA-Z]/;\n      var peg$r3 = /^[0-9]/;\n      var peg$r4 = /^[.,;:\\-*\\/()!?=+<>[\\]`'\"~]/;\n      var peg$e0 = peg$otherExpectation(\"document\");\n      var peg$e1 = peg$otherExpectation(\"math\");\n      var peg$e2 = peg$otherExpectation(\"token\");\n      var peg$e3 = peg$anyExpectation();\n      var peg$e4 = peg$otherExpectation(\"parbreak\");\n      var peg$e5 = peg$otherExpectation(\"math token\");\n      var peg$e6 = peg$otherExpectation(\"nonchar token\");\n      var peg$e7 = peg$literalExpectation(\"%\", false);\n      var peg$e8 = peg$otherExpectation(\"whitespace\");\n      var peg$e9 = peg$otherExpectation(\"number\");\n      var peg$e10 = peg$literalExpectation(\".\", false);\n      var peg$e11 = peg$otherExpectation(\"special macro\");\n      var peg$e12 = peg$literalExpectation(\"verb*\", false);\n      var peg$e13 = peg$literalExpectation(\"verb\", false);\n      var peg$e14 = peg$literalExpectation(\"[\", false);\n      var peg$e15 = peg$literalExpectation(\"]\", false);\n      var peg$e16 = peg$classExpectation([\" \", \"\t\", \"\\n\", \"\\r\"], true, false);\n      var peg$e17 = peg$otherExpectation(\"verbatim listings\");\n      var peg$e18 = peg$literalExpectation(\"lstinline\", false);\n      var peg$e19 = peg$otherExpectation(\"verbatim minted\");\n      var peg$e20 = peg$literalExpectation(\"mintinline\", false);\n      var peg$e21 = peg$literalExpectation(\"mint\", false);\n      var peg$e22 = peg$otherExpectation(\"verbatim minted environment\");\n      var peg$e23 = peg$literalExpectation(\"minted\", false);\n      var peg$e24 = peg$otherExpectation(\"verbatim environment\");\n      var peg$e25 = peg$literalExpectation(\"verbatim*\", false);\n      var peg$e26 = peg$literalExpectation(\"verbatim\", false);\n      var peg$e27 = peg$literalExpectation(\"filecontents*\", false);\n      var peg$e28 = peg$literalExpectation(\"filecontents\", false);\n      var peg$e29 = peg$literalExpectation(\"comment\", false);\n      var peg$e30 = peg$literalExpectation(\"lstlisting\", false);\n      var peg$e31 = peg$otherExpectation(\"macro\");\n      var peg$e32 = peg$otherExpectation(\"group\");\n      var peg$e33 = peg$otherExpectation(\"environment\");\n      var peg$e34 = peg$otherExpectation(\"math environment\");\n      var peg$e35 = peg$otherExpectation(\"math group\");\n      var peg$e36 = peg$literalExpectation(\"(\", false);\n      var peg$e37 = peg$literalExpectation(\")\", false);\n      var peg$e38 = peg$literalExpectation(\"begin\", false);\n      var peg$e39 = peg$literalExpectation(\"end\", false);\n      var peg$e40 = peg$literalExpectation(\"equation*\", false);\n      var peg$e41 = peg$literalExpectation(\"equation\", false);\n      var peg$e42 = peg$literalExpectation(\"align*\", false);\n      var peg$e43 = peg$literalExpectation(\"align\", false);\n      var peg$e44 = peg$literalExpectation(\"alignat*\", false);\n      var peg$e45 = peg$literalExpectation(\"alignat\", false);\n      var peg$e46 = peg$literalExpectation(\"gather*\", false);\n      var peg$e47 = peg$literalExpectation(\"gather\", false);\n      var peg$e48 = peg$literalExpectation(\"multline*\", false);\n      var peg$e49 = peg$literalExpectation(\"multline\", false);\n      var peg$e50 = peg$literalExpectation(\"flalign*\", false);\n      var peg$e51 = peg$literalExpectation(\"flalign\", false);\n      var peg$e52 = peg$literalExpectation(\"split\", false);\n      var peg$e53 = peg$literalExpectation(\"math\", false);\n      var peg$e54 = peg$literalExpectation(\"displaymath\", false);\n      var peg$e55 = peg$otherExpectation(\"escape\");\n      var peg$e56 = peg$literalExpectation(\"\\\\\", false);\n      var peg$e57 = peg$literalExpectation(\"{\", false);\n      var peg$e58 = peg$literalExpectation(\"}\", false);\n      var peg$e59 = peg$literalExpectation(\"$\", false);\n      var peg$e60 = peg$literalExpectation(\"&\", false);\n      var peg$e61 = peg$otherExpectation(\"newline\");\n      var peg$e62 = peg$literalExpectation(\"\\r\", false);\n      var peg$e63 = peg$literalExpectation(\"\\n\", false);\n      var peg$e64 = peg$literalExpectation(\"\\r\\n\", false);\n      var peg$e65 = peg$literalExpectation(\"#\", false);\n      var peg$e66 = peg$literalExpectation(\"^\", false);\n      var peg$e67 = peg$literalExpectation(\"_\", false);\n      var peg$e68 = peg$literalExpectation(\"\\0\", false);\n      var peg$e69 = peg$classExpectation([\" \", \"\t\"], false, false);\n      var peg$e70 = peg$otherExpectation(\"letter\");\n      var peg$e71 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n      var peg$e72 = peg$otherExpectation(\"digit\");\n      var peg$e73 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n      var peg$e74 = peg$otherExpectation(\"punctuation\");\n      var peg$e75 = peg$classExpectation([\".\", \",\", \";\", \":\", \"-\", \"*\", \"/\", \"(\", \")\", \"!\", \"?\", \"=\", \"+\", \"<\", \">\", \"[\", \"]\", \"`\", \"'\", '\"', \"~\"], false, false);\n      var peg$e76 = peg$otherExpectation(\"full comment\");\n      var peg$e77 = peg$otherExpectation(\"comment\");\n      var peg$f0 = function(content) {\n        return createNode(\"root\", { content: content.flatMap((x) => x) });\n      };\n      var peg$f1 = function(t) {\n        return t;\n      };\n      var peg$f2 = function(eq) {\n        return createNode(\"inlinemath\", { content: eq.flatMap((x) => x) });\n      };\n      var peg$f3 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f4 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f5 = function() {\n        return createNode(\"parbreak\");\n      };\n      var peg$f6 = function(x) {\n        return x;\n      };\n      var peg$f7 = function(x) {\n        return x;\n      };\n      var peg$f8 = function() {\n        return createNode(\"macro\", { content: \"^\", escapeToken: \"\" });\n      };\n      var peg$f9 = function() {\n        return createNode(\"macro\", { content: \"_\", escapeToken: \"\" });\n      };\n      var peg$f10 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f11 = function() {\n        return createNode(\"whitespace\");\n      };\n      var peg$f12 = function(a, b) {\n        return a.join(\"\") + \".\" + b.join(\"\");\n      };\n      var peg$f13 = function(b) {\n        return \".\" + b.join(\"\");\n      };\n      var peg$f14 = function(a) {\n        return a.join(\"\") + \".\";\n      };\n      var peg$f15 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f16 = function(env, e, end) {\n        return end == e;\n      };\n      var peg$f17 = function(env, e, x) {\n        return x;\n      };\n      var peg$f18 = function(env, e, x, end) {\n        return end == e;\n      };\n      var peg$f19 = function(env, e, x) {\n        return createNode(\"verb\", {\n          env,\n          escape: e,\n          content: x.join(\"\")\n        });\n      };\n      var peg$f20 = function(x) {\n        return x;\n      };\n      var peg$f21 = function(x) {\n        return createNode(\"displaymath\", { content: x.flatMap((x2) => x2) });\n      };\n      var peg$f22 = function(x) {\n        return x;\n      };\n      var peg$f23 = function(x) {\n        return createNode(\"inlinemath\", { content: x.flatMap((x2) => x2) });\n      };\n      var peg$f24 = function(x) {\n        return x;\n      };\n      var peg$f25 = function(x) {\n        return createNode(\"displaymath\", { content: x.flatMap((x2) => x2) });\n      };\n      var peg$f26 = function(end) {\n        return end.type === \"string\" && end.content === \"]\";\n      };\n      var peg$f27 = function(x) {\n        return x;\n      };\n      var peg$f28 = function(o) {\n        return [\n          createNode(\"string\", { content: \"[\" }),\n          ...o,\n          createNode(\"string\", { content: \"]\" })\n        ];\n      };\n      var peg$f29 = function(x) {\n        return x;\n      };\n      var peg$f30 = function(v) {\n        return createNode(\"group\", {\n          content: createNode(\"string\", { content: v.join(\"\") })\n        });\n      };\n      var peg$f31 = function(d, end) {\n        return end == d;\n      };\n      var peg$f32 = function(d, x) {\n        return x;\n      };\n      var peg$f33 = function(d, v, end) {\n        return end == d;\n      };\n      var peg$f34 = function(d, v) {\n        return [\n          createNode(\"string\", { content: d }),\n          createNode(\"string\", { content: v.join(\"\") }),\n          createNode(\"string\", { content: d })\n        ];\n      };\n      var peg$f35 = function(macro, option, verbatim) {\n        return [\n          createNode(\"macro\", { content: macro }),\n          ...option || [],\n          ...[].concat(verbatim)\n        ];\n      };\n      var peg$f36 = function(macro, option, language, verbatim) {\n        return [\n          createNode(\"macro\", { content: macro }),\n          ...option || [],\n          language,\n          ...[].concat(verbatim)\n        ];\n      };\n      var peg$f37 = function(env, option, language, end_env) {\n        return compare_env({ content: [env] }, end_env);\n      };\n      var peg$f38 = function(env, option, language, body) {\n        const content = [\n          ...option || [],\n          language,\n          { type: \"string\", content: body }\n        ];\n        return createNode(\"environment\", {\n          env,\n          content\n        });\n      };\n      var peg$f39 = function(env, end_env) {\n        return compare_env({ content: [env] }, end_env);\n      };\n      var peg$f40 = function(env, x) {\n        return x;\n      };\n      var peg$f41 = function(env, body) {\n        return createNode(\"verbatim\", {\n          env,\n          content: body\n        });\n      };\n      var peg$f42 = function(n) {\n        return n.join(\"\");\n      };\n      var peg$f43 = function(n) {\n        return n;\n      };\n      var peg$f44 = function(m) {\n        return createNode(\"macro\", { content: m });\n      };\n      var peg$f45 = function(c) {\n        return c;\n      };\n      var peg$f46 = function(x) {\n        return createNode(\"group\", { content: x.flatMap((x2) => x2) });\n      };\n      var peg$f47 = function(g) {\n        return text().slice(1, -1);\n      };\n      var peg$f48 = function(env, env_comment, end_env) {\n        return compare_env(env, end_env);\n      };\n      var peg$f49 = function(env, env_comment, x) {\n        return x;\n      };\n      var peg$f50 = function(env, env_comment, body) {\n        body = body.flatMap((x) => x);\n        return createNode(\"environment\", {\n          env,\n          content: env_comment ? [env_comment, ...body] : body\n        });\n      };\n      var peg$f51 = function(env, env_comment, end_env) {\n        return compare_env({ content: [env] }, end_env);\n      };\n      var peg$f52 = function(env, env_comment, x) {\n        return x;\n      };\n      var peg$f53 = function(env, env_comment, body) {\n        body = body.flatMap((x) => x);\n        return createNode(\"mathenv\", {\n          env,\n          content: env_comment ? [env_comment, ...body] : body\n        });\n      };\n      var peg$f54 = function(c) {\n        return c;\n      };\n      var peg$f55 = function(x) {\n        return createNode(\"group\", { content: x.flatMap((x2) => x2) });\n      };\n      var peg$f56 = function(e) {\n        return createNode(\"string\", { content: e });\n      };\n      var peg$f57 = function() {\n        return createNode(\"string\", { content: \"\\\\\" });\n      };\n      var peg$f58 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f59 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f60 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f61 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f62 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f63 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f64 = function(s) {\n        return createNode(\"string\", { content: s });\n      };\n      var peg$f65 = function() {\n        return \" \";\n      };\n      var peg$f66 = function(p) {\n        return createNode(\"string\", { content: p });\n      };\n      var peg$f67 = function(leading_sp, comment) {\n        return createNode(\"comment\", {\n          ...comment,\n          sameline: false,\n          leadingWhitespace: leading_sp.length > 0\n        });\n      };\n      var peg$f68 = function(spaces, x) {\n        return createNode(\"comment\", {\n          ...x,\n          sameline: true,\n          leadingWhitespace: spaces.length > 0\n        });\n      };\n      var peg$f69 = function(c) {\n        return c;\n      };\n      var peg$f70 = function(c) {\n        return { content: c.join(\"\"), suffixParbreak: true };\n      };\n      var peg$f71 = function(c) {\n        return c;\n      };\n      var peg$f72 = function(c) {\n        return { content: c.join(\"\") };\n      };\n      var peg$f73 = function() {\n        var loc = location();\n        return loc.start.column === 1;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsedocument() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsetoken();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsetoken();\n        }\n        peg$savedPos = s0;\n        s1 = peg$f0(s1);\n        s0 = s1;\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e0);\n        }\n        return s0;\n      }\n      function peg$parsemath() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        s1 = peg$parsemath_token();\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = peg$parsemath_token();\n        }\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e1);\n        }\n        return s0;\n      }\n      function peg$parsetoken() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$parsespecial_macro();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsemacro();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefull_comment();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsegroup();\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsemath_shift();\n                if (s1 !== peg$FAILED) {\n                  s2 = [];\n                  s3 = peg$currPos;\n                  s4 = peg$currPos;\n                  peg$silentFails++;\n                  s5 = peg$parsemath_shift();\n                  peg$silentFails--;\n                  if (s5 === peg$FAILED) {\n                    s4 = void 0;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsemath_token();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s3 = peg$f1(s5);\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    while (s3 !== peg$FAILED) {\n                      s2.push(s3);\n                      s3 = peg$currPos;\n                      s4 = peg$currPos;\n                      peg$silentFails++;\n                      s5 = peg$parsemath_shift();\n                      peg$silentFails--;\n                      if (s5 === peg$FAILED) {\n                        s4 = void 0;\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                      if (s4 !== peg$FAILED) {\n                        s5 = peg$parsemath_token();\n                        if (s5 !== peg$FAILED) {\n                          peg$savedPos = s3;\n                          s3 = peg$f1(s5);\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    }\n                  } else {\n                    s2 = peg$FAILED;\n                  }\n                  if (s2 !== peg$FAILED) {\n                    s3 = peg$parsemath_shift();\n                    if (s3 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f2(s2);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsealignment_tab();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseparbreak();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsemacro_parameter();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenumber();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsewhitespace();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsepunctuation();\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$currPos;\n                                s1 = peg$currPos;\n                                s2 = [];\n                                s3 = peg$currPos;\n                                s4 = peg$currPos;\n                                peg$silentFails++;\n                                s5 = peg$parsenonchar_token();\n                                peg$silentFails--;\n                                if (s5 === peg$FAILED) {\n                                  s4 = void 0;\n                                } else {\n                                  peg$currPos = s4;\n                                  s4 = peg$FAILED;\n                                }\n                                if (s4 !== peg$FAILED) {\n                                  if (input.length > peg$currPos) {\n                                    s5 = input.charAt(peg$currPos);\n                                    peg$currPos++;\n                                  } else {\n                                    s5 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                      peg$fail(peg$e3);\n                                    }\n                                  }\n                                  if (s5 !== peg$FAILED) {\n                                    s4 = [s4, s5];\n                                    s3 = s4;\n                                  } else {\n                                    peg$currPos = s3;\n                                    s3 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s3;\n                                  s3 = peg$FAILED;\n                                }\n                                if (s3 !== peg$FAILED) {\n                                  while (s3 !== peg$FAILED) {\n                                    s2.push(s3);\n                                    s3 = peg$currPos;\n                                    s4 = peg$currPos;\n                                    peg$silentFails++;\n                                    s5 = peg$parsenonchar_token();\n                                    peg$silentFails--;\n                                    if (s5 === peg$FAILED) {\n                                      s4 = void 0;\n                                    } else {\n                                      peg$currPos = s4;\n                                      s4 = peg$FAILED;\n                                    }\n                                    if (s4 !== peg$FAILED) {\n                                      if (input.length > peg$currPos) {\n                                        s5 = input.charAt(peg$currPos);\n                                        peg$currPos++;\n                                      } else {\n                                        s5 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                          peg$fail(peg$e3);\n                                        }\n                                      }\n                                      if (s5 !== peg$FAILED) {\n                                        s4 = [s4, s5];\n                                        s3 = s4;\n                                      } else {\n                                        peg$currPos = s3;\n                                        s3 = peg$FAILED;\n                                      }\n                                    } else {\n                                      peg$currPos = s3;\n                                      s3 = peg$FAILED;\n                                    }\n                                  }\n                                } else {\n                                  s2 = peg$FAILED;\n                                }\n                                if (s2 !== peg$FAILED) {\n                                  s1 = input.substring(s1, peg$currPos);\n                                } else {\n                                  s1 = s2;\n                                }\n                                if (s1 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s1 = peg$f3(s1);\n                                }\n                                s0 = s1;\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$parsebegin_group();\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$parseend_group();\n                                    if (s0 === peg$FAILED) {\n                                      s0 = peg$parsemath_shift();\n                                      if (s0 === peg$FAILED) {\n                                        s0 = peg$currPos;\n                                        if (input.length > peg$currPos) {\n                                          s1 = input.charAt(peg$currPos);\n                                          peg$currPos++;\n                                        } else {\n                                          s1 = peg$FAILED;\n                                          if (peg$silentFails === 0) {\n                                            peg$fail(peg$e3);\n                                          }\n                                        }\n                                        if (s1 !== peg$FAILED) {\n                                          peg$savedPos = s0;\n                                          s1 = peg$f4(s1);\n                                        }\n                                        s0 = s1;\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        return s0;\n      }\n      function peg$parseparbreak() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsesp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsesp();\n        }\n        s3 = peg$parsenl();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = [];\n          s7 = peg$parsesp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsesp();\n          }\n          s7 = peg$parsenl();\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = [];\n              s7 = peg$parsesp();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsesp();\n              }\n              s7 = peg$parsenl();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsesp();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsesp();\n            }\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsecomment_start();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = [];\n          s3 = peg$parsesp();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsesp();\n          }\n          s3 = peg$parsenl();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = [];\n            s7 = peg$parsesp();\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parsesp();\n            }\n            s7 = peg$parsenl();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$currPos;\n                s6 = [];\n                s7 = peg$parsesp();\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$parsesp();\n                }\n                s7 = peg$parsenl();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f5();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemath_token() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$parsespecial_macro();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsemacro();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefull_comment();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = [];\n              s2 = peg$parsewhitespace();\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$parsewhitespace();\n              }\n              s2 = peg$parsegroup();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parsewhitespace();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parsewhitespace();\n                }\n                peg$savedPos = s0;\n                s0 = peg$f6(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = [];\n                s2 = peg$parsewhitespace();\n                while (s2 !== peg$FAILED) {\n                  s1.push(s2);\n                  s2 = peg$parsewhitespace();\n                }\n                s2 = peg$parsealignment_tab();\n                if (s2 !== peg$FAILED) {\n                  s3 = [];\n                  s4 = peg$parsewhitespace();\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$parsewhitespace();\n                  }\n                  peg$savedPos = s0;\n                  s0 = peg$f7(s2);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsemacro_parameter();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = [];\n                    s2 = peg$parsewhitespace();\n                    while (s2 !== peg$FAILED) {\n                      s1.push(s2);\n                      s2 = peg$parsewhitespace();\n                    }\n                    s2 = peg$parsesuperscript();\n                    if (s2 !== peg$FAILED) {\n                      s3 = [];\n                      s4 = peg$parsewhitespace();\n                      while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parsewhitespace();\n                      }\n                      peg$savedPos = s0;\n                      s0 = peg$f8();\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      s1 = [];\n                      s2 = peg$parsewhitespace();\n                      while (s2 !== peg$FAILED) {\n                        s1.push(s2);\n                        s2 = peg$parsewhitespace();\n                      }\n                      s2 = peg$parsesubscript();\n                      if (s2 !== peg$FAILED) {\n                        s3 = [];\n                        s4 = peg$parsewhitespace();\n                        while (s4 !== peg$FAILED) {\n                          s3.push(s4);\n                          s4 = peg$parsewhitespace();\n                        }\n                        peg$savedPos = s0;\n                        s0 = peg$f9();\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsewhitespace();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$currPos;\n                            if (input.length > peg$currPos) {\n                              s1 = input.charAt(peg$currPos);\n                              peg$currPos++;\n                            } else {\n                              s1 = peg$FAILED;\n                              if (peg$silentFails === 0) {\n                                peg$fail(peg$e3);\n                              }\n                            }\n                            if (s1 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$f10(s1);\n                            }\n                            s0 = s1;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        return s0;\n      }\n      function peg$parsenonchar_token() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parseescape();\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 37) {\n            s0 = peg$c0;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e7);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsebegin_group();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseend_group();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsemath_shift();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsealignment_tab();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsenl();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsemacro_parameter();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseignore();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsesp();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsepunctuation();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseEOF();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        return s0;\n      }\n      function peg$parsewhitespace() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parsenl();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsesp();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsesp();\n          }\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = [];\n          s3 = peg$parsesp();\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsesp();\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsenl();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parsecomment_start();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$parsesp();\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parsesp();\n                }\n                s6 = peg$currPos;\n                peg$silentFails++;\n                s7 = peg$parsenl();\n                peg$silentFails--;\n                if (s7 === peg$FAILED) {\n                  s6 = void 0;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  s2 = [s2, s3, s4, s5, s6];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = [];\n            s2 = peg$parsesp();\n            if (s2 !== peg$FAILED) {\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$parsesp();\n              }\n            } else {\n              s1 = peg$FAILED;\n            }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f11();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        return s0;\n      }\n      function peg$parsenumber() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsenum();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenum();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c1;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e10);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsenum();\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parsenum();\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s1 = peg$f12(s2, s4);\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s2 = peg$c1;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e10);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parsenum();\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsenum();\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s1 = peg$f13(s3);\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = [];\n            s3 = peg$parsenum();\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsenum();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s3 = peg$c1;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e10);\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s1 = peg$f14(s2);\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f15(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        return s0;\n      }\n      function peg$parsespecial_macro() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c2) {\n            s2 = peg$c2;\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e12);\n            }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4) === peg$c3) {\n              s2 = peg$c3;\n              peg$currPos += 4;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e13);\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$currPos;\n              if (input.length > peg$currPos) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s8 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s9 = peg$f16(s2, s3, s8);\n                if (s9) {\n                  s9 = void 0;\n                } else {\n                  s9 = peg$FAILED;\n                }\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e3);\n                  }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s5 = peg$f17(s2, s3, s7);\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$currPos;\n                s6 = peg$currPos;\n                peg$silentFails++;\n                s7 = peg$currPos;\n                if (input.length > peg$currPos) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e3);\n                  }\n                }\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s9 = peg$f16(s2, s3, s8);\n                  if (s9) {\n                    s9 = void 0;\n                  } else {\n                    s9 = peg$FAILED;\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s8 = [s8, s9];\n                    s7 = s8;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s7 === peg$FAILED) {\n                  s6 = void 0;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s7 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e3);\n                    }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s5;\n                    s5 = peg$f17(s2, s3, s7);\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              }\n              s5 = peg$currPos;\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s7 = peg$f18(s2, s3, s4, s6);\n                if (s7) {\n                  s7 = void 0;\n                } else {\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f19(s2, s3, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseverbatim_listings();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseverbatim_minted();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseverbatim_minted_environment();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseverbatim_environment();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = peg$parsebegin_display_math();\n                  if (s1 !== peg$FAILED) {\n                    s2 = [];\n                    s3 = peg$currPos;\n                    s4 = peg$currPos;\n                    peg$silentFails++;\n                    s5 = peg$parseend_display_math();\n                    peg$silentFails--;\n                    if (s5 === peg$FAILED) {\n                      s4 = void 0;\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parsemath_token();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s3 = peg$f20(s5);\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                    while (s3 !== peg$FAILED) {\n                      s2.push(s3);\n                      s3 = peg$currPos;\n                      s4 = peg$currPos;\n                      peg$silentFails++;\n                      s5 = peg$parseend_display_math();\n                      peg$silentFails--;\n                      if (s5 === peg$FAILED) {\n                        s4 = void 0;\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                      if (s4 !== peg$FAILED) {\n                        s5 = peg$parsemath_token();\n                        if (s5 !== peg$FAILED) {\n                          peg$savedPos = s3;\n                          s3 = peg$f20(s5);\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    }\n                    s3 = peg$parseend_display_math();\n                    if (s3 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f21(s2);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = peg$parsebegin_inline_math();\n                    if (s1 !== peg$FAILED) {\n                      s2 = [];\n                      s3 = peg$currPos;\n                      s4 = peg$currPos;\n                      peg$silentFails++;\n                      s5 = peg$parseend_inline_math();\n                      peg$silentFails--;\n                      if (s5 === peg$FAILED) {\n                        s4 = void 0;\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                      if (s4 !== peg$FAILED) {\n                        s5 = peg$parsemath_token();\n                        if (s5 !== peg$FAILED) {\n                          peg$savedPos = s3;\n                          s3 = peg$f22(s5);\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                      while (s3 !== peg$FAILED) {\n                        s2.push(s3);\n                        s3 = peg$currPos;\n                        s4 = peg$currPos;\n                        peg$silentFails++;\n                        s5 = peg$parseend_inline_math();\n                        peg$silentFails--;\n                        if (s5 === peg$FAILED) {\n                          s4 = void 0;\n                        } else {\n                          peg$currPos = s4;\n                          s4 = peg$FAILED;\n                        }\n                        if (s4 !== peg$FAILED) {\n                          s5 = peg$parsemath_token();\n                          if (s5 !== peg$FAILED) {\n                            peg$savedPos = s3;\n                            s3 = peg$f22(s5);\n                          } else {\n                            peg$currPos = s3;\n                            s3 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      }\n                      s3 = peg$parseend_inline_math();\n                      if (s3 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f23(s2);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      s1 = peg$parsemath_shift();\n                      if (s1 !== peg$FAILED) {\n                        s2 = peg$parsemath_shift();\n                        if (s2 !== peg$FAILED) {\n                          s3 = [];\n                          s4 = peg$currPos;\n                          s5 = peg$currPos;\n                          peg$silentFails++;\n                          s6 = peg$currPos;\n                          s7 = peg$parsemath_shift();\n                          if (s7 !== peg$FAILED) {\n                            s8 = peg$parsemath_shift();\n                            if (s8 !== peg$FAILED) {\n                              s7 = [s7, s8];\n                              s6 = s7;\n                            } else {\n                              peg$currPos = s6;\n                              s6 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s6;\n                            s6 = peg$FAILED;\n                          }\n                          peg$silentFails--;\n                          if (s6 === peg$FAILED) {\n                            s5 = void 0;\n                          } else {\n                            peg$currPos = s5;\n                            s5 = peg$FAILED;\n                          }\n                          if (s5 !== peg$FAILED) {\n                            s6 = peg$parsemath_token();\n                            if (s6 !== peg$FAILED) {\n                              peg$savedPos = s4;\n                              s4 = peg$f24(s6);\n                            } else {\n                              peg$currPos = s4;\n                              s4 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s4;\n                            s4 = peg$FAILED;\n                          }\n                          while (s4 !== peg$FAILED) {\n                            s3.push(s4);\n                            s4 = peg$currPos;\n                            s5 = peg$currPos;\n                            peg$silentFails++;\n                            s6 = peg$currPos;\n                            s7 = peg$parsemath_shift();\n                            if (s7 !== peg$FAILED) {\n                              s8 = peg$parsemath_shift();\n                              if (s8 !== peg$FAILED) {\n                                s7 = [s7, s8];\n                                s6 = s7;\n                              } else {\n                                peg$currPos = s6;\n                                s6 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s6;\n                              s6 = peg$FAILED;\n                            }\n                            peg$silentFails--;\n                            if (s6 === peg$FAILED) {\n                              s5 = void 0;\n                            } else {\n                              peg$currPos = s5;\n                              s5 = peg$FAILED;\n                            }\n                            if (s5 !== peg$FAILED) {\n                              s6 = peg$parsemath_token();\n                              if (s6 !== peg$FAILED) {\n                                peg$savedPos = s4;\n                                s4 = peg$f24(s6);\n                              } else {\n                                peg$currPos = s4;\n                                s4 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s4;\n                              s4 = peg$FAILED;\n                            }\n                          }\n                          s4 = peg$parsemath_shift();\n                          if (s4 !== peg$FAILED) {\n                            s5 = peg$parsemath_shift();\n                            if (s5 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s0 = peg$f25(s3);\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsemath_environment();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseenvironment();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        return s0;\n      }\n      function peg$parsesquare_bracket_argument() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c4;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$currPos;\n          s6 = peg$parsetoken();\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s7 = peg$f26(s6);\n            if (s7) {\n              s7 = void 0;\n            } else {\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetoken();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f27(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$currPos;\n            s6 = peg$parsetoken();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s7 = peg$f26(s6);\n              if (s7) {\n                s7 = void 0;\n              } else {\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetoken();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f27(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c5;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e15);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f28(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseverbatim_group() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_group();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseend_group();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f29(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseend_group();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f29(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$parseend_group();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f30(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseverbatim_delimited_by_char() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$currPos;\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e3);\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s7 = peg$f31(s1, s6);\n            if (s7) {\n              s7 = void 0;\n            } else {\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f32(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$currPos;\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = peg$currPos;\n              s7 = peg$f31(s1, s6);\n              if (s7) {\n                s7 = void 0;\n              } else {\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f32(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$currPos;\n          if (input.length > peg$currPos) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e3);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s5 = peg$f33(s1, s2, s4);\n            if (s5) {\n              s5 = void 0;\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f34(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseverbatim_listings() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 9) === peg$c6) {\n            s2 = peg$c6;\n            peg$currPos += 9;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e18);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsesquare_bracket_argument();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            s4 = peg$parseverbatim_group();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseverbatim_delimited_by_char();\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f35(s2, s3, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e17);\n          }\n        }\n        return s0;\n      }\n      function peg$parseverbatim_minted() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 10) === peg$c7) {\n            s2 = peg$c7;\n            peg$currPos += 10;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4) === peg$c8) {\n              s2 = peg$c8;\n              peg$currPos += 4;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e21);\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsesquare_bracket_argument();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            s4 = peg$parsegroup();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseverbatim_group();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseverbatim_delimited_by_char();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f36(s2, s3, s4, s5);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        return s0;\n      }\n      function peg$parseverbatim_minted_environment() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_env();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebegin_group();\n          if (s2 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c9) {\n              s3 = peg$c9;\n              peg$currPos += 6;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e23);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseend_group();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesquare_bracket_argument();\n                if (s5 === peg$FAILED) {\n                  s5 = null;\n                }\n                s6 = peg$parsegroup();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$currPos;\n                  peg$silentFails++;\n                  s11 = peg$currPos;\n                  s12 = peg$parseend_env();\n                  if (s12 !== peg$FAILED) {\n                    s13 = peg$parsegroup();\n                    if (s13 !== peg$FAILED) {\n                      peg$savedPos = peg$currPos;\n                      s14 = peg$f37(s3, s5, s6, s13);\n                      if (s14) {\n                        s14 = void 0;\n                      } else {\n                        s14 = peg$FAILED;\n                      }\n                      if (s14 !== peg$FAILED) {\n                        s12 = [s12, s13, s14];\n                        s11 = s12;\n                      } else {\n                        peg$currPos = s11;\n                        s11 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s11;\n                      s11 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s11;\n                    s11 = peg$FAILED;\n                  }\n                  peg$silentFails--;\n                  if (s11 === peg$FAILED) {\n                    s10 = void 0;\n                  } else {\n                    peg$currPos = s10;\n                    s10 = peg$FAILED;\n                  }\n                  if (s10 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s11 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s11 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e3);\n                      }\n                    }\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$currPos;\n                    peg$silentFails++;\n                    s11 = peg$currPos;\n                    s12 = peg$parseend_env();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$parsegroup();\n                      if (s13 !== peg$FAILED) {\n                        peg$savedPos = peg$currPos;\n                        s14 = peg$f37(s3, s5, s6, s13);\n                        if (s14) {\n                          s14 = void 0;\n                        } else {\n                          s14 = peg$FAILED;\n                        }\n                        if (s14 !== peg$FAILED) {\n                          s12 = [s12, s13, s14];\n                          s11 = s12;\n                        } else {\n                          peg$currPos = s11;\n                          s11 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s11;\n                        s11 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s11;\n                      s11 = peg$FAILED;\n                    }\n                    peg$silentFails--;\n                    if (s11 === peg$FAILED) {\n                      s10 = void 0;\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      if (input.length > peg$currPos) {\n                        s11 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s11 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e3);\n                        }\n                      }\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  s7 = input.substring(s7, peg$currPos);\n                  s8 = peg$parseend_env();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsebegin_group();\n                    if (s9 !== peg$FAILED) {\n                      if (input.substr(peg$currPos, 6) === peg$c9) {\n                        s10 = peg$c9;\n                        peg$currPos += 6;\n                      } else {\n                        s10 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e23);\n                        }\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parseend_group();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s0 = peg$f38(s3, s5, s6, s7);\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e22);\n          }\n        }\n        return s0;\n      }\n      function peg$parseverbatim_environment() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_env();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebegin_group();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseverbatim_env_name();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseend_group();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$currPos;\n                s6 = [];\n                s7 = peg$currPos;\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$currPos;\n                s10 = peg$parseend_env();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsegroup();\n                  if (s11 !== peg$FAILED) {\n                    peg$savedPos = peg$currPos;\n                    s12 = peg$f39(s3, s11);\n                    if (s12) {\n                      s12 = void 0;\n                    } else {\n                      s12 = peg$FAILED;\n                    }\n                    if (s12 !== peg$FAILED) {\n                      s10 = [s10, s11, s12];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = void 0;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s9 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e3);\n                    }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    peg$savedPos = s7;\n                    s7 = peg$f40(s3, s9);\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$currPos;\n                  s8 = peg$currPos;\n                  peg$silentFails++;\n                  s9 = peg$currPos;\n                  s10 = peg$parseend_env();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsegroup();\n                    if (s11 !== peg$FAILED) {\n                      peg$savedPos = peg$currPos;\n                      s12 = peg$f39(s3, s11);\n                      if (s12) {\n                        s12 = void 0;\n                      } else {\n                        s12 = peg$FAILED;\n                      }\n                      if (s12 !== peg$FAILED) {\n                        s10 = [s10, s11, s12];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  peg$silentFails--;\n                  if (s9 === peg$FAILED) {\n                    s8 = void 0;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s9 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e3);\n                      }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s7;\n                      s7 = peg$f40(s3, s9);\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                }\n                s5 = input.substring(s5, peg$currPos);\n                s6 = peg$parseend_env();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsebegin_group();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parseverbatim_env_name();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parseend_group();\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f41(s3, s5);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e24);\n          }\n        }\n        return s0;\n      }\n      function peg$parseverbatim_env_name() {\n        var s0;\n        if (input.substr(peg$currPos, 9) === peg$c10) {\n          s0 = peg$c10;\n          peg$currPos += 9;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e25);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c11) {\n            s0 = peg$c11;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e26);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 13) === peg$c12) {\n              s0 = peg$c12;\n              peg$currPos += 13;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e27);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 12) === peg$c13) {\n                s0 = peg$c13;\n                peg$currPos += 12;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e28);\n                }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c14) {\n                  s0 = peg$c14;\n                  peg$currPos += 7;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e29);\n                  }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 10) === peg$c15) {\n                    s0 = peg$c15;\n                    peg$currPos += 10;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e30);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsemacro() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseescape();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsechar();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsechar();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f42(s3);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parseescape();\n          if (s2 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s1 = peg$f43(s3);\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f44(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e31);\n          }\n        }\n        return s0;\n      }\n      function peg$parsegroup() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_group();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseend_group();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetoken();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f45(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseend_group();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetoken();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f45(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$parseend_group();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f46(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e32);\n          }\n        }\n        return s0;\n      }\n      function peg$parsegroup_contents_as_string() {\n        var s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parsegroup();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f47(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseenvironment() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_env();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsegroup_contents_as_string();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsesameline_comment();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            s8 = peg$parseend_env();\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parsegroup_contents_as_string();\n              if (s9 !== peg$FAILED) {\n                peg$savedPos = peg$currPos;\n                s10 = peg$f48(s2, s3, s9);\n                if (s10) {\n                  s10 = void 0;\n                } else {\n                  s10 = peg$FAILED;\n                }\n                if (s10 !== peg$FAILED) {\n                  s8 = [s8, s9, s10];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsetoken();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s5 = peg$f49(s2, s3, s7);\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$currPos;\n              s8 = peg$parseend_env();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsegroup_contents_as_string();\n                if (s9 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s10 = peg$f48(s2, s3, s9);\n                  if (s10) {\n                    s10 = void 0;\n                  } else {\n                    s10 = peg$FAILED;\n                  }\n                  if (s10 !== peg$FAILED) {\n                    s8 = [s8, s9, s10];\n                    s7 = s8;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsetoken();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s5 = peg$f49(s2, s3, s7);\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            s5 = peg$parseend_env();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsegroup_contents_as_string();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f50(s2, s3, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e33);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemath_environment() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_env();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebegin_group();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsemath_env_name();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseend_group();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesameline_comment();\n                if (s5 === peg$FAILED) {\n                  s5 = null;\n                }\n                s6 = [];\n                s7 = peg$currPos;\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$currPos;\n                s10 = peg$parseend_env();\n                if (s10 !== peg$FAILED) {\n                  s11 = peg$parsegroup();\n                  if (s11 !== peg$FAILED) {\n                    peg$savedPos = peg$currPos;\n                    s12 = peg$f51(s3, s5, s11);\n                    if (s12) {\n                      s12 = void 0;\n                    } else {\n                      s12 = peg$FAILED;\n                    }\n                    if (s12 !== peg$FAILED) {\n                      s10 = [s10, s11, s12];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s9;\n                  s9 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = void 0;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsemath_token();\n                  if (s9 !== peg$FAILED) {\n                    peg$savedPos = s7;\n                    s7 = peg$f52(s3, s5, s9);\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$currPos;\n                  s8 = peg$currPos;\n                  peg$silentFails++;\n                  s9 = peg$currPos;\n                  s10 = peg$parseend_env();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsegroup();\n                    if (s11 !== peg$FAILED) {\n                      peg$savedPos = peg$currPos;\n                      s12 = peg$f51(s3, s5, s11);\n                      if (s12) {\n                        s12 = void 0;\n                      } else {\n                        s12 = peg$FAILED;\n                      }\n                      if (s12 !== peg$FAILED) {\n                        s10 = [s10, s11, s12];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  peg$silentFails--;\n                  if (s9 === peg$FAILED) {\n                    s8 = void 0;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsemath_token();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s7;\n                      s7 = peg$f52(s3, s5, s9);\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                }\n                s7 = peg$parseend_env();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsebegin_group();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsemath_env_name();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseend_group();\n                      if (s10 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f53(s3, s5, s6);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e34);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemath_group() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsebegin_group();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseend_group();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemath_token();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f54(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseend_group();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemath_token();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f54(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$parseend_group();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f55(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e35);\n          }\n        }\n        return s0;\n      }\n      function peg$parsebegin_display_math() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s2 = peg$c4;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e14);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseend_display_math() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s2 = peg$c5;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e15);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsebegin_inline_math() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s2 = peg$c16;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e36);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseend_inline_math() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s2 = peg$c17;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e37);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsebegin_env() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c18) {\n            s2 = peg$c18;\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e38);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseend_env() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseescape();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c19) {\n            s2 = peg$c19;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e39);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemath_env_name() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 9) === peg$c20) {\n          s1 = peg$c20;\n          peg$currPos += 9;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e40);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c21) {\n            s1 = peg$c21;\n            peg$currPos += 8;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e41);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c22) {\n              s1 = peg$c22;\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e42);\n              }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c23) {\n                s1 = peg$c23;\n                peg$currPos += 5;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e43);\n                }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c24) {\n                  s1 = peg$c24;\n                  peg$currPos += 8;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e44);\n                  }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 7) === peg$c25) {\n                    s1 = peg$c25;\n                    peg$currPos += 7;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e45);\n                    }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7) === peg$c26) {\n                      s1 = peg$c26;\n                      peg$currPos += 7;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e46);\n                      }\n                    }\n                    if (s1 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 6) === peg$c27) {\n                        s1 = peg$c27;\n                        peg$currPos += 6;\n                      } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e47);\n                        }\n                      }\n                      if (s1 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9) === peg$c28) {\n                          s1 = peg$c28;\n                          peg$currPos += 9;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$e48);\n                          }\n                        }\n                        if (s1 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c29) {\n                            s1 = peg$c29;\n                            peg$currPos += 8;\n                          } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                              peg$fail(peg$e49);\n                            }\n                          }\n                          if (s1 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 8) === peg$c30) {\n                              s1 = peg$c30;\n                              peg$currPos += 8;\n                            } else {\n                              s1 = peg$FAILED;\n                              if (peg$silentFails === 0) {\n                                peg$fail(peg$e50);\n                              }\n                            }\n                            if (s1 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 7) === peg$c31) {\n                                s1 = peg$c31;\n                                peg$currPos += 7;\n                              } else {\n                                s1 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                  peg$fail(peg$e51);\n                                }\n                              }\n                              if (s1 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 5) === peg$c32) {\n                                  s1 = peg$c32;\n                                  peg$currPos += 5;\n                                } else {\n                                  s1 = peg$FAILED;\n                                  if (peg$silentFails === 0) {\n                                    peg$fail(peg$e52);\n                                  }\n                                }\n                                if (s1 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 4) === peg$c33) {\n                                    s1 = peg$c33;\n                                    peg$currPos += 4;\n                                  } else {\n                                    s1 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                      peg$fail(peg$e53);\n                                    }\n                                  }\n                                  if (s1 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 11) === peg$c34) {\n                                      s1 = peg$c34;\n                                      peg$currPos += 11;\n                                    } else {\n                                      s1 = peg$FAILED;\n                                      if (peg$silentFails === 0) {\n                                        peg$fail(peg$e54);\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f56(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseescape() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c35;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e56);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f57();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e55);\n          }\n        }\n        return s0;\n      }\n      function peg$parsebegin_group() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c36;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e57);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f58(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseend_group() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s1 = peg$c37;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e58);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f59(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsemath_shift() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 36) {\n          s1 = peg$c38;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e59);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f60(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsealignment_tab() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 38) {\n          s1 = peg$c39;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e60);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f61(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsenl() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e62);\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 10) {\n            s2 = peg$c41;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e63);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c40;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e62);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c42) {\n              s0 = peg$c42;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e64);\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e61);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemacro_parameter() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s1 = peg$c43;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e65);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f62(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsesuperscript() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 94) {\n          s1 = peg$c44;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e66);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f63(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsesubscript() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 95) {\n          s1 = peg$c45;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e67);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f64(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseignore() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 0) {\n          s0 = peg$c46;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e68);\n          }\n        }\n        return s0;\n      }\n      function peg$parsesp() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e69);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e69);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f65();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        return s0;\n      }\n      function peg$parsechar() {\n        var s0, s1;\n        peg$silentFails++;\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e71);\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e70);\n          }\n        }\n        return s0;\n      }\n      function peg$parsenum() {\n        var s0, s1;\n        peg$silentFails++;\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e73);\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e72);\n          }\n        }\n        return s0;\n      }\n      function peg$parsepunctuation() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (peg$r4.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e75);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f66(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e74);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecomment_start() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 37) {\n          s0 = peg$c0;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        return s0;\n      }\n      function peg$parsefull_comment() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parseownline_comment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsesameline_comment();\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e76);\n          }\n        }\n        return s0;\n      }\n      function peg$parseownline_comment() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsesp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsesp();\n        }\n        s3 = peg$parsenl();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parseleading_sp();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsecomment();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f67(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesameline_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsesp();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsesp();\n        }\n        s2 = peg$parsecomment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f68(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecomment() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsecomment_start();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsenl();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e3);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f69(s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsenl();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f69(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseparbreak();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = void 0;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f70(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecomment_start();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsenl();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = void 0;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e3);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f71(s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parsenl();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e3);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f71(s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            s3 = peg$currPos;\n            s4 = peg$parsenl();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsesp();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsesp();\n              }\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parsecomment_start();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsenl();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parseEOF();\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f72(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e77);\n          }\n        }\n        return s0;\n      }\n      function peg$parseleading_sp() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parsestart_of_line();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsesp();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsesp();\n          }\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsestart_of_line() {\n        var s0;\n        peg$savedPos = peg$currPos;\n        s0 = peg$f73();\n        if (s0) {\n          s0 = void 0;\n        } else {\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOF() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function toString(e) {\n        if (typeof e === \"string\") {\n          return e;\n        }\n        if (typeof e.content === \"string\") {\n          return e.content;\n        }\n        if (e && e.type === \"whitespace\") {\n          return \" \";\n        }\n        return e;\n      }\n      function compare_env(g1, g2) {\n        const g1Name = typeof g1 === \"string\" ? g1 : g1.content.map(toString).join(\"\");\n        const g2Name = typeof g2 === \"string\" ? g2 : g2.content.map(toString).join(\"\");\n        return g1Name === g2Name;\n      }\n      function createNode(type, extra = {}) {\n        return { type, ...extra, position: location() };\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$anyExpectation();\n      var peg$f0 = function() {\n        return [];\n      };\n      var peg$f1 = function(x) {\n        return { cells: [], colSeps: [], ...x };\n      };\n      var peg$f2 = function(rowItems, rowSep, trailingComment) {\n        return { ...rowItems, rowSep, trailingComment };\n      };\n      var peg$f3 = function(rowItems, trailingComment) {\n        return { ...rowItems, rowSep: null, trailingComment };\n      };\n      var peg$f4 = function(x) {\n        return x;\n      };\n      var peg$f5 = function(x) {\n        return {\n          cells: [],\n          colSeps: [],\n          rowSep: null,\n          trailingComment: x\n        };\n      };\n      var peg$f6 = function(x) {\n        return x;\n      };\n      var peg$f7 = function(colSep, cell) {\n        return { colSep, cell };\n      };\n      var peg$f8 = function(colSep) {\n        return { colSep };\n      };\n      var peg$f9 = function(a, b) {\n        return processRow(a, b);\n      };\n      var peg$f10 = function(b) {\n        return processRow(null, b);\n      };\n      var peg$f11 = function(tok) {\n        return options.isSameLineComment(tok);\n      };\n      var peg$f12 = function(tok) {\n        return tok;\n      };\n      var peg$f13 = function(tok) {\n        return options.isOwnLineComment(tok);\n      };\n      var peg$f14 = function(tok) {\n        return tok;\n      };\n      var peg$f15 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$f16 = function(tok) {\n        return tok;\n      };\n      var peg$f17 = function(tok) {\n        return options.isRowSep(tok);\n      };\n      var peg$f18 = function(tok) {\n        return tok;\n      };\n      var peg$f19 = function(tok) {\n        return options.isColSep(tok);\n      };\n      var peg$f20 = function(tok) {\n        return tok;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1;\n        s0 = [];\n        s1 = peg$parsecomment_only_line();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parserow_with_end();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parserow_without_end();\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            s1 = peg$parsecomment_only_line();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parserow_with_end();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parserow_without_end();\n              }\n            }\n          }\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOL();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f0();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parserow_with_end() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parserow_items();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s1;\n        s2 = peg$f1(s2);\n        s1 = s2;\n        s2 = peg$parserow_sep();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetrailing_comment();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f2(s1, s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parserow_without_end() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parserow_items();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsetrailing_comment();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsetrailing_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n        }\n        s2 = peg$parsesame_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f4(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecomment_only_line() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n        }\n        s2 = peg$parseown_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f5(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsetoken() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$parserow_sep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsecol_sep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsetrailing_comment();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseown_line_comment();\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecell() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsetoken();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsetoken();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parseseparated_cell() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsecol_sep();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsecell();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecol_sep();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f8(s1);\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parserow_items() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsecell();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseseparated_cell();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseseparated_cell();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f9(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parseseparated_cell();\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parseseparated_cell();\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f10(s1);\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsesame_line_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f11(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f12(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseown_line_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f13(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f14(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsewhitespace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f15(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f16(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parserow_sep() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f17(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f18(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecol_sep() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f19(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f20(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function processRow(leadCell, otherCells) {\n        const cells = [leadCell || []];\n        const seps = [];\n        for (const x of otherCells) {\n          cells.push(x.cell || []);\n          seps.push(x.colSep);\n        }\n        return { cells, colSeps: seps };\n      }\n      if (!options.isWhitespace) {\n        try {\n          Object.assign(\n            options,\n            createMatchers([\"\\\\\", \"hline\", \"cr\"], [\"&\"])\n          );\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };\n      var peg$startRuleFunction = peg$parseargs_spec_list;\n      var peg$c0 = \"+\";\n      var peg$c1 = \"v\";\n      var peg$c2 = \"b\";\n      var peg$c3 = \"!\";\n      var peg$c4 = \"D\";\n      var peg$c5 = \"d\";\n      var peg$c6 = \"s\";\n      var peg$c7 = \"O\";\n      var peg$c8 = \"o\";\n      var peg$c9 = \"e\";\n      var peg$c10 = \"E\";\n      var peg$c11 = \"t\";\n      var peg$c12 = \"R\";\n      var peg$c13 = \"r\";\n      var peg$c14 = \"u\";\n      var peg$c15 = \"m\";\n      var peg$c16 = \"{\";\n      var peg$c17 = \"}\";\n      var peg$c18 = \" \";\n      var peg$c19 = \"\\n\";\n      var peg$c20 = \"\\r\";\n      var peg$c21 = \"\\\\\";\n      var peg$r0 = /^[{ ]/;\n      var peg$r1 = /^[a-zA-Z]/;\n      var peg$r2 = /^[{}]/;\n      var peg$e0 = peg$literalExpectation(\"+\", false);\n      var peg$e1 = peg$literalExpectation(\"v\", false);\n      var peg$e2 = peg$anyExpectation();\n      var peg$e3 = peg$literalExpectation(\"b\", false);\n      var peg$e4 = peg$literalExpectation(\"!\", false);\n      var peg$e5 = peg$literalExpectation(\"D\", false);\n      var peg$e6 = peg$literalExpectation(\"d\", false);\n      var peg$e7 = peg$literalExpectation(\"s\", false);\n      var peg$e8 = peg$literalExpectation(\"O\", false);\n      var peg$e9 = peg$literalExpectation(\"o\", false);\n      var peg$e10 = peg$literalExpectation(\"e\", false);\n      var peg$e11 = peg$literalExpectation(\"E\", false);\n      var peg$e12 = peg$literalExpectation(\"t\", false);\n      var peg$e13 = peg$literalExpectation(\"R\", false);\n      var peg$e14 = peg$literalExpectation(\"r\", false);\n      var peg$e15 = peg$literalExpectation(\"u\", false);\n      var peg$e16 = peg$classExpectation([\"{\", \" \"], false, false);\n      var peg$e17 = peg$literalExpectation(\"m\", false);\n      var peg$e18 = peg$literalExpectation(\"{\", false);\n      var peg$e19 = peg$literalExpectation(\"}\", false);\n      var peg$e20 = peg$literalExpectation(\" \", false);\n      var peg$e21 = peg$literalExpectation(\"\\n\", false);\n      var peg$e22 = peg$literalExpectation(\"\\r\", false);\n      var peg$e23 = peg$literalExpectation(\"\\\\\", false);\n      var peg$e24 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n      var peg$e25 = peg$classExpectation([\"{\", \"}\"], false, false);\n      var peg$f0 = function(x) {\n        return x;\n      };\n      var peg$f1 = function(spec) {\n        return spec;\n      };\n      var peg$f2 = function(spec) {\n        return spec;\n      };\n      var peg$f3 = function(openBrace) {\n        return createNode(\"verbatim\", { openBrace, closeBrace: openBrace });\n      };\n      var peg$f4 = function() {\n        return createNode(\"body\");\n      };\n      var peg$f5 = function(leading_bang, spec) {\n        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;\n      };\n      var peg$f6 = function(braceSpec, defaultArg) {\n        return createNode(\"optional\", { ...braceSpec, defaultArg });\n      };\n      var peg$f7 = function(braceSpec) {\n        return createNode(\"optional\", braceSpec);\n      };\n      var peg$f8 = function() {\n        return createNode(\"optionalStar\");\n      };\n      var peg$f9 = function(g) {\n        return createNode(\"optional\", { defaultArg: g });\n      };\n      var peg$f10 = function() {\n        return createNode(\"optional\");\n      };\n      var peg$f11 = function(args) {\n        return createNode(\"embellishment\", {\n          embellishmentTokens: args\n        });\n      };\n      var peg$f12 = function(args, g) {\n        return createNode(\"embellishment\", {\n          embellishmentTokens: args,\n          defaultArg: g\n        });\n      };\n      var peg$f13 = function(tok) {\n        return createNode(\"optionalToken\", { token: tok });\n      };\n      var peg$f14 = function(braceSpec, defaultArg) {\n        return createNode(\"mandatory\", { ...braceSpec, defaultArg });\n      };\n      var peg$f15 = function(braceSpec) {\n        return createNode(\"mandatory\", braceSpec);\n      };\n      var peg$f16 = function(stopTokens) {\n        return createNode(\"until\", { stopTokens });\n      };\n      var peg$f17 = function(x) {\n        return [x];\n      };\n      var peg$f18 = function(g) {\n        return g.content;\n      };\n      var peg$f19 = function() {\n        return createNode(\"mandatory\");\n      };\n      var peg$f20 = function(openBrace, closeBrace) {\n        return { openBrace, closeBrace };\n      };\n      var peg$f21 = function(g) {\n        return g.content.map(groupToStr).join(\"\");\n      };\n      var peg$f22 = function(t) {\n        return [t];\n      };\n      var peg$f23 = function(args) {\n        return args.filter((a) => !a.match(/^\\s*$/));\n      };\n      var peg$f24 = function(content) {\n        return { type: \"group\", content };\n      };\n      var peg$f25 = function() {\n        return \"\";\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parseargs_spec_list() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$currPos;\n        s3 = peg$parsewhitespace();\n        s4 = peg$parsearg_spec();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s2 = peg$f0(s4);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parsewhitespace();\n          s4 = peg$parsearg_spec();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s2 = peg$f0(s4);\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n        s2 = peg$parsewhitespace();\n        peg$savedPos = s0;\n        s0 = peg$f1(s1);\n        return s0;\n      }\n      function peg$parsearg_spec() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s1 = peg$c0;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parseoptional();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsemandatory();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseverbatim();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parserequired();\n              if (s2 === peg$FAILED) {\n                s2 = peg$parsebody();\n                if (s2 === peg$FAILED) {\n                  s2 = peg$parseuntil();\n                }\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseverbatim() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 118) {\n          s1 = peg$c1;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsebody() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 98) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f4();\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseoptional() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s1 = peg$c3;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parseoptional_star();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoptional_standard();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoptional_delimited();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseoptional_embellishment();\n              if (s2 === peg$FAILED) {\n                s2 = peg$parseoptional_token();\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseoptional_delimited() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 68) {\n          s1 = peg$c4;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebrace_spec();\n          s3 = peg$parsearg();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 100) {\n            s1 = peg$c5;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e6);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsebrace_spec();\n            peg$savedPos = s0;\n            s0 = peg$f7(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseoptional_star() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 115) {\n          s1 = peg$c6;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f8();\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseoptional_standard() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 79) {\n          s1 = peg$c7;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsewhitespace();\n          s3 = peg$parsearg();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f9(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 111) {\n            s1 = peg$c8;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e9);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f10();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parseoptional_embellishment() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 101) {\n          s1 = peg$c9;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsewhitespace();\n          s3 = peg$parseargs();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 69) {\n            s1 = peg$c10;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e11);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsewhitespace();\n            s3 = peg$parseargs();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsewhitespace();\n              s5 = peg$parseargs();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f12(s3, s5);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseoptional_token() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 116) {\n          s1 = peg$c11;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f13(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parserequired() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 82) {\n          s1 = peg$c12;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e13);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsebrace_spec();\n          s3 = peg$parsearg();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f14(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 114) {\n            s1 = peg$c13;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e14);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsebrace_spec();\n            peg$savedPos = s0;\n            s0 = peg$f15(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseuntil() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 117) {\n          s1 = peg$c14;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e15);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseuntil_stop_token();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f16(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseuntil_stop_token() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsebraced_group();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f18(s1);\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsemandatory() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 109) {\n          s1 = peg$c15;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e17);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f19();\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsebrace_spec() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsewhitespace_token();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = void 0;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsemacro();\n          if (s4 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s1 = input.substring(s1, peg$currPos);\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parsewhitespace_token();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemacro();\n          if (s5 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s2 = input.substring(s2, peg$currPos);\n        peg$savedPos = s0;\n        s0 = peg$f20(s1, s2);\n        return s0;\n      }\n      function peg$parsearg() {\n        var s0, s1;\n        s0 = peg$parsetoken();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsebraced_group();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f21(s1);\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parseargs() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsetoken();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f22(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c16;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e18);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsearg();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsewhitespace_token();\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsearg();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsewhitespace_token();\n              }\n            }\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s3 = peg$c17;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e19);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f23(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parsebraced_group() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c16;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e18);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s6 = peg$c17;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e19);\n            }\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsebraced_group();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsetoken();\n              if (s7 === peg$FAILED) {\n                s7 = peg$parsewhitespace_token();\n              }\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsebraced_group();\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s6 = peg$c17;\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e19);\n              }\n            }\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parsebraced_group();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsetoken();\n                if (s7 === peg$FAILED) {\n                  s7 = peg$parsewhitespace_token();\n                }\n                if (s7 !== peg$FAILED) {\n                  s5 = [s5, s6, s7];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = input.substring(s3, peg$currPos);\n            } else {\n              s3 = s4;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsebraced_group();\n            }\n          }\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s3 = peg$c17;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e19);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f24(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsewhitespace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace_token();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace_token();\n        }\n        peg$savedPos = s0;\n        s1 = peg$f25();\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsewhitespace_token() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s0 = peg$c18;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 10) {\n            s0 = peg$c19;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e21);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 13) {\n              s0 = peg$c20;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e22);\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsemacro() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s2 = peg$c21;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e23);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e24);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$r1.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e24);\n                }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s2 = peg$c21;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e23);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            peg$silentFails++;\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e24);\n              }\n            }\n            peg$silentFails--;\n            if (s4 === peg$FAILED) {\n              s3 = void 0;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e2);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s2 = [s2, s3, s4];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s0 = input.substring(s0, peg$currPos);\n          } else {\n            s0 = s1;\n          }\n        }\n        return s0;\n      }\n      function peg$parsetoken() {\n        var s0, s1, s2, s3;\n        s0 = peg$parsemacro();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          peg$silentFails++;\n          if (peg$r2.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e25);\n            }\n          }\n          peg$silentFails--;\n          if (s2 === peg$FAILED) {\n            s1 = void 0;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            peg$silentFails++;\n            s3 = peg$parsewhitespace_token();\n            peg$silentFails--;\n            if (s3 === peg$FAILED) {\n              s2 = void 0;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e2);\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                s0 = s3;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      const DEFAULT_OPTIONS = {\n        optional: { openBrace: \"[\", closeBrace: \"]\" },\n        mandatory: { openBrace: \"{\", closeBrace: \"}\" }\n      };\n      function createNode(type, options2) {\n        const computedOptions = DEFAULT_OPTIONS[type] || {};\n        return { type, ...computedOptions, ...options2 };\n      }\n      function groupToStr(node) {\n        if (typeof node !== \"object\" || !node) {\n          return node;\n        }\n        if (node.type === \"group\") {\n          return `{${node.content.map(groupToStr).join(\"\")}}`;\n        }\n        return node;\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$anyExpectation();\n      var peg$f0 = function() {\n        return [];\n      };\n      var peg$f1 = function(rowItems, trailingComment) {\n        return {\n          itemParts: [],\n          ...rowItems,\n          trailingComment,\n          trailingComma: true\n        };\n      };\n      var peg$f2 = function(rowItems, trailingComment) {\n        return { ...rowItems, trailingComment };\n      };\n      var peg$f3 = function(a, b) {\n        return processItem(a, b);\n      };\n      var peg$f4 = function(b) {\n        return processItem(null, b);\n      };\n      var peg$f5 = function(cell) {\n        return { cell };\n      };\n      var peg$f6 = function() {\n        return {};\n      };\n      var peg$f7 = function(part) {\n        return part;\n      };\n      var peg$f8 = function(x) {\n        return x;\n      };\n      var peg$f9 = function(space, x) {\n        return {\n          trailingComment: x,\n          leadingParbreak: space.parbreak > 0\n        };\n      };\n      var peg$f10 = function(list) {\n        return {\n          whitespace: list.filter((x) => options.isWhitespace(x)).length,\n          parbreak: list.filter((x) => options.isParbreak(x)).length\n        };\n      };\n      var peg$f11 = function() {\n        return !options.allowParenGroups;\n      };\n      var peg$f12 = function(tok) {\n        return options.isSameLineComment(tok);\n      };\n      var peg$f13 = function(tok) {\n        return tok;\n      };\n      var peg$f14 = function(tok) {\n        return options.isOwnLineComment(tok);\n      };\n      var peg$f15 = function(tok) {\n        return tok;\n      };\n      var peg$f16 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$f17 = function(tok) {\n        return tok;\n      };\n      var peg$f18 = function(tok) {\n        return options.isParbreak(tok);\n      };\n      var peg$f19 = function(tok) {\n        return tok;\n      };\n      var peg$f20 = function(tok) {\n        return options.isComma(tok);\n      };\n      var peg$f21 = function(tok) {\n        return tok;\n      };\n      var peg$f22 = function(tok) {\n        return options.isEquals(tok);\n      };\n      var peg$f23 = function(tok) {\n        return tok;\n      };\n      var peg$f24 = function(tok) {\n        return options.isChar(tok, \"(\");\n      };\n      var peg$f25 = function(tok) {\n        return tok;\n      };\n      var peg$f26 = function(tok) {\n        return options.isChar(tok, \")\");\n      };\n      var peg$f27 = function(tok) {\n        return tok;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1, s2;\n        s0 = [];\n        s1 = peg$parsecomment_only_line();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseitem_with_end();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseitem_without_end();\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            s1 = peg$parsecomment_only_line();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseitem_with_end();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseitem_without_end();\n              }\n            }\n          }\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewhitespace();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewhitespace();\n          }\n          s2 = peg$parseEOL();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f0();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseitem_with_end() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        s0 = peg$currPos;\n        s1 = peg$parsewhitespace_or_parbreaks();\n        s2 = peg$parserow_items();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s3 = peg$parsewhitespace_or_parbreaks();\n        s4 = peg$parseitem_sep();\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsewhitespace();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsewhitespace();\n          }\n          s6 = peg$parsetrailing_comment();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewhitespace();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewhitespace();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f1(s2, s6);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseitem_without_end() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsewhitespace_or_parbreaks();\n        s2 = peg$parserow_items();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetrailing_comment();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f2(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parserow_items() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseitem_part();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseseparated_part();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseseparated_part();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parseseparated_part();\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parseseparated_part();\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f4(s1);\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parseseparated_part() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseparbreak();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseparbreak();\n        }\n        s2 = peg$parseequals();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseparbreak();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseparbreak();\n          }\n          s4 = peg$parseitem_part();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parseparbreak();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseparbreak();\n          }\n          s2 = peg$parseequals();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseitem_part() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n        }\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$parsenon_whitespace_non_parbreak_token();\n        if (s4 === peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsewhitespace();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseparbreak();\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$currPos;\n            s8 = [];\n            s9 = peg$parsewhitespace();\n            if (s9 === peg$FAILED) {\n              s9 = peg$parseparbreak();\n            }\n            while (s9 !== peg$FAILED) {\n              s8.push(s9);\n              s9 = peg$parsewhitespace();\n              if (s9 === peg$FAILED) {\n                s9 = peg$parseparbreak();\n              }\n            }\n            s9 = peg$parsenon_whitespace_non_parbreak_token();\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = void 0;\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsenon_whitespace_non_parbreak_token();\n            if (s4 === peg$FAILED) {\n              s4 = peg$currPos;\n              s5 = peg$parsewhitespace();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseparbreak();\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                peg$silentFails++;\n                s7 = peg$currPos;\n                s8 = [];\n                s9 = peg$parsewhitespace();\n                if (s9 === peg$FAILED) {\n                  s9 = peg$parseparbreak();\n                }\n                while (s9 !== peg$FAILED) {\n                  s8.push(s9);\n                  s9 = peg$parsewhitespace();\n                  if (s9 === peg$FAILED) {\n                    s9 = peg$parseparbreak();\n                  }\n                }\n                s9 = peg$parsenon_whitespace_non_parbreak_token();\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s7 !== peg$FAILED) {\n                  peg$currPos = s6;\n                  s6 = void 0;\n                } else {\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsewhitespace();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsewhitespace();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f7(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsetrailing_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n        }\n        s2 = peg$parsesame_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecomment_only_line() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsewhitespace_or_parbreaks();\n        s2 = peg$parseown_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f9(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsetoken() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsenon_token();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsenon_whitespace_non_parbreak_token() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsewhitespace();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseparbreak();\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseparen_block();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsetoken();\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsenon_token() {\n        var s0;\n        s0 = peg$parseitem_sep();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseequals();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsetrailing_comment();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseown_line_comment();\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsewhitespace_or_parbreaks() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsewhitespace();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseparbreak();\n        }\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsewhitespace();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseparbreak();\n          }\n        }\n        peg$savedPos = s0;\n        s1 = peg$f10(s1);\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseparen_block() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        s0 = peg$currPos;\n        peg$savedPos = peg$currPos;\n        s1 = peg$f11();\n        if (s1) {\n          s1 = peg$FAILED;\n        } else {\n          s1 = void 0;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          s4 = peg$parseopen_paren();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            peg$silentFails++;\n            s8 = peg$parseclose_paren();\n            peg$silentFails--;\n            if (s8 === peg$FAILED) {\n              s7 = void 0;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$parseclose_paren();\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e0);\n                  }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            s6 = peg$parseclose_paren();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = input.substring(s2, peg$currPos);\n          } else {\n            s2 = s3;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesame_line_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f12(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f13(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseown_line_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f14(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f15(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsewhitespace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f16(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseparbreak() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f18(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f19(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseitem_sep() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f20(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f21(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseequals() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f22(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f23(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseopen_paren() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f24(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseclose_paren() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f26(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f27(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function processItem(leadCell, otherCells) {\n        const cells = [leadCell || []];\n        for (const x of otherCells) {\n          cells.push(x.cell || []);\n        }\n        return { itemParts: cells };\n      }\n      if (!options.isWhitespace) {\n        try {\n          Object.assign(options, {\n            isChar: (node, char) => node.type === \"string\" && node.content === char,\n            isComma(node) {\n              return node.type === \"string\" && node.content === \",\";\n            },\n            isEquals(node) {\n              return node.type === \"string\" && node.content === \"=\";\n            },\n            isParbreak(node) {\n              return node.type === \"parbreak\";\n            },\n            isWhitespace(node) {\n              return node.type === \"whitespace\";\n            },\n            isSameLineComment: (node) => node.type === \"comment\" && node.sameline,\n            isOwnLineComment: (node) => node.type === \"comment\" && !node.sameline,\n            isComment: (node) => node.type === \"comment\",\n            allowParenGroups: true\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$anyExpectation();\n      var peg$f0 = function(e) {\n        return [].concat(...e).filter((n) => !!n);\n      };\n      var peg$f1 = function() {\n        return [];\n      };\n      var peg$f2 = function(tok) {\n        return options.isHash(tok);\n      };\n      var peg$f3 = function(tok) {\n        return tok;\n      };\n      var peg$f4 = function(tok) {\n        return options.isNumber(tok);\n      };\n      var peg$f5 = function(tok) {\n        return tok;\n      };\n      var peg$f6 = function() {\n        return { type: \"string\", content: \"#\" };\n      };\n      var peg$f7 = function(num) {\n        const split = options.splitNumber(num);\n        return [{ type: \"hash_number\", number: split.number }, split.rest];\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsedouble_hash();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsehash_number();\n          if (s2 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsedouble_hash();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsehash_number();\n              if (s2 === peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s2 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e0);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f0(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOL();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f1();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsehash() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f2(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsenumber() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f4(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedouble_hash() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsehash();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsehash();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsehash_number() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsehash();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsenumber();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      if (!options.isHash) {\n        try {\n          Object.assign(options, {\n            isHash: (node) => node.type === \"string\" && node.content === \"#\",\n            isNumber: (node) => node.type === \"string\" && 0 < +node.content.charAt(0),\n            splitNumber: (node) => {\n              const number = +node.content.charAt(0);\n              if (node.content.length > 1) {\n                return {\n                  number,\n                  rest: {\n                    type: \"string\",\n                    content: node.content.slice(1)\n                  }\n                };\n              }\n              return { number };\n            }\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$anyExpectation();\n      var peg$f0 = function(e) {\n        return [].concat(...e).filter((n) => !!n);\n      };\n      var peg$f1 = function() {\n        return [];\n      };\n      var peg$f2 = function(toks) {\n        return options.isRecognized(toks);\n      };\n      var peg$f3 = function(toks) {\n        return options.isRecognized(toks);\n      };\n      var peg$f4 = function(tok1, tok2) {\n        const split = options.split(tok2);\n        return options.isRecognized([tok1, split[0]]);\n      };\n      var peg$f5 = function(tok1, tok2) {\n        const split = options.split(tok2);\n        return [options.isRecognized([tok1, split[0]]), split[1]];\n      };\n      var peg$f6 = function(tok1, tok2) {\n        return options.isRecognized([tok1, tok2]);\n      };\n      var peg$f7 = function(tok1, tok2) {\n        return options.isRecognized([tok1, tok2]);\n      };\n      var peg$f8 = function(toks) {\n        return options.isRecognized(toks);\n      };\n      var peg$f9 = function(toks) {\n        return options.isRecognized(toks);\n      };\n      var peg$f10 = function(tok) {\n        return options.isRecognized([tok]);\n      };\n      var peg$f11 = function(tok) {\n        return options.isRecognized([tok]);\n      };\n      var peg$f12 = function(tok) {\n        return options.isMacro(tok);\n      };\n      var peg$f13 = function(tok) {\n        return tok;\n      };\n      var peg$f14 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$f15 = function(tok) {\n        return tok;\n      };\n      var peg$f16 = function(tok) {\n        return options.isSplitable(tok);\n      };\n      var peg$f17 = function(tok) {\n        return tok;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsetriple_ligature();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsedouble_ligature();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsemono_ligature();\n            if (s2 === peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsetriple_ligature();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsedouble_ligature();\n              if (s2 === peg$FAILED) {\n                s2 = peg$parsemono_ligature();\n                if (s2 === peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s2 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e0);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f0(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOL();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f1();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsetriple_ligature() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f2(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedouble_ligature() {\n        var s0;\n        s0 = peg$parsedouble_macro_ligature();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsedouble_macro_ligature_extracted();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsedouble_char_ligature();\n          }\n        }\n        return s0;\n      }\n      function peg$parsedouble_macro_ligature_extracted() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parsemacro();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsewhitespace();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsewhitespace();\n          }\n          s3 = peg$parsesplitable();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s4 = peg$f4(s1, s3);\n            if (s4) {\n              s4 = void 0;\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f5(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedouble_macro_ligature() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parsemacro();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsewhitespace();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsewhitespace();\n          }\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = peg$currPos;\n            s4 = peg$f6(s1, s3);\n            if (s4) {\n              s4 = void 0;\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f7(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedouble_char_ligature() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f8(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f9(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemono_ligature() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f10(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemacro() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f12(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f13(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsewhitespace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f14(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f15(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesplitable() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f16(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      if (!options.isWhitespace) {\n        try {\n          Object.assign(options, {\n            isMacro: (node) => node.type === \"macro\",\n            isWhitespace: (node) => node.type === \"whitespace\",\n            isRecognized: (nodes) => {\n              if (nodes.length == 2 && nodes[0].content === \"^\" && nodes[1].content === \"o\") {\n                return { type: \"string\", content: \"\\xF4\" };\n              }\n              return null;\n            },\n            isSplitable: (node) => node.type === \"string\" && node.content.length > 1,\n            split: (node) => [\n              { type: \"string\", content: node.content.charAt(0) },\n              { type: \"string\", content: node.content.slice(1) }\n            ]\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { start: peg$parsestart };\n      var peg$startRuleFunction = peg$parsestart;\n      var peg$c0 = \";\";\n      var peg$c1 = \",\";\n      var peg$c2 = \":\";\n      var peg$c3 = \"/\";\n      var peg$c4 = \">\";\n      var peg$c5 = \"!\";\n      var peg$c6 = \".\";\n      var peg$c7 = \"!![\";\n      var peg$c8 = \"]\";\n      var peg$c9 = \"!!\";\n      var peg$c10 = \"+\";\n      var peg$c11 = \"-\";\n      var peg$r0 = /^[a-zA-Z0-9]/;\n      var peg$r1 = /^[0-9]/;\n      var peg$r2 = /^[ \\t\\n\\r]/;\n      var peg$r3 = /^[0-9a-fA-F]/;\n      var peg$e0 = peg$anyExpectation();\n      var peg$e1 = peg$literalExpectation(\";\", false);\n      var peg$e2 = peg$literalExpectation(\",\", false);\n      var peg$e3 = peg$otherExpectation(\"model list\");\n      var peg$e4 = peg$literalExpectation(\":\", false);\n      var peg$e5 = peg$literalExpectation(\"/\", false);\n      var peg$e6 = peg$otherExpectation(\"model\");\n      var peg$e7 = peg$otherExpectation(\"color spec list\");\n      var peg$e8 = peg$otherExpectation(\"color spec\");\n      var peg$e9 = peg$otherExpectation(\"color\");\n      var peg$e10 = peg$otherExpectation(\"function expression\");\n      var peg$e11 = peg$literalExpectation(\">\", false);\n      var peg$e12 = peg$otherExpectation(\"function\");\n      var peg$e13 = peg$otherExpectation(\"extended expression\");\n      var peg$e14 = peg$otherExpectation(\"core model\");\n      var peg$e15 = peg$otherExpectation(\"expr\");\n      var peg$e16 = peg$literalExpectation(\"!\", false);\n      var peg$e17 = peg$otherExpectation(\"mix expr\");\n      var peg$e18 = peg$otherExpectation(\"name\");\n      var peg$e19 = peg$literalExpectation(\".\", false);\n      var peg$e20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false);\n      var peg$e21 = peg$otherExpectation(\"postfix\");\n      var peg$e22 = peg$literalExpectation(\"!![\", false);\n      var peg$e23 = peg$literalExpectation(\"]\", false);\n      var peg$e24 = peg$literalExpectation(\"!!\", false);\n      var peg$e25 = peg$otherExpectation(\"prefix\");\n      var peg$e26 = peg$otherExpectation(\"plus\");\n      var peg$e27 = peg$literalExpectation(\"+\", false);\n      var peg$e28 = peg$otherExpectation(\"minus\");\n      var peg$e29 = peg$literalExpectation(\"-\", false);\n      var peg$e30 = peg$otherExpectation(\"num\");\n      var peg$e31 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n      var peg$e32 = peg$otherExpectation(\"positive float\");\n      var peg$e33 = peg$otherExpectation(\"divisor\");\n      var peg$e34 = peg$otherExpectation(\"int\");\n      var peg$e35 = peg$otherExpectation(\"whitespace\");\n      var peg$e36 = peg$classExpectation([\" \", \"\t\", \"\\n\", \"\\r\"], false, false);\n      var peg$e37 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"], [\"A\", \"F\"]], false, false);\n      var peg$f0 = function(m) {\n        return m;\n      };\n      var peg$f1 = function(m) {\n        return m;\n      };\n      var peg$f2 = function(m) {\n        return m;\n      };\n      var peg$f3 = function(m) {\n        return m;\n      };\n      var peg$f4 = function(m) {\n        return m;\n      };\n      var peg$f5 = function(a) {\n        return { type: \"invalid_spec\", content: a };\n      };\n      var peg$f6 = function(f, c) {\n        return c;\n      };\n      var peg$f7 = function(f, r) {\n        return { type: \"color_set\", content: [f].concat(r) };\n      };\n      var peg$f8 = function(n, s) {\n        return { type: \"color_set_item\", name: n, spec_list: s };\n      };\n      var peg$f9 = function(c, m) {\n        return { type: \"model_list\", contents: m, core_model: c };\n      };\n      var peg$f10 = function(m) {\n        return { type: \"model_list\", contents: m, core_model: null };\n      };\n      var peg$f11 = function(m, a) {\n        return a;\n      };\n      var peg$f12 = function(m, r) {\n        return [m].concat(r);\n      };\n      var peg$f13 = function(s, a) {\n        return a;\n      };\n      var peg$f14 = function(s, r) {\n        return { type: \"spec_list\", content: [s].concat(r) };\n      };\n      var peg$f15 = function(c) {\n        return { type: \"hex_spec\", content: [c] };\n      };\n      var peg$f16 = function(c, d) {\n        return d;\n      };\n      var peg$f17 = function(c, d) {\n        return d;\n      };\n      var peg$f18 = function(c, r) {\n        return { type: \"num_spec\", content: r ? [c].concat(r) : [c] };\n      };\n      var peg$f19 = function(c, fs) {\n        return { type: \"color\", color: c, functions: fs };\n      };\n      var peg$f20 = function(f, n) {\n        return n;\n      };\n      var peg$f21 = function(f, args) {\n        return { type: \"function\", name: f, args };\n      };\n      var peg$f22 = function(core, d, e, es) {\n        return {\n          type: \"extended_expr\",\n          core_model: core,\n          div: d,\n          expressions: [e].concat(es)\n        };\n      };\n      var peg$f23 = function(core, e, es) {\n        return {\n          type: \"extended_expr\",\n          core_model: core,\n          div: null,\n          expressions: [e].concat(es)\n        };\n      };\n      var peg$f24 = function(e, d) {\n        return { type: \"weighted_expr\", color: e, weight: d };\n      };\n      var peg$f25 = function(e) {\n        return e;\n      };\n      var peg$f26 = function(p, n, e, po) {\n        return {\n          type: \"expr\",\n          prefix: p,\n          name: n,\n          mix_expr: e,\n          postfix: po\n        };\n      };\n      var peg$f27 = function(p, n) {\n        return { type: \"complete_mix\", mix_percent: p, name: n };\n      };\n      var peg$f28 = function(p) {\n        return { type: \"partial_mix\", mix_percent: p };\n      };\n      var peg$f29 = function(c, p) {\n        return c.concat(p || []);\n      };\n      var peg$f30 = function(n) {\n        return { type: \"postfix\", num: n };\n      };\n      var peg$f31 = function(p) {\n        return { type: \"postfix\", plusses: p };\n      };\n      var peg$f32 = function(n) {\n        return parseInt(n, 10);\n      };\n      var peg$f33 = function(n) {\n        return parseFloat(n);\n      };\n      var peg$f34 = function(n) {\n        return n;\n      };\n      var peg$f35 = function(n) {\n        return -n;\n      };\n      var peg$f36 = function(m, n) {\n        return m ? -n : n;\n      };\n      var peg$f37 = function(h) {\n        return h.toUpperCase();\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsestart() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsespec();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseEOL();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f0(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsespec_list();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseEOL();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f1(s1);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecolor();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseEOL();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f2(s1);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parsemodel_list();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parseEOL();\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f3(s1);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsecolor_set_spec();\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parseEOL();\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f4(s1);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = peg$currPos;\n                  s2 = [];\n                  if (input.length > peg$currPos) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e0);\n                    }\n                  }\n                  while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    if (input.length > peg$currPos) {\n                      s3 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s3 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e0);\n                      }\n                    }\n                  }\n                  s1 = input.substring(s1, peg$currPos);\n                  peg$savedPos = s0;\n                  s1 = peg$f5(s1);\n                  s0 = s1;\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsecolor_set_spec() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parsecolor_set_item();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s4 = peg$c0;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e1);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecolor_set_item();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f6(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s4 = peg$c0;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e1);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecolor_set_item();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f6(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          peg$savedPos = s0;\n          s0 = peg$f7(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecolor_set_item() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsename();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s2 = peg$c1;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsespec_list();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f8(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemodel_list() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsecore_model();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s2 = peg$c2;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e4);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsemodel_list_tail();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f9(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemodel_list_tail();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f10(s1);\n          }\n          s0 = s1;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        return s0;\n      }\n      function peg$parsemodel_list_tail() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parsemodel();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s4 = peg$c3;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e5);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemodel();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f11(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e5);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemodel();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f11(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          peg$savedPos = s0;\n          s0 = peg$f12(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemodel() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parsecore_model();\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        return s0;\n      }\n      function peg$parsespec_list() {\n        var s0, s1, s2, s3, s4, s5;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsespec();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s4 = peg$c3;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e5);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsespec();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s3 = peg$f13(s1, s5);\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e5);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsespec();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f13(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          peg$savedPos = s0;\n          s0 = peg$f14(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        return s0;\n      }\n      function peg$parsespec() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$parsehex();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsehex();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsehex();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsehex();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehex();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsehex();\n                  if (s8 !== peg$FAILED) {\n                    s3 = [s3, s4, s5, s6, s7, s8];\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f15(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsedec();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s4 = peg$c1;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsedec();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s3 = peg$f16(s1, s5);\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s4 = peg$c1;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e2);\n                  }\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsedec();\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s3;\n                    s3 = peg$f16(s1, s5);\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = [];\n              s3 = peg$currPos;\n              s4 = peg$parsesp();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsedec();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s3 = peg$f17(s1, s5);\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$currPos;\n                  s4 = peg$parsesp();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsedec();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s3;\n                      s3 = peg$f17(s1, s5);\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              } else {\n                s2 = peg$FAILED;\n              }\n            }\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            peg$savedPos = s0;\n            s0 = peg$f18(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecolor() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsecolor_expr();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsefunc_expr();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsefunc_expr();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f19(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecolor_expr() {\n        var s0;\n        s0 = peg$parseext_expr();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseexpr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsename();\n          }\n        }\n        return s0;\n      }\n      function peg$parsefunc_expr() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s1 = peg$c4;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsefunction();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e2);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseint();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s4 = peg$f20(s2, s6);\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c1;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e2);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseint();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s4;\n                  s4 = peg$f20(s2, s6);\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            peg$savedPos = s0;\n            s0 = peg$f21(s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        return s0;\n      }\n      function peg$parsefunction() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parsename();\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        return s0;\n      }\n      function peg$parseext_expr() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsecore_model();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s2 = peg$c1;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsediv();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s4 = peg$c2;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e4);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseweighted_expr();\n                if (s5 !== peg$FAILED) {\n                  s6 = [];\n                  s7 = peg$parseadditional_weighted_expr();\n                  while (s7 !== peg$FAILED) {\n                    s6.push(s7);\n                    s7 = peg$parseadditional_weighted_expr();\n                  }\n                  peg$savedPos = s0;\n                  s0 = peg$f22(s1, s3, s5, s6);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecore_model();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s2 = peg$c2;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e4);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseweighted_expr();\n              if (s3 !== peg$FAILED) {\n                s4 = [];\n                s5 = peg$parseadditional_weighted_expr();\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = peg$parseadditional_weighted_expr();\n                }\n                peg$savedPos = s0;\n                s0 = peg$f23(s1, s3, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e13);\n          }\n        }\n        return s0;\n      }\n      function peg$parseweighted_expr() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseexpr();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s2 = peg$c1;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsedec();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f24(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseadditional_weighted_expr() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 59) {\n          s1 = peg$c0;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseweighted_expr();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecore_model() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parsename();\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        return s0;\n      }\n      function peg$parseexpr() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseprefix();\n        s2 = peg$parsename();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemix_expr();\n          s4 = peg$parsepostfix();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f26(s1, s2, s3, s4);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e15);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecomplete_mix() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsepct();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 33) {\n              s3 = peg$c5;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e16);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsename();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f27(s2, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsepartial_mix() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsepct();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f28(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemix_expr() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsecomplete_mix();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsecomplete_mix();\n        }\n        s2 = peg$parsepartial_mix();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f29(s1, s2);\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e17);\n        }\n        return s0;\n      }\n      function peg$parsename() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s0 = peg$c6;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              if (peg$r0.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e20);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s0 = input.substring(s0, peg$currPos);\n          } else {\n            s0 = s1;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e18);\n          }\n        }\n        return s0;\n      }\n      function peg$parsepostfix() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c7) {\n          s1 = peg$c7;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e22);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsenum();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s3 = peg$c8;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e23);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f30(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c9) {\n            s1 = peg$c9;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e24);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parseplus();\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parseplus();\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s2 = input.substring(s2, peg$currPos);\n            } else {\n              s2 = s3;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f31(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e21);\n          }\n        }\n        return s0;\n      }\n      function peg$parseprefix() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parseminus();\n        if (s0 === peg$FAILED) {\n          s0 = null;\n        }\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e25);\n        }\n        return s0;\n      }\n      function peg$parseplus() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s2 = peg$c10;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e27);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c10;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e27);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e26);\n          }\n        }\n        return s0;\n      }\n      function peg$parseminus() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c11;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e29);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s2 = peg$c11;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e29);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e28);\n          }\n        }\n        return s0;\n      }\n      function peg$parsenum() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e31);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e31);\n              }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f32(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e30);\n          }\n        }\n        return s0;\n      }\n      function peg$parsepct() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e31);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e31);\n              }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s6 = peg$c6;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e19);\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$currPos;\n            s8 = [];\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s9 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e31);\n              }\n            }\n            while (s9 !== peg$FAILED) {\n              s8.push(s9);\n              if (peg$r1.test(input.charAt(peg$currPos))) {\n                s9 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e31);\n                }\n              }\n            }\n            s7 = input.substring(s7, peg$currPos);\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          s4 = input.substring(s4, peg$currPos);\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e19);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = [];\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e31);\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (peg$r1.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e31);\n                  }\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = input.substring(s4, peg$currPos);\n            } else {\n              s4 = s5;\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = input.substring(s1, peg$currPos);\n          } else {\n            s1 = s2;\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f33(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e32);\n          }\n        }\n        return s0;\n      }\n      function peg$parsediv() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = peg$parsepct();\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e33);\n          }\n        }\n        return s0;\n      }\n      function peg$parsedec() {\n        var s0, s1, s2;\n        s0 = peg$parsepct();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s1 = peg$c10;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e27);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsepct();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f34(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s1 = peg$c11;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e29);\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsepct();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f35(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseint() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseminus();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parsenum();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f36(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e34);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e36);\n          }\n        }\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$r2.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e36);\n            }\n          }\n        }\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e35);\n        }\n        return s0;\n      }\n      function peg$parsesp() {\n        var s0, s1;\n        s0 = [];\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e36);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            if (peg$r2.test(input.charAt(peg$currPos))) {\n              s1 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e36);\n              }\n            }\n          }\n        } else {\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsehex() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e37);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f37(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$otherExpectation(\"decl_start\");\n      var peg$e1 = peg$otherExpectation(\"decl_end\");\n      var peg$e2 = peg$otherExpectation(\"vert\");\n      var peg$e3 = peg$anyExpectation();\n      var peg$e4 = peg$otherExpectation(\"l\");\n      var peg$e5 = peg$otherExpectation(\"r\");\n      var peg$e6 = peg$otherExpectation(\"c\");\n      var peg$e7 = peg$otherExpectation(\"p\");\n      var peg$e8 = peg$otherExpectation(\"m\");\n      var peg$e9 = peg$otherExpectation(\"b\");\n      var peg$e10 = peg$otherExpectation(\"w\");\n      var peg$e11 = peg$otherExpectation(\"W\");\n      var peg$e12 = peg$otherExpectation(\"X\");\n      var peg$e13 = peg$otherExpectation(\"!\");\n      var peg$e14 = peg$otherExpectation(\"@\");\n      var peg$e15 = peg$otherExpectation(\"<\");\n      var peg$e16 = peg$otherExpectation(\">\");\n      var peg$e17 = peg$otherExpectation(\"group\");\n      var peg$e18 = peg$otherExpectation(\"whitespace\");\n      var peg$f0 = function(c) {\n        return c;\n      };\n      var peg$f1 = function(cols) {\n        return cols;\n      };\n      var peg$f2 = function() {\n        return [];\n      };\n      var peg$f3 = function(divs1, start, a, end, divs2) {\n        return {\n          type: \"column\",\n          pre_dividers: divs1,\n          post_dividers: divs2,\n          before_start_code: start,\n          before_end_code: end,\n          alignment: a\n        };\n      };\n      var peg$f4 = function() {\n        return {\n          type: \"vert_divider\"\n        };\n      };\n      var peg$f5 = function(b, g) {\n        return {\n          type: \"bang_divider\",\n          content: g[0].content\n        };\n      };\n      var peg$f6 = function(g) {\n        return {\n          type: \"at_divider\",\n          content: g[0].content\n        };\n      };\n      var peg$f7 = function(div) {\n        return div;\n      };\n      var peg$f8 = function(g) {\n        return { type: \"decl_code\", code: g[0].content };\n      };\n      var peg$f9 = function(g) {\n        return { type: \"decl_code\", code: g[0].content };\n      };\n      var peg$f10 = function() {\n        return { type: \"alignment\", alignment: \"left\" };\n      };\n      var peg$f11 = function() {\n        return { type: \"alignment\", alignment: \"center\" };\n      };\n      var peg$f12 = function() {\n        return { type: \"alignment\", alignment: \"right\" };\n      };\n      var peg$f13 = function() {\n        return { type: \"alignment\", alignment: \"X\" };\n      };\n      var peg$f14 = function() {\n        return \"top\";\n      };\n      var peg$f15 = function() {\n        return \"default\";\n      };\n      var peg$f16 = function() {\n        return \"bottom\";\n      };\n      var peg$f17 = function(a, g) {\n        return {\n          type: \"alignment\",\n          alignment: \"parbox\",\n          baseline: a,\n          size: g[0].content\n        };\n      };\n      var peg$f18 = function(g1, g2) {\n        return {\n          type: \"alignment\",\n          alignment: \"parbox\",\n          baseline: g1[0].content,\n          size: g2[0].content\n        };\n      };\n      var peg$f19 = function(tok) {\n        return options.matchChar(tok, \"|\");\n      };\n      var peg$f20 = function(tok) {\n        return options.matchChar(tok, \"l\");\n      };\n      var peg$f21 = function(tok) {\n        return options.matchChar(tok, \"r\");\n      };\n      var peg$f22 = function(tok) {\n        return options.matchChar(tok, \"c\");\n      };\n      var peg$f23 = function(tok) {\n        return options.matchChar(tok, \"p\");\n      };\n      var peg$f24 = function(tok) {\n        return options.matchChar(tok, \"m\");\n      };\n      var peg$f25 = function(tok) {\n        return options.matchChar(tok, \"b\");\n      };\n      var peg$f26 = function(tok) {\n        return options.matchChar(tok, \"w\");\n      };\n      var peg$f27 = function(tok) {\n        return options.matchChar(tok, \"W\");\n      };\n      var peg$f28 = function(tok) {\n        return options.matchChar(tok, \"X\");\n      };\n      var peg$f29 = function(tok) {\n        return options.matchChar(tok, \"!\");\n      };\n      var peg$f30 = function(tok) {\n        return options.matchChar(tok, \"@\");\n      };\n      var peg$f31 = function(tok) {\n        return options.matchChar(tok, \"<\");\n      };\n      var peg$f32 = function(tok) {\n        return options.matchChar(tok, \">\");\n      };\n      var peg$f33 = function(tok) {\n        return options.isGroup(tok);\n      };\n      var peg$f34 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$currPos;\n        s3 = peg$parsecolumn();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          peg$savedPos = s2;\n          s2 = peg$f0(s3);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$currPos;\n            s3 = peg$parsecolumn();\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = peg$parse_();\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parse_();\n              }\n              peg$savedPos = s2;\n              s2 = peg$f0(s3);\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f1(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOL();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f2();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsecolumn() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsecolumn_divider();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsecolumn_divider();\n        }\n        s2 = peg$parsedecl_start();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s3 = peg$parsealignment();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsedecl_end();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          s5 = [];\n          s6 = peg$parsecolumn_divider();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsecolumn_divider();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s2, s3, s4, s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecolumn_divider() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        s2 = peg$currPos;\n        s3 = peg$parsevert();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$f4();\n        }\n        s2 = s3;\n        if (s2 === peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parsebang();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsegroup();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s2;\n              s2 = peg$f5(s3, s4);\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parseat();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsegroup();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s2;\n                s2 = peg$f6(s4);\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f7(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedecl_start() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parsegreater();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsegroup();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f8(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        return s0;\n      }\n      function peg$parsedecl_end() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseless();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsegroup();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f9(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        return s0;\n      }\n      function peg$parsealignment() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parsel();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f10();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsec();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f11();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parser();\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f12();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseX();\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f13();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$currPos;\n                s2 = peg$parsep();\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$f14();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  s2 = peg$parsem();\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$f15();\n                  }\n                  s1 = s2;\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    s2 = peg$parseb();\n                    if (s2 !== peg$FAILED) {\n                      peg$savedPos = s1;\n                      s2 = peg$f16();\n                    }\n                    s1 = s2;\n                  }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = [];\n                  s3 = peg$parse_();\n                  while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    s3 = peg$parse_();\n                  }\n                  s3 = peg$parsegroup();\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f17(s1, s3);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = peg$parsew();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parseW();\n                  }\n                  if (s1 !== peg$FAILED) {\n                    s2 = [];\n                    s3 = peg$parse_();\n                    while (s3 !== peg$FAILED) {\n                      s2.push(s3);\n                      s3 = peg$parse_();\n                    }\n                    s3 = peg$parsegroup();\n                    if (s3 !== peg$FAILED) {\n                      s4 = [];\n                      s5 = peg$parse_();\n                      while (s5 !== peg$FAILED) {\n                        s4.push(s5);\n                        s5 = peg$parse_();\n                      }\n                      s5 = peg$parsegroup();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f18(s3, s5);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsevert() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f19(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        return s0;\n      }\n      function peg$parsel() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f20(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        return s0;\n      }\n      function peg$parser() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f21(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        return s0;\n      }\n      function peg$parsec() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f22(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        return s0;\n      }\n      function peg$parsep() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f23(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        return s0;\n      }\n      function peg$parsem() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f24(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        return s0;\n      }\n      function peg$parseb() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f25(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        return s0;\n      }\n      function peg$parsew() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f26(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        return s0;\n      }\n      function peg$parseW() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f27(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        return s0;\n      }\n      function peg$parseX() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f28(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        return s0;\n      }\n      function peg$parsebang() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f29(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e13);\n          }\n        }\n        return s0;\n      }\n      function peg$parseat() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f30(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        return s0;\n      }\n      function peg$parseless() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f31(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e15);\n          }\n        }\n        return s0;\n      }\n      function peg$parsegreater() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f32(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e16);\n          }\n        }\n        return s0;\n      }\n      function peg$parsegroup() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f33(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e17);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f34(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e18);\n          }\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      if (!options.isHash) {\n        try {\n          Object.assign(options, {\n            matchChar: (node, char) => node.type === \"string\" && node.content === char,\n            isGroup: (node) => node.type === \"group\",\n            isWhitespace: (node) => node.type === \"whitespace\"\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { body: peg$parsebody };\n      var peg$startRuleFunction = peg$parsebody;\n      var peg$e0 = peg$otherExpectation(\"partial item\");\n      var peg$e1 = peg$otherExpectation(\"item\");\n      var peg$e2 = peg$anyExpectation();\n      var peg$e3 = peg$otherExpectation(\"equation\");\n      var peg$e4 = peg$otherExpectation(\"trailing comment\");\n      var peg$e5 = peg$otherExpectation(\"comment only line\");\n      var peg$e6 = peg$otherExpectation(\"non-var token\");\n      var peg$e7 = peg$otherExpectation(\"token\");\n      var peg$e8 = peg$otherExpectation(\"same line comment\");\n      var peg$e9 = peg$otherExpectation(\"own line comment\");\n      var peg$e10 = peg$otherExpectation(\",\");\n      var peg$e11 = peg$otherExpectation(\"@\");\n      var peg$e12 = peg$otherExpectation(\"variable token\");\n      var peg$e13 = peg$otherExpectation(\"+/-\");\n      var peg$e14 = peg$otherExpectation(\"=\");\n      var peg$f0 = function(a, b) {\n        return a.concat(b ? b : []);\n      };\n      var peg$f1 = function() {\n        return [];\n      };\n      var peg$f2 = function(a, b, c) {\n        return a.concat(b, c);\n      };\n      var peg$f3 = function(op, a, b, c) {\n        return { type: \"item\", op, variable: b, content: a.concat(b, c) };\n      };\n      var peg$f4 = function(op, a) {\n        return { type: \"item\", op, variable: null, content: a };\n      };\n      var peg$f5 = function(line, sep, comment) {\n        return { ...line, sep: [].concat(sep), trailingComment: comment };\n      };\n      var peg$f6 = function(line, comment) {\n        return { ...line, trailingComment: comment };\n      };\n      var peg$f7 = function(eq, ann) {\n        return {\n          type: \"line\",\n          equation: eq,\n          annotation: ann,\n          sep: null\n        };\n      };\n      var peg$f8 = function(at, ann) {\n        return at ? { type: \"annotation\", marker: at, content: ann } : null;\n      };\n      var peg$f9 = function(left, eq, right) {\n        return { type: \"equation\", left, right, equals: eq };\n      };\n      var peg$f10 = function(x) {\n        return x;\n      };\n      var peg$f11 = function(x) {\n        return {\n          type: \"line\",\n          trailingComment: x\n        };\n      };\n      var peg$f12 = function(v, s) {\n        return [v].concat(s ? s : []);\n      };\n      var peg$f13 = function(t) {\n        return t;\n      };\n      var peg$f14 = function(x) {\n        return x;\n      };\n      var peg$f15 = function(x) {\n        return x;\n      };\n      var peg$f16 = function(tok) {\n        return options.isSameLineComment(tok);\n      };\n      var peg$f17 = function(tok) {\n        return tok;\n      };\n      var peg$f18 = function(tok) {\n        return options.isOwnLineComment(tok);\n      };\n      var peg$f19 = function(tok) {\n        return tok;\n      };\n      var peg$f20 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$f21 = function(tok) {\n        return tok;\n      };\n      var peg$f22 = function(tok) {\n        return options.isSep(tok);\n      };\n      var peg$f23 = function(tok) {\n        return tok;\n      };\n      var peg$f24 = function(tok) {\n        return options.isAt(tok);\n      };\n      var peg$f25 = function(tok) {\n        return tok;\n      };\n      var peg$f26 = function(tok) {\n        return options.isVar(tok);\n      };\n      var peg$f27 = function(tok) {\n        return tok;\n      };\n      var peg$f28 = function(tok) {\n        return options.isOperation(tok);\n      };\n      var peg$f29 = function(tok) {\n        return tok;\n      };\n      var peg$f30 = function(tok) {\n        return options.isEquals(tok);\n      };\n      var peg$f31 = function(tok) {\n        return tok;\n      };\n      var peg$f32 = function(tok) {\n        return options.isSubscript(tok);\n      };\n      var peg$f33 = function(tok) {\n        return tok;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsebody() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parsecomment_only_line();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseline_with_sep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsepartial_line_with_comment();\n          }\n        }\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsecomment_only_line();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseline_with_sep();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsepartial_line_with_comment();\n            }\n          }\n        }\n        s2 = peg$parseline_without_sep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseEOL();\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f0(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOL();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f1();\n          }\n          s0 = s1;\n        }\n        return s0;\n      }\n      function peg$parsepartial_item() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        s2 = [];\n        s3 = peg$parsenon_var_token();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsenon_var_token();\n        }\n        s3 = [];\n        s4 = peg$parse_();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parse_();\n        }\n        s4 = peg$parsevar();\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parse_();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parse_();\n          }\n          s6 = [];\n          s7 = peg$parsetoken();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsetoken();\n          }\n          s7 = [];\n          s8 = peg$parse_();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f2(s2, s4, s6);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        return s0;\n      }\n      function peg$parseitem() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parseoperation();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = [];\n        s3 = peg$parse_();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parse_();\n        }\n        s3 = [];\n        s4 = peg$parsenon_var_token();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsenon_var_token();\n        }\n        s4 = [];\n        s5 = peg$parse_();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parse_();\n        }\n        s5 = peg$parsevar();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parse_();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parse_();\n          }\n          s7 = [];\n          s8 = peg$parsetoken();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsetoken();\n          }\n          s8 = [];\n          s9 = peg$parse_();\n          while (s9 !== peg$FAILED) {\n            s8.push(s9);\n            s9 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s3, s5, s7);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseoperation();\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = [];\n          s4 = peg$parsenon_var_token();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsenon_var_token();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parse_();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parse_();\n            }\n            peg$savedPos = s0;\n            s0 = peg$f4(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        return s0;\n      }\n      function peg$parseline_with_sep() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseline_without_sep();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsesep();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsetrailing_comment();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            peg$savedPos = s0;\n            s0 = peg$f5(s1, s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsepartial_line_with_comment() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseline_without_sep();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsetrailing_comment();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseline_without_sep() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        peg$silentFails--;\n        if (s2 !== peg$FAILED) {\n          peg$currPos = s1;\n          s1 = void 0;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseequation();\n          s3 = peg$parseannotation();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f7(s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseannotation() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseat();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsenon_sep_token();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenon_sep_token();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f8(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseequation() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseitem();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseitem();\n        }\n        s2 = peg$parseequals();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s3 = [];\n        s4 = peg$parsetoken();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseoperation();\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsetoken();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseoperation();\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f9(s1, s2, s3);\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e3);\n        }\n        return s0;\n      }\n      function peg$parsetrailing_comment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        s2 = peg$parsesame_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f10(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e4);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecomment_only_line() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        s2 = peg$parseown_line_comment();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f11(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        return s0;\n      }\n      function peg$parsevar() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parsevar_token();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$parsesubscript();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f12(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsenon_var_token() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$parsevar();\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsetoken();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f13(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        return s0;\n      }\n      function peg$parsenon_sep_token() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$parsesep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsetrailing_comment();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseown_line_comment();\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f14(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsetoken() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$parsesep();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseat();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoperation();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseequals();\n              if (s2 === peg$FAILED) {\n                s2 = peg$parsetrailing_comment();\n                if (s2 === peg$FAILED) {\n                  s2 = peg$parseown_line_comment();\n                }\n              }\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = void 0;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e2);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f15(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e7);\n          }\n        }\n        return s0;\n      }\n      function peg$parsesame_line_comment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f16(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e8);\n          }\n        }\n        return s0;\n      }\n      function peg$parseown_line_comment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f18(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f19(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e9);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f20(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f21(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesep() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f22(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f23(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e10);\n          }\n        }\n        return s0;\n      }\n      function peg$parseat() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f24(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e11);\n          }\n        }\n        return s0;\n      }\n      function peg$parsevar_token() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f26(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f27(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e12);\n          }\n        }\n        return s0;\n      }\n      function peg$parseoperation() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          peg$savedPos = peg$currPos;\n          s4 = peg$f28(s2);\n          if (s4) {\n            s4 = void 0;\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f29(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e13);\n          }\n        }\n        return s0;\n      }\n      function peg$parseequals() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f30(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f31(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e14);\n          }\n        }\n        return s0;\n      }\n      function peg$parsesubscript() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f32(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f33(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      if (!options.isWhitespace) {\n        try {\n          Object.assign(options, {\n            isSep: (node) => node.type === \"string\" && node.content === \",\",\n            isVar: (node) => node.type === \"string\" && node.content.match(/[a-zA-Z]/),\n            isOperation: (node) => node.type === \"string\" && node.content.match(/[+-]/),\n            isEquals: (node) => node.type === \"string\" && node.content === \"=\",\n            isAt: (node) => node.type === \"string\" && node.content === \"@\",\n            isSubscript: (node) => node.content === \"_\",\n            isWhitespace: (node) => node.type === \"whitespace\",\n            isSameLineComment: (node) => node.type === \"comment\" && node.sameline,\n            isOwnLineComment: (node) => node.type === \"comment\" && !node.sameline\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { root: peg$parseroot };\n      var peg$startRuleFunction = peg$parseroot;\n      var peg$c0 = \"plus\";\n      var peg$c1 = \"minus\";\n      var peg$c2 = \"pt\";\n      var peg$c3 = \"mm\";\n      var peg$c4 = \"cm\";\n      var peg$c5 = \"in\";\n      var peg$c6 = \"ex\";\n      var peg$c7 = \"em\";\n      var peg$c8 = \"bp\";\n      var peg$c9 = \"pc\";\n      var peg$c10 = \"dd\";\n      var peg$c11 = \"cc\";\n      var peg$c12 = \"nd\";\n      var peg$c13 = \"nc\";\n      var peg$c14 = \"sp\";\n      var peg$c15 = \"filll\";\n      var peg$c16 = \"fill\";\n      var peg$c17 = \"fil\";\n      var peg$c18 = \".\";\n      var peg$c19 = \"+\";\n      var peg$c20 = \"-\";\n      var peg$r0 = /^[0-9]/;\n      var peg$e0 = peg$anyExpectation();\n      var peg$e1 = peg$literalExpectation(\"plus\", false);\n      var peg$e2 = peg$literalExpectation(\"minus\", false);\n      var peg$e3 = peg$literalExpectation(\"pt\", false);\n      var peg$e4 = peg$literalExpectation(\"mm\", false);\n      var peg$e5 = peg$literalExpectation(\"cm\", false);\n      var peg$e6 = peg$literalExpectation(\"in\", false);\n      var peg$e7 = peg$literalExpectation(\"ex\", false);\n      var peg$e8 = peg$literalExpectation(\"em\", false);\n      var peg$e9 = peg$literalExpectation(\"bp\", false);\n      var peg$e10 = peg$literalExpectation(\"pc\", false);\n      var peg$e11 = peg$literalExpectation(\"dd\", false);\n      var peg$e12 = peg$literalExpectation(\"cc\", false);\n      var peg$e13 = peg$literalExpectation(\"nd\", false);\n      var peg$e14 = peg$literalExpectation(\"nc\", false);\n      var peg$e15 = peg$literalExpectation(\"sp\", false);\n      var peg$e16 = peg$literalExpectation(\"filll\", false);\n      var peg$e17 = peg$literalExpectation(\"fill\", false);\n      var peg$e18 = peg$literalExpectation(\"fil\", false);\n      var peg$e19 = peg$otherExpectation(\"number\");\n      var peg$e20 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n      var peg$e21 = peg$literalExpectation(\".\", false);\n      var peg$e22 = peg$literalExpectation(\"+\", false);\n      var peg$e23 = peg$literalExpectation(\"-\", false);\n      var peg$f0 = function(b, st, sh) {\n        return {\n          type: \"glue\",\n          fixed: b,\n          stretchable: st,\n          shrinkable: sh,\n          position: location()\n        };\n      };\n      var peg$f1 = function(glue) {\n        return glue;\n      };\n      var peg$f2 = function(n, u) {\n        return { type: \"dim\", value: n, unit: u };\n      };\n      var peg$f3 = function(n, u) {\n        return { type: \"dim\", value: n, unit: u };\n      };\n      var peg$f4 = function(n, u) {\n        return { type: \"dim\", value: n, unit: u };\n      };\n      var peg$f5 = function(n) {\n        return parseFloat(n);\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parseroot() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parsebase();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsestretchable();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = peg$parseshrinkable();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          peg$savedPos = s1;\n          s1 = peg$f0(s2, s3, s4);\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (input.length > peg$currPos) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (input.length > peg$currPos) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n          }\n          peg$savedPos = s0;\n          s0 = peg$f1(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsebase() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsenumber();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseunit();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f2(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsestretchable() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c0) {\n          s1 = peg$c0;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsenumber();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserubber_unit();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f3(s2, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseshrinkable() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5) === peg$c1) {\n          s1 = peg$c1;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsenumber();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserubber_unit();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f4(s2, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseunit() {\n        var s0;\n        if (input.substr(peg$currPos, 2) === peg$c2) {\n          s0 = peg$c2;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c3) {\n            s0 = peg$c3;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e4);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c4) {\n              s0 = peg$c4;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e5);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c5) {\n                s0 = peg$c5;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e6);\n                }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c6) {\n                  s0 = peg$c6;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$e7);\n                  }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c7) {\n                    s0 = peg$c7;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$e8);\n                    }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c8) {\n                      s0 = peg$c8;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$e9);\n                      }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c9) {\n                        s0 = peg$c9;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                          peg$fail(peg$e10);\n                        }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c10) {\n                          s0 = peg$c10;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$e11);\n                          }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 2) === peg$c11) {\n                            s0 = peg$c11;\n                            peg$currPos += 2;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                              peg$fail(peg$e12);\n                            }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c12) {\n                              s0 = peg$c12;\n                              peg$currPos += 2;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) {\n                                peg$fail(peg$e13);\n                              }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 2) === peg$c13) {\n                                s0 = peg$c13;\n                                peg$currPos += 2;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                  peg$fail(peg$e14);\n                                }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 2) === peg$c14) {\n                                  s0 = peg$c14;\n                                  peg$currPos += 2;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) {\n                                    peg$fail(peg$e15);\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parserubber_unit() {\n        var s0;\n        s0 = peg$parseunit();\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c15) {\n            s0 = peg$c15;\n            peg$currPos += 5;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e16);\n            }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4) === peg$c16) {\n              s0 = peg$c16;\n              peg$currPos += 4;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e17);\n              }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 3) === peg$c17) {\n                s0 = peg$c17;\n                peg$currPos += 3;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e18);\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsenumber() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$parsesign();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$currPos;\n        s5 = [];\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e20);\n          }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n        }\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s6 = peg$c18;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e21);\n          }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = [];\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s8 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n          if (s8 !== peg$FAILED) {\n            while (s8 !== peg$FAILED) {\n              s7.push(s8);\n              if (peg$r0.test(input.charAt(peg$currPos))) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e20);\n                }\n              }\n            }\n          } else {\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            s5 = [s5, s6, s7];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = [];\n          if (peg$r0.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e20);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              if (peg$r0.test(input.charAt(peg$currPos))) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e20);\n                }\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f5(s1);\n        }\n        s0 = s1;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e19);\n          }\n        }\n        return s0;\n      }\n      function peg$parsesign() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s0 = peg$c19;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e22);\n          }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s0 = peg$c20;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e23);\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "export default (\n  // Generated by Peggy 3.0.2.\n  //\n  // https://peggyjs.org/\n  function() {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      var self = Error.call(this, message);\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n      }\n      self.expected = expected;\n      self.found = found;\n      self.location = location;\n      self.name = \"SyntaxError\";\n      return self;\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    function peg$padEnd(str, targetLength, padString) {\n      padString = padString || \" \";\n      if (str.length > targetLength) {\n        return str;\n      }\n      targetLength -= str.length;\n      padString += padString.repeat(targetLength);\n      return str + padString.slice(0, targetLength);\n    }\n    peg$SyntaxError.prototype.format = function(sources) {\n      var str = \"Error: \" + this.message;\n      if (this.location) {\n        var src = null;\n        var k;\n        for (k = 0; k < sources.length; k++) {\n          if (sources[k].source === this.location.source) {\n            src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n            break;\n          }\n        }\n        var s = this.location.start;\n        var offset_s = this.location.source && typeof this.location.source.offset === \"function\" ? this.location.source.offset(s) : s;\n        var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n        if (src) {\n          var e = this.location.end;\n          var filler = peg$padEnd(\"\", offset_s.line.toString().length, \" \");\n          var line = src[s.line - 1];\n          var last = s.line === e.line ? e.column : line.length + 1;\n          var hatLen = last - s.column || 1;\n          str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + offset_s.line + \" | \" + line + \"\\n\" + filler + \" | \" + peg$padEnd(\"\", s.column - 1, \" \") + peg$padEnd(\"\", hatLen, \"^\");\n        } else {\n          str += \"\\n at \" + loc;\n        }\n      }\n      return str;\n    };\n    peg$SyntaxError.buildMessage = function(expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$source = options.grammarSource;\n      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };\n      var peg$startRuleFunction = peg$parsepath_spec;\n      var peg$e0 = peg$anyExpectation();\n      var peg$e1 = peg$otherExpectation(\"same line comment\");\n      var peg$e2 = peg$otherExpectation(\"own line comment\");\n      var peg$e3 = peg$otherExpectation(\"comment\");\n      var peg$e4 = peg$otherExpectation(\"floating comment\");\n      var peg$e5 = peg$otherExpectation(\"operation\");\n      var peg$e6 = peg$otherExpectation(\"=\");\n      var peg$f0 = function(v) {\n        return v;\n      };\n      var peg$f1 = function(ops) {\n        return { type: \"path_spec\", content: ops };\n      };\n      var peg$f2 = function(c1, op, comment) {\n        return { op, comment };\n      };\n      var peg$f3 = function(c1, ops, c2, body) {\n        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(\n          (x) => x\n        );\n        const attribute = ops.map((x) => x.op.content.content).join(\" \");\n        return {\n          type: \"animation\",\n          comments,\n          attribute,\n          content: body.content\n        };\n      };\n      var peg$f4 = function(start, b) {\n        return { ...b, start, type: \"foreach\" };\n      };\n      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {\n        const comments = [c1, c2, c3, c4].filter((x) => x);\n        return {\n          type: \"foreach_body\",\n          variables,\n          options: options2 && options2.content,\n          list,\n          command,\n          comments\n        };\n      };\n      var peg$f6 = function(c1, options2, c2, body) {\n        const comments = [c1, c2].filter((x) => x);\n        return {\n          type: \"svg_operation\",\n          options: options2 && options2.content,\n          content: body,\n          comments\n        };\n      };\n      var peg$f7 = function(c1, c2, coord, c3, c4, x) {\n        return { coord: x, comment: c4 };\n      };\n      var peg$f8 = function(c1, c2, coord, c3, a, c5) {\n        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);\n        return {\n          type: \"curve_to\",\n          controls: a ? [coord, a.coord] : [coord],\n          comments\n        };\n      };\n      var peg$f9 = function() {\n        return { type: \"line_to\", command: \"|-\" };\n      };\n      var peg$f10 = function() {\n        return { type: \"line_to\", command: \"-|\" };\n      };\n      var peg$f11 = function() {\n        return { type: \"line_to\", command: \"--\" };\n      };\n      var peg$f12 = function(prefix, content) {\n        return { type: \"coordinate\", content, prefix };\n      };\n      var peg$f13 = function(content) {\n        return { type: \"square_brace_group\", content };\n      };\n      var peg$f14 = function(v) {\n        return { type: \"unknown\", content: v };\n      };\n      var peg$f15 = function(tok) {\n        return options.isSameLineComment(tok);\n      };\n      var peg$f16 = function(tok) {\n        return tok;\n      };\n      var peg$f17 = function(tok) {\n        return options.isOwnLineComment(tok);\n      };\n      var peg$f18 = function(tok) {\n        return tok;\n      };\n      var peg$f19 = function(tok) {\n        return options.isComment(tok);\n      };\n      var peg$f20 = function(tok) {\n        return tok;\n      };\n      var peg$f21 = function(tok) {\n        return options.isWhitespace(tok);\n      };\n      var peg$f22 = function(tok) {\n        return tok;\n      };\n      var peg$f23 = function(c) {\n        return c;\n      };\n      var peg$f24 = function(tok) {\n        return options.isOperation(tok);\n      };\n      var peg$f25 = function(tok) {\n        return { type: \"operation\", content: tok };\n      };\n      var peg$f26 = function(tok) {\n        return options.isChar(tok, \"=\");\n      };\n      var peg$f27 = function(tok) {\n        return tok;\n      };\n      var peg$f28 = function(tok) {\n        return options.isChar(tok, \"[\");\n      };\n      var peg$f29 = function(tok) {\n        return tok;\n      };\n      var peg$f30 = function(tok) {\n        return options.isChar(tok, \"]\");\n      };\n      var peg$f31 = function(tok) {\n        return tok;\n      };\n      var peg$f32 = function(tok) {\n        return options.isChar(tok, \"(\");\n      };\n      var peg$f33 = function(tok) {\n        return tok;\n      };\n      var peg$f34 = function(tok) {\n        return options.isChar(tok, \")\");\n      };\n      var peg$f35 = function(tok) {\n        return tok;\n      };\n      var peg$f36 = function(tok) {\n        return options.isChar(tok, \"+\");\n      };\n      var peg$f37 = function(tok) {\n        return tok;\n      };\n      var peg$f38 = function(tok) {\n        return options.isChar(tok, \"-\");\n      };\n      var peg$f39 = function(tok) {\n        return tok;\n      };\n      var peg$f40 = function(tok) {\n        return options.isChar(tok, \"|\");\n      };\n      var peg$f41 = function(tok) {\n        return tok;\n      };\n      var peg$f42 = function(tok) {\n        return options.isChar(tok, \".\");\n      };\n      var peg$f43 = function(tok) {\n        return tok;\n      };\n      var peg$f44 = function(tok) {\n        return options.isChar(tok, \"controls\");\n      };\n      var peg$f45 = function(tok) {\n        return tok;\n      };\n      var peg$f46 = function(tok) {\n        return options.isChar(tok, \"and\");\n      };\n      var peg$f47 = function(tok) {\n        return tok;\n      };\n      var peg$f48 = function(tok) {\n        return options.isChar(tok, \"svg\");\n      };\n      var peg$f49 = function(tok) {\n        return tok;\n      };\n      var peg$f50 = function(tok) {\n        return options.isGroup(tok);\n      };\n      var peg$f51 = function(tok) {\n        return tok;\n      };\n      var peg$f52 = function(tok) {\n        return options.isAnyMacro(tok);\n      };\n      var peg$f53 = function(tok) {\n        return tok;\n      };\n      var peg$f54 = function(tok) {\n        return options.isChar(tok, \"foreach\");\n      };\n      var peg$f55 = function(tok) {\n        return tok;\n      };\n      var peg$f56 = function(tok) {\n        return options.isMacro(tok, \"foreach\");\n      };\n      var peg$f57 = function(tok) {\n        return tok;\n      };\n      var peg$f58 = function(tok) {\n        return options.isChar(tok, \"in\");\n      };\n      var peg$f59 = function(tok) {\n        return tok;\n      };\n      var peg$f60 = function(tok) {\n        return options.isChar(tok, \":\");\n      };\n      var peg$f61 = function(tok) {\n        return tok;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$maxFailPos = 0;\n      var peg$maxFailExpected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return {\n          source: peg$source,\n          start: peg$savedPos,\n          end: peg$currPos\n        };\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError(\n          [peg$otherExpectation(description)],\n          input.substring(peg$savedPos, peg$currPos),\n          location2\n        );\n      }\n      function error(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text2, ignoreCase) {\n        return { type: \"literal\", text: text2, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts, inverted, ignoreCase };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos, offset2) {\n        var startPosDetails = peg$computePosDetails(startPos);\n        var endPosDetails = peg$computePosDetails(endPos);\n        var res = {\n          source: peg$source,\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n        if (offset2 && peg$source && typeof peg$source.offset === \"function\") {\n          res.start = peg$source.offset(res.start);\n          res.end = peg$source.offset(res.end);\n        }\n        return res;\n      }\n      function peg$fail(expected2) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected2);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(\n          peg$SyntaxError.buildMessage(expected2, found),\n          expected2,\n          found,\n          location2\n        );\n      }\n      function peg$parsepath_spec() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$currPos;\n        s3 = peg$parsesquare_brace_group();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsecoordinate();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsecurve_to();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseline_to();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsesvg();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parseforeach();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parseoperation();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parsecomment();\n                      if (s3 === peg$FAILED) {\n                        s3 = peg$parseanimation();\n                        if (s3 === peg$FAILED) {\n                          s3 = peg$parseunknown();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          peg$savedPos = s2;\n          s2 = peg$f0(s3);\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$currPos;\n            s3 = peg$parsesquare_brace_group();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsecoordinate();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsecurve_to();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parseline_to();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parsesvg();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parseforeach();\n                      if (s3 === peg$FAILED) {\n                        s3 = peg$parseoperation();\n                        if (s3 === peg$FAILED) {\n                          s3 = peg$parsecomment();\n                          if (s3 === peg$FAILED) {\n                            s3 = peg$parseanimation();\n                            if (s3 === peg$FAILED) {\n                              s3 = peg$parseunknown();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = peg$parse_();\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parse_();\n              }\n              peg$savedPos = s2;\n              s2 = peg$f0(s3);\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f1(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseanimation() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parsecolon();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_comment_();\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$parseoperation();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_comment_();\n            peg$savedPos = s4;\n            s4 = peg$f2(s2, s5, s6);\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$currPos;\n              s5 = peg$parseoperation();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_comment_();\n                peg$savedPos = s4;\n                s4 = peg$f2(s2, s5, s6);\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseequals();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_comment_();\n              s6 = peg$parsegroup();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f3(s2, s3, s5, s6);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseforeach() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseforeach_keyword();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseforeach_macro();\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseforeach_body();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseforeach_body() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n        s0 = peg$currPos;\n        s1 = peg$parse_comment_();\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parsein_keyword();\n        if (s6 === peg$FAILED) {\n          s6 = peg$parsesquare_brace_group();\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = void 0;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$e0);\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsein_keyword();\n          if (s6 === peg$FAILED) {\n            s6 = peg$parsesquare_brace_group();\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        s2 = input.substring(s2, peg$currPos);\n        s3 = peg$parsesquare_brace_group();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$parse_comment_();\n        s5 = peg$parsein_keyword();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_comment_();\n          s7 = peg$parsegroup();\n          if (s7 === peg$FAILED) {\n            s7 = peg$parsemacro();\n          }\n          if (s7 !== peg$FAILED) {\n            s8 = peg$parse_comment_();\n            s9 = peg$parseforeach();\n            if (s9 === peg$FAILED) {\n              s9 = peg$parsegroup();\n              if (s9 === peg$FAILED) {\n                s9 = peg$parsemacro();\n              }\n            }\n            if (s9 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesvg() {\n        var s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parsesvg_keyword();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_comment_();\n          s3 = peg$parsesquare_brace_group();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = peg$parse_comment_();\n          s5 = peg$parsegroup();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s2, s3, s4, s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecurve_to() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n        s0 = peg$currPos;\n        s1 = peg$parsedotdot();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_comment_();\n          s3 = peg$parsecontrols_keyword();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_comment_();\n            s5 = peg$parsecoordinate();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_comment_();\n              s7 = peg$currPos;\n              s8 = peg$parseand_keyword();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parse_comment_();\n                s10 = peg$parsecoordinate();\n                if (s10 !== peg$FAILED) {\n                  peg$savedPos = s7;\n                  s7 = peg$f7(s2, s4, s5, s6, s9, s10);\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 === peg$FAILED) {\n                s7 = null;\n              }\n              s8 = peg$parse_comment_();\n              s9 = peg$parsedotdot();\n              if (s9 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f8(s2, s4, s5, s6, s7, s8);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseline_to() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsepipe();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseminus();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f9();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseminus();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsepipe();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f10();\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseminus();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseminus();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f11();\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parsecoordinate() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$parseplus();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseplus();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s1 = input.substring(s1, peg$currPos);\n        s2 = peg$parseopen_paren();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parseclose_paren();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseclose_paren();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          s3 = input.substring(s3, peg$currPos);\n          s4 = peg$parseclose_paren();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f12(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesquare_brace_group() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parseopen_square_brace();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseclose_square_brace();\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$e0);\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseclose_square_brace();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$e0);\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          s2 = input.substring(s2, peg$currPos);\n          s3 = peg$parseclose_square_brace();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f13(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedotdot() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parsedot();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsedot();\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseunknown() {\n        var s0, s1;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f14(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parsesame_line_comment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f15(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f16(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e1);\n          }\n        }\n        return s0;\n      }\n      function peg$parseown_line_comment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f17(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f18(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e2);\n          }\n        }\n        return s0;\n      }\n      function peg$parsecomment() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f19(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f20(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e3);\n          }\n        }\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f21(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f22(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parse_comment_() {\n        var s0, s1, s2, s3, s4;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        s2 = peg$parsecomment();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s3 = [];\n        s4 = peg$parse_();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parse_();\n        }\n        peg$savedPos = s0;\n        s0 = peg$f23(s2);\n        peg$silentFails--;\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$e4);\n        }\n        return s0;\n      }\n      function peg$parseoperation() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f24(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e5);\n          }\n        }\n        return s0;\n      }\n      function peg$parseequals() {\n        var s0, s1, s2;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f26(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f27(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e6);\n          }\n        }\n        return s0;\n      }\n      function peg$parseopen_square_brace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f28(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f29(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseclose_square_brace() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f30(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f31(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseopen_paren() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f32(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f33(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseclose_paren() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f34(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f35(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseplus() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f36(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f37(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseminus() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f38(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f39(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsepipe() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f40(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f41(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsedot() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f42(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f43(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecontrols_keyword() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f44(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f45(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseand_keyword() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f46(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f47(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsesvg_keyword() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f48(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f49(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsegroup() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f50(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f51(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsemacro() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f52(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f53(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseforeach_keyword() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f54(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f55(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseforeach_macro() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f56(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f57(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsein_keyword() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f58(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f59(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parsecolon() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s2 = peg$f60(s1);\n          if (s2) {\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f61(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseEOL() {\n        var s0, s1;\n        s0 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$e0);\n          }\n        }\n        peg$silentFails--;\n        if (s1 === peg$FAILED) {\n          s0 = void 0;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      if (!options.isWhitespace) {\n        try {\n          Object.assign(options, {\n            isChar: (node, char) => node.type === \"string\" && node.content === char,\n            isOperation: (node) => node.type === \"string\" && node.content.match(/[a-zA-Z]/),\n            isWhitespace: (node) => node.type === \"whitespace\" || node.type === \"parbreak\",\n            isSameLineComment: (node) => node.type === \"comment\" && node.sameline,\n            isOwnLineComment: (node) => node.type === \"comment\" && !node.sameline,\n            isComment: (node) => node.type === \"comment\",\n            isGroup: (node) => node.type === \"group\",\n            isMacro: (node, name) => node.type === \"macro\" && node.content === name,\n            isAnyMacro: (node) => node.type === \"macro\"\n          });\n        } catch (e) {\n          console.warn(\"Error when initializing parser\", e);\n        }\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(\n          peg$maxFailExpected,\n          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n        );\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }()\n);\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n// This file needs to be here because typescript does not know how to use babel's transpiler\n// to directly load Pegjs grammars.\n// @ts-nocheck\nimport _LatexPegParser from \"../grammars/latex.pegjs\";\nimport _AlignEnvironmentPegParser from \"../grammars/align-environment.pegjs\";\nimport _ArgSpecPegParser from \"../grammars/xparse-argspec.pegjs\";\nimport _PgfkeysPegParser from \"../grammars/pgfkeys.pegjs\";\nimport _MacroSubstitutionPegParser from \"../grammars/macro-substitutions.pegjs\";\nimport _LigaturesPegParser from \"../grammars/ligatures.pegjs\";\nimport _XColorPegParser from \"../grammars/xcolor-expressions.pegjs\";\nimport _TabularPegParser from \"../grammars/tabular-spec.pegjs\";\nimport _SystemePegParser from \"../grammars/systeme-environment.pegjs\";\nimport _GluePegParser from \"../grammars/tex-glue.pegjs\";\nimport _TikzPegParser from \"../grammars/tikz.pegjs\";\n\ntype PegParser = {\n    parse: (input: string | unknown[], options?: unknown) => any;\n    SyntaxError: (\n        message: string,\n        expected: string,\n        found: unknown,\n        location: unknown\n    ) => unknown;\n};\n\nconst LatexPegParser = _LatexPegParser as PegParser;\nconst AlignEnvironmentPegParser = _AlignEnvironmentPegParser as PegParser;\nconst ArgSpecPegParser = _ArgSpecPegParser as PegParser;\nconst PgfkeysPegParser = _PgfkeysPegParser as PegParser;\nconst MacroSubstitutionPegParser = _MacroSubstitutionPegParser as PegParser;\nconst LigaturesPegParser = _LigaturesPegParser as PegParser;\nconst XColorPegParser = _XColorPegParser as PegParser;\nconst TabularPegParser = _TabularPegParser as PegParser;\nconst SystemePegParser = _SystemePegParser as PegParser;\nconst GluePegParser = _GluePegParser as PegParser;\nconst TikzPegParser = _TikzPegParser as PegParser;\n\nexport {\n    LatexPegParser,\n    AlignEnvironmentPegParser,\n    ArgSpecPegParser,\n    PgfkeysPegParser,\n    MacroSubstitutionPegParser,\n    LigaturesPegParser,\n    XColorPegParser,\n    TabularPegParser,\n    SystemePegParser,\n    GluePegParser,\n    TikzPegParser,\n};\n", "import { ArgSpecPegParser as PegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as ArgSpec from \"./argspec-types\";\n\n/**\n * Produce a string containing any decorators for the argspec node.\n * For example, `!` in front of a node means \"don't accept leading whitespace\"\n */\nfunction getDecorators(node: ArgSpec.Node): string {\n    let ret = \"\";\n    if ((node as ArgSpec.LeadingWhitespace).noLeadingWhitespace) {\n        ret += \"!\";\n    }\n    return ret;\n}\n\n/**\n * Print an `xparse` argument specification AST\n * to a string.\n */\nexport function printRaw(\n    node: ArgSpec.Node | string | (ArgSpec.Node | string)[],\n    root = false\n): string {\n    if (typeof node === \"string\") {\n        return node;\n    }\n\n    if (Array.isArray(node)) {\n        const sepToken = root ? \" \" : \"\";\n        return node.map((tok) => printRaw(tok)).join(sepToken);\n    }\n\n    const decorators = getDecorators(node);\n    const defaultArg = printDefaultArg(\n        \"defaultArg\" in node ? node.defaultArg : undefined,\n        // `embellishment`s are the only spec that can have multiple default args\n        node.type === \"embellishment\"\n    );\n    let spec = decorators;\n\n    const type = node.type;\n    switch (type) {\n        case \"body\":\n            return decorators + \"b\";\n        case \"optionalStar\":\n            return decorators + \"s\";\n        case \"optionalToken\":\n            return spec + \"t\" + node.token;\n        case \"optional\":\n            // [...] is the default enclosure for optional arguments\n            if (node.openBrace === \"[\" && node.closeBrace === \"]\") {\n                spec += node.defaultArg ? \"O\" : \"o\";\n            } else {\n                spec += node.defaultArg ? \"D\" : \"d\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"mandatory\":\n            // {...} is the default enclosure for mandatory arguments\n            if (node.openBrace === \"{\" && node.closeBrace === \"}\") {\n                spec += \"m\";\n            } else {\n                spec += node.defaultArg ? \"R\" : \"r\";\n                spec += node.openBrace + node.closeBrace;\n            }\n            return spec + defaultArg;\n        case \"embellishment\":\n            spec += node.defaultArg ? \"E\" : \"e\";\n            return (\n                spec +\n                \"{\" +\n                printRaw(node.embellishmentTokens) +\n                \"}\" +\n                defaultArg\n            );\n        case \"verbatim\":\n            return spec + \"v\" + node.openBrace;\n        case \"group\":\n            return spec + \"{\" + printRaw(node.content) + \"}\";\n        case \"until\": {\n            const stopTokens = printRaw(node.stopTokens);\n            return stopTokens.length > 1 || stopTokens[0] === \" \"\n                ? `u{${stopTokens}}`\n                : `u${stopTokens}`;\n        }\n        default:\n            const neverType: never = type;\n            console.warn(`Unknown node type \"${neverType}\" for node`, node);\n            return \"\";\n    }\n}\n\nconst parseCache: { [argStr: string]: ArgSpec.Node[] } = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): ArgSpec.Node[] {\n    parseCache[str] = parseCache[str] || PegParser.parse(str);\n    return parseCache[str];\n}\n\nfunction printDefaultArg(\n    args: string | string[] | undefined,\n    multipleArgs: boolean\n): string {\n    if (!args) {\n        return \"\";\n    }\n    if (typeof args === \"string\") {\n        args = [args];\n    }\n    if (!multipleArgs) {\n        return `{${args.join(\"\")}}`;\n    }\n    return `{${args.map((a) => `{${a}}`).join(\"\")}}`;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Scan `nodes` looking for the first occurrence of `token`.\n * If `options.onlySkipWhitespaceAndComments==true`, then the scan\n * will only skip whitespace/comment nodes.\n */\nexport function scan(\n    nodes: (Ast.Node | Ast.Argument)[],\n    token: string | Ast.Node | Ast.Argument,\n    options?: {\n        /**\n         * Index to start scanning.\n         */\n        startIndex?: number;\n        /**\n         * If `true`, whitespace and comments will be skilled but any other\n         * node that doesn't match `token` will cause the scan to terminate.\n         */\n        onlySkipWhitespaceAndComments?: boolean;\n        /**\n         * If `true`, will look inside `Ast.String` nodes to see if the string contents\n         * contain `token`.\n         */\n        allowSubstringMatches?: boolean;\n    }\n): number | null {\n    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } =\n        options || {};\n    if (typeof token === \"string\") {\n        token = { type: \"string\", content: token } as Ast.String;\n    }\n\n    for (let i = startIndex || 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.type === token.type) {\n            switch (node.type) {\n                case \"comment\":\n                case \"displaymath\":\n                case \"inlinemath\":\n                case \"root\":\n                case \"parbreak\":\n                case \"whitespace\":\n                case \"verb\":\n                case \"verbatim\":\n                case \"group\":\n                    return i;\n                case \"macro\":\n                    if (node.content === (token as Ast.Macro).content) {\n                        return i;\n                    }\n                    break;\n                case \"environment\":\n                case \"mathenv\":\n                    if (\n                        printRaw(node.env) ===\n                        printRaw((token as Ast.Environment).env)\n                    ) {\n                        return i;\n                    }\n                    break;\n                case \"string\":\n                    if (node.content === (token as Ast.String).content) {\n                        return i;\n                    }\n                    if (\n                        allowSubstringMatches &&\n                        node.content.indexOf((token as Ast.String).content) >= 0\n                    ) {\n                        return i;\n                    }\n                    break;\n            }\n        }\n        if (\n            onlySkipWhitespaceAndComments &&\n            !match.whitespace(node) &&\n            !match.comment(node)\n        ) {\n            return null;\n        }\n    }\n\n    return null;\n}\n", "import Trie from \"trie-prefix-tree\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nexport { Trie };\n\n/**\n * Efficiently search for a large number of strings using a prefix-tree.\n * The longest match is returned.\n *\n * @param options.startIndex the index to start scanning at. Defaults to 0.\n * @param options.matchSubstrings whether to allow matching only part of a substring.\n * @param options.assumeOneCharStrings assume that all strings are one character long (for example, like they are in math mode)\n */\nexport function prefixMatch(\n    nodes: Ast.Node[],\n    prefixes: string | string[] | ReturnType<typeof Trie>,\n    options?: {\n        startIndex?: number;\n        matchSubstrings?: boolean;\n        assumeOneCharStrings?: boolean;\n    }\n): {\n    match: string;\n    endNodeIndex: number;\n    endNodePartialMatch: string | null;\n} | null {\n    const {\n        startIndex = 0,\n        matchSubstrings = false,\n        assumeOneCharStrings = false,\n    } = options || {};\n\n    if (typeof prefixes === \"string\") {\n        prefixes = [prefixes];\n    }\n    if (Array.isArray(prefixes)) {\n        prefixes = Trie(prefixes);\n    }\n    const prefixTree = prefixes;\n\n    const history = {\n        lastPrefix: \"\",\n        lastWord: \"\",\n        index: startIndex,\n        partialMatch: \"\",\n    };\n\n    /**\n     * Try to match the next character. If it matches,\n     * record it properly in the `history` object.\n     */\n    function tryToMatchNextChar(char: string, index: number): boolean {\n        let ret = false;\n        if (prefixTree.isPrefix(history.lastPrefix + char)) {\n            history.lastPrefix += char;\n            history.index = index;\n            ret = true;\n        }\n        if (prefixTree.hasWord(history.lastPrefix)) {\n            history.lastWord = history.lastPrefix;\n        }\n        return ret;\n    }\n\n    // Loop through the nodes looking for the longest prefix match\n    for (let i = 0; startIndex + i < nodes.length; i++) {\n        const node = nodes[startIndex + i];\n        if (!match.string(node)) {\n            break;\n        }\n        if (assumeOneCharStrings && node.content.length !== 1) {\n            break;\n        }\n        if (matchSubstrings) {\n            // We need to test letter-by-letter for substring matches\n            let fullMatch = true;\n            history.partialMatch = \"\";\n            for (let j = 0; j < node.content.length; j++) {\n                const char = node.content[j];\n                if (tryToMatchNextChar(char, startIndex + i)) {\n                    history.partialMatch += char;\n                } else {\n                    fullMatch = false;\n                    break;\n                }\n            }\n            if (fullMatch) {\n                history.partialMatch = \"\";\n            } else {\n                break;\n            }\n        } else {\n            if (!tryToMatchNextChar(node.content, startIndex + i)) {\n                break;\n            }\n        }\n    }\n\n    return history.lastWord\n        ? {\n              match: history.lastWord,\n              endNodeIndex: history.index,\n              endNodePartialMatch: history.partialMatch\n                  ? history.partialMatch\n                  : null,\n          }\n        : null;\n}\n", "/* eslint-disable no-fallthrough */\nimport { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    printRaw,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`.\n * If an argument couldn't be found, `argument` will be `null`.\n */\nexport function gobbleSingleArgument(\n    nodes: Ast.Node[],\n    argSpec: ArgSpec.Node,\n    startPos = 0\n): {\n    argument: Ast.Argument | null;\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"string\" || !argSpec.type) {\n        throw new Error(\n            `argSpec must be an already-parsed argument specification, not \"${JSON.stringify(\n                argSpec\n            )}\"`\n        );\n    }\n\n    let argument: Ast.Argument | null = null;\n\n    let currPos = startPos;\n\n    // Gobble whitespace from `currPos` onward, updating `currPos`.\n    // If `argSpec` specifies leading whitespace is not allowed,\n    // this function does nothing.\n    const gobbleWhitespace = (argSpec as ArgSpec.LeadingWhitespace)\n        .noLeadingWhitespace\n        ? () => {}\n        : () => {\n              while (currPos < nodes.length) {\n                  if (!match.whitespace(nodes[currPos])) {\n                      break;\n                  }\n                  currPos++;\n              }\n          };\n\n    const openMark: string = (argSpec as any).openBrace || \"\";\n    const closeMark: string = (argSpec as any).closeBrace || \"\";\n\n    // Only mandatory arguments can be wrapped in {...}.\n    // Since we already parse such things as groups, we need to\n    // check the open and closing symbols to see if we allow for\n    // groups to be accepted as arguments\n    const acceptGroup =\n        (argSpec.type === \"mandatory\" || argSpec.type === \"optional\") &&\n        openMark === \"{\" &&\n        closeMark === \"}\";\n\n    // Do the actual matching\n    gobbleWhitespace();\n    const currNode = nodes[currPos];\n    if (\n        currNode == null ||\n        match.comment(currNode) ||\n        match.parbreak(currNode)\n    ) {\n        const ret: { argument: null; nodesRemoved: number } = {\n            argument,\n            nodesRemoved: 0,\n        };\n        return ret;\n    }\n\n    switch (argSpec.type) {\n        case \"mandatory\":\n            if (acceptGroup) {\n                // We have already gobbled whitespace, so at this point, `currNode`\n                // is either an openMark or we don't have an optional argument.\n                let content: Ast.Node[] = [currNode];\n                if (match.group(currNode)) {\n                    // Unwrap a group if there is one.\n                    content = currNode.content;\n                }\n                argument = arg(content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            } else {\n                const bracePos = findBracePositions(\n                    nodes,\n                    currPos,\n                    openMark,\n                    closeMark\n                );\n                if (bracePos) {\n                    argument = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {\n                        openMark,\n                        closeMark,\n                    });\n                    currPos = bracePos[1] + 1;\n                    break;\n                }\n            }\n        // NOTE: Fallthrough is on purpose.\n        // Matching a mandatory argument and an optional argument is the same for our purposes\n        // because we're not going to fail to parse because of a missing argument.\n        case \"optional\":\n            // It is possible that an optional argument accepts a group if its open/close braces are `{}`\n            if (acceptGroup && match.group(currNode)) {\n                argument = arg(currNode.content, {\n                    openMark,\n                    closeMark,\n                });\n                currPos++;\n                break;\n            }\n            // If we're here, we have custom braces to match\n            const bracePos = findBracePositions(\n                nodes,\n                currPos,\n                openMark,\n                closeMark\n            );\n            if (bracePos) {\n                argument = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {\n                    openMark,\n                    closeMark,\n                });\n                currPos = bracePos[1] + 1;\n                break;\n            }\n            break;\n        case \"optionalStar\":\n        case \"optionalToken\": {\n            const bracePos = findBracePositions(\n                nodes,\n                currPos,\n                argSpec.type === \"optionalStar\" ? \"*\" : argSpec.token\n            );\n            if (bracePos) {\n                argument = arg(currNode, { openMark: \"\", closeMark: \"\" });\n                // Instead of `closeMarkPos` returned from findBracePositions,\n                // one should use `openMarkPos + ` because there's no argument\n                currPos = bracePos[0] + 1;\n            }\n            break;\n        }\n        case \"until\": {\n            if (argSpec.stopTokens.length > 1) {\n                console.warn(\n                    `\"until\" matches with multi-token stop conditions are not yet implemented`\n                );\n                break;\n            }\n            const rawToken = argSpec.stopTokens[0];\n            const stopToken: string | Ast.Whitespace =\n                rawToken === \" \" ? { type: \"whitespace\" } : rawToken;\n\n            let bracePos = findBracePositions(\n                nodes,\n                startPos,\n                undefined,\n                stopToken\n            );\n            // If the corresponding token is not found, eat nothing;\n            if (!bracePos) {\n                break;\n            }\n\n            argument = arg(nodes.slice(startPos, bracePos[1]), {\n                openMark: \"\",\n                closeMark: rawToken,\n            });\n            currPos = bracePos[1];\n            if (currPos < nodes.length) {\n                currPos++;\n            }\n            break;\n        }\n        case \"embellishment\": {\n            for (const token of argSpec.embellishmentTokens) {\n                const bracePos = findBracePositions(nodes, currPos, token);\n                if (!bracePos) {\n                    continue;\n                }\n                let argNode = nodes[bracePos[0] + 1];\n                argument = arg(\n                    match.group(argNode) ? argNode.content : argNode,\n                    {\n                        openMark: token,\n                        closeMark: \"\",\n                    }\n                );\n                currPos = bracePos[1] + 1;\n                break;\n            }\n            break;\n        }\n        default:\n            console.warn(\n                `Don't know how to find an argument of argspec type \"${argSpec.type}\"`\n            );\n    }\n\n    // `currPos` is has already stepped past any whitespace. However,\n    // if we did not consume an argument, we don't want to consume the whitespace.\n    const nodesRemoved = argument ? currPos - startPos : 0;\n    nodes.splice(startPos, nodesRemoved);\n    return { argument, nodesRemoved };\n}\n\nfunction cloneStringNode(node: Ast.String, content: string): Ast.String {\n    return Object.assign({}, node, { content });\n}\n\n/**\n * Find the position of the open brace and the closing brace.\n * Returns undefined if the brace isn't found.\n * This may mutate `nodes`, if braces are not a kind of characters that are\n * always parsed as a separate token\n */\nfunction findBracePositions(\n    nodes: Ast.Node[],\n    startPos: number,\n    openMark?: string,\n    closeMark?: string | Ast.Node\n): [number, number] | undefined {\n    const currNode = nodes[startPos];\n    let openMarkPos = startPos;\n    let closeMarkPos: number | null = startPos;\n    if (openMark) {\n        if (!match.anyString(currNode)) {\n            return;\n        }\n        const nodeContent = currNode.content;\n        // The first node we encounter must contain the opening brace.\n        if (!nodeContent.startsWith(openMark)) {\n            return;\n        }\n        openMarkPos = startPos;\n        if (currNode.content.length > openMark.length) {\n            const nodeContent = currNode.content;\n            currNode.content = openMark;\n            nodes.splice(\n                openMarkPos + 1,\n                0,\n                cloneStringNode(currNode, nodeContent.slice(openMark.length))\n            );\n        }\n        closeMarkPos = openMarkPos + 1;\n    }\n    if (!closeMark) {\n        // In such a case, the token immediately preceding the opening brace\n        // will be treated as an argument. If the next token is a string node,\n        // only its first character is picked up.\n        const argNode = nodes[closeMarkPos];\n        if (!argNode) {\n            return;\n        }\n        if (match.anyString(argNode) && argNode.content.length > 1) {\n            const argContent = argNode.content;\n            argNode.content = argContent[0];\n            nodes.splice(\n                closeMarkPos + 1,\n                0,\n                cloneStringNode(argNode, argContent.slice(1))\n            );\n        }\n        return [openMarkPos, closeMarkPos];\n    }\n    // scan for closing marks\n    closeMarkPos = scan(nodes, closeMark, {\n        startIndex: closeMarkPos,\n        allowSubstringMatches: true,\n    });\n    if (closeMarkPos === null) {\n        return;\n    }\n    const closingNode = nodes[closeMarkPos];\n    if (match.anyString(closingNode) && typeof closeMark === \"string\") {\n        const closingNodeContent = closingNode.content;\n        let closeMarkIndex = closingNodeContent.indexOf(closeMark);\n        if (closingNodeContent.length > closeMark.length) {\n            closingNode.content = closeMark;\n            const prev = closingNodeContent.slice(0, closeMarkIndex);\n            const next = closingNodeContent.slice(\n                closeMarkIndex + closeMark.length\n            );\n            if (prev) {\n                nodes.splice(\n                    closeMarkPos,\n                    0,\n                    cloneStringNode(closingNode, prev)\n                );\n                closeMarkPos++;\n            }\n            if (next) {\n                nodes.splice(\n                    closeMarkPos + 1,\n                    0,\n                    cloneStringNode(closingNode, next)\n                );\n            }\n        }\n    }\n    return [openMarkPos, closeMarkPos];\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { gobbleSingleArgument } from \"./gobble-single-argument\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\n\n/**\n * Gobbles an argument of whose type is specified\n * by `argSpec` starting at the position `startPos`. If an argument couldn't be found,\n * `argument` will be `null`.\n */\nexport function gobbleArguments(\n    nodes: Ast.Node[],\n    argSpec: string | ArgSpec.Node[] | ArgumentParser,\n    startPos = 0\n): {\n    args: Ast.Argument[];\n    nodesRemoved: number;\n} {\n    if (typeof argSpec === \"function\") {\n        return argSpec(nodes, startPos);\n    }\n\n    if (typeof argSpec === \"string\") {\n        argSpec = parseArgspec(argSpec);\n    }\n\n    const args: Ast.Argument[] = [];\n    let nodesRemoved = 0;\n\n    for (const spec of argSpec) {\n        if (spec.type === \"embellishment\") {\n            // We need special behavior for embellishment argspecs.\n            // Because an embellishment argspec specifies more than one argument,\n            // we need to keep gobbling arguments until we've got them all.\n            const remainingTokens = new Set(spec.embellishmentTokens);\n            const argForToken = Object.fromEntries(\n                spec.embellishmentTokens.map((t, i) => {\n                    // For empty arguments, we also store their default.\n                    const defaultArg =\n                        \"defaultArg\" in spec ? spec.defaultArg?.[i] : undefined;\n                    return [t, emptyArg(defaultArg)];\n                })\n            );\n\n            let { argument, nodesRemoved: removed } = gobbleSingleArgument(\n                nodes,\n                embellishmentSpec(remainingTokens),\n                startPos\n            );\n            while (argument) {\n                const token = argument.openMark;\n                remainingTokens.delete(token);\n                argForToken[token] = argument;\n                nodesRemoved += removed;\n                const newSpec = embellishmentSpec(remainingTokens);\n                ({ argument, nodesRemoved: removed } = gobbleSingleArgument(\n                    nodes,\n                    newSpec,\n                    startPos\n                ));\n            }\n\n            args.push(...spec.embellishmentTokens.map((t) => argForToken[t]));\n        } else {\n            const { argument, nodesRemoved: removed } = gobbleSingleArgument(\n                nodes,\n                spec,\n                startPos\n            );\n            // For empty arguments, we also store their default.\n            const defaultArg =\n                \"defaultArg\" in spec ? spec.defaultArg : undefined;\n            args.push(argument || emptyArg(defaultArg));\n            nodesRemoved += removed;\n        }\n    }\n\n    return { args, nodesRemoved };\n}\n\n/**\n * Create an embellishment argspec from a set of tokens.\n */\nfunction embellishmentSpec(tokens: Set<string>): ArgSpec.Embellishment {\n    return {\n        type: \"embellishment\",\n        embellishmentTokens: [...tokens],\n    };\n}\n\n/**\n * Create an empty argument.\n */\nfunction emptyArg(defaultArg?: string): Ast.Argument {\n    const ret = arg([], { openMark: \"\", closeMark: \"\" });\n    if (defaultArg != null) {\n        updateRenderInfo(ret, { defaultArg });\n    }\n    return ret;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"./gobble-arguments\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Search (in a right-associative way) through the array for instances of\n * `macros` and attach arguments to the macro. Argument signatures are\n * specified by `macros[].signature`.\n *\n * Info stored in `macros[].renderInfo` will be attached to the node\n * with attribute `_renderInfo`.\n */\nexport function attachMacroArgsInArray(\n    nodes: Ast.Node[],\n    macros: MacroInfoRecord\n): void {\n    // Some preliminaries that are only used if `ast` is an array.\n    let currIndex: number;\n\n    /**\n     * Determine whether `node` matches one of the macros in `macros`.\n     * Care is taken when matching because not all macros have\n     * `\\` as their escape token.\n     */\n    const isRelevantMacro = match.createMacroMatcher(macros);\n\n    function gobbleUntilMacro() {\n        // Step backwards until we find the required macro\n        while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {\n            currIndex--;\n        }\n    }\n\n    // Search for an occurrence of any of the macros `macroName` and its arguments.\n    // Some macros are right-associative, so we should start searching from\n    // the right\n    currIndex = nodes.length - 1;\n    while (currIndex >= 0) {\n        gobbleUntilMacro();\n        if (currIndex < 0) {\n            // We didn't find an occurrence of the macro\n            return;\n        }\n\n        // Store the currIndex, which is where the macro is. Start searching\n        // for its arguments at the next index.\n        const macroIndex = currIndex;\n        const macro = nodes[macroIndex] as Ast.Macro;\n        const macroName = macro.content;\n        const macroInfo = macros[macroName];\n\n        // Add `._renderInfo` if we have any\n        updateRenderInfo(macro, macroInfo.renderInfo);\n\n        const signatureOrParser =\n            macroInfo.argumentParser || macroInfo.signature;\n\n        // If the macro has no signature, it shouldn't consume any arguments. Just move along.\n        // Note: It is important that this happens *after* `updateRenderInfo` is called, since\n        // we still want to update the render info even if there are no args.\n        if (signatureOrParser == null) {\n            currIndex--;\n            continue;\n        }\n\n        // We don't want to search for macro arguments if we already\n        // found them. If the macro has arguments, we assume that\n        // they've already been attached\n        if (macro.args != null) {\n            currIndex = macroIndex - 1;\n            continue;\n        }\n\n        // `currIndex` is the position of the macro. We want to start\n        // looking for the arguments right after the macro\n        currIndex++;\n        const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);\n        macro.args = args;\n        // After we've gobbled the arguments, set\n        // ourselves one space before the macro so we can continue.\n        currIndex = macroIndex - 1;\n    }\n}\n\n/**\n * Recursively search for and attach the arguments for a\n * particular macro to its AST node. `macros` should\n * contain a `signature` property which specifies the arguments\n * signature in xparse syntax.\n */\nexport function attachMacroArgs(tree: Ast.Ast, macros: MacroInfoRecord) {\n    visit(\n        tree,\n        (nodes) => {\n            attachMacroArgsInArray(nodes, macros);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { MacroInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { attachMacroArgsInArray } from \"./attach-arguments\";\n\ntype PluginOptions = { macros: MacroInfoRecord } | undefined;\n\n/**\n * Unified plugin to attach macro arguments to the macros specified via the `macros`\n * option.\n *\n * @param macros An object whose keys are macro names and values contains information about the macro and its argument signature.\n */\nexport const unifiedLatexAttachMacroArguments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree) => {\n        const { macros = {} } = options || {};\n        if (Object.keys(macros).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n        visit(\n            tree,\n            (nodes) => {\n                attachMacroArgsInArray(nodes, macros);\n            },\n            { includeArrays: true, test: Array.isArray }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Returns the content of `args` for a macro or environment as an array. If an argument\n * was omitted (e.g., because it was an optional arg that wasn't included), then `null` is returned.\n */\nexport function getArgsContent(\n    node: Ast.Macro | Ast.Environment\n): (Ast.Node[] | null)[] {\n    if (!Array.isArray(node.args)) {\n        return [];\n    }\n\n    return node.args.map((arg) => {\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            return null;\n        }\n        return arg.content;\n    });\n}\n\n/**\n * Returns the content of `args` for a macro or environment as an object whose keys are the \"names\"\n * of each argument. These names of the arguments must be specified in the `_renderInfo` prop. If `_renderInfo`\n * does not contain a `namedArguments` array, then an empty object will be returned.\n *\n * @namedArgumentsFallback - If `_renderInfo.namedArguments` is not provided, `namedArgumentsFallback` is ued.\n */\nexport function getNamedArgsContent(\n    node: Ast.Macro | Ast.Environment,\n    namedArgumentsFallback: readonly (string | null)[] = []\n): Record<string, Ast.Node[] | null> {\n    const names = node._renderInfo?.namedArguments || namedArgumentsFallback;\n\n    if (\n        !Array.isArray(node.args) ||\n        !Array.isArray(names) ||\n        names.length === 0\n    ) {\n        return {};\n    }\n    const ret: Record<string, Ast.Node[] | null> = {};\n\n    node.args.forEach((arg, i) => {\n        const name = names[i];\n        if (name == null) {\n            // If a null name was given, it shouldn't be listed as a named argument.\n            return;\n        }\n        let val: Ast.Node[] | null = arg.content;\n        if (arg.openMark === \"\" && arg.content.length === 0) {\n            val = null;\n        }\n        ret[name] = val;\n    });\n\n    return ret;\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport { Argument, ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { parse as parseArgspec } from \"@unified-latex/unified-latex-util-argspec\";\nimport { Node } from \"@unified-latex/unified-latex-util-argspec/libs/argspec-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nconst argSpecM = parseArgspec(\"m\")[0];\nconst argSpecO = parseArgspec(\"o\")[0];\nconst argSpecRDelim: { [delim: string]: Node } = {};\n\n/**\n * This argument parser parses arguments in the form of\n * - [⟨key=value list⟩]⟨character⟩⟨source code⟩⟨same character⟩\n * - [⟨key=value list⟩]{⟨source code⟩}\n */\nexport const argumentParser: ArgumentParser = (nodes, startPos) => {\n    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecO, startPos);\n\n    let codeArg: Argument | Argument[] | null = null;\n    let codeArgNodesRemoved: number = 0;\n    const nextNode = nodes[startPos];\n    if (match.group(nextNode)) {\n        const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);\n        codeArg = mandatoryArg.argument;\n        codeArgNodesRemoved = mandatoryArg.nodesRemoved;\n    } else if (match.string(nextNode) && nextNode.content.length === 1) {\n        const delim = nextNode.content;\n        argSpecRDelim[delim] =\n            argSpecRDelim[delim] || parseArgspec(`r${delim}${delim}`)[0];\n        const delimArg = gobbleSingleArgument(\n            nodes,\n            argSpecRDelim[delim],\n            startPos\n        );\n        codeArg = delimArg.argument;\n        codeArgNodesRemoved = delimArg.nodesRemoved;\n    }\n\n    return {\n        args: [optionalArg || arg(null), codeArg || arg(null)],\n        nodesRemoved: optionalArgNodesRemoved + codeArgNodesRemoved,\n    };\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { argumentParser } from \"./libs/argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    lstset: { signature: \"m\" },\n    lstinline: { argumentParser: argumentParser },\n    lstinputlisting: { signature: \"o m\" },\n    lstdefinestyle: { signature: \"m m\" },\n    lstnewenvironment: { signature: \"m o o m m\" },\n    lstMakeShortInline: { signature: \"o m\" },\n    lstDeleteShortInline: { signature: \"m\" },\n    lstdefineformat: { signature: \"m m\" },\n    lstdefinelanguage: { signature: \"o m o m o\" },\n    lstalias: { signature: \"o m o m\" },\n    lstloadlanguages: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    see: { signature: \"m m\" },\n    seealso: { signature: \"m m\" },\n    seename: { signature: \"m\" },\n    alsoname: { signature: \"m\" },\n    index: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    mathtoolsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    mathllap: {\n        signature: \"o m\",\n    },\n    mathrlap: {\n        signature: \"o m\",\n    },\n    mathclap: {\n        signature: \"o m\",\n    },\n    clap: {\n        signature: \"m\",\n    },\n    mathmbox: {\n        signature: \"m\",\n    },\n    mathmakebox: {\n        signature: \"o o m\",\n    },\n    cramped: {\n        signature: \"o m\",\n    },\n    crampedllap: {\n        signature: \"o m\",\n    },\n    crampedrlap: {\n        signature: \"o m\",\n    },\n    crampedclap: {\n        signature: \"o m\",\n    },\n    crampedsubstack: {\n        signature: \"o m\",\n    },\n    smashoperator: {\n        signature: \"o m\",\n    },\n    newtagform: {\n        signature: \"m o m m\",\n    },\n    renewtagform: {\n        signature: \"m o m m\",\n    },\n    usetagform: {\n        signature: \"m\",\n    },\n    xleftrightarrow: { signature: \"o m\" },\n    xLeftarrow: { signature: \"o m\" },\n    xhookleftarrow: { signature: \"o m\" },\n    xmapsto: { signature: \"o m\" },\n    xRightarrow: { signature: \"o m\" },\n    xLeftrightarrow: { signature: \"o m\" },\n    xhookrightarrow: { signature: \"o m\" },\n    underbracket: { signature: \"o o m\" },\n    overbracket: { signature: \"o o m\" },\n    underbrace: { signature: \"m\" },\n    overbrace: { signature: \"m\" },\n    shoveleft: { signature: \"o m\" },\n    shoveright: { signature: \"o m\" },\n    ArrowBetweenLines: { signature: \"s o\" },\n    vdotswithin: { signature: \"m\" },\n    shortdotswithin: { signature: \"s m\" },\n    DeclarePairedDelimiter: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterX: {\n        signature: \"m o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclarePairedDelimiterXPP: {\n        signature: \"m o m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    prescript: { signature: \"m m m\" },\n    DeclareMathSizes: { signature: \"m m m m\" },\n    newgathered: { signature: \"m m m m\" },\n    renewgathered: { signature: \"m m m m\" },\n    splitfrac: { signature: \"m m\" },\n    splitdfrac: { signature: \"m m\" },\n    xmathstrut: { signature: \"o m\" },\n    // amsthm\n    newtheorem: { signature: \"s m o m o\", renderInfo: { breakAround: true } },\n    theoremstyle: { signature: \"m\", renderInfo: { breakAround: true } },\n    newtheoremstyle: {\n        signature: \"m m m m m m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    // amsmath\n    text: { signature: \"m\", renderInfo: { inMathMode: false } },\n    // amsfonts\n    mathbb: { signature: \"m\" },\n    mathscr: { signature: \"m\" },\n    mathfrak: { signature: \"m\" },\n    frak: { signature: \"m\" },\n    Bdd: { signature: \"m\" },\n    bold: { signature: \"m\" },\n    // amsopn\n    operatorname: { signature: \"s m\" },\n    DeclareMathOperator: {\n        signature: \"s m m\",\n        renderInfo: { breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    crampedsubarray: {\n        signature: \"m\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    matrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"matrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"pmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"smallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"psmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Bsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    \"Vsmallmatrix*\": {\n        signature: \"o\",\n        renderInfo: { alignContent: true, inMathMode: true },\n    },\n    multilined: { signature: \"o o\", renderInfo: { inMathMode: true } },\n    cases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"cases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    dcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"dcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    rcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"rcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    drcases: { renderInfo: { alignContent: true, inMathMode: true } },\n    \"drcases*\": { renderInfo: { alignContent: true, inMathMode: true } },\n    spreadlines: { signature: \"m\", renderInfo: { inMathMode: true } },\n    lgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    rgathered: { signature: \"o\", renderInfo: { inMathMode: true } },\n    // amsmath\n    \"align*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    align: { renderInfo: { inMathMode: true, alignContent: true } },\n    aligned: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"alignat*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    alignat: { renderInfo: { inMathMode: true, alignContent: true } },\n    \"equation*\": { renderInfo: { inMathMode: true } },\n    equation: { renderInfo: { inMathMode: true } },\n    \"gather*\": { renderInfo: { inMathMode: true } },\n    gather: { renderInfo: { inMathMode: true } },\n    \"multline*\": { renderInfo: { inMathMode: true } },\n    multline: { renderInfo: { inMathMode: true } },\n    \"flalign*\": { renderInfo: { inMathMode: true, alignContent: true } },\n    flalign: { renderInfo: { inMathMode: true, alignContent: true } },\n    split: { renderInfo: { inMathMode: true } },\n    // Math environments\n    displaymath: { renderInfo: { inMathMode: true } },\n    // Typical amsthm environments\n    theorem: { signature: \"o\" },\n    lemma: { signature: \"o\" },\n    definition: { signature: \"o\" },\n    proposition: { signature: \"o\" },\n    corollary: { signature: \"o\" },\n    remark: { signature: \"!o\" },\n    example: { signature: \"!o\" },\n    proof: { signature: \"o\" },\n};\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport { Argument, ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { parse as parseArgspec } from \"@unified-latex/unified-latex-util-argspec\";\nimport { Node } from \"@unified-latex/unified-latex-util-argspec/libs/argspec-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\n\nconst argSpecM = parseArgspec(\"m\")[0];\nconst argSpecO = parseArgspec(\"o\")[0];\nconst argSpecRDelim: { [delim: string]: Node } = {};\n\n/**\n * This argument parser parses arguments in the form of\n * - [⟨options⟩]{⟨language⟩}⟨delim⟩⟨code⟩⟨delim⟩\n * - [⟨options⟩]{⟨language⟩}{⟨code⟩}\n */\nexport const argumentParser: ArgumentParser = (nodes, startPos) => {\n    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecO, startPos);\n\n    const { argument: languageArg, nodesRemoved: languageArgNodesRemoved } =\n        gobbleSingleArgument(nodes, argSpecM, startPos);\n\n    let codeArg: Argument | Argument[] | null = null;\n    let codeArgNodesRemoved: number = 0;\n    const nextNode = nodes[startPos];\n    if (match.group(nextNode)) {\n        const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);\n        codeArg = mandatoryArg.argument;\n        codeArgNodesRemoved = mandatoryArg.nodesRemoved;\n    } else if (match.string(nextNode) && nextNode.content.length === 1) {\n        const delim = nextNode.content;\n        argSpecRDelim[delim] =\n            argSpecRDelim[delim] || parseArgspec(`r${delim}${delim}`)[0];\n        const delimArg = gobbleSingleArgument(\n            nodes,\n            argSpecRDelim[delim],\n            startPos\n        );\n        codeArg = delimArg.argument;\n        codeArgNodesRemoved = delimArg.nodesRemoved;\n    }\n\n    return {\n        args: [\n            optionalArg || arg(null),\n            languageArg || arg(null),\n            codeArg || arg(null),\n        ],\n        nodesRemoved:\n            optionalArgNodesRemoved +\n            languageArgNodesRemoved +\n            codeArgNodesRemoved,\n    };\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { argumentParser } from \"./libs/argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    mint: { argumentParser: argumentParser },\n    mintinline: { argumentParser: argumentParser },\n    inputminted: { argumentParser: argumentParser },\n    usemintedstyle: { signature: \"m\" },\n    setminted: { signature: \"o m\" },\n    setmintedinline: { signature: \"o m\" },\n    newmint: { signature: \"o m m\" },\n    newminted: { signature: \"o m m\" },\n    newmintinline: { signature: \"o m m\" },\n    newmintedfile: { signature: \"o m m\" },\n};\n\nexport const environments: EnvInfoRecord = {\n    minted: { signature: \"o m\" },\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NiceMatrixOptions: {\n        signature: \"m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    NiceTabular: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrixBlock: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArrayWithDelims: {\n        signature: \"m m o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceArray: {\n        signature: \"o m !o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    NiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    pNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    bNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    BNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    vNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n    VNiceMatrix: {\n        signature: \"!o\",\n        renderInfo: { pgfkeysArgs: true, alignContent: true },\n    },\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    systeme: {\n        signature: \"s o o m\",\n        renderInfo: { inMathMode: true },\n    },\n    sysdelim: {\n        signature: \"m m\",\n    },\n    syseqsep: { signature: \"m\" },\n    sysalign: { signature: \"m\" },\n    syssignspace: { signature: \"m\" },\n    syseqspace: { signature: \"m\" },\n    syslineskipcoeff: { signature: \"m\" },\n    syseqivsign: { signature: \"m\" },\n    sysaddeqsign: { signature: \"m\" },\n    sysremoveeqsign: { signature: \"m\" },\n    sysextracolonsign: { signature: \"m\" },\n    syscodeextracol: { signature: \"m\" },\n    sysautonum: { signature: \"m\" },\n    syssubstitute: { signature: \"m\" },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "// globalThis polyfill from https://mathiasbynens.be/notes/globalthis\n(function () {\n    if (typeof globalThis === \"object\") {\n        return;\n    }\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n        get: function () {\n            return this;\n        },\n        configurable: true, // This makes it possible to `delete` the getter later.\n    });\n    __magic__.globalThis = __magic__; // lolwat\n    delete Object.prototype.__magic__;\n})();\n\nconst clone =\n    typeof globalThis.structuredClone === \"function\"\n        ? globalThis.structuredClone\n        : (obj: any) => JSON.parse(JSON.stringify(obj));\n\n/**\n * Wrapper around the built-in structured clone. Uses `JSON.parse(JSON.stringify(...))`\n * as a fallback.\n */\nexport function structuredClone<T>(obj: T): T {\n    return clone(obj);\n}\n\ndeclare global {\n    const __magic__: any;\n    interface Object {\n        __magic__?: any;\n    }\n}\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    ArgSpecAst as ArgSpec,\n    parse as parseArgspec,\n} from \"@unified-latex/unified-latex-util-argspec\";\nimport { Argument, ArgumentParser } from \"@unified-latex/unified-latex-types\";\nimport { gobbleSingleArgument } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { scan } from \"@unified-latex/unified-latex-util-scan\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\nconst OPTIONAL_ARGUMENT_ARG_SPEC = parseArgspec(\"o\")[0];\n\nfunction blankArg() {\n    return arg([], { openMark: \"\", closeMark: \"\" });\n}\n\n/**\n * Find the arguments of a tikz command. Many tikz commands accept either\n * the a group as their only argument, or they scan their arguments until the first\n * `;` is found.\n *\n * This behavior cannot be achieved via a standard xparse spec.\n */\nexport const tikzCommandArgumentParser: ArgumentParser = (nodes, startPos) => {\n    const origStartPos = startPos;\n    let pos = startPos;\n    let nodesRemoved = 0;\n\n    const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);\n    let animationArg = blankArg();\n    if (cursorPosAfterAnimations !== pos) {\n        const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);\n        trim(argContent);\n        animationArg = arg(argContent, {\n            openMark: \" \",\n            closeMark: \" \",\n        });\n    }\n    nodesRemoved += cursorPosAfterAnimations - pos;\n\n    const {\n        argument: _optionalArgument,\n        nodesRemoved: optionalArgumentNodesRemoved,\n    } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos) as {\n        argument: Argument;\n        nodesRemoved: number;\n    };\n    nodesRemoved += optionalArgumentNodesRemoved;\n    const optionalArg = _optionalArgument || blankArg();\n\n    // Eat whitespace\n    while (match.whitespace(nodes[pos])) {\n        pos++;\n    }\n    const firstNode = nodes[pos];\n\n    // If we're past the end of the array, give up.\n    if (!firstNode) {\n        return {\n            args: [animationArg, optionalArg, blankArg()],\n            nodesRemoved: 0,\n        };\n    }\n\n    // If we're a group, grab the contents and call it good.\n    if (match.group(firstNode)) {\n        const args = [animationArg, optionalArg, arg(firstNode.content)];\n        nodes.splice(origStartPos, pos - origStartPos + 1);\n        return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };\n    }\n\n    // No group, so scan for a semicolon.\n    const semicolonPosition = scan(nodes, \";\", { startIndex: pos });\n    if (semicolonPosition != null) {\n        const argNodes = nodes.splice(\n            origStartPos,\n            semicolonPosition - origStartPos + 1\n        );\n        trim(argNodes);\n        const args = [animationArg, optionalArg, arg(argNodes)];\n        return {\n            args,\n            nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved,\n        };\n    }\n\n    // If there was no semicolon, give up.\n    return {\n        args: [animationArg, optionalArg, blankArg()],\n        nodesRemoved: 0,\n    };\n};\n\n/**\n * Find the next index after all animation specs. If no animation specs are present,\n * return `startPos`.\n *\n * An animation spec looks like\n * ```\n * :rotate = { 0s=\"0\", 2s=\"90\", begin on=click }\n * ```\n * Any number can be listed. They start with a colon and have an equals sign followed by a group.\n */\nfunction eatAllAnimationSpecs(nodes: Ast.Node[], startPos: number): number {\n    const colonPos = scan(nodes, \":\", {\n        startIndex: startPos,\n        allowSubstringMatches: true,\n        onlySkipWhitespaceAndComments: true,\n    });\n\n    if (!colonPos) {\n        return startPos;\n    }\n\n    let lastMatchPos = startPos;\n    let i = colonPos + 1;\n    for (; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (match.string(node, \"[\")) {\n            // XXX As per the tikz manual, we stop scanning if we find an open square brace.\n            break;\n        }\n        if (match.string(node, \"=\")) {\n            i++;\n            // Look for a group next\n            while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {\n                i++;\n            }\n            if (!match.group(nodes[i])) {\n                break;\n            }\n            // We have a match!\n            lastMatchPos = i + 1;\n\n            // Start the process again\n            const colonPos = scan(nodes, \":\", {\n                startIndex: lastMatchPos,\n                allowSubstringMatches: true,\n                onlySkipWhitespaceAndComments: true,\n            });\n            if (colonPos == null) {\n                break;\n            }\n            i = colonPos + 1;\n        }\n    }\n\n    return lastMatchPos;\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { tikzCommandArgumentParser } from \"./libs/tikz-command-argument-parser\";\n\nexport const macros: MacroInfoRecord = {\n    pgfkeys: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzoption: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikzstyle: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usetikzlibrary: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    usepgfmodule: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    usepgflibrary: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    pgfplotsset: {\n        signature: \"m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    pgfplotstabletypeset: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    tikz: {\n        signature: \"o o m\",\n        argumentParser: tikzCommandArgumentParser,\n        renderInfo: { namedArguments: [\"animation\", \"options\", \"command\"] },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    tikzpicture: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    axis: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    scope: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfonlayer: {\n        signature: \"m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgflowlevelscope: {\n        signature: \"m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfviewboxscope: {\n        signature: \"m m m m m\",\n        renderInfo: { tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    pgftransparencygroup: {\n        signature: \"o\",\n        renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },\n        processContent: processTikzEnvironmentContent,\n    },\n    behindforegroundpath: {\n        signature: \"m\",\n        processContent: processTikzEnvironmentContent,\n    },\n    pgfmetadecoration: {\n        signature: \"m\",\n        processContent: processTikzEnvironmentContent,\n    },\n    colormixin: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n};\n\n/**\n * Attach macro arguments for all macros that are only available within a tikz environment.\n */\nfunction processTikzEnvironmentContent(nodes: Ast.Node[]): Ast.Node[] {\n    attachMacroArgsInArray(nodes, conditionalMacros);\n    return nodes;\n}\n\n/**\n * Macros that are only parsed inside a tikz environment.\n */\nexport const conditionalMacros: MacroInfoRecord = {\n    pgfextra: { signature: \"m\" },\n    beginpgfgraphicnamed: { signature: \"m\" },\n    pgfrealjobname: { signature: \"m\" },\n    pgfplotstreampoint: { signature: \"m\" },\n    pgfplotstreampointoutlier: { signature: \"m\" },\n    pgfplotstreamspecial: { signature: \"m\" },\n    pgfplotxyfile: { signature: \"m\" },\n    pgfplotxyzfile: { signature: \"m\" },\n    pgfplotfunction: { signature: \"mmm\" },\n    pgfplotgnuplot: { signature: \"o m\" },\n    pgfplothandlerrecord: { signature: \"m\" },\n    pgfdeclareplothandler: { signature: \"m m m\" },\n    pgfdeclarelayer: { signature: \"m\" },\n    pgfsetlayers: { signature: \"m\", renderInfo: { pgfkeysArgs: true } },\n    pgfonlayer: { signature: \"m\" },\n    startpgfonlayer: { signature: \"m\" },\n    pgfdeclarehorizontalshading: { signature: \"o m m m \" },\n    pgfdeclareradialshading: { signature: \"o m m m\" },\n    pgfdeclarefunctionalshading: { signature: \"o m m m m m\" },\n    pgfshadecolortorgb: { signature: \"m m\" },\n    pgfshadecolortocmyk: { signature: \"m m\" },\n    pgfshadecolortogray: { signature: \"m m\" },\n    pgfuseshading: { signature: \"m\" },\n    pgfshadepath: { signature: \"m m\" },\n    pgfsetadditionalshadetransform: { signature: \"m\" },\n    pgfsetstrokeopacity: { signature: \"m\" },\n    pgfsetfillopacity: { signature: \"m\" },\n    pgfsetblendmode: { signature: \"m\" },\n    pgfdeclarefading: { signature: \"m m\" },\n    pgfsetfading: { signature: \"m m\" },\n    pgfsetfadingforcurrentpath: { signature: \"m m\" },\n    pgfsetfadingforcurrentpathstroked: { signature: \"m m\" },\n    pgfanimateattribute: { signature: \"m m\" },\n    pgfsnapshot: { signature: \"m\" },\n    pgfqpoint: { signature: \"m m\" },\n    pgfqpointxy: { signature: \"m m\" },\n    pgfqpointxyz: { signature: \"m m m\" },\n    pgfqpointscale: { signature: \"m m\" },\n    pgfpathqmoveto: { signature: \"m m\" },\n    pgfpathqlineto: { signature: \"m m\" },\n    pgfpathqcurveto: { signature: \"m m m m m m\" },\n    pgfpathqcircle: { signature: \"m\" },\n    pgfqbox: { signature: \"m\" },\n    pgfqboxsynced: { signature: \"m\" },\n    pgfaliasimage: { signature: \"m m\" },\n    pgfuseimage: { signature: \"m\" },\n    pgfimage: { signature: \"o m\", renderInfo: { pgfkeysArgs: true } },\n    pgfdeclaremask: { signature: \"o m m\", renderInfo: { pgfkeysArgs: true } },\n    pgfdeclarepatternformonly: { signature: \"o m m m m m\" },\n    pgfdeclarepatterninherentlycolored: { signature: \"o m m m m m\" },\n    pgfsetfillpattern: { signature: \"m m\" },\n    // Coordinate canvas and nonlinear transformations\n    pgftransformshift: { signature: \"m\" },\n    pgftransformxshift: { signature: \"m\" },\n    pgftransformyshift: { signature: \"m\" },\n    pgftransformscale: { signature: \"m\" },\n    pgftransformxscale: { signature: \"m\" },\n    pgftransformyscale: { signature: \"m\" },\n    pgftransformxslant: { signature: \"m\" },\n    pgftransformyslant: { signature: \"m\" },\n    pgftransformrotate: { signature: \"m\" },\n    pgftransformtriangle: { signature: \"m m m\" },\n    pgftransformcm: { signature: \"m m m m m\" },\n    pgftransformarrow: { signature: \"m m\" },\n    pgftransformlineattime: { signature: \"m m m\" },\n    pgftransformcurveattime: { signature: \"m m m m m\" },\n    pgftransformarcaxesattime: { signature: \"m m m m m m\" },\n    pgfgettransform: { signature: \"m\" },\n    pgfsettransform: { signature: \"m\" },\n    pgfgettransformentries: { signature: \"m m m m m m\" },\n    pgfsettransformentries: { signature: \"m m m m m m\" },\n    pgfpointtransformed: { signature: \"m\" },\n    pgflowlevel: { signature: \"m\" },\n    pgflowlevelobj: { signature: \"m m\" },\n    pgflowlevelscope: { signature: \"m\" },\n    startpgflowlevelscope: { signature: \"m\" },\n    pgfviewboxscope: { signature: \"m m m m m\" },\n    startpgfviewboxscope: { signature: \"m m m m m\" },\n    pgftransformnonlinear: { signature: \"m\" },\n    pgfpointtransformednonlinear: { signature: \"m\" },\n    pgfsetcurvilinearbeziercurve: { signature: \"m m m m\" },\n    pgfcurvilineardistancetotime: { signature: \"m\" },\n    pgfpointcurvilinearbezierorthogonal: { signature: \"m m\" },\n    pgfpointcurvilinearbezierpolar: { signature: \"m m\" },\n    // Matrices\n    pgfmatrix: { signature: \"m m m m m m m\" },\n    pgfsetmatrixcolumnsep: { signature: \"m\" },\n    pgfmatrixnextcell: { signature: \"o\" },\n    pgfsetmatrixrowsep: { signature: \"m\" },\n    pgfmatrixendrow: { signature: \"o\" },\n    // Nodes and shapes\n    pgfnode: { signature: \"m m m m m\" },\n    pgfmultipartnode: { signature: \"m m m m\" },\n    pgfcoordinate: { signature: \"m m\" },\n    pgfnodealias: { signature: \"m m\" },\n    pgfnoderename: { signature: \"m m\" },\n    pgfpositionnodelater: { signature: \"m\" },\n    pgfpositionnodenow: { signature: \"m\" },\n    pgfnodepostsetupcode: { signature: \"m m\" },\n    pgfpointanchor: { signature: \"m m\" },\n    pgfpointshapeborder: { signature: \"m m\" },\n    pgfdeclareshape: { signature: \"m m\" },\n    saveddimen: { signature: \"m m\" },\n    savedmacro: { signature: \" m\" },\n    anchor: { signature: \"m m\" },\n    deferredanchor: { signature: \"m m\" },\n    anchorborder: { signature: \"m\" },\n    backgroundpath: { signature: \"m\" },\n    foregroundpath: { signature: \"m\" },\n    behindbackgroundpath: { signature: \"m\" },\n    beforebackgroundpath: { signature: \"m\" },\n    beforeforegroundpath: { signature: \"m\" },\n    behindforegroundpath: { signature: \"m\" },\n    // Arrows\n    pgfdeclarearrow: { signature: \"m\" },\n    pgfarrowssettipend: { signature: \"m\" },\n    pgfarrowssetbackend: { signature: \"m\" },\n    pgfarrowssetlineend: { signature: \"m\" },\n    pgfarrowssetvisualbackend: { signature: \"m\" },\n    pgfarrowssetvisualtipend: { signature: \"m\" },\n    pgfarrowshullpoint: { signature: \"m m\" },\n    pgfarrowsupperhullpoint: { signature: \"m m\" },\n    pgfarrowssave: { signature: \"m\" },\n    pgfarrowssavethe: { signature: \"m\" },\n    pgfarrowsaddtooptions: { signature: \"m\" },\n    pgfarrowsaddtolateoptions: { signature: \"m\" },\n    pgfarrowsaddtolengthscalelist: { signature: \"m\" },\n    pgfarrowsaddtowidthscalelist: { signature: \"m\" },\n    pgfarrowsthreeparameters: { signature: \"m\" },\n    pgfarrowslinewidthdependent: { signature: \"m m m\" },\n    pgfarrowslengthdependent: { signature: \"m\" },\n    // Path\n    pgfusepath: { signature: \"m\" },\n    pgfsetlinewidth: { signature: \"m\" },\n    pgfsetmiterlimit: { signature: \"m\" },\n    pgfsetdash: { signature: \"m m\" },\n    pgfsetstrokecolor: { signature: \"m\" },\n    pgfsetcolor: { signature: \"m\" },\n    pgfsetinnerlinewidth: { signature: \"m\" },\n    pgfsetinnerstrokecolor: { signature: \"m\" },\n    pgfsetarrowsstart: { signature: \"m\" },\n    pgfsetarrowsend: { signature: \"m\" },\n    pgfsetarrows: { signature: \"m\" },\n    pgfsetshortenstart: { signature: \"m\" },\n    pgfsetshortenend: { signature: \"m\" },\n    pgfsetfillcolor: { signature: \"m\" },\n    // Decorations\n    pgfdeclaredecoration: { signature: \"m m m\" },\n    state: { signature: \"m o m\" },\n    pgfdecoratepath: { signature: \"m m\" },\n    startpgfdecoration: { signature: \"m\" },\n    pgfdecoration: { signature: \"m\" },\n    pgfdecoratecurrentpath: { signature: \"m\" },\n    pgfsetdecorationsegmenttransformation: { signature: \"m\" },\n    pgfdeclaremetadecorate: { signature: \"m m m\" },\n    pgfmetadecoration: { signature: \"m\" },\n    startpgfmetadecoration: { signature: \"m\" },\n    // Constructing paths\n    pgfpathmoveto: { signature: \"m\" },\n    pgfpathlineto: { signature: \"m\" },\n    pgfpathcurveto: { signature: \"m m m\" },\n    pgfpathquadraticcurveto: { signature: \"m m\" },\n    pgfpathcurvebetweentime: { signature: \"m m m m m m\" },\n    pgfpathcurvebetweentimecontinue: { signature: \"m m m m m m\" },\n    pgfpatharc: { signature: \"m m m\" },\n    pgfpatharcaxes: { signature: \"m m m m\" },\n    pgfpatharcto: { signature: \"m m m m m m\" },\n    pgfpatharctoprecomputed: { signature: \"m m m m m m m m\" },\n    pgfpathellipse: { signature: \"m m m\" },\n    pgfpathcircle: { signature: \"m m\" },\n    pgfpathrectangle: { signature: \"m m\" },\n    pgfpathrectanglecorners: { signature: \"m m\" },\n    pgfpathgrid: { signature: \" o m m\" },\n    pgfpathparabola: { signature: \"m m\" },\n    pgfpathsine: { signature: \"m\" },\n    pgfpathcosine: { signature: \"m\" },\n    pgfsetcornersarced: { signature: \"m\" },\n    \"pgf@protocolsizes\": { signature: \"m m\" },\n    // Specifying coordinates\n    pgfpoint: { signature: \"m m\" },\n    pgfpointpolar: { signature: \"m m m\" },\n    pgfpointxy: { signature: \"m m\" },\n    pgfsetxvec: { signature: \"m\" },\n    pgfsetyvec: { signature: \"m\" },\n    pgfpointpolarxy: { signature: \"m m\" },\n    pgfpointxyz: { signature: \"m m m\" },\n    pgfsetzvec: { signature: \"m\" },\n    pgfpointcylindrical: { signature: \"m m m\" },\n    pgfpointspherical: { signature: \"m m m\" },\n    pgfpointadd: { signature: \"m m\" },\n    pgfpointscale: { signature: \"m m\" },\n    pgfpointdiff: { signature: \"m m\" },\n    pgfpointnormalised: { signature: \"m\" },\n    pgfpointlineattime: { signature: \"m m m\" },\n    pgfpointlineatdistance: { signature: \"m m m\" },\n    pgfpointarcaxesattime: { signature: \"m m m m m m\" },\n    pgfpointcurveattime: { signature: \"m m m m m\" },\n    pgfpointborderrectangle: { signature: \"m m\" },\n    pgfpointborderellipse: { signature: \"m m\" },\n    pgfpointintersectionoflines: { signature: \"m m m m\" },\n    pgfpointintersectionofcircles: { signature: \"m m m m m\" },\n    pgfintersectionofpaths: { signature: \"m m\" },\n    pgfpointintersectionsolution: { signature: \"m\" },\n    pgfextractx: { signature: \"m m\" },\n    pgfextracty: { signature: \"m m\" },\n    pgfgetlastxy: { signature: \"m m\" },\n    \"pgf@process\": { signature: \"m\" },\n    // Heirarchical structres ...\n    pgfsetbaseline: { signature: \"m\" },\n    pgfsetbaselinepointnow: { signature: \"m\" },\n    pgfsetbaselinepointlater: { signature: \"m\" },\n    pgftext: { signature: \"o m\", renderInfo: { pgfkeysArgs: true } },\n    pgfuseid: { signature: \"m\" },\n    pgfusetype: { signature: \"m\" },\n    pgfidrefnextuse: { signature: \"m m\" },\n    pgfidrefprevuse: { signature: \"m m\" },\n    pgfaliasid: { signature: \"m m\" },\n    pgfgaliasid: { signature: \"m m\" },\n    pgfifidreferenced: { signature: \"m m m\" },\n    pgfrdfabout: { signature: \"m\" },\n    pgfrdfcontent: { signature: \"m\" },\n    pgfrdfdatatype: { signature: \"m\" },\n    pgfrdfhref: { signature: \"m\" },\n    pgfrdfprefix: { signature: \"m\" },\n    pgfrdfproperty: { signature: \"m\" },\n    pgfrdfrel: { signature: \"m\" },\n    pgfrdfresource: { signature: \"m\" },\n    pgfrdfrev: { signature: \"m\" },\n    pgfrdfsrc: { signature: \"m\" },\n    pgfrdftypeof: { signature: \"m\" },\n    pgfrdfvocab: { signature: \"m\" },\n    pgferror: { signature: \"m\" },\n    pgfwarning: { signature: \"m\" },\n    path: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    draw: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    fill: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    filldraw: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    pattern: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    shade: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    clip: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    useasboundingbox: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    node: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    coordinate: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    graph: {\n        signature: \"u;\",\n        renderInfo: { breakAround: true, tikzPathCommand: true },\n    },\n    scoped: {\n        signature: \"o o m\",\n        argumentParser: tikzCommandArgumentParser,\n        renderInfo: {\n            namedArguments: [\"animation\", \"options\", \"command\"],\n            breakAround: true,\n        },\n    },\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport * as TikzSpec from \"./types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { decorateArrayForPegjs } from \"@unified-latex/unified-latex-util-pegjs\";\nimport { TikzPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\n\ntype TikzParseOptions = {\n    startRule?: \"path_spec\" | \"foreach_body\";\n};\n\nfunction createMatchers() {\n    return {\n        isChar: match.string,\n        isTerminal: (node: any) => match.string(node, \";\"),\n        isOperation: (node: any) =>\n            match.anyString(node) && node.content.match(/[a-zA-Z]/),\n        isWhitespace: (node: any) =>\n            match.whitespace(node) || match.parbreak(node),\n        isComment: match.comment,\n        isGroup: match.group,\n        isMacro: match.macro,\n        isAnyMacro: match.anyMacro,\n    };\n}\n\nconst matchers = createMatchers();\n\n/**\n * Parse the contents of the `\\systeme{...}` macro\n */\nexport function parse<Options extends TikzParseOptions>(\n    ast: Ast.Node[],\n    options?: Options\n): Options extends { startRule: infer R }\n    ? R extends \"path_spec\"\n        ? TikzSpec.PathSpec\n        : TikzSpec.ForeachBody\n    : TikzSpec.PathSpec {\n    const { startRule = \"path_spec\" } = options || {};\n    if (!Array.isArray(ast)) {\n        throw new Error(\"You must pass an array of nodes\");\n    }\n    // We need to at functions to `nodes` so that it imitates\n    // a Javascript string. Because we're mutating, make a copy first\n    ast = decorateArrayForPegjs([...ast]);\n    // matchers are passed in via the second argument (the `options` argument)\n    // so they are available from within the Pegjs grammar.\n    return TikzPegParser.parse(ast, {\n        ...matchers,\n        startRule,\n    });\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    substitutecolormodel: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true },\n    },\n    selectcolormodel: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    colorlet: {\n        signature: \"o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolorset: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolor: {\n        signature: \"o m m m\",\n        renderInfo: { breakAround: true },\n    },\n    preparecolorset: {\n        signature: \"o m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DefineNamedColor: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    definecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    providecolors: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    color: { signature: \"o m\", renderInfo: { breakAround: true } },\n    textcolor: { signature: \"o m m\", renderInfo: { inParMode: true } },\n    pagecolor: { signature: \"o m\" },\n    colorbox: { signature: \"o m m\" },\n    fcolorbox: { signature: \"o m o m m\" },\n    boxframe: { signature: \"o m\" },\n    testcolor: { signature: \"o m\" },\n    blendcolors: { signature: \"s m\" },\n    maskcolors: { signature: \"o m\" },\n    definecolorseries: {\n        signature: \"m m m o m o m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcolorseries: {\n        signature: \"o m\",\n        renderInfo: { breakAround: true },\n    },\n    rowcolors: { signature: \"s o m m m\" },\n    extractcolorspec: { signature: \"m m\" },\n    extractcolorspecs: { signature: \"m m m\" },\n    convertcolorspec: { signature: \"m m m m\" },\n};\n\nexport const environments: EnvInfoRecord = {\n    testcolors: { signature: \"o\", renderInfo: { pgfkeysArgs: true } },\n};\n", "import Color from \"color\";\n\nconst fromRgb = ([r, g, b]: number[]) =>\n    Color([r * 255, g * 255, b * 255], \"rgb\");\n\nexport const DVI_PS_NAMES = {\n    Apricot: Color(\"#FBB982\"),\n    Aquamarine: Color(\"#00B5BE\"),\n    Bittersweet: Color(\"#C04F17\"),\n    Black: Color(\"#221E1F\"),\n    Blue: Color(\"#2D2F92\"),\n    BlueGreen: Color(\"#00B3B8\"),\n    BlueViolet: Color(\"#473992\"),\n    BrickRed: Color(\"#B6321C\"),\n    Brown: Color(\"#792500\"),\n    BurntOrange: Color(\"#F7921D\"),\n    CadetBlue: Color(\"#74729A\"),\n    CarnationPink: Color(\"#F282B4\"),\n    Cerulean: Color(\"#00A2E3\"),\n    CornflowerBlue: Color(\"#41B0E4\"),\n    Cyan: Color(\"#00AEEF\"),\n    Dandelion: Color(\"#FDBC42\"),\n    DarkOrchid: Color(\"#A4538A\"),\n    Emerald: Color(\"#00A99D\"),\n    ForestGreen: Color(\"#009B55\"),\n    Fuchsia: Color(\"#8C368C\"),\n    Goldenrod: Color(\"#FFDF42\"),\n    Gray: Color(\"#949698\"),\n    Green: Color(\"#00A64F\"),\n    GreenYellow: Color(\"#DFE674\"),\n    JungleGreen: Color(\"#00A99A\"),\n    Lavender: Color(\"#F49EC4\"),\n    LimeGreen: Color(\"#8DC73E\"),\n    Magenta: Color(\"#EC008C\"),\n    Mahogany: Color(\"#A9341F\"),\n    Maroon: Color(\"#AF3235\"),\n    Melon: Color(\"#F89E7B\"),\n    MidnightBlue: Color(\"#006795\"),\n    Mulberry: Color(\"#A93C93\"),\n    NavyBlue: Color(\"#006EB8\"),\n    OliveGreen: Color(\"#3C8031\"),\n    Orange: Color(\"#F58137\"),\n    OrangeRed: Color(\"#ED135A\"),\n    Orchid: Color(\"#AF72B0\"),\n    Peach: Color(\"#F7965A\"),\n    Periwinkle: Color(\"#7977B8\"),\n    PineGreen: Color(\"#008B72\"),\n    Plum: Color(\"#92268F\"),\n    ProcessBlue: Color(\"#00B0F0\"),\n    Purple: Color(\"#99479B\"),\n    RawSienna: Color(\"#974006\"),\n    Red: Color(\"#ED1B23\"),\n    RedOrange: Color(\"#F26035\"),\n    RedViolet: Color(\"#A1246B\"),\n    Rhodamine: Color(\"#EF559F\"),\n    RoyalBlue: Color(\"#0071BC\"),\n    RoyalPurple: Color(\"#613F99\"),\n    RubineRed: Color(\"#ED017D\"),\n    Salmon: Color(\"#F69289\"),\n    SeaGreen: Color(\"#3FBC9D\"),\n    Sepia: Color(\"#671800\"),\n    SkyBlue: Color(\"#46C5DD\"),\n    SpringGreen: Color(\"#C6DC67\"),\n    Tan: Color(\"#DA9D76\"),\n    TealBlue: Color(\"#00AEB3\"),\n    Thistle: Color(\"#D883B7\"),\n    Turquoise: Color(\"#00B4CE\"),\n    Violet: Color(\"#58429B\"),\n    VioletRed: Color(\"#EF58A0\"),\n    White: Color(\"#FFFFFF\"),\n    WildStrawberry: Color(\"#EE2967\"),\n    Yellow: Color(\"#FFF200\"),\n    YellowGreen: Color(\"#98CC70\"),\n    YellowOrange: Color(\"#FAA21A\"),\n};\n\nexport const SVG_NAMES = {\n    AliceBlue: fromRgb([0.94, 0.972, 1]),\n    AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),\n    Aqua: fromRgb([0, 1, 1]),\n    Aquamarine: fromRgb([0.498, 1, 0.83]),\n    Azure: fromRgb([0.94, 1, 1]),\n    Beige: fromRgb([0.96, 0.96, 0.864]),\n    Bisque: fromRgb([1, 0.894, 0.77]),\n    Black: fromRgb([0, 0, 0]),\n    BlanchedAlmond: fromRgb([1, 0.92, 0.804]),\n    Blue: fromRgb([0, 0, 1]),\n    BlueViolet: fromRgb([0.54, 0.17, 0.888]),\n    Brown: fromRgb([0.648, 0.165, 0.165]),\n    BurlyWood: fromRgb([0.87, 0.72, 0.53]),\n    CadetBlue: fromRgb([0.372, 0.62, 0.628]),\n    Chartreuse: fromRgb([0.498, 1, 0]),\n    Chocolate: fromRgb([0.824, 0.41, 0.116]),\n    Coral: fromRgb([1, 0.498, 0.312]),\n    CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),\n    Cornsilk: fromRgb([1, 0.972, 0.864]),\n    Crimson: fromRgb([0.864, 0.08, 0.235]),\n    Cyan: fromRgb([0, 1, 1]),\n    DarkBlue: fromRgb([0, 0, 0.545]),\n    DarkCyan: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),\n    DarkGray: fromRgb([0.664, 0.664, 0.664]),\n    DarkGreen: fromRgb([0, 0.392, 0]),\n    DarkGrey: fromRgb([0.664, 0.664, 0.664]),\n    DarkKhaki: fromRgb([0.74, 0.716, 0.42]),\n    DarkMagenta: fromRgb([0.545, 0, 0.545]),\n    DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),\n    DarkOrange: fromRgb([1, 0.55, 0]),\n    DarkOrchid: fromRgb([0.6, 0.196, 0.8]),\n    DarkRed: fromRgb([0.545, 0, 0]),\n    DarkSalmon: fromRgb([0.912, 0.59, 0.48]),\n    DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),\n    DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),\n    DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),\n    DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),\n    DarkTurquoise: fromRgb([0, 0.808, 0.82]),\n    DarkViolet: fromRgb([0.58, 0, 0.828]),\n    DeepPink: fromRgb([1, 0.08, 0.576]),\n    DeepSkyBlue: fromRgb([0, 0.75, 1]),\n    DimGray: fromRgb([0.41, 0.41, 0.41]),\n    DimGrey: fromRgb([0.41, 0.41, 0.41]),\n    DodgerBlue: fromRgb([0.116, 0.565, 1]),\n    FireBrick: fromRgb([0.698, 0.132, 0.132]),\n    FloralWhite: fromRgb([1, 0.98, 0.94]),\n    ForestGreen: fromRgb([0.132, 0.545, 0.132]),\n    Fuchsia: fromRgb([1, 0, 1]),\n    Gainsboro: fromRgb([0.864, 0.864, 0.864]),\n    GhostWhite: fromRgb([0.972, 0.972, 1]),\n    Gold: fromRgb([1, 0.844, 0]),\n    Goldenrod: fromRgb([0.855, 0.648, 0.125]),\n    Gray: fromRgb([0.5, 0.5, 0.5]),\n    Green: fromRgb([0, 0.5, 0]),\n    GreenYellow: fromRgb([0.68, 1, 0.185]),\n    Grey: fromRgb([0.5, 0.5, 0.5]),\n    Honeydew: fromRgb([0.94, 1, 0.94]),\n    HotPink: fromRgb([1, 0.41, 0.705]),\n    IndianRed: fromRgb([0.804, 0.36, 0.36]),\n    Indigo: fromRgb([0.294, 0, 0.51]),\n    Ivory: fromRgb([1, 1, 0.94]),\n    Khaki: fromRgb([0.94, 0.9, 0.55]),\n    Lavender: fromRgb([0.9, 0.9, 0.98]),\n    LavenderBlush: fromRgb([1, 0.94, 0.96]),\n    LawnGreen: fromRgb([0.488, 0.99, 0]),\n    LemonChiffon: fromRgb([1, 0.98, 0.804]),\n    LightBlue: fromRgb([0.68, 0.848, 0.9]),\n    LightCoral: fromRgb([0.94, 0.5, 0.5]),\n    LightCyan: fromRgb([0.88, 1, 1]),\n    LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),\n    LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),\n    LightGray: fromRgb([0.828, 0.828, 0.828]),\n    LightGreen: fromRgb([0.565, 0.932, 0.565]),\n    LightGrey: fromRgb([0.828, 0.828, 0.828]),\n    LightPink: fromRgb([1, 0.712, 0.756]),\n    LightSalmon: fromRgb([1, 0.628, 0.48]),\n    LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),\n    LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),\n    LightSlateBlue: fromRgb([0.518, 0.44, 1]),\n    LightSlateGray: fromRgb([0.468, 0.532, 0.6]),\n    LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),\n    LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),\n    LightYellow: fromRgb([1, 1, 0.88]),\n    Lime: fromRgb([0, 1, 0]),\n    LimeGreen: fromRgb([0.196, 0.804, 0.196]),\n    Linen: fromRgb([0.98, 0.94, 0.9]),\n    Magenta: fromRgb([1, 0, 1]),\n    Maroon: fromRgb([0.5, 0, 0]),\n    MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),\n    MediumBlue: fromRgb([0, 0, 0.804]),\n    MediumOrchid: fromRgb([0.73, 0.332, 0.828]),\n    MediumPurple: fromRgb([0.576, 0.44, 0.86]),\n    MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),\n    MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),\n    MediumSpringGreen: fromRgb([0, 0.98, 0.604]),\n    MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),\n    MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),\n    MidnightBlue: fromRgb([0.098, 0.098, 0.44]),\n    MintCream: fromRgb([0.96, 1, 0.98]),\n    MistyRose: fromRgb([1, 0.894, 0.884]),\n    Moccasin: fromRgb([1, 0.894, 0.71]),\n    NavajoWhite: fromRgb([1, 0.87, 0.68]),\n    Navy: fromRgb([0, 0, 0.5]),\n    NavyBlue: fromRgb([0, 0, 0.5]),\n    OldLace: fromRgb([0.992, 0.96, 0.9]),\n    Olive: fromRgb([0.5, 0.5, 0]),\n    OliveDrab: fromRgb([0.42, 0.556, 0.136]),\n    Orange: fromRgb([1, 0.648, 0]),\n    OrangeRed: fromRgb([1, 0.27, 0]),\n    Orchid: fromRgb([0.855, 0.44, 0.84]),\n    PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),\n    PaleGreen: fromRgb([0.596, 0.985, 0.596]),\n    PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),\n    PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),\n    PapayaWhip: fromRgb([1, 0.936, 0.835]),\n    PeachPuff: fromRgb([1, 0.855, 0.725]),\n    Peru: fromRgb([0.804, 0.52, 0.248]),\n    Pink: fromRgb([1, 0.752, 0.796]),\n    Plum: fromRgb([0.868, 0.628, 0.868]),\n    PowderBlue: fromRgb([0.69, 0.88, 0.9]),\n    Purple: fromRgb([0.5, 0, 0.5]),\n    Red: fromRgb([1, 0, 0]),\n    RosyBrown: fromRgb([0.736, 0.56, 0.56]),\n    RoyalBlue: fromRgb([0.255, 0.41, 0.884]),\n    SaddleBrown: fromRgb([0.545, 0.27, 0.075]),\n    Salmon: fromRgb([0.98, 0.5, 0.448]),\n    SandyBrown: fromRgb([0.956, 0.644, 0.376]),\n    SeaGreen: fromRgb([0.18, 0.545, 0.34]),\n    Seashell: fromRgb([1, 0.96, 0.932]),\n    Sienna: fromRgb([0.628, 0.32, 0.176]),\n    Silver: fromRgb([0.752, 0.752, 0.752]),\n    SkyBlue: fromRgb([0.53, 0.808, 0.92]),\n    SlateBlue: fromRgb([0.415, 0.352, 0.804]),\n    SlateGray: fromRgb([0.44, 0.5, 0.565]),\n    SlateGrey: fromRgb([0.44, 0.5, 0.565]),\n    Snow: fromRgb([1, 0.98, 0.98]),\n    SpringGreen: fromRgb([0, 1, 0.498]),\n    SteelBlue: fromRgb([0.275, 0.51, 0.705]),\n    Tan: fromRgb([0.824, 0.705, 0.55]),\n    Teal: fromRgb([0, 0.5, 0.5]),\n    Thistle: fromRgb([0.848, 0.75, 0.848]),\n    Tomato: fromRgb([1, 0.39, 0.28]),\n    Turquoise: fromRgb([0.25, 0.88, 0.815]),\n    Violet: fromRgb([0.932, 0.51, 0.932]),\n    VioletRed: fromRgb([0.816, 0.125, 0.565]),\n    Wheat: fromRgb([0.96, 0.87, 0.7]),\n    White: fromRgb([1, 1, 1]),\n    WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),\n    Yellow: fromRgb([1, 1, 0]),\n    YellowGreen: fromRgb([0.604, 0.804, 0.196]),\n};\n\nexport const X11_NAMES = {\n    AntiqueWhite1: fromRgb([1, 0.936, 0.86]),\n    AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),\n    AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),\n    AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),\n    Aquamarine1: fromRgb([0.498, 1, 0.83]),\n    Aquamarine2: fromRgb([0.464, 0.932, 0.776]),\n    Aquamarine3: fromRgb([0.4, 0.804, 0.668]),\n    Aquamarine4: fromRgb([0.27, 0.545, 0.455]),\n    Azure1: fromRgb([0.94, 1, 1]),\n    Azure2: fromRgb([0.88, 0.932, 0.932]),\n    Azure3: fromRgb([0.756, 0.804, 0.804]),\n    Azure4: fromRgb([0.512, 0.545, 0.545]),\n    Bisque1: fromRgb([1, 0.894, 0.77]),\n    Bisque2: fromRgb([0.932, 0.835, 0.716]),\n    Bisque3: fromRgb([0.804, 0.716, 0.62]),\n    Bisque4: fromRgb([0.545, 0.49, 0.42]),\n    Blue1: fromRgb([0, 0, 1]),\n    Blue2: fromRgb([0, 0, 0.932]),\n    Blue3: fromRgb([0, 0, 0.804]),\n    Blue4: fromRgb([0, 0, 0.545]),\n    Brown1: fromRgb([1, 0.25, 0.25]),\n    Brown2: fromRgb([0.932, 0.23, 0.23]),\n    Brown3: fromRgb([0.804, 0.2, 0.2]),\n    Brown4: fromRgb([0.545, 0.136, 0.136]),\n    Burlywood1: fromRgb([1, 0.828, 0.608]),\n    Burlywood2: fromRgb([0.932, 0.772, 0.57]),\n    Burlywood3: fromRgb([0.804, 0.668, 0.49]),\n    Burlywood4: fromRgb([0.545, 0.45, 0.332]),\n    CadetBlue1: fromRgb([0.596, 0.96, 1]),\n    CadetBlue2: fromRgb([0.556, 0.898, 0.932]),\n    CadetBlue3: fromRgb([0.48, 0.772, 0.804]),\n    CadetBlue4: fromRgb([0.325, 0.525, 0.545]),\n    Chartreuse1: fromRgb([0.498, 1, 0]),\n    Chartreuse2: fromRgb([0.464, 0.932, 0]),\n    Chartreuse3: fromRgb([0.4, 0.804, 0]),\n    Chartreuse4: fromRgb([0.27, 0.545, 0]),\n    Chocolate1: fromRgb([1, 0.498, 0.14]),\n    Chocolate2: fromRgb([0.932, 0.464, 0.13]),\n    Chocolate3: fromRgb([0.804, 0.4, 0.112]),\n    Chocolate4: fromRgb([0.545, 0.27, 0.075]),\n    Coral1: fromRgb([1, 0.448, 0.336]),\n    Coral2: fromRgb([0.932, 0.415, 0.312]),\n    Coral3: fromRgb([0.804, 0.356, 0.27]),\n    Coral4: fromRgb([0.545, 0.244, 0.185]),\n    Cornsilk1: fromRgb([1, 0.972, 0.864]),\n    Cornsilk2: fromRgb([0.932, 0.91, 0.804]),\n    Cornsilk3: fromRgb([0.804, 0.785, 0.694]),\n    Cornsilk4: fromRgb([0.545, 0.532, 0.47]),\n    Cyan1: fromRgb([0, 1, 1]),\n    Cyan2: fromRgb([0, 0.932, 0.932]),\n    Cyan3: fromRgb([0, 0.804, 0.804]),\n    Cyan4: fromRgb([0, 0.545, 0.545]),\n    DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),\n    DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),\n    DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),\n    DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),\n    DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),\n    DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),\n    DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),\n    DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),\n    DarkOrange1: fromRgb([1, 0.498, 0]),\n    DarkOrange2: fromRgb([0.932, 0.464, 0]),\n    DarkOrange3: fromRgb([0.804, 0.4, 0]),\n    DarkOrange4: fromRgb([0.545, 0.27, 0]),\n    DarkOrchid1: fromRgb([0.75, 0.244, 1]),\n    DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),\n    DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),\n    DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),\n    DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),\n    DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),\n    DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),\n    DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),\n    DarkSlateGray1: fromRgb([0.592, 1, 1]),\n    DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),\n    DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),\n    DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),\n    DeepPink1: fromRgb([1, 0.08, 0.576]),\n    DeepPink2: fromRgb([0.932, 0.07, 0.536]),\n    DeepPink3: fromRgb([0.804, 0.064, 0.464]),\n    DeepPink4: fromRgb([0.545, 0.04, 0.312]),\n    DeepSkyBlue1: fromRgb([0, 0.75, 1]),\n    DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),\n    DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),\n    DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),\n    DodgerBlue1: fromRgb([0.116, 0.565, 1]),\n    DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),\n    DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),\n    DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),\n    Firebrick1: fromRgb([1, 0.19, 0.19]),\n    Firebrick2: fromRgb([0.932, 0.172, 0.172]),\n    Firebrick3: fromRgb([0.804, 0.15, 0.15]),\n    Firebrick4: fromRgb([0.545, 0.1, 0.1]),\n    Gold1: fromRgb([1, 0.844, 0]),\n    Gold2: fromRgb([0.932, 0.79, 0]),\n    Gold3: fromRgb([0.804, 0.68, 0]),\n    Gold4: fromRgb([0.545, 0.46, 0]),\n    Goldenrod1: fromRgb([1, 0.756, 0.145]),\n    Goldenrod2: fromRgb([0.932, 0.705, 0.132]),\n    Goldenrod3: fromRgb([0.804, 0.608, 0.112]),\n    Goldenrod4: fromRgb([0.545, 0.41, 0.08]),\n    Green1: fromRgb([0, 1, 0]),\n    Green2: fromRgb([0, 0.932, 0]),\n    Green3: fromRgb([0, 0.804, 0]),\n    Green4: fromRgb([0, 0.545, 0]),\n    Honeydew1: fromRgb([0.94, 1, 0.94]),\n    Honeydew2: fromRgb([0.88, 0.932, 0.88]),\n    Honeydew3: fromRgb([0.756, 0.804, 0.756]),\n    Honeydew4: fromRgb([0.512, 0.545, 0.512]),\n    HotPink1: fromRgb([1, 0.43, 0.705]),\n    HotPink2: fromRgb([0.932, 0.415, 0.655]),\n    HotPink3: fromRgb([0.804, 0.376, 0.565]),\n    HotPink4: fromRgb([0.545, 0.228, 0.385]),\n    IndianRed1: fromRgb([1, 0.415, 0.415]),\n    IndianRed2: fromRgb([0.932, 0.39, 0.39]),\n    IndianRed3: fromRgb([0.804, 0.332, 0.332]),\n    IndianRed4: fromRgb([0.545, 0.228, 0.228]),\n    Ivory1: fromRgb([1, 1, 0.94]),\n    Ivory2: fromRgb([0.932, 0.932, 0.88]),\n    Ivory3: fromRgb([0.804, 0.804, 0.756]),\n    Ivory4: fromRgb([0.545, 0.545, 0.512]),\n    Khaki1: fromRgb([1, 0.965, 0.56]),\n    Khaki2: fromRgb([0.932, 0.9, 0.52]),\n    Khaki3: fromRgb([0.804, 0.776, 0.45]),\n    Khaki4: fromRgb([0.545, 0.525, 0.305]),\n    LavenderBlush1: fromRgb([1, 0.94, 0.96]),\n    LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),\n    LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),\n    LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),\n    LemonChiffon1: fromRgb([1, 0.98, 0.804]),\n    LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),\n    LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),\n    LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),\n    LightBlue1: fromRgb([0.75, 0.936, 1]),\n    LightBlue2: fromRgb([0.698, 0.875, 0.932]),\n    LightBlue3: fromRgb([0.604, 0.752, 0.804]),\n    LightBlue4: fromRgb([0.408, 0.512, 0.545]),\n    LightCyan1: fromRgb([0.88, 1, 1]),\n    LightCyan2: fromRgb([0.82, 0.932, 0.932]),\n    LightCyan3: fromRgb([0.705, 0.804, 0.804]),\n    LightCyan4: fromRgb([0.48, 0.545, 0.545]),\n    LightGoldenrod1: fromRgb([1, 0.925, 0.545]),\n    LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),\n    LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),\n    LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),\n    LightPink1: fromRgb([1, 0.684, 0.725]),\n    LightPink2: fromRgb([0.932, 0.635, 0.68]),\n    LightPink3: fromRgb([0.804, 0.55, 0.585]),\n    LightPink4: fromRgb([0.545, 0.372, 0.396]),\n    LightSalmon1: fromRgb([1, 0.628, 0.48]),\n    LightSalmon2: fromRgb([0.932, 0.585, 0.448]),\n    LightSalmon3: fromRgb([0.804, 0.505, 0.385]),\n    LightSalmon4: fromRgb([0.545, 0.34, 0.26]),\n    LightSkyBlue1: fromRgb([0.69, 0.888, 1]),\n    LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),\n    LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),\n    LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),\n    LightSteelBlue1: fromRgb([0.792, 0.884, 1]),\n    LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),\n    LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),\n    LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),\n    LightYellow1: fromRgb([1, 1, 0.88]),\n    LightYellow2: fromRgb([0.932, 0.932, 0.82]),\n    LightYellow3: fromRgb([0.804, 0.804, 0.705]),\n    LightYellow4: fromRgb([0.545, 0.545, 0.48]),\n    Magenta1: fromRgb([1, 0, 1]),\n    Magenta2: fromRgb([0.932, 0, 0.932]),\n    Magenta3: fromRgb([0.804, 0, 0.804]),\n    Magenta4: fromRgb([0.545, 0, 0.545]),\n    Maroon1: fromRgb([1, 0.204, 0.7]),\n    Maroon2: fromRgb([0.932, 0.19, 0.655]),\n    Maroon3: fromRgb([0.804, 0.16, 0.565]),\n    Maroon4: fromRgb([0.545, 0.11, 0.385]),\n    MediumOrchid1: fromRgb([0.88, 0.4, 1]),\n    MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),\n    MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),\n    MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),\n    MediumPurple1: fromRgb([0.67, 0.51, 1]),\n    MediumPurple2: fromRgb([0.624, 0.475, 0.932]),\n    MediumPurple3: fromRgb([0.536, 0.408, 0.804]),\n    MediumPurple4: fromRgb([0.365, 0.28, 0.545]),\n    MistyRose1: fromRgb([1, 0.894, 0.884]),\n    MistyRose2: fromRgb([0.932, 0.835, 0.824]),\n    MistyRose3: fromRgb([0.804, 0.716, 0.71]),\n    MistyRose4: fromRgb([0.545, 0.49, 0.484]),\n    NavajoWhite1: fromRgb([1, 0.87, 0.68]),\n    NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),\n    NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),\n    NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),\n    OliveDrab1: fromRgb([0.752, 1, 0.244]),\n    OliveDrab2: fromRgb([0.7, 0.932, 0.228]),\n    OliveDrab3: fromRgb([0.604, 0.804, 0.196]),\n    OliveDrab4: fromRgb([0.41, 0.545, 0.132]),\n    Orange1: fromRgb([1, 0.648, 0]),\n    Orange2: fromRgb([0.932, 0.604, 0]),\n    Orange3: fromRgb([0.804, 0.52, 0]),\n    Orange4: fromRgb([0.545, 0.352, 0]),\n    OrangeRed1: fromRgb([1, 0.27, 0]),\n    OrangeRed2: fromRgb([0.932, 0.25, 0]),\n    OrangeRed3: fromRgb([0.804, 0.215, 0]),\n    OrangeRed4: fromRgb([0.545, 0.145, 0]),\n    Orchid1: fromRgb([1, 0.512, 0.98]),\n    Orchid2: fromRgb([0.932, 0.48, 0.912]),\n    Orchid3: fromRgb([0.804, 0.41, 0.79]),\n    Orchid4: fromRgb([0.545, 0.28, 0.536]),\n    PaleGreen1: fromRgb([0.604, 1, 0.604]),\n    PaleGreen2: fromRgb([0.565, 0.932, 0.565]),\n    PaleGreen3: fromRgb([0.488, 0.804, 0.488]),\n    PaleGreen4: fromRgb([0.33, 0.545, 0.33]),\n    PaleTurquoise1: fromRgb([0.732, 1, 1]),\n    PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),\n    PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),\n    PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),\n    PaleVioletRed1: fromRgb([1, 0.51, 0.67]),\n    PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),\n    PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),\n    PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),\n    PeachPuff1: fromRgb([1, 0.855, 0.725]),\n    PeachPuff2: fromRgb([0.932, 0.796, 0.68]),\n    PeachPuff3: fromRgb([0.804, 0.688, 0.585]),\n    PeachPuff4: fromRgb([0.545, 0.468, 0.396]),\n    Pink1: fromRgb([1, 0.71, 0.772]),\n    Pink2: fromRgb([0.932, 0.664, 0.72]),\n    Pink3: fromRgb([0.804, 0.57, 0.62]),\n    Pink4: fromRgb([0.545, 0.39, 0.424]),\n    Plum1: fromRgb([1, 0.732, 1]),\n    Plum2: fromRgb([0.932, 0.684, 0.932]),\n    Plum3: fromRgb([0.804, 0.59, 0.804]),\n    Plum4: fromRgb([0.545, 0.4, 0.545]),\n    Purple1: fromRgb([0.608, 0.19, 1]),\n    Purple2: fromRgb([0.57, 0.172, 0.932]),\n    Purple3: fromRgb([0.49, 0.15, 0.804]),\n    Purple4: fromRgb([0.332, 0.1, 0.545]),\n    Red1: fromRgb([1, 0, 0]),\n    Red2: fromRgb([0.932, 0, 0]),\n    Red3: fromRgb([0.804, 0, 0]),\n    Red4: fromRgb([0.545, 0, 0]),\n    RosyBrown1: fromRgb([1, 0.756, 0.756]),\n    RosyBrown2: fromRgb([0.932, 0.705, 0.705]),\n    RosyBrown3: fromRgb([0.804, 0.608, 0.608]),\n    RosyBrown4: fromRgb([0.545, 0.41, 0.41]),\n    RoyalBlue1: fromRgb([0.284, 0.464, 1]),\n    RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),\n    RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),\n    RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),\n    Salmon1: fromRgb([1, 0.55, 0.41]),\n    Salmon2: fromRgb([0.932, 0.51, 0.385]),\n    Salmon3: fromRgb([0.804, 0.44, 0.33]),\n    Salmon4: fromRgb([0.545, 0.298, 0.224]),\n    SeaGreen1: fromRgb([0.33, 1, 0.624]),\n    SeaGreen2: fromRgb([0.305, 0.932, 0.58]),\n    SeaGreen3: fromRgb([0.264, 0.804, 0.5]),\n    SeaGreen4: fromRgb([0.18, 0.545, 0.34]),\n    Seashell1: fromRgb([1, 0.96, 0.932]),\n    Seashell2: fromRgb([0.932, 0.898, 0.87]),\n    Seashell3: fromRgb([0.804, 0.772, 0.75]),\n    Seashell4: fromRgb([0.545, 0.525, 0.51]),\n    Sienna1: fromRgb([1, 0.51, 0.28]),\n    Sienna2: fromRgb([0.932, 0.475, 0.26]),\n    Sienna3: fromRgb([0.804, 0.408, 0.224]),\n    Sienna4: fromRgb([0.545, 0.28, 0.15]),\n    SkyBlue1: fromRgb([0.53, 0.808, 1]),\n    SkyBlue2: fromRgb([0.494, 0.752, 0.932]),\n    SkyBlue3: fromRgb([0.424, 0.65, 0.804]),\n    SkyBlue4: fromRgb([0.29, 0.44, 0.545]),\n    SlateBlue1: fromRgb([0.512, 0.435, 1]),\n    SlateBlue2: fromRgb([0.48, 0.404, 0.932]),\n    SlateBlue3: fromRgb([0.41, 0.35, 0.804]),\n    SlateBlue4: fromRgb([0.28, 0.235, 0.545]),\n    SlateGray1: fromRgb([0.776, 0.888, 1]),\n    SlateGray2: fromRgb([0.725, 0.828, 0.932]),\n    SlateGray3: fromRgb([0.624, 0.712, 0.804]),\n    SlateGray4: fromRgb([0.424, 0.484, 0.545]),\n    Snow1: fromRgb([1, 0.98, 0.98]),\n    Snow2: fromRgb([0.932, 0.912, 0.912]),\n    Snow3: fromRgb([0.804, 0.79, 0.79]),\n    Snow4: fromRgb([0.545, 0.536, 0.536]),\n    SpringGreen1: fromRgb([0, 1, 0.498]),\n    SpringGreen2: fromRgb([0, 0.932, 0.464]),\n    SpringGreen3: fromRgb([0, 0.804, 0.4]),\n    SpringGreen4: fromRgb([0, 0.545, 0.27]),\n    SteelBlue1: fromRgb([0.39, 0.72, 1]),\n    SteelBlue2: fromRgb([0.36, 0.675, 0.932]),\n    SteelBlue3: fromRgb([0.31, 0.58, 0.804]),\n    SteelBlue4: fromRgb([0.21, 0.392, 0.545]),\n    Tan1: fromRgb([1, 0.648, 0.31]),\n    Tan2: fromRgb([0.932, 0.604, 0.288]),\n    Tan3: fromRgb([0.804, 0.52, 0.248]),\n    Tan4: fromRgb([0.545, 0.352, 0.17]),\n    Thistle1: fromRgb([1, 0.884, 1]),\n    Thistle2: fromRgb([0.932, 0.824, 0.932]),\n    Thistle3: fromRgb([0.804, 0.71, 0.804]),\n    Thistle4: fromRgb([0.545, 0.484, 0.545]),\n    Tomato1: fromRgb([1, 0.39, 0.28]),\n    Tomato2: fromRgb([0.932, 0.36, 0.26]),\n    Tomato3: fromRgb([0.804, 0.31, 0.224]),\n    Tomato4: fromRgb([0.545, 0.21, 0.15]),\n    Turquoise1: fromRgb([0, 0.96, 1]),\n    Turquoise2: fromRgb([0, 0.898, 0.932]),\n    Turquoise3: fromRgb([0, 0.772, 0.804]),\n    Turquoise4: fromRgb([0, 0.525, 0.545]),\n    VioletRed1: fromRgb([1, 0.244, 0.59]),\n    VioletRed2: fromRgb([0.932, 0.228, 0.55]),\n    VioletRed3: fromRgb([0.804, 0.196, 0.47]),\n    VioletRed4: fromRgb([0.545, 0.132, 0.32]),\n    Wheat1: fromRgb([1, 0.905, 0.73]),\n    Wheat2: fromRgb([0.932, 0.848, 0.684]),\n    Wheat3: fromRgb([0.804, 0.73, 0.59]),\n    Wheat4: fromRgb([0.545, 0.494, 0.4]),\n    Yellow1: fromRgb([1, 1, 0]),\n    Yellow2: fromRgb([0.932, 0.932, 0]),\n    Yellow3: fromRgb([0.804, 0.804, 0]),\n    Yellow4: fromRgb([0.545, 0.545, 0]),\n    Gray0: fromRgb([0.745, 0.745, 0.745]),\n    Green0: fromRgb([0, 1, 0]),\n    Grey0: fromRgb([0.745, 0.745, 0.745]),\n    Maroon0: fromRgb([0.69, 0.19, 0.376]),\n    Purple0: fromRgb([0.628, 0.125, 0.94]),\n};\n", "import { XColorPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as XColorSpec from \"./types\";\n\nconst parseCache: Record<string, XColorSpec.Ast> = {};\n\n/**\n * Parse an `xparse` argument specification string to an AST.\n * This function caches results. Don't mutate the returned AST!\n *\n * @param {string} [str=\"\"] - LaTeX string input\n * @returns - AST for LaTeX string\n */\nexport function parse(str = \"\"): XColorSpec.Ast {\n    parseCache[str] =\n        parseCache[str] || (XColorPegParser.parse(str) as XColorSpec.Ast);\n    return parseCache[str];\n}\n", "import Color from \"color\";\nimport { DVI_PS_NAMES, SVG_NAMES, X11_NAMES } from \"./predefined-colors\";\nimport { XColor } from \"./types\";\nimport { parse as xcolorParser } from \"./parser\";\n\nconst CORE_MODELS = new Set([\"rgb\", \"cmy\", \"cmyk\", \"hsb\", \"gray\"]);\n\nexport const XColorCoreModelToColor = {\n    rgb: ([r, g, b]: number[]) => Color([r * 255, g * 255, b * 255], \"rgb\"),\n    cmy: ([c, m, y]: number[]) =>\n        XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),\n    cmyk: ([c, m, y, k]: number[]) =>\n        Color([c * 255, m * 255, y * 255, k * 100], \"cmyk\"),\n    hsb: ([h, s, b]: number[]) => Color([h * 360, s * 100, b * 100], \"hsv\"),\n    gray: ([v]: number[]) => Color([v * 255, v * 255, v * 255], \"rgb\"),\n};\nconst XColorModelToColor = {\n    wave: ([lambda]: number[]) => {\n        // Constants according to the xcolor readme\n        const gamma = 0.8;\n        let baseRgb = [0, 0, 0];\n        if (380 <= lambda && lambda < 440) {\n            baseRgb = [(440 - lambda) / (440 - 380), 0, 1];\n        }\n        if (440 <= lambda && lambda < 490) {\n            baseRgb = [0, (lambda - 440) / (490 - 440), 1];\n        }\n        if (490 <= lambda && lambda < 510) {\n            baseRgb = [0, 1, (510 - lambda) / (510 - 490)];\n        }\n        if (510 <= lambda && lambda < 580) {\n            baseRgb = [(lambda - 510) / (580 - 510), 1, 0];\n        }\n        if (580 <= lambda && lambda < 6450) {\n            baseRgb = [1, (645 - lambda) / (645 - 580), 0];\n        }\n        if (645 <= lambda && lambda <= 780) {\n            baseRgb = [1, 0, 0];\n        }\n        let f = 1.0;\n        if (380 <= lambda && 420 < lambda) {\n            f = 0.3 + (0.7 * (lambda - 380)) / (420 - 380);\n        }\n        if (700 < lambda && lambda <= 780) {\n            f = 0.3 + (0.7 * (780 - lambda)) / (780 - 700);\n        }\n\n        const rgb = [\n            Math.pow(baseRgb[0] * f, gamma),\n            Math.pow(baseRgb[1] * f, gamma),\n            Math.pow(baseRgb[2] * f, gamma),\n        ];\n\n        return Color([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], \"rgb\");\n    },\n    Hsb: ([h, s, b]: number[]) => XColorCoreModelToColor.hsb([h / 360, s, b]),\n    HSB: ([h, s, b]: number[]) =>\n        XColorCoreModelToColor.hsb([h / 240, s / 240, b / 240]),\n    HTML: ([v]: [string]) => (v.startsWith(\"#\") ? Color(v) : Color(`#${v}`)),\n    RGB: ([r, g, b]: number[]) => Color([r, g, b], \"rgb\"),\n    Gray: ([v]: number[]) => XColorCoreModelToColor.gray([v / 15]),\n    ...XColorCoreModelToColor,\n};\n\nconst ColorToXColorModel = {\n    rgb: (color: Color<any>) =>\n        color\n            .rgb()\n            .array()\n            .map((v) => v / 255),\n    cmy: (color: Color<any>) =>\n        [255 - color.red(), 255 - color.green(), 255 - color.blue()].map(\n            (v) => v / 255\n        ),\n    cmyk: (color: Color<any>) =>\n        color\n            .cmyk()\n            .array()\n            // The k component goes from 0-100\n            .map((v, i) => (i === 3 ? v / 100 : v / 255)),\n    hsb: (color: Color<any>) => [\n        color.hue() / 360,\n        color.saturationv() / 100,\n        color.value() / 100,\n    ],\n    gray: (color: Color<any>) => [color.gray() / 100],\n};\n\nexport const PREDEFINED_XCOLOR_COLORS: Record<string, Color<any>> = {\n    // Core colors\n    red: XColorCoreModelToColor.rgb([1, 0, 0]),\n    green: XColorCoreModelToColor.rgb([0, 1, 0]),\n    blue: XColorCoreModelToColor.rgb([0, 0, 1]),\n    brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),\n    lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),\n    orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),\n    pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),\n    purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),\n    teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),\n    violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),\n    cyan: XColorCoreModelToColor.rgb([0, 1, 1]),\n    magenta: XColorCoreModelToColor.rgb([1, 0, 1]),\n    yellow: XColorCoreModelToColor.rgb([1, 1, 0]),\n    olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),\n    black: XColorCoreModelToColor.rgb([0, 0, 0]),\n    darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),\n    gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),\n    lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),\n    white: XColorCoreModelToColor.rgb([1, 1, 1]),\n    ...DVI_PS_NAMES,\n    ...SVG_NAMES,\n    ...X11_NAMES,\n};\n\nfunction scalarMul(scalar: number, vec: number[]) {\n    return vec.map((v) => scalar * v);\n}\nfunction addVectors(...vecs: number[][]) {\n    return vecs.reduce((prev, current) => prev.map((v, i) => v + current[i]));\n}\n\n/**\n * Mix a color in color model `model` as per the algorithm in 2.3.3 of the xcolor manual.\n */\nfunction mixInModel(\n    model: string,\n    colorsAndCoefficients: [number, Color<any>][]\n): Color<any> {\n    if (!CORE_MODELS.has(model)) {\n        throw new Error(\n            `Cannot mix colors in model \"${model}\"; only core modes ${Array.from(\n                CORE_MODELS\n            ).join(\", \")} are supported`\n        );\n    }\n    const toModel =\n        ColorToXColorModel[model as keyof typeof ColorToXColorModel];\n    const fromModel =\n        XColorCoreModelToColor[model as keyof typeof XColorCoreModelToColor];\n\n    const mixed = addVectors(\n        ...colorsAndCoefficients.map(([v, color]) => {\n            const colorInModel = toModel(color);\n            return scalarMul(v, colorInModel);\n        })\n    );\n    return fromModel(mixed);\n}\n\n/**\n * Given a parsed `XColor`, compute the color and return a `Color` object\n * (that can be used in CSS, for example).\n */\nexport function computeColor(\n    expr: XColor,\n    predefinedColors: Record<string, Color<any>> = {}\n): Color<any> {\n    if (expr.type !== \"color\") {\n        throw new Error(\n            `Can only compute the color of a \"color\" expression, not one of type ${expr.type}`\n        );\n    }\n\n    const knownColors = { ...PREDEFINED_XCOLOR_COLORS, ...predefinedColors };\n    function getColor(name: string) {\n        if (!knownColors[name]) {\n            throw new Error(`Unknown color \"${name}\"`);\n        }\n        return knownColors[name];\n    }\n\n    const color = expr.color;\n    let computedColor = Color(\"#000000\");\n    if (color.type === \"expr\") {\n        // From the algorithm in 2.3.2 of the xcolor manual\n\n        // TODO: the suffix `!![num]` is not yet implemented.\n        let base = getColor(color.name);\n        for (const mix of color.mix_expr) {\n            if (mix.type === \"complete_mix\") {\n                const mixColor = getColor(mix.name);\n                base = base.mix(mixColor, 1 - mix.mix_percent / 100);\n            } else if (mix.type === \"partial_mix\") {\n                base = base.mix(Color(\"#FFFFFF\"), 1 - mix.mix_percent / 100);\n            }\n        }\n        if (color.prefix && color.prefix.length % 2 === 1) {\n            base = base.rotate(180);\n        }\n        computedColor = base;\n    }\n    if (color.type === \"extended_expr\") {\n        const model = color.core_model;\n        const div =\n            color.div ||\n            color.expressions.reduce((a, expr) => a + expr.weight, 0);\n        if (div <= 0) {\n            throw new Error(\n                `Cannot mix color with ratios that have a denominator of ${div}`\n            );\n        }\n        const colorsToMix: [number, Color<any>][] = color.expressions.map(\n            (expr) => [\n                expr.weight / div,\n                computeColor({\n                    type: \"color\",\n                    color: expr.color,\n                    functions: [],\n                }),\n            ]\n        );\n        computedColor = mixInModel(model, colorsToMix);\n    }\n\n    // Now we apply any color functions\n    for (const func of expr.functions) {\n        if (func.name === \"wheel\") {\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360);\n        }\n        if (func.name === \"twheel\") {\n            // This function depends on the definition of \\rangetHsb, which we\n            // don't actually know, so we just use it's default, which is to\n            // add a 60 deg. angle to everything. I think...\n            const angle = func.args[0];\n            const circ = func.args[1] || 360;\n            computedColor = computedColor.rotate((angle / circ) * 360 + 60);\n        }\n    }\n\n    return computedColor;\n}\n\n/**\n * Convert the xcolor defined color to RGB Hex representation.\n * If the color is unknown or cannot be computed, `null` is returned.\n *\n * If `model` is supplied,\n *\n * The most likely reason a color will be `null` is if the color is defined\n * using a pre-defined color that wasn't supplied as an argument.\n */\nexport function xcolorColorToHex(\n    color: string,\n    model?: string | null,\n    options: {\n        predefinedColors?: Record<string, Color<any>>;\n    } = { predefinedColors: {} }\n): string | null {\n    const { predefinedColors = {} } = options;\n    const parsed = xcolorParser(color);\n    // If a model was entered, the corresponding color was directly entered without\n    // mixing, unless the parsed type was \"color\". This would through an error in `xcolor`,\n    // but we won't error.\n    if (model && model !== \"default\" && parsed.type !== \"color\") {\n        if (!(model in XColorModelToColor)) {\n            throw new Error(\n                `Unknown color model \"${model}\"; known models are ${Object.keys(\n                    XColorModelToColor\n                ).join(\", \")}`\n            );\n        }\n        if (parsed.type !== \"hex_spec\" && parsed.type !== \"num_spec\") {\n            throw new Error(\n                `Cannot use model ${model} to compute the color \"${color}\"`\n            );\n        }\n\n        if (model === \"HTML\" && parsed.type === \"hex_spec\") {\n            return XColorModelToColor.HTML(parsed.content).hex();\n        } else if (parsed.type === \"num_spec\") {\n            type x = keyof Omit<typeof XColorModelToColor, \"HTML\">;\n            return XColorModelToColor[\n                model as keyof Omit<typeof XColorModelToColor, \"HTML\">\n            ](parsed.content).hex();\n        }\n\n        throw new Error(\n            `Don't know how to process color \"${color}\" in model \"${model}\"`\n        );\n    }\n\n    if (Array.isArray(parsed) || parsed.type !== \"color\") {\n        throw new Error(\n            `Cannot the color \"${color}\" is not a valid color string`\n        );\n    }\n    let computed: Color<any> | null = null;\n    try {\n        computed = computeColor(parsed, predefinedColors);\n    } catch (e) {}\n\n    return computed && computed.hex();\n}\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    NewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareDocumentEnvironment: {\n        signature: \"m m m m\",\n        renderInfo: { breakAround: true },\n    },\n    NewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RenewExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    ProvideExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    DeclareExpandableDocumentCommand: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    RequirePackage: {\n        signature: \"o m\",\n        renderInfo: { pgfkeysArgs: true, breakAround: true },\n    },\n    DeclareOption: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    mode: { signature: \"s d<> d{}\", renderInfo: { breakAround: true } },\n    insertnavigation: { signature: \"m\", renderInfo: { breakAround: true } },\n    insertsectionnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    insertsectionnavigationhorizontal: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    insertauthor: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortauthor: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortdate: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortinstitute: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshortpart: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertshorttitle: { signature: \"o\", renderInfo: { breakAround: true } },\n    insertsubsectionnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    insertsubsectionnavigationhorizontal: {\n        signature: \"m m m\",\n        renderInfo: { breakAround: true },\n    },\n    insertverticalnavigation: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    usebeamercolor: { signature: \"s m\", renderInfo: { breakAround: true } },\n    usebeamertemplate: { signature: \"s m\", renderInfo: { breakAround: true } },\n    setbeamercolor: {\n        signature: \"m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    setbeamersize: {\n        signature: \"m o o\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    setbeamertemplate: {\n        signature: \"m o o d{}\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n\n    newcommand: {\n        signature: \"s d<> +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\n                \"starred\",\n                null,\n                \"name\",\n                \"numArgs\",\n                \"default\",\n                \"body\",\n            ],\n        },\n    },\n    renewcommand: {\n        signature: \"s d<> +m o +o +m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\n                \"starred\",\n                null,\n                \"name\",\n                \"numArgs\",\n                \"default\",\n                \"body\",\n            ],\n        },\n    },\n    newenvironment: {\n        signature: \"s d<> m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    renewenvironment: {\n        signature: \"s d<> m o o m m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcounteronoverlays: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    resetcountonoverlays: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    logo: { signature: \"m\", renderInfo: { breakAround: true } },\n    frametitle: { signature: \"d<> o m\", renderInfo: { breakAround: true } },\n    framesubtitle: { signature: \"d<> m\", renderInfo: { breakAround: true } },\n    pause: { signature: \"o\" },\n    onslide: { signature: \"t+ t* d<> d{}\" },\n    only: { signature: \"d<> m d<>\" },\n    uncover: { signature: \"d<> m\" },\n    visible: { signature: \"d<> m\" },\n    invisible: { signature: \"d<> m\" },\n    alt: { signature: \"d<> m m d<>\" },\n    temporal: { signature: \"r<> m m m\" },\n    item: {\n        signature: \"d<> o d<>\",\n        renderInfo: {\n            hangingIndent: true,\n            namedArguments: [null, \"label\", null],\n        },\n    },\n    label: { signature: \"d<> o m\" }, // cleveref adds an optional argument to label; this gives maximum compatibility.\n    action: { signature: \"d<> m\" },\n    beamerdefaultoverlayspecification: { signature: \"m\" },\n\n    titlegraphic: { signature: \"m\", renderInfo: { breakAround: true } },\n    subject: { signature: \"m\", renderInfo: { breakAround: true } },\n    keywords: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    lecture: { signature: \"o m m\", renderInfo: { breakAround: true } },\n    partpage: { renderInfo: { breakAround: true } },\n    sectionpage: { renderInfo: { breakAround: true } },\n    subsectionpage: { renderInfo: { breakAround: true } },\n    AtBeginLecture: { signature: \"m\", renderInfo: { breakAround: true } },\n    AtBeginPart: { signature: \"m\", renderInfo: { breakAround: true } },\n    tableofcontents: {\n        signature: \"o\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    againframe: { signature: \"d<> o o m\", renderInfo: { breakAround: true } },\n    framezoom: {\n        signature: \"r<> r<> o r() r()\",\n        renderInfo: { breakAround: true },\n    },\n    column: { signature: \"d<> o m\", renderInfo: { breakAround: true } },\n\n    animate: { signature: \"r<>\", renderInfo: { breakAround: true } },\n    animatevalue: { signature: \"r<> m m m\", renderInfo: { breakAround: true } },\n    sound: {\n        signature: \"o m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    hyperlinksound: {\n        signature: \"o m m\",\n        renderInfo: { breakAround: true, pgfkeysArgs: true },\n    },\n    hyperlinkmute: { signature: \"m\", renderInfo: { breakAround: true } },\n\n    // These signatures conflict with the default signatures.\n    // Care must be taken when processing an AST.\n    section: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    subsection: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    subsubsection: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    part: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            breakAround: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n    bibitem: {\n        signature: \"s d<> o m\",\n        renderInfo: {\n            hangingIndent: true,\n            namedArguments: [\"starred\", null, \"tocTitle\", \"title\"],\n        },\n    },\n};\n\nexport const environments: EnvInfoRecord = {\n    frame: {\n        signature: \"!d<> !o !o !d{} !d{}\",\n    },\n    block: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    alertblock: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    exampleblock: {\n        signature: \"!d<> !d{} !d<>\",\n    },\n    onlyenv: {\n        signature: \"!d<>\",\n    },\n    altenv: {\n        signature: \"!d<> m m m m !d<>\",\n    },\n    overlayarea: { signature: \"m m\" },\n    overprint: { signature: \"o\" },\n    actionenv: { signature: \"!d<>\" },\n    columns: { signature: \"d<> o\" },\n    column: { signature: \"d<> o m\" },\n};\n", "import {\n    MacroInfoRecord,\n    EnvInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\n\nexport const macros: MacroInfoRecord = {\n    columnbreak: { renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    multicols: {\n        signature: \"m o o\",\n    },\n    \"multicols*\": {\n        signature: \"m o o\",\n    },\n};\n", "import * as cleveref from \"./package/cleveref\";\nimport * as exam from \"./package/exam\";\nimport * as geometry from \"./package/geometry\";\nimport * as hyperref from \"./package/hyperref\";\nimport * as latex2e from \"./package/latex2e\";\nimport * as listings from \"./package/listings\";\nimport * as makeidx from \"./package/makeidx\";\nimport * as mathtools from \"./package/mathtools\";\nimport * as minted from \"./package/minted\";\nimport * as nicematrix from \"./package/nicematrix\";\nimport * as systeme from \"./package/systeme\";\nimport * as tikz from \"./package/tikz\";\nimport * as xcolor from \"./package/xcolor\";\nimport * as xparse from \"./package/xparse\";\nimport * as beamer from \"./package/beamer\";\nimport * as multicol from \"./package/multicol\";\n\n/**\n * Info about the macros for available ctan packages. `latex2e` contains\n * the standard macros for LaTeX.\n */\nexport const macroInfo = {\n    cleveref: cleveref.macros,\n    exam: exam.macros,\n    geometry: geometry.macros,\n    hyperref: hyperref.macros,\n    latex2e: latex2e.macros,\n    listings: listings.macros,\n    makeidx: makeidx.macros,\n    mathtools: mathtools.macros,\n    minted: minted.macros,\n    nicematrix: nicematrix.macros,\n    systeme: systeme.macros,\n    tikz: tikz.macros,\n    xcolor: xcolor.macros,\n    xparse: xparse.macros,\n    beamer: beamer.macros,\n    multicol: multicol.macros,\n};\n\n/**\n * Info about the environments for available ctan packages. `latex2e` contains\n * the standard environments for LaTeX.\n */\nexport const environmentInfo = {\n    cleveref: cleveref.environments,\n    exam: exam.environments,\n    geometry: geometry.environments,\n    hyperref: hyperref.environments,\n    latex2e: latex2e.environments,\n    listings: listings.environments,\n    makeidx: makeidx.environments,\n    mathtools: mathtools.environments,\n    minted: minted.environments,\n    nicematrix: nicematrix.environments,\n    systeme: systeme.environments,\n    tikz: tikz.environments,\n    xcolor: xcolor.environments,\n    xparse: xparse.environments,\n    beamer: beamer.environments,\n    multicol: multicol.environments,\n};\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Macro/environment definitions and utilities for specific LaTeX packages from CTAN.\n *\n * Note: basic LaTeX macro/environment definitions come from the `latex2e` package, even though\n * this is technically not a CTAN \"package\".\n *\n * ## When should I use this?\n *\n * If you want information about special functions/macros from particular CTAN packages, or\n * you need to parse special environments.\n *\n * ## Notes\n *\n * By default all macros/environments that are exported get processed. If multiple packages\n * export a macro with the same name, then the later-exported one takes precedence. If two packages\n * export a macro/environment of the same name but with conflicting argument signatures, this can\n * cause issues when another unified-latex package processes arguments positionally. For example,\n * by default `\\textbf` takes one argument, but the beamer version of `\\textbf` takes two arguments.\n * During HTML conversion, if arguments are referenced positionally, this may cause previously-working\n * code to fail with when beamer macro signatures are used. A workaround is provided: `_renderInfo.namedArguments`.\n * If `_renderInfo.namedArguments` is specified on both the original macro/environment definition\n * **and** the conflicting one, other unified-latex commands can reference arguments by name instead\n * of by position.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Performs any needed processing on the environment (as specified by `envInfo`)\n * including attaching arguments and possibly manipulating the environment's body.\n */\nexport function processEnvironment(envNode: Ast.Environment, envInfo: EnvInfo) {\n    if (envInfo.signature && envNode.args == null) {\n        const { args } = gobbleArguments(envNode.content, envInfo.signature);\n        envNode.args = args;\n    }\n\n    updateRenderInfo(envNode, envInfo.renderInfo);\n    if (typeof envInfo.processContent === \"function\") {\n        envNode.content = envInfo.processContent(envNode.content);\n    }\n}\n\n/**\n * Recursively search for and process the specified environments. Arguments are\n * consumed according to the `signature` specified. The body is processed\n * with the specified `processContent` function (if given). Any specified `renderInfo`\n * is attached to the environment node.\n */\nexport function processEnvironments(\n    tree: Ast.Ast,\n    environments: EnvInfoRecord\n) {\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    visit(\n        tree,\n        {\n            leave: (node) => {\n                const envName = printRaw(node.env);\n                const envInfo = environments[envName];\n                if (!envInfo) {\n                    throw new Error(\n                        `Could not find environment info for environment \"${envName}\"`\n                    );\n                }\n                processEnvironment(node, envInfo);\n            },\n        },\n        { test: isRelevantEnvironment }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { processEnvironment } from \"./process-environment\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\ntype PluginOptions = { environments: EnvInfoRecord } | undefined;\n\n/**\n * Unified plugin to process environment content and attach arguments.\n *\n * @param environments An object whose keys are environment names and values contains information about the environment and its argument signature.\n */\nexport const unifiedLatexProcessEnvironments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {} } = options || {};\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    return (tree) => {\n        if (Object.keys(environments).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n\n        visit(\n            tree,\n            {\n                leave: (node) => {\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { test: isRelevantEnvironment }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Region } from \"./regions\";\n\n/**\n * Find all contiguous segments in the array that are between start and end blocks.\n * The `start` and `end` are functions that determine when a region starts and ends.\n */\nexport function findRegionInArray(\n    tree: Ast.Node[],\n    start: (node: Ast.Node) => boolean,\n    end: (node: Ast.Node) => boolean\n): Region[] {\n    const ret: Region[] = [];\n    let currRegion: Region = { start: undefined as any, end: tree.length };\n    for (let i = 0; i < tree.length; i++) {\n        const node = tree[i];\n        if (start(node)) {\n            currRegion.start = i;\n        }\n        if (end(node)) {\n            currRegion.end = i + 1;\n            ret.push(currRegion);\n            currRegion = { start: undefined as any, end: tree.length };\n        }\n    }\n\n    if (currRegion.start != null) {\n        // Regions don't necessarily have to encounter an `end` to end.\n        ret.push(currRegion);\n    }\n    return ret;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\n\nexport type Region = { start: number; end: number };\n\n/**\n * Given `regions`, a list of `Region`s (not necessarily ordered, possibly overlapping), return a list of in-order,\n * non-overlapping regions and a corresponding list containing a set of the original `Region`s that the new region\n * is a subset of.\n */\nexport function refineRegions(regions: Region[]): {\n    regions: Region[];\n    regionsContainedIn: Set<Region>[];\n} {\n    const _regions = [...regions];\n    _regions.sort((a, b) => a.start - b.start);\n    const cutPointsSet = new Set(_regions.flatMap((r) => [r.start, r.end]));\n    const cutPoints = Array.from(cutPointsSet);\n    cutPoints.sort((a, b) => a - b);\n\n    const retRegions: Region[] = [];\n    const retRegionsContainedIn: Set<Region>[] = [];\n\n    // We will be checking what regions we are completely contained in.\n    // Because `_regions` is sorted by start, `seekIndex` will be incremented\n    // by end, so that we don't do too much array testing.\n    let seekIndex = 0;\n    for (let i = 0; i < cutPoints.length - 1; i++) {\n        const start = cutPoints[i];\n        const end = cutPoints[i + 1];\n        const region = { start, end };\n        const regionContainedIn: Set<Region> = new Set();\n\n        let encounteredEndPastStart = false;\n        for (let j = seekIndex; j < _regions.length; j++) {\n            const superRegion = _regions[j];\n            if (superRegion.end >= region.start) {\n                encounteredEndPastStart = true;\n            }\n            if (!encounteredEndPastStart && superRegion.end < region.start) {\n                // In this case, the region (and all regions that came before)\n                // end before the region we are testing, so we may safely skip past it\n                // from here on out.\n                seekIndex = j + 1;\n                continue;\n            }\n\n            if (superRegion.start > end) {\n                // Because `_regions` is sorted, we can stop here\n                break;\n            }\n            if (\n                superRegion.start <= region.start &&\n                superRegion.end >= region.end\n            ) {\n                encounteredEndPastStart = true;\n                regionContainedIn.add(superRegion);\n            }\n        }\n\n        if (regionContainedIn.size > 0) {\n            // We only count if we are contained in a subregion\n            retRegions.push(region);\n            retRegionsContainedIn.push(regionContainedIn);\n        }\n    }\n\n    return { regions: retRegions, regionsContainedIn: retRegionsContainedIn };\n}\n\n/**\n * Split an array up into the disjoint regions specified by `regionRecord`.\n * Returned is a list of tuples, the first item being the key of `regionRecord` if there\n * was a corresponding region, or `null` if there was no corresponding region.\n *\n * This function assumes that the regions in `regionRecord` are disjoint and fully contained\n * within the bounds of `array`.\n */\nexport function splitByRegions<\n    T,\n    RegionRecord extends Record<string, Region[]>\n>(array: T[], regionsRecord: RegionRecord) {\n    const ret: [keyof RegionRecord | null, T[]][] = [];\n\n    const indices = [0, array.length];\n    const reverseMap: Record<string, keyof RegionRecord> = {};\n    for (const [key, records] of Object.entries(regionsRecord)) {\n        indices.push(\n            ...records.flatMap((r) => {\n                reverseMap[\"\" + [r.start, r.end]] = key;\n                return [r.start, r.end];\n            })\n        );\n    }\n    indices.sort((a, b) => a - b);\n\n    for (let i = 0; i < indices.length - 1; i++) {\n        const start = indices[i];\n        const end = indices[i + 1];\n        if (start === end) {\n            continue;\n        }\n        const regionKey = reverseMap[\"\" + [start, end]];\n\n        ret.push([regionKey || null, array.slice(start, end)]);\n    }\n\n    return ret;\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\n\n/**\n * Escape a string so that it can be used to build a regular expression.\n *\n * From: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n */\nfunction escapeRegExp(str: string) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\n/**\n * Build a regular expression that matches everything up to the first non-allowed symbol.\n */\nfunction buildWordRegex(allowedSet: Set<string>): RegExp {\n    // /\\p{L}/ matches all letters, including unicode letters. We join this with\n    // everything allowed in our set to form a regexp like\n    //   /(\\p{L}|_|:)*/u\n    // The `u` at the end allows unicode characters to be matched.\n    const regexpStr = `^(${[\"\\\\p{L}\"]\n        .concat(Array.from(allowedSet).map(escapeRegExp))\n        .join(\"|\")})*`;\n    return new RegExp(regexpStr, \"u\");\n}\n\n/**\n * Checks whether the array has a macro that could be reparsed given the `allowedTokens` but\n * do not do any reparsing. This function can be used in auto-detection schemes to determine if\n * macro names should actually be reparsed.\n */\nexport function hasReparsableMacroNamesInArray(\n    tree: Ast.Node[],\n    allowedTokens: Set<string>\n): boolean {\n    for (let i = 0; i < tree.length; i++) {\n        const macro = tree[i];\n        const string = tree[i + 1];\n        if (match.anyMacro(macro) && match.anyString(string)) {\n            // There are two options. Either the macro ends with the special character,\n            // e.g. `\\@foo` or the special character starts the next string, e.g. `\\foo@`.\n            if (\n                allowedTokens.has(\n                    macro.content.charAt(macro.content.length - 1)\n                ) ||\n                allowedTokens.has(string.content.charAt(0))\n            ) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Checks whether `tree` has a macro that could be reparsed given the `allowedTokens` but\n * do not do any reparsing. This function can be used in auto-detection schemes to determine if\n * macro names should actually be reparsed.\n */\nexport function hasReparsableMacroNames(\n    tree: Ast.Ast,\n    allowedTokens: string | Set<string>\n): boolean {\n    if (typeof allowedTokens === \"string\") {\n        allowedTokens = new Set(allowedTokens.split(\"\"));\n    }\n    // Recast so typescript doesn't complain\n    const _allowedTokens = allowedTokens;\n    for (const v of _allowedTokens) {\n        if (v.length > 1) {\n            throw new Error(\n                `Only single characters are allowed as \\`allowedTokens\\` when reparsing macro names, not \\`${v}\\`.`\n            );\n        }\n    }\n\n    let ret = false;\n    visit(\n        tree,\n        (nodes) => {\n            if (hasReparsableMacroNamesInArray(nodes, _allowedTokens)) {\n                ret = true;\n                return EXIT;\n            }\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n    return ret;\n}\n\n/**\n * Reparses all macro names in the array so that they may optionally include characters listed in `allowedTokens`.\n * This is used, for example, when parsing expl3 syntax which allows `_` to be used in a macro name (even though\n * `_` is normally stops the parsing for a macro name).\n */\nexport function reparseMacroNamesInArray(\n    tree: Ast.Node[],\n    allowedTokens: Set<string>\n) {\n    const regex = buildWordRegex(allowedTokens);\n    let i = 0;\n    while (i < tree.length) {\n        const macro = tree[i];\n        const string = tree[i + 1];\n        if (\n            match.anyMacro(macro) &&\n            // The _^ macros in math mode should not be extended no-matter what;\n            // So we check to make sure that the macro we're dealing with has the default escape token.\n            (macro.escapeToken == null || macro.escapeToken === \"\\\\\") &&\n            match.anyString(string) &&\n            // There are two options. Either the macro ends with the special character,\n            // e.g. `\\@foo` or the special character starts the next string, e.g. `\\foo@`.\n            (allowedTokens.has(\n                macro.content.charAt(macro.content.length - 1)\n            ) ||\n                allowedTokens.has(string.content.charAt(0)))\n        ) {\n            // There might be a number somewhere in the string. If so, we should\n            // break the string apart at that number\n            const match = string.content.match(regex);\n            const takeable = match ? match[0] : \"\";\n            if (takeable.length > 0) {\n                if (takeable.length === string.content.length) {\n                    // The whole string can be appended to the macro name\n                    macro.content += string.content;\n                    tree.splice(i + 1, 1);\n\n                    // Preserve the source location if available\n                    if (macro.position && string.position?.end) {\n                        macro.position.end = string.position.end;\n                    }\n                } else {\n                    // Only part of the string can be appended to the macro name\n                    macro.content += takeable;\n                    string.content = string.content.slice(takeable.length);\n\n                    // Preserve the source location if available\n                    if (macro.position?.end) {\n                        macro.position.end.offset += takeable.length;\n                        macro.position.end.column += takeable.length;\n                    }\n                    if (string.position?.start) {\n                        string.position.start.offset += takeable.length;\n                        string.position.start.column += takeable.length;\n                    }\n                }\n            } else {\n                i++;\n            }\n        } else {\n            ++i;\n        }\n    }\n}\n\n/**\n * Reparses all macro names so that they may optionally include characters listed in `allowedTokens`.\n * This is used, for example, when parsing expl3 syntax which allows `_` to be used in a macro name (even though\n * `_` is normally stops the parsing for a macro name). Thus, a macro `\\foo_bar:Nn` would be parsed as having\n * the name `foo_bar:Nn` rather than as `foo` followed by the strings `_`, `bar`, `:`, `Nn`.\n */\nexport function reparseMacroNames(\n    tree: Ast.Ast,\n    allowedTokens: string | Set<string>\n) {\n    if (typeof allowedTokens === \"string\") {\n        allowedTokens = new Set(allowedTokens.split(\"\"));\n    }\n    // Recast so typescript doesn't complain\n    const _allowedTokens = allowedTokens;\n    for (const v of _allowedTokens) {\n        if (v.length > 1) {\n            throw new Error(\n                `Only single characters are allowed as \\`allowedTokens\\` when reparsing macro names, not \\`${v}\\`.`\n            );\n        }\n    }\n\n    visit(\n        tree,\n        (nodes) => {\n            reparseMacroNamesInArray(nodes, _allowedTokens);\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { findRegionInArray } from \"./find-region\";\nimport { refineRegions, Region, splitByRegions } from \"./regions\";\nimport { SKIP, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { reparseMacroNames } from \"./reparse-macro-names\";\n\nconst expl3Find = {\n    start: match.createMacroMatcher([\"ExplSyntaxOn\"]),\n    end: match.createMacroMatcher([\"ExplSyntaxOff\"]),\n};\nconst atLetterFind = {\n    start: match.createMacroMatcher([\"makeatletter\"]),\n    end: match.createMacroMatcher([\"makeatother\"]),\n};\n\n/**\n * Find regions between `\\ExplSyntaxOn...\\ExplSyntaxOff` and `\\makeatletter...\\makeatother`.\n * Returns an object containing regions where one or both syntax's apply.\n */\nexport function findExpl3AndAtLetterRegionsInArray(tree: Ast.Node[]): {\n    explOnly: Region[];\n    atLetterOnly: Region[];\n    both: Region[];\n} {\n    const expl3 = findRegionInArray(tree, expl3Find.start, expl3Find.end);\n    const atLetter = findRegionInArray(\n        tree,\n        atLetterFind.start,\n        atLetterFind.end\n    );\n\n    const regionMap = new Map([\n        ...(expl3.map((x) => [x, \"expl\"]) as [Region, \"expl\"][]),\n        ...(atLetter.map((x) => [x, \"atLetter\"]) as [Region, \"atLetter\"][]),\n    ]);\n    const all = refineRegions([...expl3, ...atLetter]);\n\n    const ret = {\n        explOnly: [] as Region[],\n        atLetterOnly: [] as Region[],\n        both: [] as Region[],\n    };\n\n    for (let i = 0; i < all.regions.length; i++) {\n        const region = all.regions[i];\n        const containedIn = all.regionsContainedIn[i];\n        if (containedIn.size === 2) {\n            ret.both.push(region);\n            continue;\n        }\n        for (const v of containedIn.values()) {\n            if (regionMap.get(v) === \"expl\") {\n                ret.explOnly.push(region);\n            }\n            if (regionMap.get(v) === \"atLetter\") {\n                ret.atLetterOnly.push(region);\n            }\n        }\n    }\n\n    // Regions of size 1 only contain the starting/stopping macro, so they should be discarded\n    ret.explOnly = ret.explOnly.filter((r) => r.end - r.start > 1);\n    ret.atLetterOnly = ret.atLetterOnly.filter((r) => r.end - r.start > 1);\n    ret.both = ret.both.filter((r) => r.end - r.start > 1);\n\n    return ret;\n}\n\nconst atLetterSet = new Set([\"@\"]);\nconst explSet = new Set([\"_\", \":\"]);\nconst bothSet = new Set([\"_\", \":\", \"@\"]);\n\n/**\n * Find regions between `\\ExplSyntaxOn...\\ExplSyntaxOff` and `\\makeatletter...\\makeatother`\n * and reparse their contents so that the relevant characters (e.g., `@`, `_`, and `:`) become\n * part of the macro names.\n */\nexport function reparseExpl3AndAtLetterRegions(tree: Ast.Ast) {\n    visit(\n        tree,\n        {\n            leave: (nodes) => {\n                const regions = findExpl3AndAtLetterRegionsInArray(nodes);\n                // In all likelihood, we don't need to do any reparsing, so bail early here\n                const totalNumRegions =\n                    regions.both.length +\n                    regions.atLetterOnly.length +\n                    regions.explOnly.length;\n                if (totalNumRegions === 0) {\n                    return;\n                }\n\n                const splits = splitByRegions(nodes, regions);\n                const processed: typeof nodes = [];\n                for (const [key, slice] of splits) {\n                    switch (key) {\n                        case null:\n                            processed.push(...slice);\n                            continue;\n                        case \"atLetterOnly\":\n                            reparseMacroNames(slice, atLetterSet);\n                            processed.push(...slice);\n                            continue;\n                        case \"explOnly\":\n                            reparseMacroNames(slice, explSet);\n                            processed.push(...slice);\n                            continue;\n                        case \"both\":\n                            reparseMacroNames(slice, bothSet);\n                            processed.push(...slice);\n                            continue;\n                        default:\n                            throw new Error(\n                                `Unexpected case when splitting ${key}`\n                            );\n                    }\n                }\n\n                nodes.length = 0;\n                nodes.push(...processed);\n                return SKIP;\n            },\n        },\n        { includeArrays: true, test: Array.isArray }\n    );\n}\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Unified complier plugin that passes through a LaTeX AST without modification.\n */\nexport const unifiedLatexAstComplier: Plugin<void[], Ast.Root, Ast.Root> =\n    function unifiedLatexAstComplier() {\n        Object.assign(this, { Compiler: (x: Ast.Root) => x });\n    };\n", "import { LatexPegParser } from \"@unified-latex/unified-latex-util-pegjs\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n */\nexport function parseMinimal(str: string): Ast.Root {\n    return LatexPegParser.parse(str);\n}\n\n/**\n * Parse `str` to an AST with minimal processing. E.g., macro\n * arguments are not attached to macros, etc. when parsed with this\n * function.\n *\n * The parsing assumes a math-mode context, so, for example, `^` and `_` are\n * parsed as macros (even though arguments are not attached to them).\n */\nexport function parseMathMinimal(str: string): Ast.Node[] {\n    return LatexPegParser.parse(str, { startRule: \"math\" });\n}\n", "import { Plugin, Parser } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { parseMathMinimal, parseMinimal } from \"./parse-minimal\";\n\ntype PluginOptions = {\n    /**\n     * Whether the text will be parsed assuming math mode or not.\n     */\n    mode: \"math\" | \"regular\";\n} | void;\n\n/**\n * Parse a string to a LaTeX AST with no post processing. For example,\n * no macro arguments will be attached, etc.\n */\nexport const unifiedLatexFromStringMinimal: Plugin<\n    PluginOptions[],\n    string,\n    Ast.Root\n> = function unifiedLatexFromStringMinimal(options) {\n    const parser: Parser<Ast.Root> = (str) => {\n        if (options?.mode === \"math\") {\n            return {\n                type: \"root\",\n                content: parseMathMinimal(str),\n                _renderInfo: { inMathMode: true },\n            };\n        }\n        return parseMinimal(str);\n    };\n\n    Object.assign(this, { Parser: parser });\n};\n", "import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { parseMathMinimal } from \"./parse-minimal\";\n\ntype PluginOptions =\n    | {\n          /**\n           * List of environments whose body should be parsed in math mode\n           */\n          mathEnvs: string[];\n          /**\n           * List of macros whose bodies should be parsed in math mode\n           */\n          mathMacros: string[];\n      }\n    | undefined;\n\n/**\n * Reparse math environments/macro contents that should have been parsed in math mode but weren't.\n */\nexport const unifiedLatexReparseMath: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexReparseMath(options) {\n    const { mathEnvs = [], mathMacros = [] } = options || {};\n\n    return unifiedLatexReparseMathConstructPlugin({ mathMacros, mathEnvs });\n};\n\n/**\n * Construct the inner function for the `unifiedLatexReparseMath` plugin. This function should not be used by libraries.\n */\nexport function unifiedLatexReparseMathConstructPlugin({\n    mathEnvs,\n    mathMacros,\n}: {\n    mathEnvs: string[];\n    mathMacros: string[];\n}) {\n    const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n    const isMathMacro = match.createMacroMatcher(mathMacros);\n\n    return (tree: Ast.Root) => {\n        visit(\n            tree,\n            (node) => {\n                if (match.anyMacro(node)) {\n                    for (const arg of node.args || []) {\n                        if (\n                            arg.content.length > 0 &&\n                            !wasParsedInMathMode(arg.content)\n                        ) {\n                            arg.content = parseMathMinimal(\n                                printRaw(arg.content)\n                            );\n                        }\n                    }\n                }\n                if (match.anyEnvironment(node)) {\n                    if (!wasParsedInMathMode(node.content)) {\n                        node.content = parseMathMinimal(printRaw(node.content));\n                    }\n                }\n            },\n            {\n                test: (node) => isMathEnvironment(node) || isMathMacro(node),\n            }\n        );\n    };\n}\n\n/**\n * Use a heuristic to decide whether a string was parsed in math mode. The heuristic\n * looks for strings of length greater than 1 or the failure for \"_\" and \"^\" to be parsed\n * as a macro.\n */\nfunction wasParsedInMathMode(nodes: Ast.Node[]): boolean {\n    return !nodes.some(\n        (node) =>\n            // If there are multi-char strings or ^ and _ have been parsed as strings, we know\n            // that we were not parsed in math mode.\n            (match.anyString(node) && node.content.length > 1) ||\n            match.string(node, \"^\") ||\n            match.string(node, \"_\")\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfoRecord,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexReparseMathConstructPlugin } from \"./reparse-math\";\nimport { attachMacroArgsInArray } from \"@unified-latex/unified-latex-util-arguments\";\nimport { processEnvironment } from \"@unified-latex/unified-latex-util-environments\";\n\ntype PluginOptions =\n    | { environments: EnvInfoRecord; macros: MacroInfoRecord }\n    | undefined;\n\n/**\n * Unified plugin to process macros and environments. Any environments that contain math content\n * are reparsed (if needed) in math mode.\n */\nexport const unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse(options) {\n    const { environments = {}, macros = {} } = options || {};\n\n    const mathMacros = Object.fromEntries(\n        Object.entries(macros).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n    const mathEnvs = Object.fromEntries(\n        Object.entries(environments).filter(\n            ([_, info]) => info.renderInfo?.inMathMode === true\n        )\n    );\n\n    const mathReparser = unifiedLatexReparseMathConstructPlugin({\n        mathEnvs: Object.keys(mathEnvs),\n        mathMacros: Object.keys(mathMacros),\n    });\n\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n    const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);\n\n    return (tree) => {\n        // First we attach all arguments/process all nodes/environments that have math content\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, mathMacros);\n                },\n                leave: (node) => {\n                    if (!isRelevantMathEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n\n        // Next we reparse macros/envs that may not have been parsed in math mode\n        mathReparser(tree);\n\n        // Now we attach all arguments/process all environment bodies\n        visit(\n            tree,\n            {\n                enter: (nodes) => {\n                    if (!Array.isArray(nodes)) {\n                        return;\n                    }\n                    attachMacroArgsInArray(nodes, macros);\n                },\n                leave: (node) => {\n                    if (!isRelevantEnvironment(node)) {\n                        return;\n                    }\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { includeArrays: true }\n        );\n    };\n};\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { reparseExpl3AndAtLetterRegions } from \"@unified-latex/unified-latex-util-catcode\";\nimport {\n    hasReparsableMacroNames,\n    reparseMacroNames,\n} from \"@unified-latex/unified-latex-util-catcode\";\n\ntype PluginOptions =\n    | {\n          /**\n           * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character).\n           * If this option is true, it disables autodetect.\n           */\n          atLetter?: boolean;\n          /**\n           * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n           * If this option is true, it disables autodetect.\n           */\n          expl3?: boolean;\n          /**\n           * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n           * Defaults to `true`.\n           */\n          autodetectExpl3AndAtLetter?: boolean;\n      }\n    | undefined;\n\n/**\n * Unified plugin to reprocess macros names to possibly include `@`, `_`, or `:`.\n * This plugin detects the `\\makeatletter` and `\\ExplSyntaxOn` commands and reprocesses macro names\n * inside of those blocks to include those characters.\n */\nexport const unifiedLatexProcessAtLetterAndExplMacros: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexProcessAtLetterAndExplMacros(options) {\n    let {\n        atLetter = false,\n        expl3 = false,\n        autodetectExpl3AndAtLetter = false,\n    } = options || {};\n\n    return (tree) => {\n        // First we reparse based on explicit \\makeatletter and \\ExplSyntaxOn macros\n        reparseExpl3AndAtLetterRegions(tree);\n        if (atLetter || expl3) {\n            autodetectExpl3AndAtLetter = false;\n        }\n        if (autodetectExpl3AndAtLetter) {\n            atLetter = hasReparsableMacroNames(tree, \"@\");\n            // We don't check for the `:` here because it could be prone to misidentification.\n            expl3 = hasReparsableMacroNames(tree, \"_\");\n        }\n        const charSet: Set<string> = new Set();\n        if (atLetter) {\n            charSet.add(\"@\");\n        }\n        if (expl3) {\n            charSet.add(\":\");\n            charSet.add(\"_\");\n        }\n\n        if (charSet.size > 0) {\n            reparseMacroNames(tree, charSet);\n        }\n    };\n};\n", "import { Plugin, Parser, unified } from \"unified\";\nimport { environmentInfo, macroInfo } from \"@unified-latex/unified-latex-ctan\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfoRecord,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport {\n    unifiedLatexTrimEnvironmentContents,\n    unifiedLatexTrimRoot,\n} from \"@unified-latex/unified-latex-util-trim\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromStringMinimal } from \"./plugin-from-string-minimal\";\nimport { unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse } from \"./process-macros-and-environments\";\nimport { unifiedLatexProcessAtLetterAndExplMacros } from \"./process-at-letter-and-expl-macros\";\n\nexport type PluginOptions =\n    | {\n          mode?: \"math\" | \"regular\";\n          macros?: MacroInfoRecord;\n          environments?: EnvInfoRecord;\n          flags?: {\n              /**\n               * Whether to parse macros as if `\\makeatletter` is set (i.e., parse `@` as a regular macro character)\n               */\n              atLetter?: boolean;\n              /**\n               * Whether to parse macros as if `\\ExplSyntaxOn` is set (i.e., parse `_` and `:` as a regular macro character)\n               */\n              expl3?: boolean;\n              /**\n               * Attempt to autodetect whether there are macros that look like they should contain `@`, `_`, or `:`.\n               * Defaults to `false`.\n               */\n              autodetectExpl3AndAtLetter?: boolean;\n          };\n      }\n    | undefined;\n\n/**\n * Parse a string to a LaTeX AST.\n */\nexport const unifiedLatexFromString: Plugin<PluginOptions[], string, Ast.Root> =\n    function unifiedLatexFromString(options) {\n        const {\n            mode = \"regular\",\n            macros = {},\n            environments = {},\n            flags: {\n                atLetter = false,\n                expl3 = false,\n                autodetectExpl3AndAtLetter = false,\n            } = {},\n        } = options || {};\n\n        // Build up a parsing plugin with only unified components\n        const allMacroInfo: MacroInfoRecord = Object.assign(\n            {},\n            ...Object.values(macroInfo),\n            macros\n        );\n        const allEnvInfo: EnvInfoRecord = Object.assign(\n            {},\n            ...Object.values(environmentInfo),\n            environments\n        );\n\n        // Build up a parser that will perform all the needed steps\n        const fullParser = unified()\n            .use(unifiedLatexFromStringMinimal, { mode })\n            .use(unifiedLatexProcessAtLetterAndExplMacros, {\n                atLetter,\n                expl3,\n                autodetectExpl3AndAtLetter,\n            })\n            // Math environments that aren't hardcoded into the PEG grammar need to be re-parsed,\n            // so do a minimal pass first with just those environments.\n            .use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {\n                macros: allMacroInfo,\n                environments: allEnvInfo,\n            })\n            .use(unifiedLatexTrimEnvironmentContents)\n            .use(unifiedLatexTrimRoot)\n            .use(unifiedLatexAstComplier);\n\n        const parser: Parser<Ast.Root> = (str) => {\n            const file = fullParser.processSync({ value: str });\n            return file.result;\n        };\n\n        Object.assign(this, { Parser: parser });\n    };\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { type FrozenProcessor, unified } from \"unified\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\nimport type { PluginOptions } from \"./plugin-from-string\";\n\nlet parser = unified().use(unifiedLatexFromString).freeze();\n\n/**\n * Parse the string into an AST.\n */\nexport function parse(str: string): Ast.Root {\n    return parser.parse(str);\n}\n\n/**\n * Returns the default `unified-latex` parser, or create a new one with the\n * provided `unifiedLatexFromString` options\n * @param options Plugin options of `unifiedLatexFromString` plugin.\n * @returns The default `unified-latex` parser if `options` is `undefined`, or a\n * newly created `unified-latex` parser with the provided `options`.\n */\nexport function getParser(\n    options?: PluginOptions\n): FrozenProcessor<Ast.Root, Ast.Root, Ast.Root, void> {\n    return options\n        ? unified().use(unifiedLatexFromString, options).freeze()\n        : parser;\n}\n", "import { unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { unifiedLatexAstComplier } from \"./compiler-ast\";\nimport { unifiedLatexFromString } from \"./plugin-from-string\";\n\n/**\n * Parse `str` into an AST. Parsing starts in math mode and a list of\n * nodes is returned (instead of a \"root\" node).\n */\nexport function parseMath(str: string | Ast.Ast): Ast.Node[] {\n    if (typeof str !== \"string\") {\n        str = printRaw(str);\n    }\n    const file = unified()\n        .use(unifiedLatexFromString, { mode: \"math\" })\n        .use(unifiedLatexAstComplier)\n        .processSync({ value: str });\n    return (file.result as Ast.Root).content;\n}\n", "function isEmptyNode(node) {\n    if (!(node === null || node === void 0 ? void 0 : node.content) || node.content.length === 0)\n        return true;\n    return false;\n}\nexport const typstStrings = {\n    ',': (state) => (state.data.inFunction ? 'comma' : ','),\n    '&': (state) => (state.data.inArray ? ',' : '&'),\n    '/': '\\\\/',\n    ';': '\\\\;',\n};\nfunction splitStrings(node) {\n    var _a, _b, _c;\n    if (((_b = (_a = node.args) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.length) === 1 &&\n        ((_c = node.args) === null || _c === void 0 ? void 0 : _c[0].content)[0].type === 'string') {\n        node.args[0].content = node.args[0].content[0].content\n            .split('')\n            .map((l) => ({ type: 'string', content: l }));\n    }\n}\nexport const typstMacros = {\n    cdot: 'dot.op',\n    to: 'arrow.r',\n    rightarrow: 'arrow.r',\n    leftarrow: 'arrow.l',\n    gets: 'arrow.l',\n    infty: 'infinity',\n    nonumber: '',\n    int: 'integral',\n    iint: 'integral.double',\n    sqrt: (state, node) => {\n        var _a;\n        if (isEmptyNode((_a = node.args) === null || _a === void 0 ? void 0 : _a[0]))\n            return 'sqrt';\n        return 'root';\n    },\n    vec: 'arrow',\n    mathbf: 'bold',\n    boldsymbol: 'bold',\n    mathrm: 'upright',\n    rm: 'upright',\n    mathcal: 'cal',\n    mathfrak: 'frak',\n    pm: 'plus.minus',\n    partial: 'diff',\n    _: (state, node) => {\n        splitStrings(node);\n        return '_';\n    },\n    '^': (state, node) => {\n        splitStrings(node);\n        return '^';\n    },\n    left: (state, node) => {\n        var _a;\n        const args = node.args;\n        node.args = [];\n        const left = ((_a = args === null || args === void 0 ? void 0 : args[0].content) === null || _a === void 0 ? void 0 : _a[0]).content;\n        if (left === '(')\n            return '(';\n        if (left === '[')\n            return '[';\n        if (left === '{')\n            return '{';\n        if (left === '|')\n            return '|';\n        throw new Error(`Undefined left bracket: ${left}`);\n    },\n    right: (state, node) => {\n        var _a;\n        const args = node.args;\n        node.args = [];\n        const right = ((_a = args === null || args === void 0 ? void 0 : args[0].content) === null || _a === void 0 ? void 0 : _a[0]).content;\n        if (right === ')')\n            return ')';\n        if (right === ']')\n            return ']';\n        if (right === '}')\n            return '}';\n        if (right === '|')\n            return '|';\n        throw new Error(`Undefined right bracket: ${right}`);\n    },\n    operatorname: (state, node) => {\n        var _a;\n        const text = (_a = node.args) === null || _a === void 0 ? void 0 : _a.slice(-1)[0];\n        node.args = [{ type: 'macro', content: 'text', args: [text] }];\n        return 'op';\n    },\n    '\\\\': (state, node) => {\n        node.args = [];\n        if (state.data.inArray)\n            return ';';\n        return '\\\\\\n';\n    },\n    sim: 'tilde',\n    phi: 'phi.alt',\n    propto: 'prop',\n    doteq: 'dot(eq)',\n    ge: 'gt.eq',\n    geq: 'gt.eq',\n    le: 'lt.eq',\n    leq: 'lt.eq',\n    neq: 'eq.not',\n    dot: 'dot',\n    ddot: 'dot.double',\n    dots: 'dots.h',\n    ldots: 'dots.h',\n    vdots: 'dots.v',\n    ddots: 'dots.down',\n    subseteq: 'subset.eq',\n    cdots: 'dots.h.c',\n    cap: 'sect',\n    cup: 'union',\n    widehat: 'hat',\n    // Spaces\n    ',': 'thin',\n    ':': 'med',\n    ';': 'thick',\n    '!': '#h(-1em)',\n    quad: 'quad',\n    qquad: 'wide',\n    prod: 'product',\n    mathbb: (state, node) => {\n        var _a, _b, _c, _d, _e;\n        const text = (_e = (_d = (_c = (_b = (_a = node.args) === null || _a === void 0 ? void 0 : _a.slice(-1)[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.content) !== null && _e !== void 0 ? _e : '';\n        const letters = text\n            .split('')\n            .map((l) => `${l}${l}`)\n            .join(' ');\n        node.args = [];\n        return letters;\n    },\n};\nexport const typstEnvs = {\n    array: (state, node) => {\n        state.data.inArray = true;\n        state.openFunction('mat');\n        // TODO: transform the surrounding brackets into arguments\n        state.write('delim: #none,');\n        state.writeChildren(node);\n        state.closeFunction();\n        state.data.inArray = false;\n    },\n};\n", "import { unified } from 'unified';\nimport { unifiedLatexFromString, unifiedLatexAstComplier, } from '@unified-latex/unified-latex-util-parse';\nimport { unifiedLatexAttachMacroArguments, gobbleArguments, } from '@unified-latex/unified-latex-util-arguments';\nimport { typstEnvs, typstMacros, typstStrings } from './macros.js';\nexport function parseLatex(value) {\n    const file = unified()\n        .use(unifiedLatexFromString, { mode: 'math' })\n        .use(unifiedLatexAstComplier)\n        .use(unifiedLatexAttachMacroArguments, {\n        macros: {\n            vec: { signature: 'm' },\n            boldsymbol: { signature: 'm' },\n            left: { signature: 'm' },\n            right: { signature: 'm' },\n            dot: { signature: 'm' },\n            ddot: { signature: 'm' },\n            hat: { signature: 'm' },\n            widehat: { signature: 'm' },\n        },\n    })\n        .processSync({ value });\n    const content = file.result.content;\n    const tree = { type: 'math', content };\n    return tree;\n}\nexport * from './macros.js';\nexport function walkLatex(node) {\n    delete node.position;\n    if (Array.isArray(node.content)) {\n        const content = node.content.map((n) => walkLatex(n));\n        let skip = 0;\n        const parsed = content.reduce((list, next, i, array) => {\n            var _a;\n            if (skip > 0) {\n                skip -= 1;\n                return list;\n            }\n            if (next.type === 'string' && (next.content === '_' || next.content === '^')) {\n                const { args, nodesRemoved } = gobbleArguments(array.slice(i + 1), 'm');\n                next.type = 'macro';\n                next.args = args;\n                skip += nodesRemoved;\n            }\n            if (next.type === 'macro' &&\n                (next.content === 'overbrace' || next.content === 'underbrace')) {\n                const { args, nodesRemoved } = gobbleArguments(array.slice(i + 1), 'm');\n                if (args[0].content.length === 1 &&\n                    args[0].content[0].type === 'macro' &&\n                    ((args[0].content[0].content === '^' && next.content === 'overbrace') ||\n                        (args[0].content[0].content === '_' && next.content === 'underbrace'))) {\n                    next.args = [...((_a = next.args) !== null && _a !== void 0 ? _a : []), ...args[0].content[0].args];\n                    skip += nodesRemoved;\n                }\n            }\n            list.push(next);\n            return list;\n        }, []);\n        node.content = parsed;\n        return { ...node, content: parsed };\n    }\n    if (Array.isArray(node.args)) {\n        const args = node.args.map((n) => walkLatex(n));\n        node.args = args;\n        return { ...node, args };\n    }\n    return node;\n}\nclass State {\n    constructor() {\n        this._scriptsSimplified = false;\n        this._closeToken = [];\n        this._currentFunctions = [];\n        this._value = '';\n        this.data = {};\n    }\n    get value() {\n        return this._value;\n    }\n    addWhitespace() {\n        const lastChar = this.value.slice(-1);\n        if (!this._value || lastChar.match(/^([\"\\s_^{(-])$/))\n            return;\n        this._value += ' ';\n    }\n    write(str) {\n        if (!str)\n            return;\n        // This is a bit verbose, but the statements are much easier to read\n        if (this._scriptsSimplified && str === '(') {\n            this.addWhitespace();\n        }\n        else if (str.match(/^([}()_^,;!])$/)) {\n            // Ignore!\n        }\n        else {\n            this.addWhitespace();\n        }\n        this._scriptsSimplified = false;\n        this._value += str;\n    }\n    writeChildren(node) {\n        var _a;\n        if (!Array.isArray(node === null || node === void 0 ? void 0 : node.content))\n            return;\n        (_a = node.content) === null || _a === void 0 ? void 0 : _a.forEach((n) => {\n            writeTypst(n, this);\n        });\n    }\n    get _currentFunction() {\n        return this._currentFunctions.slice(-1)[0];\n    }\n    get _functionCount() {\n        return this._currentFunctions.length;\n    }\n    openFunction(command) {\n        if (command === 'text') {\n            this.addWhitespace();\n        }\n        else {\n            this.write(command);\n        }\n        this._currentFunctions.push(command);\n        this.data.inFunction = true;\n        this._simplify = command === '_' || command === '^';\n        this._lastFunction = this._value.length;\n        this._value += command === 'text' ? '\"' : '(';\n        this._closeToken.push(command === 'text' ? '\"' : ')');\n    }\n    closeFunction() {\n        this._value += this._closeToken.pop() || ')';\n        this._currentFunctions.pop();\n        this.data.inFunction = this._functionCount >= 1;\n        if (!this._simplify)\n            return;\n        // We will attempt to change `x_(i)` into `x_i`\n        const simple = this._value.slice(this._lastFunction);\n        if (simple.length === 3 || simple.match(/^\\([a-zA-Z]*\\)$/)) {\n            this._value = this._value.slice(0, this._lastFunction) + simple.slice(1, -1);\n            this._scriptsSimplified = true;\n        }\n    }\n}\nfunction convert(state, node) {\n    if (node.type === 'macro' && typeof node.content === 'string') {\n        const result = typstMacros[node.content];\n        const converted = typeof result === 'function' ? result(state, node) : result;\n        return converted !== null && converted !== void 0 ? converted : node.content;\n    }\n    return '';\n}\nfunction convertText(state, text) {\n    const result = typstStrings[text];\n    if (typeof result === 'function')\n        return result(state) || text;\n    return result || text;\n}\nexport function writeTypst(node, state = new State()) {\n    if (node.type === 'whitespace') {\n        // We are controlling whitespace in the renderer\n        return state;\n    }\n    else if (node.type === 'string') {\n        // Values can come in as multiple characters\n        const val = node.content;\n        if (state._currentFunction === 'text') {\n            state.write(convertText(state, val));\n        }\n        else {\n            val.split('').forEach((v) => {\n                state.write(convertText(state, v));\n            });\n        }\n    }\n    else if (node.type === 'environment' && Array.isArray(node.content)) {\n        const env = typstEnvs[node.env];\n        env === null || env === void 0 ? void 0 : env(state, node);\n    }\n    else if (Array.isArray(node.content)) {\n        state.writeChildren(node);\n    }\n    else if (node.type === 'macro' && Array.isArray(node.args)) {\n        const converted = convert(state, node);\n        if (node.args.length === 0) {\n            state.write(converted);\n            return state;\n        }\n        state.openFunction(converted);\n        node.args\n            .filter((n) => {\n            if (Array.isArray(n.content) && n.content.length === 0)\n                return false;\n            return true;\n        })\n            .forEach((n, i) => {\n            if (i !== 0)\n                state.write(',');\n            writeTypst(n, state);\n        });\n        state.closeFunction();\n    }\n    else if (node.type === 'macro' && typeof node.content === 'string') {\n        const converted = convert(state, node);\n        state.write(converted !== null && converted !== void 0 ? converted : node.content);\n    }\n    return state;\n}\nfunction postProcess(typst) {\n    return typst.replace(/^(_|\\^)/, '\"\"$1');\n}\nexport function texToTypst(value) {\n    const tree = parseLatex(value);\n    walkLatex(tree);\n    const state = writeTypst(tree);\n    return postProcess(state.value);\n}\n", "import { texToTypst } from 'tex-to-typst';\nfunction addMacrosToState(value, state) {\n    if (!state.options.math)\n        return;\n    Object.entries(state.options.math).forEach(([k, v]) => {\n        const key = texToTypst(k);\n        if (value.includes(key)) {\n            state.data.mathPlugins[key] = texToTypst(v.macro);\n        }\n    });\n}\nfunction findCommandInMacro(macro, command) {\n    const escapedCommand = command.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const commandRe = new RegExp(`${escapedCommand}(?![a-zA-Z])`, 'g');\n    return [...macro.matchAll(commandRe)].length > 0;\n}\nfunction replaceCommandInMacro(macro, command, replaceValue) {\n    const escapedCommand = command.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const commandRe = new RegExp(`${escapedCommand}(?![a-zA-Z])`, 'g');\n    return macro.replaceAll(commandRe, replaceValue);\n}\n/**\n * MyST typst exports currently require recursive commands to be resolved\n *\n * As opposed to tex where recursive commands can remain and the latex compiler\n * will handle them.\n *\n * All the state.options.math macros are passed to this function and resolved prior to\n * exporting typst.\n */\nexport function resolveRecursiveCommands(plugins) {\n    let pluginsUpdated = false;\n    const newPlugins = Object.fromEntries(Object.entries(plugins).map(([command, value]) => {\n        let newMacro = value.macro;\n        Object.entries(plugins).forEach(([c, { macro: m }]) => {\n            if (findCommandInMacro(newMacro, c)) {\n                if (command === c) {\n                    // recursive issue\n                }\n                else {\n                    newMacro = replaceCommandInMacro(newMacro, c, m);\n                    pluginsUpdated = true;\n                }\n            }\n        });\n        return [command, { ...value, macro: newMacro }];\n    }));\n    if (pluginsUpdated)\n        return resolveRecursiveCommands(newPlugins);\n    return newPlugins;\n}\nconst math = (node, state) => {\n    const value = texToTypst(node.value);\n    addMacrosToState(value, state);\n    state.ensureNewLine();\n    // Note: must have spaces $ math $ for the block!\n    state.write(`$ ${value} $${node.label ? ` <${node.label}>` : ''}\\n\\n`);\n    state.ensureNewLine(true);\n};\nconst inlineMath = (node, state) => {\n    const value = texToTypst(node.value);\n    addMacrosToState(value, state);\n    state.write(`$${value}$`);\n};\nconst MATH_HANDLERS = { math, inlineMath };\nexport default MATH_HANDLERS;\n", "import { fileError } from 'myst-common';\nfunction countColumns(table) {\n    var _a, _b;\n    const firstRow = (_a = table.children) === null || _a === void 0 ? void 0 : _a.find((child) => child.type === 'tableRow');\n    const columns = (_b = firstRow === null || firstRow === void 0 ? void 0 : firstRow.children) === null || _b === void 0 ? void 0 : _b.filter((cell) => cell.type === 'tableCell').reduce((val, cell) => { var _a; return val + ((_a = cell.colspan) !== null && _a !== void 0 ? _a : 1); }, 0);\n    return columns;\n}\nfunction isHeaderRow(node) {\n    var _a;\n    if (node.type !== 'tableRow')\n        return false;\n    return (_a = node.children) === null || _a === void 0 ? void 0 : _a.filter((child) => child.type === 'tableCell').every((child) => child.header);\n}\nfunction countHeaderRows(table) {\n    var _a, _b;\n    const headerRows = (_a = table.children) === null || _a === void 0 ? void 0 : _a.filter((child) => isHeaderRow(child));\n    return (_b = headerRows === null || headerRows === void 0 ? void 0 : headerRows.length) !== null && _b !== void 0 ? _b : 0;\n}\nexport const tableHandler = (node, state) => {\n    const prevState = state.data.isInTable;\n    state.data.isInTable = true;\n    const command = state.data.isInFigure ? 'tablex' : '#tablex';\n    const columns = countColumns(node);\n    if (!columns) {\n        fileError(state.file, 'Unable to count table columns', {\n            node,\n            source: 'myst-to-typst',\n        });\n        return;\n    }\n    state.useMacro('#import \"@preview/tablex:0.0.7\": tablex, cellx');\n    state.write(`${command}(columns: ${columns}, header-rows: ${countHeaderRows(node)}, repeat-header: true,\\n`);\n    state.renderChildren(node, 1);\n    state.write(')\\n');\n    state.data.isInTable = prevState;\n};\nexport const tableRowHandler = (node, state) => {\n    state.renderChildren(node, 1);\n};\nexport const tableCellHandler = (node, state) => {\n    if (node.rowspan || node.colspan) {\n        state.write('cellx(');\n        if (node.rowspan) {\n            state.write(`rowspan: ${node.rowspan}, `);\n        }\n        if (node.colspan) {\n            state.write(`colspan: ${node.colspan}, `);\n        }\n        state.write(')');\n    }\n    state.write('[\\n');\n    state.renderChildren(node, 1);\n    state.write('],\\n');\n};\n", "import { fileError, fileWarn, toText, getMetadataTags } from 'myst-common';\nimport { captionHandler, containerHandler } from './container.js';\nimport { getLatexImageWidth, hrefToLatexText, nodeOnlyHasTextChildren, stringToTypstMath, stringToTypstText, } from './utils.js';\nimport MATH_HANDLERS, { resolveRecursiveCommands } from './math.js';\nimport { select, selectAll } from 'unist-util-select';\nimport { tableCellHandler, tableHandler, tableRowHandler } from './table.js';\nconst admonition = `#let admonition(body, heading: none, color: blue) = {\n  let stroke = (left: 2pt + color.darken(20%))\n  let fill = color.lighten(80%)\n  let title\n  if heading != none {\n    title = block(width: 100%, inset: (x: 8pt, y: 4pt), fill: fill, below: 0pt, radius: (top-right: 2pt))[#text(11pt, weight: \"bold\")[#heading]]\n  }\n  block(width: 100%, stroke: stroke, [\n    #title\n  #block(fill: luma(240), width: 100%, inset: 8pt, radius: (bottom-right: 2pt))[#body]\n])\n}`;\nconst admonitionMacros = {\n    attention: '#let attentionBlock(body, heading: [Attention]) = admonition(body, heading: heading, color: yellow)',\n    caution: '#let cautionBlock(body, heading: [Caution]) = admonition(body, heading: heading, color: yellow)',\n    danger: '#let dangerBlock(body, heading: [Danger]) = admonition(body, heading: heading, color: red)',\n    error: '#let errorBlock(body, heading: [Error]) = admonition(body, heading: heading, color: red)',\n    hint: '#let hintBlock(body, heading: [Hint]) = admonition(body, heading: heading, color: green)',\n    important: '#let importantBlock(body, heading: [Important]) = admonition(body, heading: heading, color: blue)',\n    note: '#let noteBlock(body, heading: [Note]) = admonition(body, heading: heading, color: blue)',\n    seealso: '#let seealsoBlock(body, heading: [See Also]) = admonition(body, heading: heading, color: green)',\n    tip: '#let tipBlock(body, heading: [Tip]) = admonition(body, heading: heading, color: green)',\n    warning: '#let warningBlock(body, heading: [Warning]) = admonition(body, heading: heading, color: yellow)',\n};\nconst blockquote = `#let blockquote(node, color: gray) = {\n  let stroke = (left: 2pt + color.darken(20%))\n  set text(fill: black.lighten(40%), style: \"oblique\")\n  block(width: 100%, inset: 8pt, stroke: stroke)[#node]\n}`;\nconst INDENT = '  ';\nconst linkHandler = (node, state) => {\n    const href = node.url;\n    state.write('#link(\"');\n    state.write(hrefToLatexText(href));\n    state.write('\")');\n    if (node.children.length && node.children[0].value !== href) {\n        state.write('[');\n        state.renderChildren(node);\n        state.write(']');\n    }\n};\nfunction nextCharacterIsText(parent, node) {\n    var _a, _b;\n    const ind = (_a = parent === null || parent === void 0 ? void 0 : parent.children) === null || _a === void 0 ? void 0 : _a.findIndex((n) => n === node);\n    if (!ind)\n        return false;\n    const next = (_b = parent === null || parent === void 0 ? void 0 : parent.children) === null || _b === void 0 ? void 0 : _b[ind + 1];\n    if (!(next === null || next === void 0 ? void 0 : next.value))\n        return false;\n    return ((next === null || next === void 0 ? void 0 : next.type) === 'text' && !!next.value.match(/^[a-zA-Z0-9\\-_]/)) || false;\n}\nconst handlers = {\n    text(node, state) {\n        state.text(node.value);\n    },\n    paragraph(node, state) {\n        state.renderChildren(node, 2);\n    },\n    heading(node, state) {\n        const { depth, identifier, enumerated } = node;\n        state.write(`${Array(depth).fill('=').join('')} `);\n        state.renderChildren(node);\n        if (enumerated !== false && identifier) {\n            state.write(` <${identifier}>`);\n        }\n        state.write('\\n\\n');\n    },\n    block(node, state) {\n        const metadataTags = getMetadataTags(node);\n        if (metadataTags.includes('no-typst'))\n            return;\n        if (metadataTags.includes('no-pdf'))\n            return;\n        if (node.visibility === 'remove')\n            return;\n        if (metadataTags.includes('page-break') || metadataTags.includes('new-page')) {\n            state.write('#pagebreak(weak: true)\\n');\n        }\n        state.renderChildren(node, 2);\n    },\n    blockquote(node, state) {\n        state.useMacro(blockquote);\n        state.renderEnvironment(node, 'blockquote');\n    },\n    definitionList(node, state) {\n        let dedent = false;\n        if (!state.data.definitionIndent) {\n            state.data.definitionIndent = 2;\n        }\n        else {\n            state.write(`#set terms(indent: ${state.data.definitionIndent}em)`);\n            state.data.definitionIndent += 2;\n            dedent = true;\n        }\n        state.renderChildren(node, 1);\n        state.data.definitionIndent -= 2;\n        if (dedent)\n            state.write(`#set terms(indent: ${state.data.definitionIndent - 2}em)\\n`);\n    },\n    definitionTerm(node, state) {\n        state.ensureNewLine();\n        state.write('/ ');\n        state.renderChildren(node);\n        state.write(': ');\n    },\n    definitionDescription(node, state) {\n        state.renderChildren(node);\n    },\n    code(node, state) {\n        var _a;\n        let ticks = '```';\n        while (node.value.includes(ticks)) {\n            ticks += '`';\n        }\n        const start = `${ticks}${(_a = node.lang) !== null && _a !== void 0 ? _a : ''}\\n`;\n        const end = `\\n${ticks}`;\n        state.write(start);\n        state.write(node.value);\n        state.write(end);\n        state.ensureNewLine(true);\n        state.addNewLine();\n    },\n    list(node, state) {\n        var _a;\n        var _b;\n        (_a = (_b = state.data).list) !== null && _a !== void 0 ? _a : (_b.list = { env: [] });\n        state.data.list.env.push(node.ordered ? '+' : '-');\n        state.renderChildren(node, 2);\n        state.data.list.env.pop();\n    },\n    listItem(node, state) {\n        var _a, _b, _c;\n        const listEnv = (_b = (_a = state.data.list) === null || _a === void 0 ? void 0 : _a.env) !== null && _b !== void 0 ? _b : [];\n        const tabs = Array(Math.max(listEnv.length - 1, 0))\n            .fill(INDENT)\n            .join('');\n        const env = (_c = listEnv.slice(-1)[0]) !== null && _c !== void 0 ? _c : '-';\n        state.ensureNewLine();\n        state.write(`${tabs}${env} `);\n        state.renderChildren(node, 1);\n    },\n    thematicBreak(node, state) {\n        state.write('#line(length: 100%, stroke: gray)\\n\\n');\n    },\n    ...MATH_HANDLERS,\n    mystRole(node, state) {\n        state.renderChildren(node);\n    },\n    mystDirective(node, state) {\n        state.renderChildren(node, 2);\n    },\n    comment(node, state) {\n        var _a, _b;\n        state.ensureNewLine();\n        if ((_a = node.value) === null || _a === void 0 ? void 0 : _a.includes('\\n')) {\n            state.write(`/*\\n${node.value}\\n*/\\n\\n`);\n        }\n        else {\n            state.write(`// ${(_b = node.value) !== null && _b !== void 0 ? _b : ''}\\n\\n`);\n        }\n    },\n    strong(node, state, parent) {\n        const next = nextCharacterIsText(parent, node);\n        if (nodeOnlyHasTextChildren(node) && !next) {\n            state.write('*');\n            state.renderChildren(node);\n            state.write('*');\n        }\n        else {\n            state.renderInlineEnvironment(node, 'strong');\n        }\n    },\n    emphasis(node, state, parent) {\n        const next = nextCharacterIsText(parent, node);\n        if (nodeOnlyHasTextChildren(node) && !next) {\n            state.write('_');\n            state.renderChildren(node);\n            state.write('_');\n        }\n        else {\n            state.renderInlineEnvironment(node, 'emph');\n        }\n    },\n    underline(node, state) {\n        state.renderInlineEnvironment(node, 'underline');\n    },\n    smallcaps(node, state) {\n        state.renderInlineEnvironment(node, 'smallcaps');\n    },\n    inlineCode(node, state) {\n        let ticks = '`';\n        // inlineCode can sometimes have children (e.g. from latex)\n        const value = toText(node);\n        // Double ticks create empty inline code; we never want that for start/end\n        while (ticks === '``' || value.includes(ticks)) {\n            ticks += '`';\n        }\n        state.write(ticks);\n        if (value.startsWith('`'))\n            state.write(' ');\n        state.write(value);\n        if (value.endsWith('`'))\n            state.write(' ');\n        state.write(ticks);\n    },\n    subscript(node, state) {\n        state.renderInlineEnvironment(node, 'sub');\n    },\n    superscript(node, state) {\n        state.renderInlineEnvironment(node, 'super');\n    },\n    delete(node, state) {\n        state.renderInlineEnvironment(node, 'strike');\n    },\n    break(node, state) {\n        state.write(' \\\\');\n        state.ensureNewLine();\n    },\n    abbreviation(node, state) {\n        state.renderChildren(node);\n    },\n    inlineExpression(node, state) {\n        // TODO: This is **very** simple at the moment\n        // It will work for inline nodes likely only, we can make it better soon\n        fileWarn(state.file, 'inlineExpression rendering in typst is in beta', {\n            node,\n            note: 'Rendering will work only for text nodes',\n        });\n        state.renderChildren(node);\n    },\n    link: linkHandler,\n    admonition(node, state) {\n        state.useMacro(admonition);\n        state.ensureNewLine();\n        const title = select('admonitionTitle', node);\n        if (!node.kind) {\n            fileError(state.file, `Unknown admonition kind`, {\n                node,\n                source: 'myst-to-typst',\n            });\n            return;\n        }\n        state.useMacro(admonitionMacros[node.kind]);\n        state.write(`#${node.kind}Block`);\n        if (title && toText(title).toLowerCase().replace(' ', '') !== node.kind) {\n            state.write('(heading: [');\n            state.renderChildren(title);\n            state.write('])');\n        }\n        state.write('[\\n');\n        state.renderChildren(node);\n        state.write('\\n]\\n\\n');\n    },\n    admonitionTitle() {\n        return;\n    },\n    table: tableHandler,\n    tableRow: tableRowHandler,\n    tableCell: tableCellHandler,\n    image(node, state) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { width: nodeWidth, url: nodeSrc, align } = node;\n        const src = nodeSrc;\n        const width = getLatexImageWidth(nodeWidth);\n        const command = state.data.isInTable || !state.data.isInFigure ? '#image' : 'image';\n        state.write(`${command}(\"${src}\"`);\n        if (!state.data.isInTable) {\n            state.write(`, width: ${width}`);\n        }\n        state.write(')\\n\\n');\n    },\n    container: containerHandler,\n    caption: captionHandler,\n    legend: captionHandler,\n    captionNumber: () => undefined,\n    crossReference(node, state, parent) {\n        // Look up reference and add the text\n        // const usedTemplate = node.template?.includes('%s') ? node.template : undefined;\n        // const text = (usedTemplate ?? toText(node))?.replace(/\\s/g, '~') || '%s';\n        const id = node.identifier;\n        // state.write(text.replace(/%s/g, `@${id}`));\n        const next = nextCharacterIsText(parent, node);\n        state.write(next ? `#[@${id}]` : `@${id}`);\n    },\n    citeGroup(node, state) {\n        state.renderChildren(node, 0, { delim: ' ' });\n    },\n    cite(node, state) {\n        const needsLabel = !/^[a-zA-Z0-9_\\-:.]+$/.test(node.label);\n        const label = needsLabel ? `label(\"${node.label}\")` : `<${node.label}>`;\n        state.write(`#cite(${label}`);\n        if (node.kind === 'narrative')\n            state.write(`, form: \"prose\"`);\n        // node.prefix not supported by typst: see https://github.com/typst/typst/issues/1139\n        if (node.suffix)\n            state.write(`, supplement: [${node.suffix}]`);\n        state.write(`)`);\n    },\n    embed(node, state) {\n        state.renderChildren(node, 2);\n    },\n    include(node, state) {\n        state.renderChildren(node, 2);\n    },\n    footnoteReference(node, state) {\n        if (!node.identifier)\n            return;\n        const footnote = state.footnotes[node.identifier];\n        if (!footnote) {\n            fileError(state.file, `Unknown footnote identifier \"${node.identifier}\"`, {\n                node,\n                source: 'myst-to-typst',\n            });\n            return;\n        }\n        state.write('#footnote[');\n        state.renderChildren(footnote);\n        state.write(']');\n    },\n    footnoteDefinition() {\n        // Nothing!\n    },\n    // si(node, state) {\n    //   // state.useMacro('siunitx');\n    //   if (node.number == null) {\n    //     state.write(`\\\\unit{${node.units?.map((u: string) => `\\\\${u}`).join('') ?? ''}}`);\n    //   } else {\n    //     state.write(\n    //       `\\\\qty{${node.number}}{${node.units?.map((u: string) => `\\\\${u}`).join('') ?? ''}}`,\n    //     );\n    //   }\n    // },\n    div(node, state) {\n        state.renderChildren(node, 1);\n    },\n    span(node, state) {\n        state.renderChildren(node, 0, { trimEnd: false });\n    },\n};\nclass TypstSerializer {\n    constructor(file, tree, opts) {\n        var _a;\n        file.result = '';\n        this.file = file;\n        const { math, ...otherOpts } = opts !== null && opts !== void 0 ? opts : {};\n        this.options = { ...otherOpts };\n        if (math)\n            this.options.math = resolveRecursiveCommands(math);\n        this.data = { mathPlugins: {}, macros: new Set() };\n        this.handlers = (_a = opts === null || opts === void 0 ? void 0 : opts.handlers) !== null && _a !== void 0 ? _a : handlers;\n        this.footnotes = Object.fromEntries(selectAll('footnoteDefinition', tree).map((node) => {\n            const fn = node;\n            return [fn.identifier, fn];\n        }));\n        this.renderChildren(tree);\n    }\n    get out() {\n        return this.file.result;\n    }\n    useMacro(macro) {\n        this.data.macros.add(macro);\n    }\n    write(value) {\n        this.file.result += value;\n    }\n    text(value, mathMode = false) {\n        const escaped = mathMode ? stringToTypstMath(value) : stringToTypstText(value);\n        this.write(escaped);\n    }\n    trimEnd() {\n        this.file.result = this.out.trimEnd();\n    }\n    addNewLine() {\n        this.write('\\n');\n    }\n    ensureNewLine(trim = false) {\n        if (trim)\n            this.trimEnd();\n        if (this.out.endsWith('\\n'))\n            return;\n        this.addNewLine();\n    }\n    renderChildren(node, trailingNewLines = 0, { delim = '', trimEnd = true } = {}) {\n        var _a, _b, _c;\n        const numChildren = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n        (_c = node.children) === null || _c === void 0 ? void 0 : _c.forEach((child, index) => {\n            if (!child)\n                return;\n            const handler = this.handlers[child === null || child === void 0 ? void 0 : child.type];\n            if (handler) {\n                handler(child, this, node);\n            }\n            else {\n                fileError(this.file, `Unhandled Typst conversion for node of \"${child === null || child === void 0 ? void 0 : child.type}\"`, {\n                    node: child,\n                    source: 'myst-to-typst',\n                });\n            }\n            if (delim && index + 1 < numChildren)\n                this.write(delim);\n        });\n        if (trimEnd)\n            this.trimEnd();\n        for (let i = trailingNewLines; i--;)\n            this.addNewLine();\n    }\n    renderEnvironment(node, env) {\n        this.file.result += `#${env}[\\n`;\n        this.renderChildren(node, 1);\n        this.file.result += `]\\n\\n`;\n    }\n    renderInlineEnvironment(node, env) {\n        this.file.result += `#${env}[`;\n        this.renderChildren(node);\n        this.file.result += ']';\n    }\n}\nconst plugin = function (opts) {\n    this.Compiler = (node, file) => {\n        const state = new TypstSerializer(file, node, opts !== null && opts !== void 0 ? opts : { handlers });\n        const tex = file.result.trim();\n        const result = {\n            macros: [...state.data.macros],\n            commands: state.data.mathPlugins,\n            value: tex,\n        };\n        file.result = result;\n        return file;\n    };\n    return (node) => {\n        // Preprocess\n        return node;\n    };\n};\nexport default plugin;\n"],
  "mappings": "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",
  "names": ["pushInOrder", "permute", "reducer", "input", "convert", "s", "string", "match", "convert", "convert", "Color", "CaptionKind", "s", "braces", "args", "macros", "macro", "index", "result", "key", "unifiedLatexTrimEnvironmentContents", "unifiedLatexTrimRoot", "macros", "macros", "environments", "macros", "environments", "macros", "environments", "macros", "environments", "s", "macro", "comment", "PegParser", "argument", "bracePos", "nodeContent", "parseArgspec", "macros", "macro", "macroInfo", "unifiedLatexAttachMacroArguments", "macros", "parseArgspec", "macros", "environments", "macros", "environments", "macros", "environments", "argSpecM", "parseArgspec", "argSpecO", "argSpecRDelim", "argumentParser", "macros", "environments", "macros", "environments", "macros", "environments", "parseArgspec", "colonPos", "macros", "environments", "createMatchers", "macros", "environments", "Color", "Color", "s", "macros", "environments", "macros", "environments", "macros", "environments", "cleveref.macros", "exam.macros", "geometry.macros", "hyperref.macros", "latex2e.macros", "listings.macros", "makeidx.macros", "mathtools.macros", "minted.macros", "nicematrix.macros", "systeme.macros", "tikz.macros", "xcolor.macros", "xparse.macros", "beamer.macros", "multicol.macros", "cleveref.environments", "exam.environments", "geometry.environments", "hyperref.environments", "latex2e.environments", "listings.environments", "makeidx.environments", "mathtools.environments", "minted.environments", "nicematrix.environments", "systeme.environments", "tikz.environments", "xcolor.environments", "xparse.environments", "beamer.environments", "multicol.environments", "macro", "string", "match", "unifiedLatexAstComplier", "unifiedLatexFromStringMinimal", "parser", "arg", "unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse", "environments", "macros", "unifiedLatexProcessAtLetterAndExplMacros", "unifiedLatexFromString", "parser", "macro", "math", "_a", "math", "macro", "trim", "trimEnd"]
}
