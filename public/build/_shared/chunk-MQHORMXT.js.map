{
  "version": 3,
  "sources": ["../../../../../node_modules/boolbase/index.js", "../../../../../node_modules/css-selector-parser/lib/utils.js", "../../../../../node_modules/css-selector-parser/lib/parser-context.js", "../../../../../node_modules/css-selector-parser/lib/render.js", "../../../../../node_modules/css-selector-parser/lib/index.js", "../../../../../node_modules/nanoid/index.browser.js", "../../../../../node_modules/myst-common/dist/utils.js", "../../../../../node_modules/zwitch/index.js", "../../../../../node_modules/unist-util-select/lib/attribute.js", "../../../../../node_modules/unist-util-select/lib/name.js", "../../../../../node_modules/nth-check/lib/esm/parse.ts", "../../../../../node_modules/nth-check/lib/esm/compile.ts", "../../../../../node_modules/nth-check/lib/esm/index.ts", "../../../../../node_modules/unist-util-select/lib/util.js", "../../../../../node_modules/unist-util-select/lib/pseudo.js", "../../../../../node_modules/unist-util-select/lib/test.js", "../../../../../node_modules/unist-util-select/lib/walk.js", "../../../../../node_modules/unist-util-select/lib/parse.js", "../../../../../node_modules/unist-util-select/index.js", "../../../../../node_modules/unist-util-remove/lib/index.js", "../../../../../node_modules/myst-frontmatter/dist/site/types.js", "../../../../../node_modules/myst-common/dist/extractParts.js", "../../../../../node_modules/myst-common/dist/ruleids.js", "../../../../../node_modules/myst-common/dist/plural.js", "../../../../../node_modules/myst-common/dist/selectNodes.js", "../../../../../node_modules/myst-common/dist/types.js"],
  "sourcesContent": ["module.exports = {\n\ttrueFunc: function trueFunc(){\n\t\treturn true;\n\t},\n\tfalseFunc: function falseFunc(){\n\t\treturn false;\n\t}\n};", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isIdentStart(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c === '-') || (c === '_');\n}\nexports.isIdentStart = isIdentStart;\nfunction isIdent(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';\n}\nexports.isIdent = isIdent;\nfunction isHex(c) {\n    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');\n}\nexports.isHex = isHex;\nfunction escapeIdentifier(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (exports.identSpecialChars[chr]) {\n            result += '\\\\' + chr;\n        }\n        else {\n            if (!(chr === '_' || chr === '-' ||\n                (chr >= 'A' && chr <= 'Z') ||\n                (chr >= 'a' && chr <= 'z') ||\n                (i !== 0 && chr >= '0' && chr <= '9'))) {\n                var charCode = chr.charCodeAt(0);\n                if ((charCode & 0xF800) === 0xD800) {\n                    var extraCharCode = s.charCodeAt(i++);\n                    if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {\n                        throw Error('UCS-2(decode): illegal sequence');\n                    }\n                    charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;\n                }\n                result += '\\\\' + charCode.toString(16) + ' ';\n            }\n            else {\n                result += chr;\n            }\n        }\n        i++;\n    }\n    return result;\n}\nexports.escapeIdentifier = escapeIdentifier;\nfunction escapeStr(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    var replacement;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (chr === '\"') {\n            chr = '\\\\\"';\n        }\n        else if (chr === '\\\\') {\n            chr = '\\\\\\\\';\n        }\n        else if ((replacement = exports.strReplacementsRev[chr]) !== undefined) {\n            chr = replacement;\n        }\n        result += chr;\n        i++;\n    }\n    return \"\\\"\" + result + \"\\\"\";\n}\nexports.escapeStr = escapeStr;\nexports.identSpecialChars = {\n    '!': true,\n    '\"': true,\n    '#': true,\n    '$': true,\n    '%': true,\n    '&': true,\n    '\\'': true,\n    '(': true,\n    ')': true,\n    '*': true,\n    '+': true,\n    ',': true,\n    '.': true,\n    '/': true,\n    ';': true,\n    '<': true,\n    '=': true,\n    '>': true,\n    '?': true,\n    '@': true,\n    '[': true,\n    '\\\\': true,\n    ']': true,\n    '^': true,\n    '`': true,\n    '{': true,\n    '|': true,\n    '}': true,\n    '~': true\n};\nexports.strReplacementsRev = {\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\f': '\\\\f',\n    '\\v': '\\\\v'\n};\nexports.singleQuoteEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\\'': '\\''\n};\nexports.doubleQuotesEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\"': '\"'\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {\n    var l = str.length;\n    var chr = '';\n    function getStr(quote, escapeTable) {\n        var result = '';\n        pos++;\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (chr === quote) {\n                pos++;\n                return result;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                chr = str.charAt(pos);\n                var esc = void 0;\n                if (chr === quote) {\n                    result += quote;\n                }\n                else if ((esc = escapeTable[chr]) !== undefined) {\n                    result += esc;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                result += chr;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function getIdent() {\n        var result = '';\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (utils_1.isIdent(chr)) {\n                result += chr;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                if (pos >= l) {\n                    throw Error('Expected symbol but end of file reached.');\n                }\n                chr = str.charAt(pos);\n                if (utils_1.identSpecialChars[chr]) {\n                    result += chr;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                return result;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function skipWhitespace() {\n        chr = str.charAt(pos);\n        var result = false;\n        while (chr === ' ' || chr === \"\\t\" || chr === \"\\n\" || chr === \"\\r\" || chr === \"\\f\") {\n            result = true;\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function parse() {\n        var res = parseSelector();\n        if (pos < l) {\n            throw Error('Rule expected but \"' + str.charAt(pos) + '\" found.');\n        }\n        return res;\n    }\n    function parseSelector() {\n        var selector = parseSingleSelector();\n        if (!selector) {\n            return null;\n        }\n        var res = selector;\n        chr = str.charAt(pos);\n        while (chr === ',') {\n            pos++;\n            skipWhitespace();\n            if (res.type !== 'selectors') {\n                res = {\n                    type: 'selectors',\n                    selectors: [selector]\n                };\n            }\n            selector = parseSingleSelector();\n            if (!selector) {\n                throw Error('Rule expected after \",\".');\n            }\n            res.selectors.push(selector);\n        }\n        return res;\n    }\n    function parseSingleSelector() {\n        skipWhitespace();\n        var selector = {\n            type: 'ruleSet'\n        };\n        var rule = parseRule();\n        if (!rule) {\n            return null;\n        }\n        var currentRule = selector;\n        while (rule) {\n            rule.type = 'rule';\n            currentRule.rule = rule;\n            currentRule = rule;\n            skipWhitespace();\n            chr = str.charAt(pos);\n            if (pos >= l || chr === ',' || chr === ')') {\n                break;\n            }\n            if (ruleNestingOperators[chr]) {\n                var op = chr;\n                pos++;\n                skipWhitespace();\n                rule = parseRule();\n                if (!rule) {\n                    throw Error('Rule expected after \"' + op + '\".');\n                }\n                rule.nestingOperator = op;\n            }\n            else {\n                rule = parseRule();\n                if (rule) {\n                    rule.nestingOperator = null;\n                }\n            }\n        }\n        return selector;\n    }\n    // @ts-ignore no-overlap\n    function parseRule() {\n        var rule = null;\n        while (pos < l) {\n            chr = str.charAt(pos);\n            if (chr === '*') {\n                pos++;\n                (rule = rule || {}).tagName = '*';\n            }\n            else if (utils_1.isIdentStart(chr) || chr === '\\\\') {\n                (rule = rule || {}).tagName = getIdent();\n            }\n            else if (chr === '.') {\n                pos++;\n                rule = rule || {};\n                (rule.classNames = rule.classNames || []).push(getIdent());\n            }\n            else if (chr === '#') {\n                pos++;\n                (rule = rule || {}).id = getIdent();\n            }\n            else if (chr === '[') {\n                pos++;\n                skipWhitespace();\n                var attr = {\n                    name: getIdent()\n                };\n                skipWhitespace();\n                // @ts-ignore\n                if (chr === ']') {\n                    pos++;\n                }\n                else {\n                    var operator = '';\n                    if (attrEqualityMods[chr]) {\n                        operator = chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \"=\" but end of file reached.');\n                    }\n                    if (chr !== '=') {\n                        throw Error('Expected \"=\" but \"' + chr + '\" found.');\n                    }\n                    attr.operator = operator + '=';\n                    pos++;\n                    skipWhitespace();\n                    var attrValue = '';\n                    attr.valueType = 'string';\n                    // @ts-ignore\n                    if (chr === '\"') {\n                        attrValue = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (chr === '\\'') {\n                        attrValue = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (substitutesEnabled && chr === '$') {\n                        pos++;\n                        attrValue = getIdent();\n                        attr.valueType = 'substitute';\n                    }\n                    else {\n                        while (pos < l) {\n                            if (chr === ']') {\n                                break;\n                            }\n                            attrValue += chr;\n                            pos++;\n                            chr = str.charAt(pos);\n                        }\n                        attrValue = attrValue.trim();\n                    }\n                    skipWhitespace();\n                    if (pos >= l) {\n                        throw Error('Expected \"]\" but end of file reached.');\n                    }\n                    if (chr !== ']') {\n                        throw Error('Expected \"]\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    attr.value = attrValue;\n                }\n                rule = rule || {};\n                (rule.attrs = rule.attrs || []).push(attr);\n            }\n            else if (chr === ':') {\n                pos++;\n                var pseudoName = getIdent();\n                var pseudo = {\n                    name: pseudoName\n                };\n                // @ts-ignore\n                if (chr === '(') {\n                    pos++;\n                    var value = '';\n                    skipWhitespace();\n                    if (pseudos[pseudoName] === 'selector') {\n                        pseudo.valueType = 'selector';\n                        value = parseSelector();\n                    }\n                    else {\n                        pseudo.valueType = pseudos[pseudoName] || 'string';\n                        // @ts-ignore\n                        if (chr === '\"') {\n                            value = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (chr === '\\'') {\n                            value = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (substitutesEnabled && chr === '$') {\n                            pos++;\n                            value = getIdent();\n                            pseudo.valueType = 'substitute';\n                        }\n                        else {\n                            while (pos < l) {\n                                if (chr === ')') {\n                                    break;\n                                }\n                                value += chr;\n                                pos++;\n                                chr = str.charAt(pos);\n                            }\n                            value = value.trim();\n                        }\n                        skipWhitespace();\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \")\" but end of file reached.');\n                    }\n                    if (chr !== ')') {\n                        throw Error('Expected \")\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    pseudo.value = value;\n                }\n                rule = rule || {};\n                (rule.pseudos = rule.pseudos || []).push(pseudo);\n            }\n            else {\n                break;\n            }\n        }\n        return rule;\n    }\n    return parse();\n}\nexports.parseCssSelector = parseCssSelector;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction renderEntity(entity) {\n    var res = '';\n    switch (entity.type) {\n        case 'ruleSet':\n            var currentEntity = entity.rule;\n            var parts = [];\n            while (currentEntity) {\n                if (currentEntity.nestingOperator) {\n                    parts.push(currentEntity.nestingOperator);\n                }\n                parts.push(renderEntity(currentEntity));\n                currentEntity = currentEntity.rule;\n            }\n            res = parts.join(' ');\n            break;\n        case 'selectors':\n            res = entity.selectors.map(renderEntity).join(', ');\n            break;\n        case 'rule':\n            if (entity.tagName) {\n                if (entity.tagName === '*') {\n                    res = '*';\n                }\n                else {\n                    res = utils_1.escapeIdentifier(entity.tagName);\n                }\n            }\n            if (entity.id) {\n                res += \"#\" + utils_1.escapeIdentifier(entity.id);\n            }\n            if (entity.classNames) {\n                res += entity.classNames.map(function (cn) {\n                    return \".\" + (utils_1.escapeIdentifier(cn));\n                }).join('');\n            }\n            if (entity.attrs) {\n                res += entity.attrs.map(function (attr) {\n                    if ('operator' in attr) {\n                        if (attr.valueType === 'substitute') {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + \"$\" + attr.value + \"]\";\n                        }\n                        else {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + utils_1.escapeStr(attr.value) + \"]\";\n                        }\n                    }\n                    else {\n                        return \"[\" + utils_1.escapeIdentifier(attr.name) + \"]\";\n                    }\n                }).join('');\n            }\n            if (entity.pseudos) {\n                res += entity.pseudos.map(function (pseudo) {\n                    if (pseudo.valueType) {\n                        if (pseudo.valueType === 'selector') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + renderEntity(pseudo.value) + \")\";\n                        }\n                        else if (pseudo.valueType === 'substitute') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"($\" + pseudo.value + \")\";\n                        }\n                        else if (pseudo.valueType === 'numeric') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + pseudo.value + \")\";\n                        }\n                        else {\n                            return (\":\" + utils_1.escapeIdentifier(pseudo.name) +\n                                \"(\" + utils_1.escapeIdentifier(pseudo.value) + \")\");\n                        }\n                    }\n                    else {\n                        return \":\" + utils_1.escapeIdentifier(pseudo.name);\n                    }\n                }).join('');\n            }\n            break;\n        default:\n            throw Error('Unknown entity type: \"' + entity.type + '\".');\n    }\n    return res;\n}\nexports.renderEntity = renderEntity;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parser_context_1 = require(\"./parser-context\");\nvar render_1 = require(\"./render\");\nvar CssSelectorParser = /** @class */ (function () {\n    function CssSelectorParser() {\n        this.pseudos = {};\n        this.attrEqualityMods = {};\n        this.ruleNestingOperators = {};\n        this.substitutesEnabled = false;\n    }\n    CssSelectorParser.prototype.registerSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {\n            var pseudo = pseudos_1[_a];\n            this.pseudos[pseudo] = 'selector';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {\n            var pseudo = pseudos_2[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {\n            var pseudo = pseudos_3[_a];\n            this.pseudos[pseudo] = 'numeric';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {\n            var pseudo = pseudos_4[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {\n            var operator = operators_1[_a];\n            this.ruleNestingOperators[operator] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {\n            var operator = operators_2[_a];\n            delete this.ruleNestingOperators[operator];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {\n            var mod = mods_1[_a];\n            this.attrEqualityMods[mod] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {\n            var mod = mods_2[_a];\n            delete this.attrEqualityMods[mod];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.enableSubstitutes = function () {\n        this.substitutesEnabled = true;\n        return this;\n    };\n    CssSelectorParser.prototype.disableSubstitutes = function () {\n        this.substitutesEnabled = false;\n        return this;\n    };\n    CssSelectorParser.prototype.parse = function (str) {\n        return parser_context_1.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);\n    };\n    CssSelectorParser.prototype.render = function (path) {\n        return render_1.renderEntity(path).trim();\n    };\n    return CssSelectorParser;\n}());\nexports.CssSelectorParser = CssSelectorParser;\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "import { customAlphabet } from 'nanoid';\nfunction addMessageInfo(message, info) {\n    if (info === null || info === void 0 ? void 0 : info.note)\n        message.note = info.note;\n    if (info === null || info === void 0 ? void 0 : info.url)\n        message.url = info.url;\n    if (info === null || info === void 0 ? void 0 : info.ruleId)\n        message.ruleId = info.ruleId;\n    if (info === null || info === void 0 ? void 0 : info.fatal)\n        message.fatal = true;\n    return message;\n}\nexport function fileError(file, message, opts) {\n    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), { ...opts, fatal: true });\n}\nexport function fileWarn(file, message, opts) {\n    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);\n}\nexport function fileInfo(file, message, opts) {\n    return addMessageInfo(file.info(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);\n}\nconst az = 'abcdefghijklmnopqrstuvwxyz';\nconst alpha = az + az.toUpperCase();\nconst numbers = '0123456789';\nconst nanoidAZ = customAlphabet(alpha, 1);\nconst nanoidAZ9 = customAlphabet(alpha + numbers, 9);\nexport function createId() {\n    return nanoidAZ() + nanoidAZ9();\n}\n/**\n * https://github.com/syntax-tree/mdast#association\n * @param label A label field can be present.\n *        label is a string value: it works just like title on a link or a\n *        lang on code: character escapes and character references are parsed.\n * @returns { identifier, label, html_id }\n */\nexport function normalizeLabel(label) {\n    if (!label)\n        return undefined;\n    const identifier = label\n        .replace(/[\\t\\n\\r ]+/g, ' ')\n        .replace(/['\u2018\u2019\"\u201C\u201D]+/g, '') // These can make matching difficult, especially in glossaries and terms\n        .trim()\n        .toLowerCase();\n    const html_id = createHtmlId(identifier);\n    return { identifier, label: label, html_id };\n}\nexport function createHtmlId(identifier) {\n    if (!identifier)\n        return undefined;\n    return identifier\n        .toLowerCase()\n        .replace(/[^a-z0-9-]/g, '-') // Remove any fancy characters\n        .replace(/^([0-9-])/, 'id-$1') // Ensure that the id starts with a letter\n        .replace(/-[-]+/g, '-') // Replace repeated `-`s\n        .replace(/(?:^[-]+)|(?:[-]+$)/g, ''); // Remove repeated `-`s at the start or the end\n}\n/**\n * Helper function for recursively lifting children\n */\nfunction getNodeOrLiftedChildren(node, removeType) {\n    if (!node.children)\n        return [node];\n    const children = node.children.map((child) => getNodeOrLiftedChildren(child, removeType)).flat();\n    if (node.type === removeType) {\n        // There are some checks in unist that look like `'children' in node`\n        // all children must be deleted, and not a key on the object\n        if (node && node.children == null)\n            delete node.children;\n        return children;\n    }\n    node.children = children;\n    return [node];\n}\n/**\n * Eliminate all parent nodes in `tree` of type `removeType`; children of eliminated nodes are moved up to it's parent\n *\n * Nodes of `removeType` will remain if:\n * - they are the root of `tree`\n * - their children are undefined\n */\nexport function liftChildren(tree, removeType) {\n    if (!tree.children)\n        return;\n    tree.children = tree.children.map((child) => getNodeOrLiftedChildren(child, removeType)).flat();\n}\nexport function setTextAsChild(node, text) {\n    node.children = [{ type: 'text', value: text }];\n}\n/**\n * Renders a textual representation of one or more nodes\n * by concatenating all children that have a text representation.\n * @param content The node or nodes to provide as input.\n * @returns A string. An empty string is returned in case no\n * textual representation could be extracted.\n */\nexport function toText(content) {\n    if (!content)\n        return '';\n    if (!Array.isArray(content))\n        return toText([content]);\n    return content\n        .map((n) => {\n        if (!n || typeof n === 'string')\n            return n || '';\n        if ('value' in n)\n            return n.value;\n        if ('children' in n && n.children)\n            return toText(n.children);\n        return '';\n    })\n        .join('');\n}\nexport function copyNode(node) {\n    return structuredClone(node);\n}\nexport function mergeTextNodes(node) {\n    var _a;\n    const children = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce((c, n) => {\n        var _a;\n        if ((n === null || n === void 0 ? void 0 : n.type) !== 'text') {\n            c.push(mergeTextNodes(n));\n            return c;\n        }\n        const last = c[c.length - 1];\n        if ((last === null || last === void 0 ? void 0 : last.type) !== 'text') {\n            c.push(n);\n            return c;\n        }\n        if ((_a = n.position) === null || _a === void 0 ? void 0 : _a.end) {\n            if (!last.position)\n                last.position = {};\n            last.position.end = n.position.end;\n        }\n        if (!last.value)\n            last.value = '';\n        if (n.value)\n            last.value += n.value;\n        return c;\n    }, []);\n    if (children)\n        node.children = children;\n    return node;\n}\nexport function admonitionKindToTitle(kind) {\n    const transform = {\n        attention: 'Attention',\n        caution: 'Caution',\n        danger: 'Danger',\n        error: 'Error',\n        important: 'Important',\n        hint: 'Hint',\n        note: 'Note',\n        seealso: 'See Also',\n        tip: 'Tip',\n        warning: 'Warning',\n    };\n    return transform[kind] || `Unknown Admonition \"${kind}\"`;\n}\nexport function writeTexLabelledComment(title, commands, commentLength) {\n    if (!commands || (commands === null || commands === void 0 ? void 0 : commands.length) === 0)\n        return '';\n    const len = (commentLength - title.length - 4) / 2;\n    const start = ''.padEnd(Math.ceil(len), '%');\n    const end = ''.padEnd(Math.floor(len), '%');\n    const titleBlock = `${start}  ${title}  ${end}\\n`;\n    return `${titleBlock}${commands.join('\\n')}\\n`;\n}\nexport function getMetadataTags(node) {\n    var _a;\n    if (!node.data)\n        return [];\n    const tags = (_a = node.data.tags) !== null && _a !== void 0 ? _a : [];\n    Object.entries(node.data).forEach(([key, val]) => {\n        if (val === true || (typeof val === 'string' && val.toLowerCase() === 'true')) {\n            tags.push(key);\n        }\n    });\n    return tags.map((tag) => tag.toLowerCase());\n}\n", "/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it\u2019s value is this function\u2019s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it\u2019s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn\u2019t have a `key` property, the special\n   * \u201Cinvalid\u201D handler will be called.\n   * If `value` has an unknown `key`, the special \u201Cunknown\u201D handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it\u2019s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it\u2019s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Node} Node\n */\n\nimport {zwitch} from 'zwitch'\n\n/** @type {(query: RuleAttr, node: Node) => boolean} */\nconst handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '^=': begins,\n    '$=': ends,\n    '*=': containsString,\n    '~=': containsArray\n  }\n})\n\n/**\n * @param {Rule} query\n * @param {Node} node\n * @returns {boolean}\n */\nexport function attribute(query, node) {\n  let index = -1\n\n  while (++index < query.attrs.length) {\n    if (!handle(query.attrs[index], node)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction exists(query, node) {\n  // @ts-expect-error: Looks like a record.\n  return node[query.name] !== null && node[query.name] !== undefined\n}\n\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction exact(query, node) {\n  // @ts-expect-error: Looks like a record.\n  return exists(query, node) && String(node[query.name]) === query.value\n}\n\n/**\n * Check whether an attribute, as a list, contains a value.\n *\n * When the attribute value is not a list, checks that the serialized value\n * is the queried one.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction containsArray(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  if (value === null || value === undefined) return false\n\n  // If this is an array, and the query is contained in it, return true.\n  // Coverage comment in place because TS turns `Array.isArray(unknown)`\n  // into `Array<any>` instead of `Array<unknown>`.\n  // type-coverage:ignore-next-line\n  if (Array.isArray(value) && value.includes(query.value)) {\n    return true\n  }\n\n  // For all other values, return whether this is an exact match.\n  return String(value) === query.value\n}\n\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction begins(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  return Boolean(\n    query.value &&\n      typeof value === 'string' &&\n      value.slice(0, query.value.length) === query.value\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction ends(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  return Boolean(\n    query.value &&\n      typeof value === 'string' &&\n      value.slice(-query.value.length) === query.value\n  )\n}\n\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction containsString(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n  return Boolean(\n    query.value && typeof value === 'string' && value.includes(query.value)\n  )\n}\n\n// Shouldn\u2019t be called, parser throws an error instead.\n/**\n * @param {unknown} query\n * @returns {never}\n */\n/* c8 ignore next 4 */\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`')\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n */\n\n/**\n * Check whether a node has a type.\n *\n * @param {Rule} query\n * @param {Node} node\n */\nexport function name(query, node) {\n  return query.tagName === '*' || query.tagName === node.type\n}\n", null, null, null, "/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n */\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nexport function parent(node) {\n  // @ts-expect-error: looks like a record.\n  return Array.isArray(node.children)\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Node} Node\n */\n\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {parent} from './util.js'\nimport {queryToSelectors, walk} from './walk.js'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: Rule | RulePseudo, node: Node, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\nconst handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    blank: empty,\n    empty,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    root,\n    scope\n  }\n})\n\npseudo.needsIndex = [\n  'any',\n  'first-child',\n  'first-of-type',\n  'last-child',\n  'last-of-type',\n  'matches',\n  'not',\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type',\n  'only-child',\n  'only-of-type'\n]\n\n/**\n * Check whether an node matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, node, index, parent, state) {\n  const pseudos = query.pseudos\n  let offset = -1\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], node, index, parent, state)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether a node matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @returns {boolean}\n */\nfunction empty(_1, node) {\n  return parent(node) ? node.children.length === 0 : !('value' in node)\n}\n\n/**\n * Check whether a node matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.nodeIndex === 0 // Specifically `0`, not falsey.\n}\n\n/**\n * Check whether a node matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, node, _1, _2, state) {\n  const fragment = {type: 'root', children: parent(node) ? node.children : []}\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeNodes: [node],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, fragment)\n\n  return childState.results.length > 0\n}\n\n/**\n * Check whether a node matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.nodeCount === 'number' &&\n    state.nodeIndex === state.nodeCount - 1\n  )\n}\n\n/**\n * Check whether a node matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether a node `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, node, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeNodes: [node],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, node)\n\n  return childState.results[0] === node\n}\n\n/**\n * Check whether a node does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, node, index, parent, state) {\n  return !matches(query, node, index, parent, state)\n}\n\n/**\n * Check whether a node matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.nodeIndex === 'number' && fn(state.nodeIndex)\n}\n\n/**\n * Check whether a node matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.nodeCount === 'number' &&\n    typeof state.nodeIndex === 'number' &&\n    fn(state.nodeCount - state.nodeIndex - 1)\n  )\n}\n\n/**\n * Check whether a node matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    fn(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether a node matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex)\n}\n\n/**\n * Check whether a node matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.nodeCount === 1\n}\n\n/**\n * Check whether a node matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether a node matches a `:root` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @param {number | undefined} _2\n * @param {Parent | undefined} parent\n * @returns {boolean}\n */\nfunction root(_1, node, _2, parent) {\n  return node && !parent\n}\n\n/**\n * Check whether a node matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_1, node, _2, _3, state) {\n  return node && state.scopeNodes.includes(node)\n}\n\n// Shouldn\u2019t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector')\n}\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`')\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class')\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value)\n    // @ts-expect-error: cache.\n    query._cachedFn = fn\n  }\n\n  return fn\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {attribute} from './attribute.js'\nimport {name} from './name.js'\nimport {pseudo} from './pseudo.js'\n\n/**\n * @param {Rule} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function test(query, node, index, parent, state) {\n  if (query.id) throw new Error('Invalid selector: id')\n  if (query.classNames) throw new Error('Invalid selector: class')\n\n  return Boolean(\n    node &&\n      (!query.tagName || name(query, node)) &&\n      (!query.attrs || attribute(query, node)) &&\n      (!query.pseudos || pseudo(query, node, index, parent, state))\n  )\n}\n", "/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on nodes in a parent.\n * @property {number} count\n *   Number of nodes.\n * @property {Map<string, number>} types\n *   Number of nodes by type.\n */\n\nimport {test} from './test.js'\nimport {parent} from './util.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {type: 'selectors', selectors: []}\n  }\n\n  if (query.type === 'ruleSet') {\n    return {type: 'selectors', selectors: [query]}\n  }\n\n  return query\n}\n\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parentNode\n * @returns {Nest}\n */\nfunction one(state, currentRules, node, index, parentNode) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n\n  nestResult = applySelectors(\n    state,\n    // Try the root rules for this node too.\n    combine(currentRules, state.rootQuery.selectors),\n    node,\n    index,\n    parentNode\n  )\n\n  // If this is a parent, and we want to delve into them, and we haven\u2019t found\n  // our single result yet.\n  if (parent(node) && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node)\n  }\n\n  return nestResult\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<RuleSet> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    const name = child.type.toUpperCase()\n    // Before counting further nodes:\n    state.nodeIndex = before.count\n    state.typeIndex = before.types.get(name) || 0\n    // After counting all nodes.\n    state.nodeCount = total.count\n    state.typeCount = total.types.get(name)\n\n    // Only apply if this is a parent.\n    const forSibling = combine(fromParent, fromSibling)\n    const nest = one(state, forSibling, node.children[index], index, node)\n    fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to a node.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Node} node\n *   Node to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we don\u2019t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule\n\n      // Are there more?\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {type: 'ruleSet', rule: nest}\n        /** @type {keyof Nest} */\n        const label =\n          nest.nestingOperator === '+'\n            ? 'adjacentSibling'\n            : nest.nestingOperator === '~'\n            ? 'generalSibling'\n            : nest.nestingOperator === '>'\n            ? 'directChild'\n            : 'descendant'\n        add(nestResult, label, rule)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet)\n    }\n    // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet)\n    }\n    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n    ? left\n    : right && right.length > 0\n    ? right\n    : empty\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node.\n * @returns {void}\n *   Nothing.\n */\nfunction count(counts, node) {\n  // Uppercase to prevent prototype polution, injecting `constructor` or so.\n  // Normalize because HTML is insensitive.\n  const name = node.type.toUpperCase()\n  const count = (counts.types.get(name) || 0) + 1\n  counts.count++\n  counts.types.set(name, count)\n}\n", "/**\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').RuleSet} RuleSet\n */\n\nimport {CssSelectorParser} from 'css-selector-parser'\n\nconst parser = new CssSelectorParser()\n\nparser.registerAttrEqualityMods('~', '^', '$', '*')\nparser.registerSelectorPseudos('any', 'matches', 'not', 'has')\nparser.registerNestingOperators('>', '+', '~')\n\n/**\n * @param {string} selector\n * @returns {Selectors | RuleSet | null}\n */\nexport function parse(selector) {\n  if (typeof selector !== 'string') {\n    throw new TypeError('Expected `string` as selector, not `' + selector + '`')\n  }\n\n  return parser.parse(selector)\n}\n", "/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('./lib/types.js').SelectState} SelectState\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {queryToSelectors, walk} from './lib/walk.js'\nimport {parse} from './lib/parse.js'\nimport {parent} from './lib/util.js'\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the node itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`paragraph strong`,\n * `paragraph > strong`), neither are selectors like `:first-child`, etc.\n * This only checks that the given node matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node that might match `selector`.\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node) {\n  const state = createState(selector, node)\n  state.one = true\n  state.shallow = true\n  walk(state, node || undefined)\n  return state.results.length > 0\n}\n\n/**\n * Select the first node that matches `selector` in the given `tree`.\n *\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [tree]\n *   Tree to search.\n * @returns {Node | null}\n *   First node in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *\n *   This could be `tree` itself.\n */\nexport function select(selector, tree) {\n  const state = createState(selector, tree)\n  state.one = true\n  walk(state, tree || undefined)\n  // To do next major: return `undefined`.\n  return state.results[0] || null\n}\n\n/**\n * Select all nodes that match `selector` in the given `tree`.\n *\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [tree]\n *   Tree to search.\n * @returns {Array<Node>}\n *   Nodes in `tree` that match `selector`.\n *\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree) {\n  const state = createState(selector, tree)\n  walk(state, tree || undefined)\n  return state.results\n}\n\n/**\n * @param {string} selector\n *   Selector to parse.\n * @param {Node | null | undefined} tree\n *   Tree to search.\n * @returns {SelectState}\n */\nfunction createState(selector, tree) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    scopeNodes: tree\n      ? parent(tree) &&\n        // Root in nlcst.\n        (tree.type === 'RootNode' || tree.type === 'root')\n        ? tree.children\n        : [tree]\n      : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    typeIndex: undefined,\n    nodeIndex: undefined,\n    typeCount: undefined,\n    nodeCount: undefined\n  }\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\n/** @type {Array<unknown>} */\nconst empty = []\n\n/**\n * Change the given `tree` by removing all nodes that pass `test`.\n *\n * The tree is walked in preorder (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to change.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   The given `tree` without nodes that pass `test`.\n *\n *   `null` is returned if `tree` itself didn\u2019t pass the test or is cascaded\n *   away.\n */\n// To do: next major: don\u2019t return `tree`.\nexport const remove =\n  /**\n   * @type {(\n   *  (<Tree extends Node>(node: Tree, options: Options, test: Test) => Tree | null) &\n   *  (<Tree extends Node>(node: Tree, test: Test) => Tree | null)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Options | null | undefined} [options]\n     * @param {Test | null | undefined} [test]\n     * @returns {Node | null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      const cascade =\n        !options || options.cascade === undefined || options.cascade === null\n          ? true\n          : options.cascade\n\n      return preorder(tree)\n\n      /**\n       * Check and remove nodes recursively in preorder.\n       * For each composite node, modify its children array in-place.\n       *\n       * @param {Node} node\n       * @param {number | null | undefined} [index]\n       * @param {Parent | null | undefined} [parent]\n       * @returns {Node | null}\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array<Node>} */\n        // @ts-expect-error looks like a parent.\n        const children = node.children || empty\n        let childIndex = -1\n        let position = 0\n\n        if (is(node, index, parent)) {\n          return null\n        }\n\n        if (children.length > 0) {\n          // Move all living children to the beginning of the children array.\n          while (++childIndex < children.length) {\n            // @ts-expect-error looks like a parent.\n            if (preorder(children[childIndex], childIndex, node)) {\n              children[position++] = children[childIndex]\n            }\n          }\n\n          // Cascade delete.\n          if (cascade && !position) {\n            return null\n          }\n\n          // Drop other nodes.\n          children.length = position\n        }\n\n        return node\n      }\n    }\n  )\n", "export const SITE_FRONTMATTER_KEYS = [\n    'title',\n    'subtitle',\n    'short_title',\n    'description',\n    'thumbnail',\n    'thumbnailOptimized',\n    'banner',\n    'bannerOptimized',\n    'tags',\n    'authors',\n    'reviewers',\n    'editors',\n    'contributors',\n    'venue',\n    'github',\n    'keywords',\n    'affiliations',\n    'funding',\n    'copyright',\n    'options',\n];\nexport const FRONTMATTER_ALIASES = {\n    author: 'authors',\n    reviewer: 'reviewers',\n    editor: 'editors',\n    contributor: 'contributors',\n    affiliation: 'affiliations',\n    export: 'exports',\n    download: 'downloads',\n    jupyter: 'thebe',\n    part: 'parts',\n    ack: 'acknowledgments',\n    acknowledgements: 'acknowledgments',\n    acknowledgment: 'acknowledgments',\n    acknowledgement: 'acknowledgments',\n    availability: 'data_availability',\n    dataAvailability: 'data_availability',\n    'data-availability': 'data_availability',\n    quote: 'epigraph',\n    plain_language_summary: 'summary',\n    'plain-language-summary': 'summary',\n    plainLanguageSummary: 'summary',\n    lay_summary: 'summary',\n    'lay-summary': 'summary',\n    keyPoints: 'keypoints',\n    key_points: 'keypoints',\n    'key-points': 'keypoints',\n    image: 'thumbnail',\n};\n", "import { remove } from 'unist-util-remove';\nimport { selectAll } from 'unist-util-select';\nimport { copyNode, toText } from './utils.js';\nimport { FRONTMATTER_ALIASES } from 'myst-frontmatter';\nfunction coercePart(part) {\n    if (!part) {\n        // Prevent an undefined, null or empty part comparison\n        return [];\n    }\n    if (typeof part === 'string')\n        return coercePart([part]);\n    const parts = [];\n    part\n        .map((p) => p.toLowerCase())\n        .forEach((p) => {\n        parts.push(p);\n        Object.entries(FRONTMATTER_ALIASES).forEach(([alias, value]) => {\n            if (p === alias || p === value) {\n                if (!parts.includes(value))\n                    parts.unshift(value);\n                if (!parts.includes(alias))\n                    parts.push(alias);\n            }\n        });\n    });\n    return parts;\n}\n/**\n * Selects the block node(s) based on part (string) or tags (string[]).\n * If `part` is a string array, any of the parts will be treated equally.\n */\nexport function selectBlockParts(tree, part) {\n    const parts = coercePart(part);\n    if (parts.length === 0)\n        return [];\n    const blockParts = selectAll('block', tree).filter((block) => {\n        var _a, _b, _c;\n        const blockTags = (((_a = block.data) === null || _a === void 0 ? void 0 : _a.tags) && Array.isArray(block.data.tags) ? block.data.tags : []).map((tag) => tag === null || tag === void 0 ? void 0 : tag.toLowerCase());\n        const blockPart = (_c = (_b = block.data) === null || _b === void 0 ? void 0 : _b.part) === null || _c === void 0 ? void 0 : _c.toLowerCase();\n        return parts\n            .map((p) => blockPart === p || blockTags.includes(p))\n            .reduce((a, b) => a || b, false);\n    });\n    return blockParts;\n}\nfunction createPartBlock(children, part, opts) {\n    var _a;\n    const block = { type: 'block', children };\n    if (!(opts === null || opts === void 0 ? void 0 : opts.removePartData)) {\n        (_a = block.data) !== null && _a !== void 0 ? _a : (block.data = {});\n        block.data.part = part;\n    }\n    return block;\n}\nfunction forcedRemove(tree, test) {\n    let success = remove(tree, test);\n    if (!success) {\n        success = remove(tree, { cascade: false }, test);\n    }\n    return success;\n}\n/**\n * Extract implicit part based on heading name\n *\n * Given a tree, search children at the root or block level for a heading\n * with text matching parts. If such heading is encountered, return a copy of\n * the subsequent paragraph nodes until a non-paragraph node is encountered.\n * Heading and paragraph nodes in the original tree are marked for deletion.\n *\n * Ignores anything that is already part of a block with explicit part.\n */\nexport function extractImplicitPart(tree, part, opts) {\n    var _a;\n    const parts = coercePart(part);\n    if (parts.length === 0)\n        return;\n    let insideImplicitPart = false;\n    const blockParts = [];\n    let paragraphs = [];\n    (_a = tree.children) === null || _a === void 0 ? void 0 : _a.forEach((child, index) => {\n        var _a;\n        // Add this paragraph to the part\n        if (insideImplicitPart && child.type === 'paragraph') {\n            paragraphs.push(copyNode(child));\n            child.type = '__part_delete__';\n        }\n        // Stop adding things if we didn't just add a paragraph OR we are at the last child\n        if (child.type !== '__part_delete__' || index === tree.children.length - 1) {\n            insideImplicitPart = false;\n            if (paragraphs.length > 0) {\n                blockParts.push(createPartBlock(paragraphs, parts[0], opts));\n                paragraphs = [];\n                selectAll('__part_heading__', tree).forEach((node) => {\n                    node.type = '__part_delete__';\n                });\n            }\n        }\n        if (child.type === 'block') {\n            // Do not search blocks already marked explicitly as parts\n            if ((_a = child.data) === null || _a === void 0 ? void 0 : _a.part)\n                return;\n            // Do not recursively search beyond top-level blocks on root node\n            if (tree.type !== 'root')\n                return;\n            const blockPartsTree = extractImplicitPart(child, parts);\n            if (blockPartsTree)\n                blockParts.push(...blockPartsTree.children);\n        }\n        else if (child.type === 'heading' && parts.includes(toText(child).toLowerCase())) {\n            // Start adding paragraphs to the part after this heading\n            insideImplicitPart = true;\n            child.type = '__part_heading__';\n        }\n    });\n    // Restore part headings if they did not contain any paragraphs\n    selectAll('__part_heading__', tree).forEach((node) => {\n        node.type = 'heading';\n    });\n    if (blockParts.length === 0)\n        return;\n    const partsTree = { type: 'root', children: blockParts };\n    forcedRemove(tree, '__part_delete__');\n    return partsTree;\n}\n/**\n * Returns a copy of the block parts and removes them from the tree.\n */\nexport function extractPart(tree, part, opts) {\n    const partStrings = coercePart(part);\n    if (partStrings.length === 0)\n        return;\n    const blockParts = selectBlockParts(tree, part);\n    if (blockParts.length === 0) {\n        if (opts === null || opts === void 0 ? void 0 : opts.requireExplicitPart)\n            return;\n        return extractImplicitPart(tree, partStrings);\n    }\n    const children = copyNode(blockParts).map((block) => {\n        var _a;\n        // Ensure the block always has the `part` defined, as it might be in the tags\n        (_a = block.data) !== null && _a !== void 0 ? _a : (block.data = {});\n        block.data.part = partStrings[0];\n        if (block.data.tags &&\n            Array.isArray(block.data.tags) &&\n            block.data.tags.reduce((a, t) => a || partStrings.includes(t.toLowerCase()), false)) {\n            block.data.tags = block.data.tags.filter((tag) => !partStrings.includes(tag.toLowerCase()));\n            if (block.data.tags.length === 0) {\n                delete block.data.tags;\n            }\n        }\n        if (opts === null || opts === void 0 ? void 0 : opts.removePartData)\n            delete block.data.part;\n        // The default is to remove the visibility on the parts\n        if (!(opts === null || opts === void 0 ? void 0 : opts.keepVisibility))\n            delete block.visibility;\n        return block;\n    });\n    const partsTree = { type: 'root', children };\n    // Remove the block parts from the main document\n    blockParts.forEach((block) => {\n        block.type = '__delete__';\n    });\n    forcedRemove(tree, '__delete__');\n    return partsTree;\n}\n", "export var RuleId;\n(function (RuleId) {\n    // Frontmatter rules\n    RuleId[\"validConfigStructure\"] = \"valid-config-structure\";\n    RuleId[\"siteConfigExists\"] = \"site-config-exists\";\n    RuleId[\"projectConfigExists\"] = \"project-config-exists\";\n    RuleId[\"validSiteConfig\"] = \"valid-site-config\";\n    RuleId[\"validProjectConfig\"] = \"valid-project-config\";\n    RuleId[\"configHasNoDeprecatedFields\"] = \"config-has-no-deprecated-fields\";\n    RuleId[\"frontmatterIsYaml\"] = \"frontmatter-is-yaml\";\n    RuleId[\"validPageFrontmatter\"] = \"valid-page-frontmatter\";\n    RuleId[\"validFrontmatterExportList\"] = \"valid-frontmatter-export-list\";\n    // Export rules\n    RuleId[\"docxRenders\"] = \"docx-renders\";\n    RuleId[\"jatsRenders\"] = \"jats-renders\";\n    RuleId[\"mdRenders\"] = \"md-renders\";\n    RuleId[\"mecaIncludesJats\"] = \"meca-includes-jats\";\n    RuleId[\"mecaExportsBuilt\"] = \"meca-exports-built\";\n    RuleId[\"mecaFilesCopied\"] = \"meca-files-copied\";\n    RuleId[\"pdfBuildCommandsAvailable\"] = \"pdf-build-commands-available\";\n    RuleId[\"pdfBuildsWithoutErrors\"] = \"pdf-builds-without-errors\";\n    RuleId[\"pdfBuilds\"] = \"pdf-builds\";\n    RuleId[\"texRenders\"] = \"tex-renders\";\n    RuleId[\"exportExtensionCorrect\"] = \"export-extension-correct\";\n    RuleId[\"exportArticleExists\"] = \"export-article-exists\";\n    // Parse rules\n    RuleId[\"texParses\"] = \"tex-parses\";\n    RuleId[\"jatsParses\"] = \"jats-parses\";\n    RuleId[\"mystFileLoads\"] = \"myst-file-loads\";\n    RuleId[\"selectedFileIsProcessed\"] = \"selected-file-is-processed\";\n    // Directive and role rules\n    RuleId[\"directiveRegistered\"] = \"directive-registered\";\n    RuleId[\"directiveKnown\"] = \"directive-known\";\n    RuleId[\"directiveArgumentCorrect\"] = \"directive-argument-correct\";\n    RuleId[\"directiveOptionsCorrect\"] = \"directive-options-correct\";\n    RuleId[\"directiveBodyCorrect\"] = \"directive-body-correct\";\n    RuleId[\"roleRegistered\"] = \"role-registered\";\n    RuleId[\"roleKnown\"] = \"role-known\";\n    RuleId[\"roleBodyCorrect\"] = \"role-body-correct\";\n    // Project structure rules\n    RuleId[\"tocContentsExist\"] = \"toc-contents-exist\";\n    RuleId[\"encounteredLegacyTOC\"] = \"encountered-legacy-toc\";\n    RuleId[\"validTOCStructure\"] = \"valid-toc-structure\";\n    RuleId[\"validTOC\"] = \"valid-toc\";\n    RuleId[\"tocWritten\"] = \"toc-written\";\n    // Image rules\n    RuleId[\"imageDownloads\"] = \"image-downloads\";\n    RuleId[\"imageExists\"] = \"image-exists\";\n    RuleId[\"imageFormatConverts\"] = \"image-format-converts\";\n    RuleId[\"imageCopied\"] = \"image-copied\";\n    RuleId[\"imageFormatOptimizes\"] = \"image-format-optimizes\";\n    // Math rules\n    RuleId[\"mathLabelLifted\"] = \"math-label-lifted\";\n    RuleId[\"mathEquationEnvRemoved\"] = \"math-equation-env-removed\";\n    RuleId[\"mathEqnarrayReplaced\"] = \"math-eqnarray-replaced\";\n    RuleId[\"mathAlignmentAdjusted\"] = \"math-alignment-adjusted\";\n    RuleId[\"mathRenders\"] = \"math-renders\";\n    // Reference rules\n    RuleId[\"referenceTemplateFills\"] = \"reference-template-fills\";\n    RuleId[\"identifierIsUnique\"] = \"identifier-is-unique\";\n    RuleId[\"referenceTargetResolves\"] = \"reference-target-resolves\";\n    RuleId[\"referenceSyntaxValid\"] = \"reference-syntax-valid\";\n    RuleId[\"referenceTargetExplicit\"] = \"reference-target-explicit\";\n    RuleId[\"footnoteReferencesDefinition\"] = \"footnote-references-definition\";\n    RuleId[\"intersphinxReferencesResolve\"] = \"intersphinx-references-resolve\";\n    // Link rules\n    RuleId[\"mystLinkValid\"] = \"myst-link-valid\";\n    RuleId[\"sphinxLinkValid\"] = \"sphinx-link-valid\";\n    RuleId[\"rridLinkValid\"] = \"rrid-link-valid\";\n    RuleId[\"rorLinkValid\"] = \"ror-link-valid\";\n    RuleId[\"wikipediaLinkValid\"] = \"wikipedia-link-valid\";\n    RuleId[\"doiLinkValid\"] = \"doi-link-valid\";\n    RuleId[\"linkResolves\"] = \"link-resolves\";\n    RuleId[\"linkTextExists\"] = \"link-text-exists\";\n    // Notebook rules\n    RuleId[\"notebookAttachmentsResolve\"] = \"notebook-attachments-resolve\";\n    RuleId[\"notebookOutputCopied\"] = \"notebook-output-copied\";\n    // Content rules\n    RuleId[\"mdastSnippetImports\"] = \"mdast-snippet-imports\";\n    RuleId[\"includeContentFilters\"] = \"include-content-filters\";\n    RuleId[\"includeContentLoads\"] = \"include-content-loads\";\n    RuleId[\"gatedNodesJoin\"] = \"gated-nodes-join\";\n    RuleId[\"glossaryUsesDefinitionList\"] = \"glossary-uses-definition-list\";\n    RuleId[\"blockMetadataLoads\"] = \"block-metadata-loads\";\n    // Citation rules\n    RuleId[\"citationIsUnique\"] = \"citation-is-unique\";\n    RuleId[\"bibFileExists\"] = \"bib-file-exists\";\n    RuleId[\"citationRenders\"] = \"citation-renders\";\n    // Code rules\n    RuleId[\"codeMetadataLifted\"] = \"code-metadata-lifted\";\n    RuleId[\"codeMetatagsValid\"] = \"code-metatags-valid\";\n    RuleId[\"codeLangDefined\"] = \"code-lang-defined\";\n    RuleId[\"codeMetadataLoads\"] = \"code-metadata-loads\";\n    RuleId[\"inlineCodeMalformed\"] = \"inline-code-malformed\";\n    RuleId[\"inlineExpressionRenders\"] = \"inline-expression-renders\";\n    // Static file rules\n    RuleId[\"staticFileCopied\"] = \"static-file-copied\";\n    RuleId[\"exportFileCopied\"] = \"export-file-copied\";\n    RuleId[\"sourceFileCopied\"] = \"source-file-copied\";\n    RuleId[\"templateFileCopied\"] = \"template-file-copied\";\n    RuleId[\"staticActionFileCopied\"] = \"static-action-file-copied\";\n    // Plugins\n    RuleId[\"pluginLoads\"] = \"plugin-loads\";\n    RuleId[\"pluginExecutionFailed\"] = \"plugin-execution-failed\";\n    // Container rules\n    RuleId[\"containerChildrenValid\"] = \"container-children-valid\";\n})(RuleId || (RuleId = {}));\n", "/**\n * Creates a plural version of a string to log to the console.\n *\n * `plural('%s book(s)', books)`\n *\n * `plural('%s stitch(es)', 3)`\n *\n * `plural('%s dependenc(y|ies)', deps)`\n *\n *\n * If passed an object as the second argument, the number of keys will be used.\n */\nexport function plural(f, count) {\n    var _a;\n    const num = (_a = (typeof count === 'number'\n        ? count\n        : Array.isArray(count)\n            ? count === null || count === void 0 ? void 0 : count.length\n            : Object.keys(count !== null && count !== void 0 ? count : {}).length)) !== null && _a !== void 0 ? _a : 0;\n    return f\n        .replace('%s', String(num))\n        .replace(/\\((?:([a-z0-9A-Z-]*)\\|)?([a-z0-9A-Z-]*)\\)/g, num === 1 ? '$1' : '$2');\n}\n", "import { selectAll } from 'unist-util-select';\nimport { EXIT, SKIP, visit } from 'unist-util-visit';\n/**\n * Determine if node with `identifier` should be considered a target\n *\n * TODO: `identifier` on these non-target should be updated to `target`\n * Doing so will make this function obsolete\n *\n * This function only returns false if node `type` equals one of:\n * crossReferences, citations, footnoteDefinition, and footnoteReference.\n *\n * It does not actually check if the node has `identifier`.\n */\nexport function isTargetIdentifierNode(node) {\n    const nonTargetTypes = ['crossReference', 'cite', 'footnoteDefinition', 'footnoteReference'];\n    return !nonTargetTypes.includes(node.type);\n}\nconst hiddenNodes = new Set(['comment', 'mystComment']);\nfunction selectHeadingNodes(mdast, identifier, maxNodes) {\n    let begin = false;\n    let htmlId = undefined;\n    const nodes = [];\n    visit(mdast, (node) => {\n        if ((begin && node.type === 'heading') || (maxNodes && nodes.length >= maxNodes)) {\n            return EXIT;\n        }\n        if (node.identifier === identifier && node.type === 'heading') {\n            begin = true;\n            htmlId = node.html_id || node.identifier;\n        }\n        if (begin) {\n            if (!hiddenNodes.has(node.type))\n                nodes.push(node);\n            return SKIP; // Don't traverse the children\n        }\n    });\n    return { htmlId, nodes };\n}\nfunction selectDefinitionTerm(mdast, identifier, maxNodes) {\n    var _a, _b;\n    let begin = false;\n    const nodes = [];\n    visit(mdast, (node) => {\n        if (begin && node.type === 'definitionTerm') {\n            if (nodes.length > 1)\n                return EXIT;\n        }\n        else if (begin && node.type !== 'definitionDescription') {\n            return EXIT;\n        }\n        if (node.identifier === identifier && node.type === 'definitionTerm') {\n            nodes.push(node);\n            begin = true;\n        }\n        if (begin) {\n            if (node.type === 'definitionDescription')\n                nodes.push(node);\n            return SKIP; // Don't traverse the children\n        }\n    });\n    return {\n        htmlId: ((_a = nodes === null || nodes === void 0 ? void 0 : nodes[0]) === null || _a === void 0 ? void 0 : _a.html_id) || ((_b = nodes === null || nodes === void 0 ? void 0 : nodes[0]) === null || _b === void 0 ? void 0 : _b.identifier),\n        nodes: [{ type: 'definitionList', key: 'dl', children: nodes.slice(0, maxNodes) }],\n    };\n}\n/**\n * Select target node, given identifier and mdast\n *\n * If identifier resolves to \"heading\" node, this will return the heading node and all\n * subsequent nodes up to the next heading, unless `maxNodes` is specified - then\n * it will only return up to that many nodes.\n *\n * If identifier resolves to \"definitionTerm\" node, this will return a single\n * \"definitionList\" node that wraps the \"definitionTerm\" node and any\n * subsequent \"definitionDescription\" node(s). The `maxNodes` value will still\n * apply here if specified.\n *\n * For all other target node types, this will only return the single target node.\n */\nexport function selectMdastNodes(mdast, identifier, maxNodes) {\n    if (maxNodes === 0)\n        return { nodes: [] };\n    // Select the first identifier that is not a crossReference or citation\n    const node = selectAll(`[identifier=${identifier}],[key=${identifier}]`, mdast).find((n) => isTargetIdentifierNode(n));\n    if (!node)\n        return { nodes: [] };\n    switch (node.type) {\n        case 'heading':\n            return selectHeadingNodes(mdast, identifier, maxNodes);\n        case 'definitionTerm':\n            return selectDefinitionTerm(mdast, identifier, maxNodes);\n        default:\n            return { htmlId: node.html_id || node.identifier, nodes: [node] };\n    }\n}\n", "export var NotebookCell;\n(function (NotebookCell) {\n    NotebookCell[\"content\"] = \"notebook-content\";\n    NotebookCell[\"code\"] = \"notebook-code\";\n})(NotebookCell || (NotebookCell = {}));\nexport var NotebookCellTags;\n(function (NotebookCellTags) {\n    NotebookCellTags[\"removeStderr\"] = \"remove-stderr\";\n    NotebookCellTags[\"removeStdout\"] = \"remove-stdout\";\n    NotebookCellTags[\"hideCell\"] = \"hide-cell\";\n    NotebookCellTags[\"hideInput\"] = \"hide-input\";\n    NotebookCellTags[\"hideOutput\"] = \"hide-output\";\n    NotebookCellTags[\"removeCell\"] = \"remove-cell\";\n    NotebookCellTags[\"removeInput\"] = \"remove-input\";\n    NotebookCellTags[\"removeOutput\"] = \"remove-output\";\n})(NotebookCellTags || (NotebookCellTags = {}));\n// Types for defining roles and directives\nexport var ParseTypesEnum;\n(function (ParseTypesEnum) {\n    ParseTypesEnum[\"string\"] = \"string\";\n    ParseTypesEnum[\"number\"] = \"number\";\n    ParseTypesEnum[\"boolean\"] = \"boolean\";\n    ParseTypesEnum[\"parsed\"] = \"parsed\";\n})(ParseTypesEnum || (ParseTypesEnum = {}));\nexport var TargetKind;\n(function (TargetKind) {\n    TargetKind[\"heading\"] = \"heading\";\n    TargetKind[\"equation\"] = \"equation\";\n    TargetKind[\"subequation\"] = \"subequation\";\n    TargetKind[\"figure\"] = \"figure\";\n    TargetKind[\"table\"] = \"table\";\n    TargetKind[\"code\"] = \"code\";\n})(TargetKind || (TargetKind = {}));\nexport var AdmonitionKind;\n(function (AdmonitionKind) {\n    AdmonitionKind[\"admonition\"] = \"admonition\";\n    AdmonitionKind[\"attention\"] = \"attention\";\n    AdmonitionKind[\"caution\"] = \"caution\";\n    AdmonitionKind[\"danger\"] = \"danger\";\n    AdmonitionKind[\"error\"] = \"error\";\n    AdmonitionKind[\"important\"] = \"important\";\n    AdmonitionKind[\"hint\"] = \"hint\";\n    AdmonitionKind[\"note\"] = \"note\";\n    AdmonitionKind[\"seealso\"] = \"seealso\";\n    AdmonitionKind[\"tip\"] = \"tip\";\n    AdmonitionKind[\"warning\"] = \"warning\";\n})(AdmonitionKind || (AdmonitionKind = {}));\n"],
  "mappings": ";;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AAAA,MAChB,UAAU,SAAS,WAAU;AAC5B,eAAO;AAAA,MACR;AAAA,MACA,WAAW,SAAS,YAAW;AAC9B,eAAO;AAAA,MACR;AAAA,IACD;AAAA;AAAA;;;ACPA;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,aAAS,aAAa,GAAG;AACrB,aAAQ,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK,OAAS,MAAM,OAAS,MAAM;AAAA,IACrF;AACA,YAAQ,eAAe;AACvB,aAAS,QAAQ,GAAG;AAChB,aAAQ,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK,OAAQ,MAAM,OAAO,MAAM;AAAA,IAC5G;AACA,YAAQ,UAAU;AAClB,aAAS,MAAM,GAAG;AACd,aAAQ,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK;AAAA,IACjF;AACA,YAAQ,QAAQ;AAChB,aAAS,iBAAiB,GAAG;AACzB,UAAI,MAAM,EAAE;AACZ,UAAI,SAAS;AACb,UAAI,IAAI;AACR,aAAO,IAAI,KAAK;AACZ,YAAI,MAAM,EAAE,OAAO,CAAC;AACpB,YAAI,QAAQ,kBAAkB,GAAG,GAAG;AAChC,oBAAU,OAAO;AAAA,QACrB,OACK;AACD,cAAI,EAAE,QAAQ,OAAO,QAAQ,OACxB,OAAO,OAAO,OAAO,OACrB,OAAO,OAAO,OAAO,OACrB,MAAM,KAAK,OAAO,OAAO,OAAO,MAAO;AACxC,gBAAI,WAAW,IAAI,WAAW,CAAC;AAC/B,iBAAK,WAAW,WAAY,OAAQ;AAChC,kBAAI,gBAAgB,EAAE,WAAW,GAAG;AACpC,mBAAK,WAAW,WAAY,UAAW,gBAAgB,WAAY,OAAQ;AACvE,sBAAM,MAAM,iCAAiC;AAAA,cACjD;AACA,2BAAa,WAAW,SAAU,OAAO,gBAAgB,QAAS;AAAA,YACtE;AACA,sBAAU,OAAO,SAAS,SAAS,EAAE,IAAI;AAAA,UAC7C,OACK;AACD,sBAAU;AAAA,UACd;AAAA,QACJ;AACA;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,YAAQ,mBAAmB;AAC3B,aAAS,UAAU,GAAG;AAClB,UAAI,MAAM,EAAE;AACZ,UAAI,SAAS;AACb,UAAI,IAAI;AACR,UAAI;AACJ,aAAO,IAAI,KAAK;AACZ,YAAI,MAAM,EAAE,OAAO,CAAC;AACpB,YAAI,QAAQ,KAAK;AACb,gBAAM;AAAA,QACV,WACS,QAAQ,MAAM;AACnB,gBAAM;AAAA,QACV,YACU,cAAc,QAAQ,mBAAmB,GAAG,OAAO,QAAW;AACpE,gBAAM;AAAA,QACV;AACA,kBAAU;AACV;AAAA,MACJ;AACA,aAAO,MAAO,SAAS;AAAA,IAC3B;AACA,YAAQ,YAAY;AACpB,YAAQ,oBAAoB;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACT;AACA,YAAQ,qBAAqB;AAAA,MACzB,MAAM;AAAA,MACN,MAAM;AAAA,MACN,KAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACV;AACA,YAAQ,yBAAyB;AAAA,MAC7B,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,MAAM;AAAA,MACN,KAAM;AAAA,IACV;AACA,YAAQ,0BAA0B;AAAA,MAC9B,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,MAAM;AAAA,MACN,KAAK;AAAA,IACT;AAAA;AAAA;;;AC1HA;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,QAAI,UAAU;AACd,aAAS,iBAAiB,KAAK,KAAK,SAAS,kBAAkB,sBAAsB,oBAAoB;AACrG,UAAI,IAAI,IAAI;AACZ,UAAI,MAAM;AACV,eAAS,OAAO,OAAO,aAAa;AAChC,YAAI,SAAS;AACb;AACA,cAAM,IAAI,OAAO,GAAG;AACpB,eAAO,MAAM,GAAG;AACZ,cAAI,QAAQ,OAAO;AACf;AACA,mBAAO;AAAA,UACX,WACS,QAAQ,MAAM;AACnB;AACA,kBAAM,IAAI,OAAO,GAAG;AACpB,gBAAI,MAAM;AACV,gBAAI,QAAQ,OAAO;AACf,wBAAU;AAAA,YACd,YACU,MAAM,YAAY,GAAG,OAAO,QAAW;AAC7C,wBAAU;AAAA,YACd,WACS,QAAQ,MAAM,GAAG,GAAG;AACzB,kBAAI,MAAM;AACV;AACA,oBAAM,IAAI,OAAO,GAAG;AACpB,qBAAO,QAAQ,MAAM,GAAG,GAAG;AACvB,uBAAO;AACP;AACA,sBAAM,IAAI,OAAO,GAAG;AAAA,cACxB;AACA,kBAAI,QAAQ,KAAK;AACb;AACA,sBAAM,IAAI,OAAO,GAAG;AAAA,cACxB;AACA,wBAAU,OAAO,aAAa,SAAS,KAAK,EAAE,CAAC;AAC/C;AAAA,YACJ,OACK;AACD,wBAAU;AAAA,YACd;AAAA,UACJ,OACK;AACD,sBAAU;AAAA,UACd;AACA;AACA,gBAAM,IAAI,OAAO,GAAG;AAAA,QACxB;AACA,eAAO;AAAA,MACX;AACA,eAAS,WAAW;AAChB,YAAI,SAAS;AACb,cAAM,IAAI,OAAO,GAAG;AACpB,eAAO,MAAM,GAAG;AACZ,cAAI,QAAQ,QAAQ,GAAG,GAAG;AACtB,sBAAU;AAAA,UACd,WACS,QAAQ,MAAM;AACnB;AACA,gBAAI,OAAO,GAAG;AACV,oBAAM,MAAM,0CAA0C;AAAA,YAC1D;AACA,kBAAM,IAAI,OAAO,GAAG;AACpB,gBAAI,QAAQ,kBAAkB,GAAG,GAAG;AAChC,wBAAU;AAAA,YACd,WACS,QAAQ,MAAM,GAAG,GAAG;AACzB,kBAAI,MAAM;AACV;AACA,oBAAM,IAAI,OAAO,GAAG;AACpB,qBAAO,QAAQ,MAAM,GAAG,GAAG;AACvB,uBAAO;AACP;AACA,sBAAM,IAAI,OAAO,GAAG;AAAA,cACxB;AACA,kBAAI,QAAQ,KAAK;AACb;AACA,sBAAM,IAAI,OAAO,GAAG;AAAA,cACxB;AACA,wBAAU,OAAO,aAAa,SAAS,KAAK,EAAE,CAAC;AAC/C;AAAA,YACJ,OACK;AACD,wBAAU;AAAA,YACd;AAAA,UACJ,OACK;AACD,mBAAO;AAAA,UACX;AACA;AACA,gBAAM,IAAI,OAAO,GAAG;AAAA,QACxB;AACA,eAAO;AAAA,MACX;AACA,eAAS,iBAAiB;AACtB,cAAM,IAAI,OAAO,GAAG;AACpB,YAAI,SAAS;AACb,eAAO,QAAQ,OAAO,QAAQ,OAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,MAAM;AAChF,mBAAS;AACT;AACA,gBAAM,IAAI,OAAO,GAAG;AAAA,QACxB;AACA,eAAO;AAAA,MACX;AACA,eAASA,SAAQ;AACb,YAAI,MAAM,cAAc;AACxB,YAAI,MAAM,GAAG;AACT,gBAAM,MAAM,wBAAwB,IAAI,OAAO,GAAG,IAAI,UAAU;AAAA,QACpE;AACA,eAAO;AAAA,MACX;AACA,eAAS,gBAAgB;AACrB,YAAI,WAAW,oBAAoB;AACnC,YAAI,CAAC,UAAU;AACX,iBAAO;AAAA,QACX;AACA,YAAI,MAAM;AACV,cAAM,IAAI,OAAO,GAAG;AACpB,eAAO,QAAQ,KAAK;AAChB;AACA,yBAAe;AACf,cAAI,IAAI,SAAS,aAAa;AAC1B,kBAAM;AAAA,cACF,MAAM;AAAA,cACN,WAAW,CAAC,QAAQ;AAAA,YACxB;AAAA,UACJ;AACA,qBAAW,oBAAoB;AAC/B,cAAI,CAAC,UAAU;AACX,kBAAM,MAAM,0BAA0B;AAAA,UAC1C;AACA,cAAI,UAAU,KAAK,QAAQ;AAAA,QAC/B;AACA,eAAO;AAAA,MACX;AACA,eAAS,sBAAsB;AAC3B,uBAAe;AACf,YAAI,WAAW;AAAA,UACX,MAAM;AAAA,QACV;AACA,YAAI,OAAO,UAAU;AACrB,YAAI,CAAC,MAAM;AACP,iBAAO;AAAA,QACX;AACA,YAAI,cAAc;AAClB,eAAO,MAAM;AACT,eAAK,OAAO;AACZ,sBAAY,OAAO;AACnB,wBAAc;AACd,yBAAe;AACf,gBAAM,IAAI,OAAO,GAAG;AACpB,cAAI,OAAO,KAAK,QAAQ,OAAO,QAAQ,KAAK;AACxC;AAAA,UACJ;AACA,cAAI,qBAAqB,GAAG,GAAG;AAC3B,gBAAI,KAAK;AACT;AACA,2BAAe;AACf,mBAAO,UAAU;AACjB,gBAAI,CAAC,MAAM;AACP,oBAAM,MAAM,0BAA0B,KAAK,IAAI;AAAA,YACnD;AACA,iBAAK,kBAAkB;AAAA,UAC3B,OACK;AACD,mBAAO,UAAU;AACjB,gBAAI,MAAM;AACN,mBAAK,kBAAkB;AAAA,YAC3B;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAEA,eAAS,YAAY;AACjB,YAAI,OAAO;AACX,eAAO,MAAM,GAAG;AACZ,gBAAM,IAAI,OAAO,GAAG;AACpB,cAAI,QAAQ,KAAK;AACb;AACA,aAAC,OAAO,QAAQ,CAAC,GAAG,UAAU;AAAA,UAClC,WACS,QAAQ,aAAa,GAAG,KAAK,QAAQ,MAAM;AAChD,aAAC,OAAO,QAAQ,CAAC,GAAG,UAAU,SAAS;AAAA,UAC3C,WACS,QAAQ,KAAK;AAClB;AACA,mBAAO,QAAQ,CAAC;AAChB,aAAC,KAAK,aAAa,KAAK,cAAc,CAAC,GAAG,KAAK,SAAS,CAAC;AAAA,UAC7D,WACS,QAAQ,KAAK;AAClB;AACA,aAAC,OAAO,QAAQ,CAAC,GAAG,KAAK,SAAS;AAAA,UACtC,WACS,QAAQ,KAAK;AAClB;AACA,2BAAe;AACf,gBAAI,OAAO;AAAA,cACP,MAAM,SAAS;AAAA,YACnB;AACA,2BAAe;AAEf,gBAAI,QAAQ,KAAK;AACb;AAAA,YACJ,OACK;AACD,kBAAI,WAAW;AACf,kBAAI,iBAAiB,GAAG,GAAG;AACvB,2BAAW;AACX;AACA,sBAAM,IAAI,OAAO,GAAG;AAAA,cACxB;AACA,kBAAI,OAAO,GAAG;AACV,sBAAM,MAAM,uCAAuC;AAAA,cACvD;AACA,kBAAI,QAAQ,KAAK;AACb,sBAAM,MAAM,uBAAuB,MAAM,UAAU;AAAA,cACvD;AACA,mBAAK,WAAW,WAAW;AAC3B;AACA,6BAAe;AACf,kBAAI,YAAY;AAChB,mBAAK,YAAY;AAEjB,kBAAI,QAAQ,KAAK;AACb,4BAAY,OAAO,KAAK,QAAQ,uBAAuB;AAAA,cAE3D,WACS,QAAQ,KAAM;AACnB,4BAAY,OAAO,KAAM,QAAQ,sBAAsB;AAAA,cAE3D,WACS,sBAAsB,QAAQ,KAAK;AACxC;AACA,4BAAY,SAAS;AACrB,qBAAK,YAAY;AAAA,cACrB,OACK;AACD,uBAAO,MAAM,GAAG;AACZ,sBAAI,QAAQ,KAAK;AACb;AAAA,kBACJ;AACA,+BAAa;AACb;AACA,wBAAM,IAAI,OAAO,GAAG;AAAA,gBACxB;AACA,4BAAY,UAAU,KAAK;AAAA,cAC/B;AACA,6BAAe;AACf,kBAAI,OAAO,GAAG;AACV,sBAAM,MAAM,uCAAuC;AAAA,cACvD;AACA,kBAAI,QAAQ,KAAK;AACb,sBAAM,MAAM,uBAAuB,MAAM,UAAU;AAAA,cACvD;AACA;AACA,mBAAK,QAAQ;AAAA,YACjB;AACA,mBAAO,QAAQ,CAAC;AAChB,aAAC,KAAK,QAAQ,KAAK,SAAS,CAAC,GAAG,KAAK,IAAI;AAAA,UAC7C,WACS,QAAQ,KAAK;AAClB;AACA,gBAAI,aAAa,SAAS;AAC1B,gBAAIC,UAAS;AAAA,cACT,MAAM;AAAA,YACV;AAEA,gBAAI,QAAQ,KAAK;AACb;AACA,kBAAI,QAAQ;AACZ,6BAAe;AACf,kBAAI,QAAQ,UAAU,MAAM,YAAY;AACpC,gBAAAA,QAAO,YAAY;AACnB,wBAAQ,cAAc;AAAA,cAC1B,OACK;AACD,gBAAAA,QAAO,YAAY,QAAQ,UAAU,KAAK;AAE1C,oBAAI,QAAQ,KAAK;AACb,0BAAQ,OAAO,KAAK,QAAQ,uBAAuB;AAAA,gBAEvD,WACS,QAAQ,KAAM;AACnB,0BAAQ,OAAO,KAAM,QAAQ,sBAAsB;AAAA,gBAEvD,WACS,sBAAsB,QAAQ,KAAK;AACxC;AACA,0BAAQ,SAAS;AACjB,kBAAAA,QAAO,YAAY;AAAA,gBACvB,OACK;AACD,yBAAO,MAAM,GAAG;AACZ,wBAAI,QAAQ,KAAK;AACb;AAAA,oBACJ;AACA,6BAAS;AACT;AACA,0BAAM,IAAI,OAAO,GAAG;AAAA,kBACxB;AACA,0BAAQ,MAAM,KAAK;AAAA,gBACvB;AACA,+BAAe;AAAA,cACnB;AACA,kBAAI,OAAO,GAAG;AACV,sBAAM,MAAM,uCAAuC;AAAA,cACvD;AACA,kBAAI,QAAQ,KAAK;AACb,sBAAM,MAAM,uBAAuB,MAAM,UAAU;AAAA,cACvD;AACA;AACA,cAAAA,QAAO,QAAQ;AAAA,YACnB;AACA,mBAAO,QAAQ,CAAC;AAChB,aAAC,KAAK,UAAU,KAAK,WAAW,CAAC,GAAG,KAAKA,OAAM;AAAA,UACnD,OACK;AACD;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AACA,aAAOD,OAAM;AAAA,IACjB;AACA,YAAQ,mBAAmB;AAAA;AAAA;;;ACxU3B;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,QAAI,UAAU;AACd,aAAS,aAAa,QAAQ;AAC1B,UAAI,MAAM;AACV,cAAQ,OAAO,MAAM;AAAA,QACjB,KAAK;AACD,cAAI,gBAAgB,OAAO;AAC3B,cAAI,QAAQ,CAAC;AACb,iBAAO,eAAe;AAClB,gBAAI,cAAc,iBAAiB;AAC/B,oBAAM,KAAK,cAAc,eAAe;AAAA,YAC5C;AACA,kBAAM,KAAK,aAAa,aAAa,CAAC;AACtC,4BAAgB,cAAc;AAAA,UAClC;AACA,gBAAM,MAAM,KAAK,GAAG;AACpB;AAAA,QACJ,KAAK;AACD,gBAAM,OAAO,UAAU,IAAI,YAAY,EAAE,KAAK,IAAI;AAClD;AAAA,QACJ,KAAK;AACD,cAAI,OAAO,SAAS;AAChB,gBAAI,OAAO,YAAY,KAAK;AACxB,oBAAM;AAAA,YACV,OACK;AACD,oBAAM,QAAQ,iBAAiB,OAAO,OAAO;AAAA,YACjD;AAAA,UACJ;AACA,cAAI,OAAO,IAAI;AACX,mBAAO,MAAM,QAAQ,iBAAiB,OAAO,EAAE;AAAA,UACnD;AACA,cAAI,OAAO,YAAY;AACnB,mBAAO,OAAO,WAAW,IAAI,SAAU,IAAI;AACvC,qBAAO,MAAO,QAAQ,iBAAiB,EAAE;AAAA,YAC7C,CAAC,EAAE,KAAK,EAAE;AAAA,UACd;AACA,cAAI,OAAO,OAAO;AACd,mBAAO,OAAO,MAAM,IAAI,SAAU,MAAM;AACpC,kBAAI,cAAc,MAAM;AACpB,oBAAI,KAAK,cAAc,cAAc;AACjC,yBAAO,MAAM,QAAQ,iBAAiB,KAAK,IAAI,IAAI,KAAK,WAAW,MAAM,KAAK,QAAQ;AAAA,gBAC1F,OACK;AACD,yBAAO,MAAM,QAAQ,iBAAiB,KAAK,IAAI,IAAI,KAAK,WAAW,QAAQ,UAAU,KAAK,KAAK,IAAI;AAAA,gBACvG;AAAA,cACJ,OACK;AACD,uBAAO,MAAM,QAAQ,iBAAiB,KAAK,IAAI,IAAI;AAAA,cACvD;AAAA,YACJ,CAAC,EAAE,KAAK,EAAE;AAAA,UACd;AACA,cAAI,OAAO,SAAS;AAChB,mBAAO,OAAO,QAAQ,IAAI,SAAUE,SAAQ;AACxC,kBAAIA,QAAO,WAAW;AAClB,oBAAIA,QAAO,cAAc,YAAY;AACjC,yBAAO,MAAM,QAAQ,iBAAiBA,QAAO,IAAI,IAAI,MAAM,aAAaA,QAAO,KAAK,IAAI;AAAA,gBAC5F,WACSA,QAAO,cAAc,cAAc;AACxC,yBAAO,MAAM,QAAQ,iBAAiBA,QAAO,IAAI,IAAI,OAAOA,QAAO,QAAQ;AAAA,gBAC/E,WACSA,QAAO,cAAc,WAAW;AACrC,yBAAO,MAAM,QAAQ,iBAAiBA,QAAO,IAAI,IAAI,MAAMA,QAAO,QAAQ;AAAA,gBAC9E,OACK;AACD,yBAAQ,MAAM,QAAQ,iBAAiBA,QAAO,IAAI,IAC9C,MAAM,QAAQ,iBAAiBA,QAAO,KAAK,IAAI;AAAA,gBACvD;AAAA,cACJ,OACK;AACD,uBAAO,MAAM,QAAQ,iBAAiBA,QAAO,IAAI;AAAA,cACrD;AAAA,YACJ,CAAC,EAAE,KAAK,EAAE;AAAA,UACd;AACA;AAAA,QACJ;AACI,gBAAM,MAAM,2BAA2B,OAAO,OAAO,IAAI;AAAA,MACjE;AACA,aAAO;AAAA,IACX;AACA,YAAQ,eAAe;AAAA;AAAA;;;ACjFvB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,QAAI,mBAAmB;AACvB,QAAI,WAAW;AACf,QAAIC;AAAA;AAAA,MAAmC,WAAY;AAC/C,iBAASA,qBAAoB;AACzB,eAAK,UAAU,CAAC;AAChB,eAAK,mBAAmB,CAAC;AACzB,eAAK,uBAAuB,CAAC;AAC7B,eAAK,qBAAqB;AAAA,QAC9B;AACA,QAAAA,mBAAkB,UAAU,0BAA0B,WAAY;AAC9D,cAAI,UAAU,CAAC;AACf,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,oBAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,UAC9B;AACA,mBAAS,KAAK,GAAG,YAAY,SAAS,KAAK,UAAU,QAAQ,MAAM;AAC/D,gBAAIC,UAAS,UAAU,EAAE;AACzB,iBAAK,QAAQA,OAAM,IAAI;AAAA,UAC3B;AACA,iBAAO;AAAA,QACX;AACA,QAAAD,mBAAkB,UAAU,4BAA4B,WAAY;AAChE,cAAI,UAAU,CAAC;AACf,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,oBAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,UAC9B;AACA,mBAAS,KAAK,GAAG,YAAY,SAAS,KAAK,UAAU,QAAQ,MAAM;AAC/D,gBAAIC,UAAS,UAAU,EAAE;AACzB,mBAAO,KAAK,QAAQA,OAAM;AAAA,UAC9B;AACA,iBAAO;AAAA,QACX;AACA,QAAAD,mBAAkB,UAAU,yBAAyB,WAAY;AAC7D,cAAI,UAAU,CAAC;AACf,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,oBAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,UAC9B;AACA,mBAAS,KAAK,GAAG,YAAY,SAAS,KAAK,UAAU,QAAQ,MAAM;AAC/D,gBAAIC,UAAS,UAAU,EAAE;AACzB,iBAAK,QAAQA,OAAM,IAAI;AAAA,UAC3B;AACA,iBAAO;AAAA,QACX;AACA,QAAAD,mBAAkB,UAAU,2BAA2B,WAAY;AAC/D,cAAI,UAAU,CAAC;AACf,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,oBAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,UAC9B;AACA,mBAAS,KAAK,GAAG,YAAY,SAAS,KAAK,UAAU,QAAQ,MAAM;AAC/D,gBAAIC,UAAS,UAAU,EAAE;AACzB,mBAAO,KAAK,QAAQA,OAAM;AAAA,UAC9B;AACA,iBAAO;AAAA,QACX;AACA,QAAAD,mBAAkB,UAAU,2BAA2B,WAAY;AAC/D,cAAI,YAAY,CAAC;AACjB,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,sBAAU,EAAE,IAAI,UAAU,EAAE;AAAA,UAChC;AACA,mBAAS,KAAK,GAAG,cAAc,WAAW,KAAK,YAAY,QAAQ,MAAM;AACrE,gBAAI,WAAW,YAAY,EAAE;AAC7B,iBAAK,qBAAqB,QAAQ,IAAI;AAAA,UAC1C;AACA,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,6BAA6B,WAAY;AACjE,cAAI,YAAY,CAAC;AACjB,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,sBAAU,EAAE,IAAI,UAAU,EAAE;AAAA,UAChC;AACA,mBAAS,KAAK,GAAG,cAAc,WAAW,KAAK,YAAY,QAAQ,MAAM;AACrE,gBAAI,WAAW,YAAY,EAAE;AAC7B,mBAAO,KAAK,qBAAqB,QAAQ;AAAA,UAC7C;AACA,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,2BAA2B,WAAY;AAC/D,cAAI,OAAO,CAAC;AACZ,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,iBAAK,EAAE,IAAI,UAAU,EAAE;AAAA,UAC3B;AACA,mBAAS,KAAK,GAAG,SAAS,MAAM,KAAK,OAAO,QAAQ,MAAM;AACtD,gBAAI,MAAM,OAAO,EAAE;AACnB,iBAAK,iBAAiB,GAAG,IAAI;AAAA,UACjC;AACA,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,6BAA6B,WAAY;AACjE,cAAI,OAAO,CAAC;AACZ,mBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,iBAAK,EAAE,IAAI,UAAU,EAAE;AAAA,UAC3B;AACA,mBAAS,KAAK,GAAG,SAAS,MAAM,KAAK,OAAO,QAAQ,MAAM;AACtD,gBAAI,MAAM,OAAO,EAAE;AACnB,mBAAO,KAAK,iBAAiB,GAAG;AAAA,UACpC;AACA,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,oBAAoB,WAAY;AACxD,eAAK,qBAAqB;AAC1B,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,qBAAqB,WAAY;AACzD,eAAK,qBAAqB;AAC1B,iBAAO;AAAA,QACX;AACA,QAAAA,mBAAkB,UAAU,QAAQ,SAAU,KAAK;AAC/C,iBAAO,iBAAiB,iBAAiB,KAAK,GAAG,KAAK,SAAS,KAAK,kBAAkB,KAAK,sBAAsB,KAAK,kBAAkB;AAAA,QAC5I;AACA,QAAAA,mBAAkB,UAAU,SAAS,SAAU,MAAM;AACjD,iBAAO,SAAS,aAAa,IAAI,EAAE,KAAK;AAAA,QAC5C;AACA,eAAOA;AAAA,MACX,EAAE;AAAA;AACF,YAAQ,oBAAoBA;AAAA;AAAA;;;AClHrB,IAAI,SAAS,WAAS,OAAO,gBAAgB,IAAI,WAAW,KAAK,CAAC;AAClE,IAAI,eAAe,CAAC,UAAU,aAAa,cAAc;AAC9D,MAAI,QAAQ,KAAM,KAAK,IAAI,SAAS,SAAS,CAAC,IAAI,KAAK,OAAQ;AAC/D,MAAI,OAAO,CAAC,EAAG,MAAM,OAAO,cAAe,SAAS;AACpD,SAAO,CAAC,OAAO,gBAAgB;AAC7B,QAAI,KAAK;AACT,WAAO,MAAM;AACX,UAAI,QAAQ,UAAU,IAAI;AAC1B,UAAI,IAAI;AACR,aAAO,KAAK;AACV,cAAM,SAAS,MAAM,CAAC,IAAI,IAAI,KAAK;AACnC,YAAI,GAAG,WAAW;AAAM,iBAAO;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AACF;AACO,IAAI,iBAAiB,CAAC,UAAU,OAAO,OAC5C,aAAa,UAAU,MAAM,MAAM;AAC9B,IAAI,SAAS,CAAC,OAAO,OAC1B,OAAO,gBAAgB,IAAI,WAAW,IAAI,CAAC,EAAE,OAAO,CAAC,IAAI,SAAS;AAChE,UAAQ;AACR,MAAI,OAAO,IAAI;AACb,UAAM,KAAK,SAAS,EAAE;AAAA,EACxB,WAAW,OAAO,IAAI;AACpB,WAAO,OAAO,IAAI,SAAS,EAAE,EAAE,YAAY;AAAA,EAC7C,WAAW,OAAO,IAAI;AACpB,UAAM;AAAA,EACR,OAAO;AACL,UAAM;AAAA,EACR;AACA,SAAO;AACT,GAAG,EAAE;;;AC/BP,SAAS,eAAe,SAAS,MAAM;AACnC,MAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD,YAAQ,OAAO,KAAK;AACxB,MAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD,YAAQ,MAAM,KAAK;AACvB,MAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD,YAAQ,SAAS,KAAK;AAC1B,MAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD,YAAQ,QAAQ;AACpB,SAAO;AACX;AACO,SAAS,UAAU,MAAM,SAAS,MAAM;AAC3C,SAAO,eAAe,KAAK,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,MAAM,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,MAAM,GAAG,EAAE,GAAG,MAAM,OAAO,KAAK,CAAC;AACzL;AACO,SAAS,SAAS,MAAM,SAAS,MAAM;AAC1C,SAAO,eAAe,KAAK,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,MAAM,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,MAAM,GAAG,IAAI;AACrK;AAIA,IAAM,KAAK;AACX,IAAM,QAAQ,KAAK,GAAG,YAAY;AAClC,IAAM,UAAU;AAChB,IAAM,WAAW,eAAe,OAAO,CAAC;AACxC,IAAM,YAAY,eAAe,QAAQ,SAAS,CAAC;AAC5C,SAAS,WAAW;AACvB,SAAO,SAAS,IAAI,UAAU;AAClC;AAQO,SAAS,eAAe,OAAO;AAClC,MAAI,CAAC;AACD,WAAO;AACX,QAAM,aAAa,MACd,QAAQ,eAAe,GAAG,EAC1B,QAAQ,cAAc,EAAE,EACxB,KAAK,EACL,YAAY;AACjB,QAAM,UAAU,aAAa,UAAU;AACvC,SAAO,EAAE,YAAY,OAAc,QAAQ;AAC/C;AACO,SAAS,aAAa,YAAY;AACrC,MAAI,CAAC;AACD,WAAO;AACX,SAAO,WACF,YAAY,EACZ,QAAQ,eAAe,GAAG,EAC1B,QAAQ,aAAa,OAAO,EAC5B,QAAQ,UAAU,GAAG,EACrB,QAAQ,wBAAwB,EAAE;AAC3C;AAIA,SAAS,wBAAwB,MAAM,YAAY;AAC/C,MAAI,CAAC,KAAK;AACN,WAAO,CAAC,IAAI;AAChB,QAAM,WAAW,KAAK,SAAS,IAAI,CAAC,UAAU,wBAAwB,OAAO,UAAU,CAAC,EAAE,KAAK;AAC/F,MAAI,KAAK,SAAS,YAAY;AAG1B,QAAI,QAAQ,KAAK,YAAY;AACzB,aAAO,KAAK;AAChB,WAAO;AAAA,EACX;AACA,OAAK,WAAW;AAChB,SAAO,CAAC,IAAI;AAChB;AAQO,SAAS,aAAa,MAAM,YAAY;AAC3C,MAAI,CAAC,KAAK;AACN;AACJ,OAAK,WAAW,KAAK,SAAS,IAAI,CAAC,UAAU,wBAAwB,OAAO,UAAU,CAAC,EAAE,KAAK;AAClG;AACO,SAAS,eAAe,MAAM,MAAM;AACvC,OAAK,WAAW,CAAC,EAAE,MAAM,QAAQ,OAAO,KAAK,CAAC;AAClD;AAQO,SAAS,OAAO,SAAS;AAC5B,MAAI,CAAC;AACD,WAAO;AACX,MAAI,CAAC,MAAM,QAAQ,OAAO;AACtB,WAAO,OAAO,CAAC,OAAO,CAAC;AAC3B,SAAO,QACF,IAAI,CAAC,MAAM;AACZ,QAAI,CAAC,KAAK,OAAO,MAAM;AACnB,aAAO,KAAK;AAChB,QAAI,WAAW;AACX,aAAO,EAAE;AACb,QAAI,cAAc,KAAK,EAAE;AACrB,aAAO,OAAO,EAAE,QAAQ;AAC5B,WAAO;AAAA,EACX,CAAC,EACI,KAAK,EAAE;AAChB;AACO,SAAS,SAAS,MAAM;AAC3B,SAAO,gBAAgB,IAAI;AAC/B;AA6BO,SAAS,sBAAsB,MAAM;AACxC,QAAM,YAAY;AAAA,IACd,WAAW;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,WAAW;AAAA,IACX,MAAM;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,IACT,KAAK;AAAA,IACL,SAAS;AAAA,EACb;AACA,SAAO,UAAU,IAAI,KAAK,uBAAuB;AACrD;AACO,SAAS,wBAAwB,OAAO,UAAU,eAAe;AACpE,MAAI,CAAC,aAAa,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,YAAY;AACvF,WAAO;AACX,QAAM,OAAO,gBAAgB,MAAM,SAAS,KAAK;AACjD,QAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,GAAG,GAAG,GAAG;AAC3C,QAAM,MAAM,GAAG,OAAO,KAAK,MAAM,GAAG,GAAG,GAAG;AAC1C,QAAM,aAAa,GAAG,UAAU,UAAU;AAAA;AAC1C,SAAO,GAAG,aAAa,SAAS,KAAK,IAAI;AAAA;AAC7C;AACO,SAAS,gBAAgB,MAAM;AAClC,MAAI;AACJ,MAAI,CAAC,KAAK;AACN,WAAO,CAAC;AACZ,QAAM,QAAQ,KAAK,KAAK,KAAK,UAAU,QAAQ,OAAO,SAAS,KAAK,CAAC;AACrE,SAAO,QAAQ,KAAK,IAAI,EAAE,QAAQ,CAAC,CAAC,KAAK,GAAG,MAAM;AAC9C,QAAI,QAAQ,QAAS,OAAO,QAAQ,YAAY,IAAI,YAAY,MAAM,QAAS;AAC3E,WAAK,KAAK,GAAG;AAAA,IACjB;AAAA,EACJ,CAAC;AACD,SAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,YAAY,CAAC;AAC9C;;;AClIA,IAAM,MAAM,CAAC,EAAE;AAcR,SAAS,OAAO,KAAK,SAAS;AACnC,QAAM,WAAW,WAAW,CAAC;AA8B7B,WAASE,KAAI,UAAU,YAAY;AAEjC,QAAI,KAAKA,KAAI;AACb,UAAM,WAAWA,KAAI;AAErB,QAAI,SAAS,IAAI,KAAK,OAAO,GAAG,GAAG;AAEjC,YAAM,KAAK,OAAO,MAAM,GAAG,CAAC;AAE5B,WAAK,IAAI,KAAK,UAAU,EAAE,IAAI,SAAS,EAAE,IAAIA,KAAI;AAAA,IACnD;AAEA,QAAI,IAAI;AACN,aAAO,GAAG,KAAK,MAAM,OAAO,GAAG,UAAU;AAAA,IAC3C;AAAA,EACF;AAEA,EAAAA,KAAI,WAAW,SAAS,YAAY,CAAC;AACrC,EAAAA,KAAI,UAAU,SAAS;AACvB,EAAAA,KAAI,UAAU,SAAS;AAGvB,SAAOA;AACT;;;AC5GA,IAAM,SAAS,OAAO,YAAY;AAAA,EAChC,SAAS;AAAA;AAAA,EAET,SAAS;AAAA,EACT,UAAU;AAAA,IACR,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AACF,CAAC;AAOM,SAAS,UAAU,OAAO,MAAM;AACrC,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,MAAM,MAAM,QAAQ;AACnC,QAAI,CAAC,OAAO,MAAM,MAAM,KAAK,GAAG,IAAI;AAAG,aAAO;AAAA,EAChD;AAEA,SAAO;AACT;AAWA,SAAS,OAAO,OAAO,MAAM;AAE3B,SAAO,KAAK,MAAM,IAAI,MAAM,QAAQ,KAAK,MAAM,IAAI,MAAM;AAC3D;AAWA,SAAS,MAAM,OAAO,MAAM;AAE1B,SAAO,OAAO,OAAO,IAAI,KAAK,OAAO,KAAK,MAAM,IAAI,CAAC,MAAM,MAAM;AACnE;AAcA,SAAS,cAAc,OAAO,MAAM;AAGlC,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,MAAI,UAAU,QAAQ,UAAU;AAAW,WAAO;AAMlD,MAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,MAAM,KAAK,GAAG;AACvD,WAAO;AAAA,EACT;AAGA,SAAO,OAAO,KAAK,MAAM,MAAM;AACjC;AAWA,SAAS,OAAO,OAAO,MAAM;AAG3B,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,SAAO;AAAA,IACL,MAAM,SACJ,OAAO,UAAU,YACjB,MAAM,MAAM,GAAG,MAAM,MAAM,MAAM,MAAM,MAAM;AAAA,EACjD;AACF;AAWA,SAAS,KAAK,OAAO,MAAM;AAGzB,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,SAAO;AAAA,IACL,MAAM,SACJ,OAAO,UAAU,YACjB,MAAM,MAAM,CAAC,MAAM,MAAM,MAAM,MAAM,MAAM;AAAA,EAC/C;AACF;AAWA,SAAS,eAAe,OAAO,MAAM;AAGnC,QAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,SAAO;AAAA,IACL,MAAM,SAAS,OAAO,UAAU,YAAY,MAAM,SAAS,MAAM,KAAK;AAAA,EACxE;AACF;AAQA,SAAS,gBAAgB,OAAO;AAE9B,QAAM,IAAI,MAAM,uBAAuB,MAAM,WAAW,GAAG;AAC7D;;;AC1JO,SAAS,KAAK,OAAO,MAAM;AAChC,SAAO,MAAM,YAAY,OAAO,MAAM,YAAY,KAAK;AACzD;;;ACVA,IAAM,aAAa,oBAAI,IAAI,CAAC,GAAG,IAAI,IAAI,IAAI,EAAE,CAAC;AAC9C,IAAM,OAAO,IAAI,WAAW,CAAC;AAC7B,IAAM,OAAO,IAAI,WAAW,CAAC;AASvB,SAAU,MAAM,SAAe;AACjC,YAAU,QAAQ,KAAI,EAAG,YAAW;AAEpC,MAAI,YAAY,QAAQ;AACpB,WAAO,CAAC,GAAG,CAAC;aACL,YAAY,OAAO;AAC1B,WAAO,CAAC,GAAG,CAAC;;AAKhB,MAAI,MAAM;AAEV,MAAI,IAAI;AACR,MAAI,OAAO,SAAQ;AACnB,MAAI,SAAS,WAAU;AAEvB,MAAI,MAAM,QAAQ,UAAU,QAAQ,OAAO,GAAG,MAAM,KAAK;AACrD;AACA,QAAI,QAAQ,WAAM,QAAN,WAAM,SAAN,SAAU;AAEtB,mBAAc;AAEd,QAAI,MAAM,QAAQ,QAAQ;AACtB,aAAO,SAAQ;AACf,qBAAc;AACd,eAAS,WAAU;WAChB;AACH,aAAO,SAAS;;;AAKxB,MAAI,WAAW,QAAQ,MAAM,QAAQ,QAAQ;AACzC,UAAM,IAAI,MAAM,kCAAkC,WAAW;;AAGjE,SAAO,CAAC,GAAG,OAAO,MAAM;AAExB,WAAS,WAAQ;AACb,QAAI,QAAQ,OAAO,GAAG,MAAM,KAAK;AAC7B;AACA,aAAO;;AAGX,QAAI,QAAQ,OAAO,GAAG,MAAM,KAAK;AAC7B;;AAGJ,WAAO;EACX;AAEA,WAAS,aAAU;AACf,UAAM,QAAQ;AACd,QAAI,QAAQ;AAEZ,WACI,MAAM,QAAQ,UACd,QAAQ,WAAW,GAAG,KAAK,QAC3B,QAAQ,WAAW,GAAG,KAAK,MAC7B;AACE,cAAQ,QAAQ,MAAM,QAAQ,WAAW,GAAG,IAAI;AAChD;;AAIJ,WAAO,QAAQ,QAAQ,OAAO;EAClC;AAEA,WAAS,iBAAc;AACnB,WACI,MAAM,QAAQ,UACd,WAAW,IAAI,QAAQ,WAAW,GAAG,CAAC,GACxC;AACE;;EAER;AACJ;;;AC3FA,sBAAqB;AAsBf,SAAU,QACZ,QAA8B;AAE9B,QAAM,IAAI,OAAO,CAAC;AAElB,QAAM,IAAI,OAAO,CAAC,IAAI;AAStB,MAAI,IAAI,KAAK,KAAK;AAAG,WAAO,gBAAAC,QAAS;AAGrC,MAAI,MAAM;AAAI,WAAO,CAAC,UAAU,SAAS;AACzC,MAAI,MAAM;AAAG,WAAO,CAAC,UAAU,UAAU;AAEzC,MAAI,MAAM;AAAG,WAAO,IAAI,IAAI,gBAAAA,QAAS,WAAW,CAAC,UAAU,SAAS;AAOpE,QAAM,OAAO,KAAK,IAAI,CAAC;AAEvB,QAAM,QAAS,IAAI,OAAQ,QAAQ;AAEnC,SAAO,IAAI,IACL,CAAC,UAAU,SAAS,KAAK,QAAQ,SAAS,OAC1C,CAAC,UAAU,SAAS,KAAK,QAAQ,SAAS;AACpD;;;AC5Bc,SAAP,SAA0B,SAAe;AAC5C,SAAO,QAAQ,MAAM,OAAO,CAAC;AACjC;;;ACrBO,SAAS,OAAO,MAAM;AAE3B,SAAO,MAAM,QAAQ,KAAK,QAAQ;AACpC;;;ACIA,IAAMC,YAAW,SAAgB,WAAW;AAG5C,IAAMC,UAAS,OAAO,QAAQ;AAAA,EAC5B,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,IACR,KAAK;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA,eAAe;AAAA,IACf,iBAAiB;AAAA,IACjB;AAAA,IACA,cAAc;AAAA,IACd,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,IACA,aAAa;AAAA,IACb,kBAAkB;AAAA,IAClB,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,cAAc;AAAA,IACd,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,EACF;AACF,CAAC;AAED,OAAO,aAAa;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAYO,SAAS,OAAO,OAAO,MAAM,OAAOC,SAAQ,OAAO;AACxD,QAAM,UAAU,MAAM;AACtB,MAAI,SAAS;AAEb,SAAO,EAAE,SAAS,QAAQ,QAAQ;AAChC,QAAI,CAACD,QAAO,QAAQ,MAAM,GAAG,MAAM,OAAOC,SAAQ,KAAK;AAAG,aAAO;AAAA,EACnE;AAEA,SAAO;AACT;AASA,SAAS,MAAM,IAAI,MAAM;AACvB,SAAO,OAAO,IAAI,IAAI,KAAK,SAAS,WAAW,IAAI,EAAE,WAAW;AAClE;AAYA,SAAS,WAAW,OAAO,IAAI,IAAI,IAAI,OAAO;AAC5C,aAAW,OAAO,KAAK;AACvB,SAAO,MAAM,cAAc;AAC7B;AAYA,SAAS,YAAY,OAAO,IAAI,IAAI,IAAI,OAAO;AAC7C,aAAW,OAAO,KAAK;AACvB,SAAO,MAAM,cAAc;AAC7B;AAUA,SAAS,IAAI,OAAO,MAAM,IAAI,IAAI,OAAO;AACvC,QAAM,WAAW,EAAC,MAAM,QAAQ,UAAU,OAAO,IAAI,IAAI,KAAK,WAAW,CAAC,EAAC;AAE3E,QAAM,aAAa;AAAA,IACjB,GAAG;AAAA;AAAA,IAEH,OAAO;AAAA;AAAA,IAEP,SAAS;AAAA;AAAA,IAET,KAAK;AAAA,IACL,YAAY,CAAC,IAAI;AAAA,IACjB,SAAS,CAAC;AAAA,IACV,WAAW,iBAAiB,MAAM,KAAK;AAAA,EACzC;AAEA,OAAK,YAAY,QAAQ;AAEzB,SAAO,WAAW,QAAQ,SAAS;AACrC;AAYA,SAAS,UAAU,OAAO,IAAI,IAAI,IAAI,OAAO;AAC3C,aAAW,OAAO,KAAK;AACvB,SACE,OAAO,MAAM,cAAc,YAC3B,MAAM,cAAc,MAAM,YAAY;AAE1C;AAYA,SAAS,WAAW,OAAO,IAAI,IAAI,IAAI,OAAO;AAC5C,aAAW,OAAO,KAAK;AACvB,SACE,OAAO,MAAM,cAAc,YAC3B,MAAM,cAAc,MAAM,YAAY;AAE1C;AAYA,SAAS,QAAQ,OAAO,MAAM,IAAI,IAAI,OAAO;AAE3C,QAAM,aAAa;AAAA,IACjB,GAAG;AAAA;AAAA,IAEH,OAAO;AAAA;AAAA,IAEP,SAAS;AAAA;AAAA,IAET,KAAK;AAAA,IACL,YAAY,CAAC,IAAI;AAAA,IACjB,SAAS,CAAC;AAAA,IACV,WAAW,iBAAiB,MAAM,KAAK;AAAA,EACzC;AAEA,OAAK,YAAY,IAAI;AAErB,SAAO,WAAW,QAAQ,CAAC,MAAM;AACnC;AAYA,SAAS,IAAI,OAAO,MAAM,OAAOA,SAAQ,OAAO;AAC9C,SAAO,CAAC,QAAQ,OAAO,MAAM,OAAOA,SAAQ,KAAK;AACnD;AAYA,SAAS,SAAS,OAAO,IAAI,IAAI,IAAI,OAAO;AAC1C,QAAM,KAAK,kBAAkB,KAAK;AAClC,aAAW,OAAO,KAAK;AACvB,SAAO,OAAO,MAAM,cAAc,YAAY,GAAG,MAAM,SAAS;AAClE;AAYA,SAAS,aAAa,OAAO,IAAI,IAAI,IAAI,OAAO;AAC9C,QAAM,KAAK,kBAAkB,KAAK;AAClC,aAAW,OAAO,KAAK;AACvB,SACE,OAAO,MAAM,cAAc,YAC3B,OAAO,MAAM,cAAc,YAC3B,GAAG,MAAM,YAAY,MAAM,YAAY,CAAC;AAE5C;AAYA,SAAS,cAAc,OAAO,IAAI,IAAI,IAAI,OAAO;AAC/C,QAAM,KAAK,kBAAkB,KAAK;AAClC,aAAW,OAAO,KAAK;AACvB,SACE,OAAO,MAAM,cAAc,YAC3B,OAAO,MAAM,cAAc,YAC3B,GAAG,MAAM,YAAY,IAAI,MAAM,SAAS;AAE5C;AAYA,SAAS,UAAU,OAAO,IAAI,IAAI,IAAI,OAAO;AAC3C,QAAM,KAAK,kBAAkB,KAAK;AAClC,aAAW,OAAO,KAAK;AACvB,SAAO,OAAO,MAAM,cAAc,YAAY,GAAG,MAAM,SAAS;AAClE;AAYA,SAAS,UAAU,OAAO,IAAI,IAAI,IAAI,OAAO;AAC3C,aAAW,OAAO,KAAK;AACvB,SAAO,MAAM,cAAc;AAC7B;AAYA,SAAS,WAAW,OAAO,IAAI,IAAI,IAAI,OAAO;AAC5C,aAAW,OAAO,KAAK;AACvB,SAAO,MAAM,cAAc;AAC7B;AAWA,SAAS,KAAK,IAAI,MAAM,IAAIA,SAAQ;AAClC,SAAO,QAAQ,CAACA;AAClB;AAYA,SAAS,MAAM,IAAI,MAAM,IAAI,IAAI,OAAO;AACtC,SAAO,QAAQ,MAAM,WAAW,SAAS,IAAI;AAC/C;AAIA,SAAS,gBAAgB;AACvB,QAAM,IAAI,MAAM,yBAAyB;AAC3C;AAMA,SAAS,cAAc,OAAO;AAE5B,MAAI,MAAM,MAAM;AAEd,UAAM,IAAI,MAAM,8BAA8B,MAAM,OAAO,GAAG;AAAA,EAChE;AAEA,QAAM,IAAI,MAAM,iDAAiD;AACnE;AAMA,SAAS,WAAW,OAAO,OAAO;AAChC,MAAI,MAAM,SAAS;AACjB,UAAM,IAAI,MAAM,kBAAkB,MAAM,OAAO,kBAAkB;AAAA,EACnE;AACF;AAMA,SAAS,kBAAkB,OAAO;AAGhC,MAAI,KAAK,MAAM;AAEf,MAAI,CAAC,IAAI;AAEP,SAAKF,UAAS,MAAM,KAAK;AAEzB,UAAM,YAAY;AAAA,EACpB;AAEA,SAAO;AACT;;;ACpYO,SAAS,KAAK,OAAO,MAAM,OAAOG,SAAQ,OAAO;AACtD,MAAI,MAAM;AAAI,UAAM,IAAI,MAAM,sBAAsB;AACpD,MAAI,MAAM;AAAY,UAAM,IAAI,MAAM,yBAAyB;AAE/D,SAAO;AAAA,IACL,SACG,CAAC,MAAM,WAAW,KAAK,OAAO,IAAI,OAClC,CAAC,MAAM,SAAS,UAAU,OAAO,IAAI,OACrC,CAAC,MAAM,WAAW,OAAO,OAAO,MAAM,OAAOA,SAAQ,KAAK;AAAA,EAC/D;AACF;;;ACCA,IAAMC,SAAQ,CAAC;AAQR,SAAS,iBAAiB,OAAO;AACtC,MAAI,UAAU,MAAM;AAClB,WAAO,EAAC,MAAM,aAAa,WAAW,CAAC,EAAC;AAAA,EAC1C;AAEA,MAAI,MAAM,SAAS,WAAW;AAC5B,WAAO,EAAC,MAAM,aAAa,WAAW,CAAC,KAAK,EAAC;AAAA,EAC/C;AAEA,SAAO;AACT;AAQO,SAAS,KAAK,OAAO,MAAM;AAChC,MAAI,MAAM;AACR,QAAI,OAAO,CAAC,GAAG,MAAM,QAAW,MAAS;AAAA,EAC3C;AACF;AAYA,SAAS,IAAI,OAAO,cAAc,MAAM,OAAO,YAAY;AAEzD,MAAI,aAAa;AAAA,IACf,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,iBAAiB;AAAA,IACjB,gBAAgB;AAAA,EAClB;AAEA,eAAa;AAAA,IACX;AAAA;AAAA,IAEA,QAAQ,cAAc,MAAM,UAAU,SAAS;AAAA,IAC/C;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAIA,MAAI,OAAO,IAAI,KAAK,CAAC,MAAM,WAAW,EAAE,MAAM,OAAO,MAAM,QAAQ;AACjE,QAAI,OAAO,YAAY,IAAI;AAAA,EAC7B;AAEA,SAAO;AACT;AAUA,SAAS,IAAI,OAAO,MAAM,MAAM;AAC9B,QAAM,aAAa,QAAQ,KAAK,YAAY,KAAK,WAAW;AAE5D,MAAI;AACJ,MAAI,QAAQ;AAKZ,QAAM,QAAQ,EAAC,OAAO,GAAG,OAAO,oBAAI,IAAI,EAAC;AAKzC,QAAM,SAAS,EAAC,OAAO,GAAG,OAAO,oBAAI,IAAI,EAAC;AAE1C,SAAO,EAAE,QAAQ,KAAK,SAAS,QAAQ;AACrC,UAAM,OAAO,KAAK,SAAS,KAAK,CAAC;AAAA,EACnC;AAEA,UAAQ;AAER,SAAO,EAAE,QAAQ,KAAK,SAAS,QAAQ;AACrC,UAAM,QAAQ,KAAK,SAAS,KAAK;AAEjC,UAAMC,QAAO,MAAM,KAAK,YAAY;AAEpC,UAAM,YAAY,OAAO;AACzB,UAAM,YAAY,OAAO,MAAM,IAAIA,KAAI,KAAK;AAE5C,UAAM,YAAY,MAAM;AACxB,UAAM,YAAY,MAAM,MAAM,IAAIA,KAAI;AAGtC,UAAM,aAAa,QAAQ,YAAY,WAAW;AAClD,UAAMC,QAAO,IAAI,OAAO,YAAY,KAAK,SAAS,KAAK,GAAG,OAAO,IAAI;AACrE,kBAAc,QAAQA,MAAK,gBAAgBA,MAAK,eAAe;AAG/D,QAAI,MAAM,OAAO,MAAM,OAAO;AAC5B;AAAA,IACF;AAEA,UAAM,QAAQ,KAAK,SAAS,KAAK,CAAC;AAAA,EACpC;AACF;AAkBA,SAAS,eAAe,OAAO,OAAO,MAAM,OAAOC,SAAQ;AAEzD,QAAM,aAAa;AAAA,IACjB,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,iBAAiB;AAAA,IACjB,gBAAgB;AAAA,EAClB;AACA,MAAI,gBAAgB;AAEpB,SAAO,EAAE,gBAAgB,MAAM,QAAQ;AACrC,UAAM,UAAU,MAAM,aAAa;AAGnC,QAAI,MAAM,OAAO,MAAM,OAAO;AAC5B;AAAA,IACF;AAKA,QAAI,MAAM,WAAW,QAAQ,KAAK,MAAM;AACtC,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAGA,QAAI,KAAK,QAAQ,MAAM,MAAM,OAAOA,SAAQ,KAAK,GAAG;AAClD,YAAM,OAAO,QAAQ,KAAK;AAG1B,UAAI,MAAM;AAER,cAAM,OAAO,EAAC,MAAM,WAAW,MAAM,KAAI;AAEzC,cAAM,QACJ,KAAK,oBAAoB,MACrB,oBACA,KAAK,oBAAoB,MACzB,mBACA,KAAK,oBAAoB,MACzB,gBACA;AACN,YAAI,YAAY,OAAO,IAAI;AAAA,MAC7B,OAAO;AAEL,cAAM,QAAQ;AAEd,YAAI,CAAC,MAAM,QAAQ,SAAS,IAAI,GAAG;AACjC,gBAAM,QAAQ,KAAK,IAAI;AAAA,QACzB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,QAAQ,KAAK,oBAAoB,MAAM;AACzC,UAAI,YAAY,cAAc,OAAO;AAAA,IACvC,WAES,QAAQ,KAAK,oBAAoB,KAAK;AAC7C,UAAI,YAAY,kBAAkB,OAAO;AAAA,IAC3C;AAAA,EAEF;AAEA,SAAO;AACT;AAWA,SAAS,QAAQ,MAAM,OAAO;AAC5B,SAAO,QAAQ,SAAS,KAAK,SAAS,KAAK,MAAM,SAAS,IACtD,CAAC,GAAG,MAAM,GAAG,KAAK,IAClB,QAAQ,KAAK,SAAS,IACtB,OACA,SAAS,MAAM,SAAS,IACxB,QACAH;AACN;AASA,SAAS,IAAI,MAAM,OAAO,MAAM;AAC9B,QAAM,OAAO,KAAK,KAAK;AACvB,MAAI,MAAM;AACR,SAAK,KAAK,IAAI;AAAA,EAChB,OAAO;AACL,SAAK,KAAK,IAAI,CAAC,IAAI;AAAA,EACrB;AACF;AAYA,SAAS,MAAM,QAAQ,MAAM;AAG3B,QAAMC,QAAO,KAAK,KAAK,YAAY;AACnC,QAAMG,UAAS,OAAO,MAAM,IAAIH,KAAI,KAAK,KAAK;AAC9C,SAAO;AACP,SAAO,MAAM,IAAIA,OAAMG,MAAK;AAC9B;;;AC5RA,iCAAgC;AAEhC,IAAM,SAAS,IAAI,6CAAkB;AAErC,OAAO,yBAAyB,KAAK,KAAK,KAAK,GAAG;AAClD,OAAO,wBAAwB,OAAO,WAAW,OAAO,KAAK;AAC7D,OAAO,yBAAyB,KAAK,KAAK,GAAG;AAMtC,SAASC,OAAM,UAAU;AAC9B,MAAI,OAAO,aAAa,UAAU;AAChC,UAAM,IAAI,UAAU,yCAAyC,WAAW,GAAG;AAAA,EAC7E;AAEA,SAAO,OAAO,MAAM,QAAQ;AAC9B;;;ACGO,SAASC,SAAQ,UAAU,MAAM;AACtC,QAAM,QAAQ,YAAY,UAAU,IAAI;AACxC,QAAM,MAAM;AACZ,QAAM,UAAU;AAChB,OAAK,OAAO,QAAQ,MAAS;AAC7B,SAAO,MAAM,QAAQ,SAAS;AAChC;AAiBO,SAAS,OAAO,UAAU,MAAM;AACrC,QAAM,QAAQ,YAAY,UAAU,IAAI;AACxC,QAAM,MAAM;AACZ,OAAK,OAAO,QAAQ,MAAS;AAE7B,SAAO,MAAM,QAAQ,CAAC,KAAK;AAC7B;AAgBO,SAAS,UAAU,UAAU,MAAM;AACxC,QAAM,QAAQ,YAAY,UAAU,IAAI;AACxC,OAAK,OAAO,QAAQ,MAAS;AAC7B,SAAO,MAAM;AACf;AASA,SAAS,YAAY,UAAU,MAAM;AACnC,SAAO;AAAA;AAAA,IAEL,WAAW,iBAAiBC,OAAM,QAAQ,CAAC;AAAA,IAC3C,SAAS,CAAC;AAAA,IACV,YAAY,OACR,OAAO,IAAI;AAAA,KAEV,KAAK,SAAS,cAAc,KAAK,SAAS,UACzC,KAAK,WACL,CAAC,IAAI,IACP,CAAC;AAAA,IACL,KAAK;AAAA,IACL,SAAS;AAAA,IACT,OAAO;AAAA;AAAA,IAEP,WAAW;AAAA,IACX,WAAW;AAAA,IACX,WAAW;AAAA,IACX,WAAW;AAAA,EACb;AACF;;;AC1FA,IAAMC,SAAQ,CAAC;AAqBR,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcT,SAAU,MAAM,SAASC,OAAM;AAC7B,UAAM,KAAK,QAAQA,SAAQ,OAAO;AAClC,UAAM,UACJ,CAAC,WAAW,QAAQ,YAAY,UAAa,QAAQ,YAAY,OAC7D,OACA,QAAQ;AAEd,WAAO,SAAS,IAAI;AAWpB,aAAS,SAAS,MAAM,OAAOC,SAAQ;AAGrC,YAAM,WAAW,KAAK,YAAYF;AAClC,UAAI,aAAa;AACjB,UAAI,WAAW;AAEf,UAAI,GAAG,MAAM,OAAOE,OAAM,GAAG;AAC3B,eAAO;AAAA,MACT;AAEA,UAAI,SAAS,SAAS,GAAG;AAEvB,eAAO,EAAE,aAAa,SAAS,QAAQ;AAErC,cAAI,SAAS,SAAS,UAAU,GAAG,YAAY,IAAI,GAAG;AACpD,qBAAS,UAAU,IAAI,SAAS,UAAU;AAAA,UAC5C;AAAA,QACF;AAGA,YAAI,WAAW,CAAC,UAAU;AACxB,iBAAO;AAAA,QACT;AAGA,iBAAS,SAAS;AAAA,MACpB;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAAA;;;ACnGG,IAAM,wBAAwB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,sBAAsB;AAAA,EAC/B,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,aAAa;AAAA,EACb,aAAa;AAAA,EACb,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,SAAS;AAAA,EACT,MAAM;AAAA,EACN,KAAK;AAAA,EACL,kBAAkB;AAAA,EAClB,gBAAgB;AAAA,EAChB,iBAAiB;AAAA,EACjB,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,qBAAqB;AAAA,EACrB,OAAO;AAAA,EACP,wBAAwB;AAAA,EACxB,0BAA0B;AAAA,EAC1B,sBAAsB;AAAA,EACtB,aAAa;AAAA,EACb,eAAe;AAAA,EACf,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,OAAO;AACX;;;AC7CA,SAAS,WAAW,MAAM;AACtB,MAAI,CAAC,MAAM;AAEP,WAAO,CAAC;AAAA,EACZ;AACA,MAAI,OAAO,SAAS;AAChB,WAAO,WAAW,CAAC,IAAI,CAAC;AAC5B,QAAM,QAAQ,CAAC;AACf,OACK,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,EAC1B,QAAQ,CAAC,MAAM;AAChB,UAAM,KAAK,CAAC;AACZ,WAAO,QAAQ,mBAAmB,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC5D,UAAI,MAAM,SAAS,MAAM,OAAO;AAC5B,YAAI,CAAC,MAAM,SAAS,KAAK;AACrB,gBAAM,QAAQ,KAAK;AACvB,YAAI,CAAC,MAAM,SAAS,KAAK;AACrB,gBAAM,KAAK,KAAK;AAAA,MACxB;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACD,SAAO;AACX;AAKO,SAAS,iBAAiB,MAAM,MAAM;AACzC,QAAM,QAAQ,WAAW,IAAI;AAC7B,MAAI,MAAM,WAAW;AACjB,WAAO,CAAC;AACZ,QAAM,aAAa,UAAU,SAAS,IAAI,EAAE,OAAO,CAAC,UAAU;AAC1D,QAAI,IAAI,IAAI;AACZ,UAAM,eAAe,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS,MAAM,QAAQ,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,IAAI,YAAY,CAAC;AACtN,UAAM,aAAa,MAAM,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,YAAY;AAC5I,WAAO,MACF,IAAI,CAAC,MAAM,cAAc,KAAK,UAAU,SAAS,CAAC,CAAC,EACnD,OAAO,CAAC,GAAG,MAAM,KAAK,GAAG,KAAK;AAAA,EACvC,CAAC;AACD,SAAO;AACX;AACA,SAAS,gBAAgB,UAAU,MAAM,MAAM;AAC3C,MAAI;AACJ,QAAM,QAAQ,EAAE,MAAM,SAAS,SAAS;AACxC,MAAI,EAAE,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,iBAAiB;AACpE,KAAC,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,KAAM,MAAM,OAAO,CAAC;AAClE,UAAM,KAAK,OAAO;AAAA,EACtB;AACA,SAAO;AACX;AACA,SAAS,aAAa,MAAMC,OAAM;AAC9B,MAAI,UAAU,OAAO,MAAMA,KAAI;AAC/B,MAAI,CAAC,SAAS;AACV,cAAU,OAAO,MAAM,EAAE,SAAS,MAAM,GAAGA,KAAI;AAAA,EACnD;AACA,SAAO;AACX;AAWO,SAAS,oBAAoB,MAAM,MAAM,MAAM;AAClD,MAAI;AACJ,QAAM,QAAQ,WAAW,IAAI;AAC7B,MAAI,MAAM,WAAW;AACjB;AACJ,MAAI,qBAAqB;AACzB,QAAM,aAAa,CAAC;AACpB,MAAI,aAAa,CAAC;AAClB,GAAC,KAAK,KAAK,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,QAAQ,CAAC,OAAO,UAAU;AACnF,QAAIC;AAEJ,QAAI,sBAAsB,MAAM,SAAS,aAAa;AAClD,iBAAW,KAAK,SAAS,KAAK,CAAC;AAC/B,YAAM,OAAO;AAAA,IACjB;AAEA,QAAI,MAAM,SAAS,qBAAqB,UAAU,KAAK,SAAS,SAAS,GAAG;AACxE,2BAAqB;AACrB,UAAI,WAAW,SAAS,GAAG;AACvB,mBAAW,KAAK,gBAAgB,YAAY,MAAM,CAAC,GAAG,IAAI,CAAC;AAC3D,qBAAa,CAAC;AACd,kBAAU,oBAAoB,IAAI,EAAE,QAAQ,CAAC,SAAS;AAClD,eAAK,OAAO;AAAA,QAChB,CAAC;AAAA,MACL;AAAA,IACJ;AACA,QAAI,MAAM,SAAS,SAAS;AAExB,WAAKA,MAAK,MAAM,UAAU,QAAQA,QAAO,SAAS,SAASA,IAAG;AAC1D;AAEJ,UAAI,KAAK,SAAS;AACd;AACJ,YAAM,iBAAiB,oBAAoB,OAAO,KAAK;AACvD,UAAI;AACA,mBAAW,KAAK,GAAG,eAAe,QAAQ;AAAA,IAClD,WACS,MAAM,SAAS,aAAa,MAAM,SAAS,OAAO,KAAK,EAAE,YAAY,CAAC,GAAG;AAE9E,2BAAqB;AACrB,YAAM,OAAO;AAAA,IACjB;AAAA,EACJ,CAAC;AAED,YAAU,oBAAoB,IAAI,EAAE,QAAQ,CAAC,SAAS;AAClD,SAAK,OAAO;AAAA,EAChB,CAAC;AACD,MAAI,WAAW,WAAW;AACtB;AACJ,QAAM,YAAY,EAAE,MAAM,QAAQ,UAAU,WAAW;AACvD,eAAa,MAAM,iBAAiB;AACpC,SAAO;AACX;AAIO,SAAS,YAAY,MAAM,MAAM,MAAM;AAC1C,QAAM,cAAc,WAAW,IAAI;AACnC,MAAI,YAAY,WAAW;AACvB;AACJ,QAAM,aAAa,iBAAiB,MAAM,IAAI;AAC9C,MAAI,WAAW,WAAW,GAAG;AACzB,QAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD;AACJ,WAAO,oBAAoB,MAAM,WAAW;AAAA,EAChD;AACA,QAAM,WAAW,SAAS,UAAU,EAAE,IAAI,CAAC,UAAU;AACjD,QAAI;AAEJ,KAAC,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,KAAM,MAAM,OAAO,CAAC;AAClE,UAAM,KAAK,OAAO,YAAY,CAAC;AAC/B,QAAI,MAAM,KAAK,QACX,MAAM,QAAQ,MAAM,KAAK,IAAI,KAC7B,MAAM,KAAK,KAAK,OAAO,CAAC,GAAG,MAAM,KAAK,YAAY,SAAS,EAAE,YAAY,CAAC,GAAG,KAAK,GAAG;AACrF,YAAM,KAAK,OAAO,MAAM,KAAK,KAAK,OAAO,CAAC,QAAQ,CAAC,YAAY,SAAS,IAAI,YAAY,CAAC,CAAC;AAC1F,UAAI,MAAM,KAAK,KAAK,WAAW,GAAG;AAC9B,eAAO,MAAM,KAAK;AAAA,MACtB;AAAA,IACJ;AACA,QAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACjD,aAAO,MAAM,KAAK;AAEtB,QAAI,EAAE,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACnD,aAAO,MAAM;AACjB,WAAO;AAAA,EACX,CAAC;AACD,QAAM,YAAY,EAAE,MAAM,QAAQ,SAAS;AAE3C,aAAW,QAAQ,CAAC,UAAU;AAC1B,UAAM,OAAO;AAAA,EACjB,CAAC;AACD,eAAa,MAAM,YAAY;AAC/B,SAAO;AACX;;;ACpKO,IAAI;AAAA,CACV,SAAUC,SAAQ;AAEf,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,iBAAiB,IAAI;AAC5B,EAAAA,QAAO,oBAAoB,IAAI;AAC/B,EAAAA,QAAO,6BAA6B,IAAI;AACxC,EAAAA,QAAO,mBAAmB,IAAI;AAC9B,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,4BAA4B,IAAI;AAEvC,EAAAA,QAAO,aAAa,IAAI;AACxB,EAAAA,QAAO,aAAa,IAAI;AACxB,EAAAA,QAAO,WAAW,IAAI;AACtB,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,iBAAiB,IAAI;AAC5B,EAAAA,QAAO,2BAA2B,IAAI;AACtC,EAAAA,QAAO,wBAAwB,IAAI;AACnC,EAAAA,QAAO,WAAW,IAAI;AACtB,EAAAA,QAAO,YAAY,IAAI;AACvB,EAAAA,QAAO,wBAAwB,IAAI;AACnC,EAAAA,QAAO,qBAAqB,IAAI;AAEhC,EAAAA,QAAO,WAAW,IAAI;AACtB,EAAAA,QAAO,YAAY,IAAI;AACvB,EAAAA,QAAO,eAAe,IAAI;AAC1B,EAAAA,QAAO,yBAAyB,IAAI;AAEpC,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,gBAAgB,IAAI;AAC3B,EAAAA,QAAO,0BAA0B,IAAI;AACrC,EAAAA,QAAO,yBAAyB,IAAI;AACpC,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,gBAAgB,IAAI;AAC3B,EAAAA,QAAO,WAAW,IAAI;AACtB,EAAAA,QAAO,iBAAiB,IAAI;AAE5B,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,mBAAmB,IAAI;AAC9B,EAAAA,QAAO,UAAU,IAAI;AACrB,EAAAA,QAAO,YAAY,IAAI;AAEvB,EAAAA,QAAO,gBAAgB,IAAI;AAC3B,EAAAA,QAAO,aAAa,IAAI;AACxB,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,aAAa,IAAI;AACxB,EAAAA,QAAO,sBAAsB,IAAI;AAEjC,EAAAA,QAAO,iBAAiB,IAAI;AAC5B,EAAAA,QAAO,wBAAwB,IAAI;AACnC,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,uBAAuB,IAAI;AAClC,EAAAA,QAAO,aAAa,IAAI;AAExB,EAAAA,QAAO,wBAAwB,IAAI;AACnC,EAAAA,QAAO,oBAAoB,IAAI;AAC/B,EAAAA,QAAO,yBAAyB,IAAI;AACpC,EAAAA,QAAO,sBAAsB,IAAI;AACjC,EAAAA,QAAO,yBAAyB,IAAI;AACpC,EAAAA,QAAO,8BAA8B,IAAI;AACzC,EAAAA,QAAO,8BAA8B,IAAI;AAEzC,EAAAA,QAAO,eAAe,IAAI;AAC1B,EAAAA,QAAO,iBAAiB,IAAI;AAC5B,EAAAA,QAAO,eAAe,IAAI;AAC1B,EAAAA,QAAO,cAAc,IAAI;AACzB,EAAAA,QAAO,oBAAoB,IAAI;AAC/B,EAAAA,QAAO,cAAc,IAAI;AACzB,EAAAA,QAAO,cAAc,IAAI;AACzB,EAAAA,QAAO,gBAAgB,IAAI;AAE3B,EAAAA,QAAO,4BAA4B,IAAI;AACvC,EAAAA,QAAO,sBAAsB,IAAI;AAEjC,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,uBAAuB,IAAI;AAClC,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,gBAAgB,IAAI;AAC3B,EAAAA,QAAO,4BAA4B,IAAI;AACvC,EAAAA,QAAO,oBAAoB,IAAI;AAE/B,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,eAAe,IAAI;AAC1B,EAAAA,QAAO,iBAAiB,IAAI;AAE5B,EAAAA,QAAO,oBAAoB,IAAI;AAC/B,EAAAA,QAAO,mBAAmB,IAAI;AAC9B,EAAAA,QAAO,iBAAiB,IAAI;AAC5B,EAAAA,QAAO,mBAAmB,IAAI;AAC9B,EAAAA,QAAO,qBAAqB,IAAI;AAChC,EAAAA,QAAO,yBAAyB,IAAI;AAEpC,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,kBAAkB,IAAI;AAC7B,EAAAA,QAAO,oBAAoB,IAAI;AAC/B,EAAAA,QAAO,wBAAwB,IAAI;AAEnC,EAAAA,QAAO,aAAa,IAAI;AACxB,EAAAA,QAAO,uBAAuB,IAAI;AAElC,EAAAA,QAAO,wBAAwB,IAAI;AACvC,GAAG,WAAW,SAAS,CAAC,EAAE;;;AC9FnB,SAAS,OAAO,GAAGC,QAAO;AAC7B,MAAI;AACJ,QAAM,OAAO,KAAM,OAAOA,WAAU,WAC9BA,SACA,MAAM,QAAQA,MAAK,IACfA,WAAU,QAAQA,WAAU,SAAS,SAASA,OAAM,SACpD,OAAO,KAAKA,WAAU,QAAQA,WAAU,SAASA,SAAQ,CAAC,CAAC,EAAE,YAAa,QAAQ,OAAO,SAAS,KAAK;AACjH,SAAO,EACF,QAAQ,MAAM,OAAO,GAAG,CAAC,EACzB,QAAQ,8CAA8C,QAAQ,IAAI,OAAO,IAAI;AACtF;;;ACTO,SAAS,uBAAuB,MAAM;AACzC,QAAM,iBAAiB,CAAC,kBAAkB,QAAQ,sBAAsB,mBAAmB;AAC3F,SAAO,CAAC,eAAe,SAAS,KAAK,IAAI;AAC7C;AACA,IAAM,cAAc,oBAAI,IAAI,CAAC,WAAW,aAAa,CAAC;AACtD,SAAS,mBAAmB,OAAO,YAAY,UAAU;AACrD,MAAI,QAAQ;AACZ,MAAI,SAAS;AACb,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,CAAC,SAAS;AACnB,QAAK,SAAS,KAAK,SAAS,aAAe,YAAY,MAAM,UAAU,UAAW;AAC9E,aAAO;AAAA,IACX;AACA,QAAI,KAAK,eAAe,cAAc,KAAK,SAAS,WAAW;AAC3D,cAAQ;AACR,eAAS,KAAK,WAAW,KAAK;AAAA,IAClC;AACA,QAAI,OAAO;AACP,UAAI,CAAC,YAAY,IAAI,KAAK,IAAI;AAC1B,cAAM,KAAK,IAAI;AACnB,aAAO;AAAA,IACX;AAAA,EACJ,CAAC;AACD,SAAO,EAAE,QAAQ,MAAM;AAC3B;AACA,SAAS,qBAAqB,OAAO,YAAY,UAAU;AACvD,MAAI,IAAI;AACR,MAAI,QAAQ;AACZ,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,CAAC,SAAS;AACnB,QAAI,SAAS,KAAK,SAAS,kBAAkB;AACzC,UAAI,MAAM,SAAS;AACf,eAAO;AAAA,IACf,WACS,SAAS,KAAK,SAAS,yBAAyB;AACrD,aAAO;AAAA,IACX;AACA,QAAI,KAAK,eAAe,cAAc,KAAK,SAAS,kBAAkB;AAClE,YAAM,KAAK,IAAI;AACf,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO;AACP,UAAI,KAAK,SAAS;AACd,cAAM,KAAK,IAAI;AACnB,aAAO;AAAA,IACX;AAAA,EACJ,CAAC;AACD,SAAO;AAAA,IACH,UAAU,KAAK,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,CAAC,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,cAAc,KAAK,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,CAAC,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG;AAAA,IAClO,OAAO,CAAC,EAAE,MAAM,kBAAkB,KAAK,MAAM,UAAU,MAAM,MAAM,GAAG,QAAQ,EAAE,CAAC;AAAA,EACrF;AACJ;AAeO,SAAS,iBAAiB,OAAO,YAAY,UAAU;AAC1D,MAAI,aAAa;AACb,WAAO,EAAE,OAAO,CAAC,EAAE;AAEvB,QAAM,OAAO,UAAU,eAAe,oBAAoB,eAAe,KAAK,EAAE,KAAK,CAAC,MAAM,uBAAuB,CAAC,CAAC;AACrH,MAAI,CAAC;AACD,WAAO,EAAE,OAAO,CAAC,EAAE;AACvB,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACD,aAAO,mBAAmB,OAAO,YAAY,QAAQ;AAAA,IACzD,KAAK;AACD,aAAO,qBAAqB,OAAO,YAAY,QAAQ;AAAA,IAC3D;AACI,aAAO,EAAE,QAAQ,KAAK,WAAW,KAAK,YAAY,OAAO,CAAC,IAAI,EAAE;AAAA,EACxE;AACJ;;;AC9FO,IAAI;AAAA,CACV,SAAUC,eAAc;AACrB,EAAAA,cAAa,SAAS,IAAI;AAC1B,EAAAA,cAAa,MAAM,IAAI;AAC3B,GAAG,iBAAiB,eAAe,CAAC,EAAE;AAC/B,IAAI;AAAA,CACV,SAAUC,mBAAkB;AACzB,EAAAA,kBAAiB,cAAc,IAAI;AACnC,EAAAA,kBAAiB,cAAc,IAAI;AACnC,EAAAA,kBAAiB,UAAU,IAAI;AAC/B,EAAAA,kBAAiB,WAAW,IAAI;AAChC,EAAAA,kBAAiB,YAAY,IAAI;AACjC,EAAAA,kBAAiB,YAAY,IAAI;AACjC,EAAAA,kBAAiB,aAAa,IAAI;AAClC,EAAAA,kBAAiB,cAAc,IAAI;AACvC,GAAG,qBAAqB,mBAAmB,CAAC,EAAE;AAEvC,IAAI;AAAA,CACV,SAAUC,iBAAgB;AACvB,EAAAA,gBAAe,QAAQ,IAAI;AAC3B,EAAAA,gBAAe,QAAQ,IAAI;AAC3B,EAAAA,gBAAe,SAAS,IAAI;AAC5B,EAAAA,gBAAe,QAAQ,IAAI;AAC/B,GAAG,mBAAmB,iBAAiB,CAAC,EAAE;AACnC,IAAI;AAAA,CACV,SAAUC,aAAY;AACnB,EAAAA,YAAW,SAAS,IAAI;AACxB,EAAAA,YAAW,UAAU,IAAI;AACzB,EAAAA,YAAW,aAAa,IAAI;AAC5B,EAAAA,YAAW,QAAQ,IAAI;AACvB,EAAAA,YAAW,OAAO,IAAI;AACtB,EAAAA,YAAW,MAAM,IAAI;AACzB,GAAG,eAAe,aAAa,CAAC,EAAE;AAC3B,IAAI;AAAA,CACV,SAAUC,iBAAgB;AACvB,EAAAA,gBAAe,YAAY,IAAI;AAC/B,EAAAA,gBAAe,WAAW,IAAI;AAC9B,EAAAA,gBAAe,SAAS,IAAI;AAC5B,EAAAA,gBAAe,QAAQ,IAAI;AAC3B,EAAAA,gBAAe,OAAO,IAAI;AAC1B,EAAAA,gBAAe,WAAW,IAAI;AAC9B,EAAAA,gBAAe,MAAM,IAAI;AACzB,EAAAA,gBAAe,MAAM,IAAI;AACzB,EAAAA,gBAAe,SAAS,IAAI;AAC5B,EAAAA,gBAAe,KAAK,IAAI;AACxB,EAAAA,gBAAe,SAAS,IAAI;AAChC,GAAG,mBAAmB,iBAAiB,CAAC,EAAE;",
  "names": ["parse", "pseudo", "pseudo", "CssSelectorParser", "pseudo", "one", "boolbase", "nthCheck", "handle", "parent", "parent", "empty", "name", "nest", "parent", "count", "parse", "matches", "parse", "empty", "test", "parent", "test", "_a", "RuleId", "count", "NotebookCell", "NotebookCellTags", "ParseTypesEnum", "TargetKind", "AdmonitionKind"]
}
